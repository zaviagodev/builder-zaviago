class Snippets {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
  }
  getSnippetsHtml() {
    const util = this.util;
    const snippetUrl = this.builder.opts.snippetUrl;
    const snippetPath = this.builder.opts.snippetPath;
    let snippetCategoriesString = '[';
    for (let i = 0; i < this.builder.opts.snippetCategories.length; i++) {
      snippetCategoriesString += `[${this.builder.opts.snippetCategories[i][0]},'${util.out(this.builder.opts.snippetCategories[i][1])}'],`;
    }
    snippetCategoriesString += ']';
    const defaultSnippetCategory = this.builder.opts.defaultSnippetCategory;
    const html = `
        <!DOCTYPE HTML>
        <html>
        
        <head>
            <meta charset="utf-8">
            <title></title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <meta name="description" content="">
            <script src="${snippetUrl}"></script>
            <style>
                body {
                    // background: #fff;
                    background: ${this.builder.styleSnippetBackground};
                    margin: 0;
                }

                .is-pop-close {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    border: none;
                    background: transparent;
                    z-index:10;width:30px;height:30px;position:absolute;
                    top:2px;right:2px;box-sizing:border-box;padding:0;line-height:40px;font-size: 12px;text-align:center;cursor:pointer;
                }
                .is-pop-close:focus-visible {
                    outline:  ${this.builder.styleOutlineColor} 2px solid;
                }

                /*
                body.dark {
                    background: #111;
                }
                .dark .is-categories {
                    background: #333;
                }
                .dark .is-category-list a {
                    background: #333;
                    color: #fff;
                }
                .dark .is-category-list a.active {
                    background: #525252;
                    color: #fff;
                }
                .dark .is-category-list a:hover {
                    color: #fff;
                }
                .dark .is-design-list>li img {
                    opacity: 0.93;
                }
                .dark .is-more-categories {
                    background: #333;
                }
                .dark .is-more-categories a {
                    background: #333;
                    color: #fff;
                }
                .dark .is-more-categories a:hover,
                .dark .is-more-categories a:focus {
                    background: #4c4c4c;
                }
                .dark .is-more-categories a.active {
                    background: #4c4c4c;
                }
                */

                
                .dark .is-design-list>li {
                    outline: transparent 1px solid;
                }

                
                        
                /* Scrollbar for modal */

                /* Darker color, because background for snippet thumbnails is always light. */
                .dark * {
                    scrollbar-width: thin;
                    scrollbar-color: rgb(78 78 78 / 62%) auto;
                }
                .dark *::-webkit-scrollbar {
                    width: 12px;
                }
                .dark *::-webkit-scrollbar-track {
                    background: transparent;
                }
                .dark *::-webkit-scrollbar-thumb {
                    background-color:rgb(78 78 78 / 62%);
                } 

                .colored-dark * {
                    scrollbar-width: thin;
                    scrollbar-color: rgb(100, 100, 100) auto;
                }
                .colored-dark *::-webkit-scrollbar {
                    width: 12px;
                }
                .colored-dark *::-webkit-scrollbar-track {
                    background: transparent;
                }
                .colored-dark *::-webkit-scrollbar-thumb {
                    background-color:rgb(100, 100, 100);
                } 

                .colored * {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(0, 0, 0, 0.4) auto;
                }
                .colored *::-webkit-scrollbar {
                    width: 12px;
                }
                .colored *::-webkit-scrollbar-track {
                    background: transparent;
                }
                .colored *::-webkit-scrollbar-thumb {
                    background-color: rgba(0, 0, 0, 0.4);
                } 

                .light * {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(0, 0, 0, 0.4) auto;
                }
                .light *::-webkit-scrollbar {
                    width: 12px;
                }
                .light *::-webkit-scrollbar-track {
                    background: transparent;
                }
                .light *::-webkit-scrollbar-thumb {
                    background-color: rgba(0, 0, 0, 0.4);
                } 
        
                svg {
                    fill: ${this.builder.styleSnippetColor};
                }

                .is-design-list {
                    position: fixed;
                    top: 0px;
                    left: 0px;
                    border-top: transparent 68px solid;
                    width: 100%;
                    height: 100%;
                    overflow-y: auto;
                    padding: 0px 0px 30px 30px;
                    box-sizing: border-box;
                    overflow: auto;
                    list-style: none;
                    margin: 0;
                }
        
                .is-design-list>li {
                    width: 250px;
                    min-height:120px;
                    position:relative;
                    background: #fff;
                    // background: ${this.builder.styleToolBackground};
                    overflow: hidden;
                    margin: 32px 40px 0 0;
                    cursor: pointer;
                    display: inline-block;
                    outline: #ececec 1px solid;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
                    border-radius: 2px;
                }

                .is-design-list>li:focus-visible {
                    outline:  ${this.builder.styleOutlineColor} 2px solid;
                }

                .is-design-list>li img {
                    box-shadow: none;
                    opacity: 1;
                    display: block;
                    box-sizing: border-box;
                    transition: all 0.2s ease-in-out;
                    max-width: 400px;
                    width: 100%
                }
        
                // .is-design-list>li:hover img {
                //     opacity: 0.95;
                // }
                
                // .is-design-list>li:hover {
                //     background: #999;
                // }
                .is-overlay {
                    position:absolute;left:0px;top:0px;width:100%;height:100%;
                }
                .is-design-list>li .is-overlay:after {
                    background: rgba(0, 0, 0, 0.02);
                    position: absolute;
                    content: "";
                    display: block;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    transition: all 0.3s ease-in-out;
                    opacity: 0;
                }
                .is-design-list>li:hover .is-overlay:after,
                .is-design-list>li:focus .is-overlay:after {
                    opacity: 0.9;
                }
                .dark .is-design-list>li .is-overlay:after {
                    background: rgb(78 78 78 / 13%);
                }
        
                .is-category-list {
                    position: relative;
                    top: 0px;
                    left: 0px;
                    width: 100%;
                    height: 80px;
                    box-sizing: border-box;
                    z-index: 1;
                }
        
                .is-category-list>div {
                    white-space: nowrap;
                    padding: 0 30px;
                    box-sizing: border-box;
                    font-family: sans-serif;
                    font-size: 10px;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                    // background: #f5f5f5;
                    background: ${this.builder.styleSnippetTabsBackground};
                    // box-shadow: 0 5px 8px rgb(0 0 0 / 4%);
                }
        
                .is-category-list a {
                    display: inline-block;
                    padding: 10px 20px;
                    // background: #fefefe;
                    // color: #000;
                    background: ${this.builder.styleSnippetTabItemBackground};
                    color: ${this.builder.styleSnippetTabItemColor};
                    border-radius: 50px;
        
                    margin: 0 12px 0 0;
                    text-decoration: none;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.03);
                    transition: box-shadow ease 0.3s;
                }
        
                .is-category-list a:hover {
                    /*background: #fafafa;*/
                    background: ${this.builder.styleSnippetTabItemBackgroundHover};
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.06);
                    // color: #000;
                    color: ${this.builder.styleSnippetTabItemColor};
                }
        
                .is-category-list a.active {
                    // background: #f5f5f5;
                    background: ${this.builder.styleSnippetTabItemBackgroundActive};
                    // color: #000;
                    color: ${this.builder.styleSnippetTabItemColor};
                    box-shadow: none;
                    cursor: default;
                }

                .is-category-list a:focus-visible {
                    outline:  ${this.builder.styleOutlineColor} 2px solid;
                }
        
                .is-more-categories {
                    display: none;
                    position: absolute;
                    width: 400px;
                    box-sizing: border-box;
                    padding: 0;
                    z-index: 1;
                    font-family: sans-serif;
                    font-size: 10px;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
                    // background: #fff;
                    background: ${this.builder.styleSnippetMoreItemBackground};
                }
        
                .is-more-categories a {
                    width: 200px;
                    float: left;
                    display: block;
                    box-sizing: border-box;
                    padding: 12px 20px;
                    // background: #fff;
                    background: ${this.builder.styleSnippetMoreItemBackground};
                    text-decoration: none;
                    // color: #000;
                    color: ${this.builder.styleSnippetMoreItemColor};
                    line-height: 1.6;
                    outline: none;
                }
        
                .is-more-categories a:hover,
                .is-more-categories a:focus {
                    // background: #eee;
                    background: ${this.builder.styleSnippetMoreItemBackgroundHover};
                }
        
                .is-more-categories a.active {
                    // background: #eee;
                    background: ${this.builder.styleSnippetMoreItemBackgroundActive};
                }
        
                .is-more-categories.active {
                    display: block;
                }
        
                /* First Loading */
                /* .is-category-list {
                    display: none;
                }
        
                .is-design-list {
                    display: none;
                }
        
                .pace {
                    -webkit-pointer-events: none;
                    pointer-events: none;
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    user-select: none;
                }
        
                .pace-inactive {
                    display: none;
                }
        
                .pace .pace-progress {
                    background: #000000;
                    position: fixed;
                    z-index: 2000;
                    top: 0;
                    right: 100%;
                    width: 100%;
                    height: 2px;
                } */
        
                .is-more-categories>a:nth-child(0) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(1) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(2) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(3) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(4) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(5) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(6) {
                    display: none
                }
        
                .is-more-categories>a:nth-child(7) {
                    display: none
                }
        
                @media all and (max-width: 1212px) {
                    .is-categories>a:nth-child(7):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(7) {
                        display: block
                    }
                }
        
                @media all and (max-width: 1070px) {
                    .is-categories>a:nth-child(6):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(6) {
                        display: block
                    }
                }
        
                @media all and (max-width: 940px) {
                    .is-categories>a:nth-child(5):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(5) {
                        display: block
                    }
                }
        
                @media all and (max-width: 700px) {
                    .is-categories>a:nth-child(4):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(4) {
                        display: block
                    }
                }
        
                @media all and (max-width: 555px) {
                    .is-categories>a:nth-child(3):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(3) {
                        display: block
                    }
                }
        
                @media all and (max-width: 415px) {
                    .is-categories>a:nth-child(2):not(.more-snippets) {
                        display: none
                    }
        
                    .is-more-categories>a:nth-child(2) {
                        display: block
                    }
                }
        
                @media all and (max-width: 640px) {
                    .is-more-categories a {
                        width: 150px;
                        padding: 10px 5px 10px 15px;
                        font-size: 10px;
                    }
        
                    .is-more-categories {
                        left: 0 !important;
                        width: 100% !important;
                    }
                }


                * {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(0, 0, 0, 0.2) auto;
                }
                *::-webkit-scrollbar {
                    width: 12px;
                }
                *::-webkit-scrollbar-track {
                    background: rgba(200, 200, 200, 0.2);
                }
                *::-webkit-scrollbar-thumb {
                    background-color:rgba(0, 0, 0, 0.2); 
                }
            </style>
        </head>
        
        <body${this.builder.styleDark ? ' class="dark"' : ''}${this.builder.styleColored ? ' class="colored"' : ''}${this.builder.styleColoredDark ? ' class="colored-dark"' : ''}${this.builder.styleLight ? ' class="light"' : ''}>

            <svg style="display:none">
                <defs>
                    <symbol viewBox="0 0 512 512" id="ion-ios-close-empty">
                        <path d="M340.2 160l-84.4 84.3-84-83.9-11.8 11.8 84 83.8-84 83.9 11.8 11.7 84-83.8 84.4 84.2 11.8-11.7-84.4-84.3 84.4-84.2z"></path>
                    </symbol>
                </defs>
            </svg>
        
            <button class="is-pop-close" tabindex="-1">
                <svg class="is-icon-flex" style="width:30px;height:30px;">
                    <use xlink:href="#ion-ios-close-empty"></use>
                </svg>
            </button>
        
            <div class="is-category-list">
                <div class="is-categories" style="position:fixed;top:0;left:0;right:0;height:68px;padding-top:17px;box-sizing:border-box;">
                </div>
            </div>

            <div class="is-more-categories" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            </div>
        
            <ul class="is-design-list" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            </ul>
        
            <script${this.builder.nonce ? ` nonce="${this.builder.nonce}"` : ''}>
        
                var snippetPath = '${snippetPath}';
                var snippetCategories = ${snippetCategoriesString};
                var defaultSnippetCategory = ${defaultSnippetCategory};

                ${typeof this.builder.slider !== 'undefined' && this.builder.slider !== null ? `
                var slider='${this.builder.slider}';` : 'var slider=null;'};
        
                var numOfCat = snippetCategories.length;
                if (numOfCat <= 7) {
                    document.querySelector('.is-more-categories').style.width = '200px';
                }
        
                var categorytabs = document.querySelector('.is-categories');
                categorytabs.innerHTML = '';
                let html_catselect = '';
                for (var i = 0; i < numOfCat; i++) {
                    if (i < 7) {
                        html_catselect += '<a href="" data-cat="' + snippetCategories[i][0] + '">' + parent._cb.out(snippetCategories[i][1]) + '</a>';
                    }
                }
                html_catselect += '<a href="" class="more-snippets">' + parent._cb.out('More') + '</a>';
                categorytabs.innerHTML = html_catselect;
        
                var categorymore = document.querySelector('.is-more-categories');
                html_catselect = '';
                for (var i = 0; i < numOfCat; i++) {
                    html_catselect += '<a href="" data-cat="' + snippetCategories[i][0] + '">' + parent._cb.out(snippetCategories[i][1]) + '</a>';
                }
                categorymore.innerHTML = html_catselect;
        
                // Show/hide "More" button
                if (numOfCat <= 7) {
                    var bHasMore = false;
        
                    const childNodes = categorymore.childNodes;
                    let i = childNodes.length;
                    while (i--) {
                        if(childNodes[i].style.display === 'block') {
                            bHasMore = true;
                        }
                    }
                    var more = document.querySelector('.more-snippets');
                    if (!bHasMore) more.style.display = 'none';
                    else more.style.display = '';
                }
        
                var elms = categorytabs.querySelectorAll('a[data-cat="' + defaultSnippetCategory + '"]'); //.classList.add('active');
                Array.prototype.forEach.call(elms, function(elm){
                    elm.classList.add('active');
                });
                elms = categorymore.querySelectorAll('a[data-cat="' + defaultSnippetCategory + '"]'); //.classList.add('active');
                Array.prototype.forEach.call(elms, function(elm){
                    elm.classList.add('active');
                });


                document.addEventListener('keydown', function(e){
                    if(e.keyCode === 27) { // escape key
                        const moreCategories = document.querySelector('.is-more-categories');
                        if(moreCategories.classList.contains('active')) {
                            moreCategories.classList.remove('active');
                            const activeTab = categorylist.querySelector('.more-snippets');
                            activeTab.classList.remove('active');
                            activeTab.focus();
                        } else {
                            const modal = parent.document.querySelector('.is-modal.snippets');
                            removeClass(modal, 'active');
                        }
                    }
                });


                let categorylist = document.querySelector('.is-category-list');
                let designlist = document.querySelector('.is-design-list');

                const select = (elm) => {

                    if(elm.classList.contains('active')) {
                        return false;
                    }
    
                    var cat = elm.getAttribute('data-cat');
                    if (cat) if(designlist.querySelectorAll('[data-cat="' + cat + '"]').length === 0) {

                        for (let i = 0; i <snippets.length; i++) {
                    
                            var thumb = snippets[i].thumbnail;
                            
                            thumb = snippetPath + thumb;    
    
                            if (snippets[i].category === cat) {
                                designlist.insertAdjacentHTML('beforeend', '<li role="button" tabindex="0" data-id="' + snippets[i].id + '" data-cat="' + snippets[i].category + '"><img src="' + thumb + '"><span class="is-overlay"></span></li>');
                            
                                var newitem = designlist.querySelector('[data-id="' + snippets[i].id + '"]');
                                newitem.addEventListener('click', function(e){
                                    
                                    var snippetid = e.target.parentNode.getAttribute('data-id');
                                    addSnippet(snippetid);
    
                                });

                                newitem.addEventListener('keydown', (e)=>{
                                    if ((e.which === 9 && !e.shiftKey)) { // tab
                                        let last = false;
                                        if(e.target.nextElementSibling) {
                                            if(!e.target.nextElementSibling.classList.contains('active')) {
                                                last = true;
                                            }
                                        } else {
                                            last = true;
                                        }
                                        if(last) {
                                            e.preventDefault();
                                            let activeTab = categorylist.querySelector('.active');
                                            if(activeTab) activeTab.focus();
                                            else {
                                                activeTab = categorylist.querySelector('.more-snippets');
                                                activeTab.focus();
                                            }
                                        }
                                    }
                                    if ((e.which === 9 && e.shiftKey)) { // shift + tab
                                        let first = false;
                                        if(e.target.previousElementSibling) {
                                            if(!e.target.previousElementSibling.classList.contains('active')) {
                                                first = true;
                                            }
                                        } else {
                                            first = true;
                                        }
                                        if(first) {
                                            e.preventDefault();
                                            let activeTab = categorylist.querySelector('.active');
                                            if(activeTab) activeTab.focus();
                                            else {
                                                activeTab = categorylist.querySelector('.more-snippets');
                                                activeTab.focus();
                                            }
                                        }
                                    }
                                });

                            }
    
                        }    
                    }
    
                    if (cat) {
                        // Hide all, show items from selected category
                        var categorylist_items = categorylist.querySelectorAll('a');    
                        Array.prototype.forEach.call(categorylist_items, function(elm){
                            elm.className = elm.className.replace('active', '');
                        });
                        categorymore.className = categorymore.className.replace('active', ''); 
                        var categorymore_items = categorymore.querySelectorAll('a');
                        Array.prototype.forEach.call(categorymore_items, function(elm){
                            elm.className = elm.className.replace('active', '');
                        });
    
                        var items = designlist.querySelectorAll('li');
                        Array.prototype.forEach.call(items, function(elm){
                            elm.style.display = 'none';
                            elm.classList.remove('active');
                        });
                        Array.prototype.forEach.call(items, function(elm){
                            var catSplit = elm.getAttribute('data-cat').split(',');
                            for (var j = 0; j < catSplit.length; j++) {
                                if (catSplit[j] == cat) {
                                    elm.style.display = ''; // TODO: hide & show snippets => animated
                                    elm.classList.add('active');
                                }
                            }
                        });
                        
                    } else {
                        // show dropdown
                        var more = document.querySelector('.more-snippets');
                        var moreCategories = document.querySelector('.is-more-categories');
    
                        var _width = moreCategories.offsetWidth;
                        more.classList.add('active');
                        moreCategories.classList.add('active');
                        var top = more.getBoundingClientRect().top;
                        var left = more.getBoundingClientRect().left;
                        top = top + 50;
                        moreCategories.style.top = top + 'px';
                        moreCategories.style.left = left + 'px';
                    }
                    elm.classList.add('active');
    
                };

                let tabs = document.querySelectorAll('.is-categories a');
                Array.prototype.forEach.call(tabs, (tab) => {
        
                    tab.addEventListener('keydown', (e)=>{
                        e.preventDefault();
        
                        if ((e.which === 39 && e.target.nextElementSibling)) { // arrow right key pressed
                            e.target.nextElementSibling.focus();
                        } else if ((e.which === 37 && e.target.previousElementSibling)) { // arrow left key pressed
                            e.target.previousElementSibling.focus();
                        } else if(e.keyCode === 13 || e.keyCode === 32) { // enter or spacebar key
                            select(e.target);
                        } else if ((e.which === 9 && !e.shiftKey)) { // tab key pressed
        
                            let moreCategories = document.querySelector('.is-more-categories');
                            if(moreCategories.classList.contains('active')) {
                 
                                // Redirect to dropdown list
                                let firstItem;
                                let activeItem;
                                let moreCategories = document.querySelector('.is-more-categories');
                                let items = moreCategories.querySelectorAll('a');
                                items.forEach(item=>{
                                    let display = window.getComputedStyle(item).getPropertyValue('display');
                                    if(display==='block') {
                                        item.classList.add('show');
                                        if(item.classList.contains('active')) {
                                            activeItem=item;
                                        }
                                    } else {
                                        item.classList.remove('show');
                                    }
                                });
                                firstItem = moreCategories.querySelector('.show');
                                if(activeItem) {
                                    activeItem.focus();
                                } else {
                                    firstItem.focus();
                                }
                                return;

                            }

                            // Redirect to tab content
                            let inputs = [];
                            let controls = designlist.querySelectorAll('.active');
                            controls.forEach(control=>{
                                inputs.push(control);
                            });
        
                            if(inputs.length===0) return;
        
                            let firstInput = inputs[0];
        
                            firstInput.focus();
                        } else if(e.which === 40 && e.target.classList.contains('more-snippets')) { // down
                 
                            // Redirect to dropdown list
                            let firstItem;
                            let activeItem;
                            let moreCategories = document.querySelector('.is-more-categories');
                            let items = moreCategories.querySelectorAll('a');
                            items.forEach(item=>{
                                let display = window.getComputedStyle(item).getPropertyValue('display');
                                if(display==='block') {
                                    item.classList.add('show');
                                    if(item.classList.contains('active')) {
                                        activeItem=item;
                                    }
                                } else {
                                    item.classList.remove('show');
                                }
                            });
                            firstItem = moreCategories.querySelector('.show');
                            if(activeItem) {
                                activeItem.focus();
                            } else {
                                firstItem.focus();
                            }

                        } 

                        
                    });
        
                    tab.addEventListener('click', (e)=>{
                        e.preventDefault();

                        e.target.focus();
        
                        select(e.target);
                    });
        
                });

                let dropdownItems = document.querySelectorAll('.is-more-categories a');
                Array.prototype.forEach.call(dropdownItems, (item) => {

                    item.addEventListener('keydown', (e)=>{
                        e.preventDefault();
                        if(e.keyCode === 38 && e.target.previousElementSibling && window.getComputedStyle(e.target.previousElementSibling).getPropertyValue('display')==='block') { // up
                            e.target.previousElementSibling.focus();
                        } else if(e.keyCode === 40 && e.target.nextElementSibling && window.getComputedStyle(e.target.nextElementSibling).getPropertyValue('display')==='block') { // down
                            e.target.nextElementSibling.focus();
                        } else if(e.keyCode === 13 || e.keyCode === 32) { // enter or spacebar key
                            select(e.target);
                        } else if ((e.which === 9 && !e.shiftKey)) { // tab key pressed
        
                            // Redirect to tab content
                            let inputs = [];
                            let controls = designlist.querySelectorAll('.active');
                            controls.forEach(control=>{
                                inputs.push(control);
                            });
        
                            if(inputs.length===0) return;
        
                            let firstInput = inputs[0];
        
                            firstInput.focus();
                        } 
                        
                    });
        
                    item.addEventListener('click', (e)=>{
                        e.preventDefault();

                        e.target.focus();
        
                        select(e.target);
                    });
                });


        
                var snippets = data_basic.snippets; //DATA

                if (slider !== null){
                    if(slider==='slick') {
                        //remove glide
                        const predicate = (item) => (item.type!=='glide');
                        snippets = snippets.filter(predicate);
                    } else if(slider==='glide') {
                        //remove slick
                        const predicate = (item) => (item.type!=='slick');
                        snippets = snippets.filter(predicate);
                    } else if(slider==='all') {
                        // Do Nothing
                    } else {
                        // remove all slider (if incorrect settings)
                        const predicate = (item) => (item.type!=='glide' && item.type!=='slick');
                        snippets = snippets.filter(predicate);
                    }

                    // for (let i = 0; i < snippets.length; i++) {
                    //     console.log(snippets[i].type)
                    // }

                } else {
                    // Backward compatible OR if slider param not set

                    // Hide slider snippet if slick is not included
                    var bHideSliderSnippet = true;
                    if(parent._cb.win.jQuery) {
                        if(parent._cb.win.jQuery.fn.slick) {
                            bHideSliderSnippet = false;
                        }
                    }
                    if(bHideSliderSnippet){
                        const result = snippets.filter((item)=>{
                            return item.type !== 'slick';
                        });
                        snippets = [...result];
                    } 

                    if(!(parent._cb.win.Glide)){
                        const result = snippets.filter((item)=>{
                            return !(item.glide || item.type === 'glide');
                        });
                        snippets = [...result];
                    }

                    // for (let i = 0; i < snippets.length; i++) {
                    //     console.log(snippets[i].type)
                    // }

                }
                

                for (let i = 0; i <snippets.length; i++) {
                    
                    snippets[i].id = i+1;
                    var thumb = snippets[i].thumbnail;
        
                    thumb = snippetPath + thumb;
        
                    if (snippets[i].category === defaultSnippetCategory + '') {
                        designlist.insertAdjacentHTML('beforeend', '<li class="active" role="button" tabindex="0" data-id="' + snippets[i].id + '" data-cat="' + snippets[i].category + '"><img src="' + thumb + '"><span class="is-overlay"></span></li>');
                    
                        var newitem = designlist.querySelector('[data-id="' + snippets[i].id + '"]');
                        newitem.addEventListener('click', function(e){
        
                            var snippetid = e.target.parentNode.getAttribute('data-id');
                            addSnippet(snippetid);
        
                        });
        
                        newitem.addEventListener('keydown', (e)=>{

                            if ((e.which === 9 && !e.shiftKey)) { // tab
                                let last = false;
                                if(e.target.nextElementSibling) {
                                    if(!e.target.nextElementSibling.classList.contains('active')) {
                                        last = true;
                                    }
                                } else {
                                    last = true;
                                }
                                if(last) {
                                    e.preventDefault();
                                    let activeTab = categorylist.querySelector('.active');
                                    if(activeTab) activeTab.focus();
                                    else {
                                        activeTab = categorylist.querySelector('.more-snippets');
                                        activeTab.focus();
                                    }
                                }
                            }
                            if ((e.which === 9 && e.shiftKey)) { // shift + tab
                                let first = false;
                                if(e.target.previousElementSibling) {
                                    if(!e.target.previousElementSibling.classList.contains('active')) {
                                        first = true;
                                    }
                                } else {
                                    first = true;
                                }
                                if(first) {
                                    e.preventDefault();
                                    let activeTab = categorylist.querySelector('.active');
                                    if(activeTab) activeTab.focus();
                                    else {
                                        activeTab = categorylist.querySelector('.more-snippets');
                                        activeTab.focus();
                                    }
                                }
                            }
                        });

                    }

                }
        



                /*
                elms = categorymore.querySelectorAll('a');
                Array.prototype.forEach.call(elms, function(elm){
        
                    elm.addEventListener('click', function(e){
                        
                        var cat = elm.getAttribute('data-cat');
                        if(designlist.querySelectorAll('[data-cat="' + cat + '"]').length === 0) {
        
                            for (let i = 0; i <snippets.length; i++) {
                        
                                var thumb = snippets[i].thumbnail;
                                
                                thumb = snippetPath + thumb;
        
                                if (snippets[i].category === cat) {
                      
                                    designlist.insertAdjacentHTML('beforeend', '<li role="button" tabindex="0" data-id="' + snippets[i].id + '" data-cat="' + snippets[i].category + '"><img src="' + thumb + '"><span class="is-overlay"></span></li>');
                                
                                    var newitem = designlist.querySelector('[data-id="' + snippets[i].id + '"]');
                                    newitem.addEventListener('click', function(e){
                                        
                                        var snippetid = e.target.parentNode.getAttribute('data-id');
                                        addSnippet(snippetid);
        
                                    });
                                }
        
                            }    
                        }
        
                        // Hide all, show items from selected category
                        Array.prototype.forEach.call(elms, function(elm){
                            elm.className = elm.className.replace('active', '');
                        });
                        categorymore.className = categorymore.className.replace('active', ''); // hide popup
                        //var categorymore_items = categorymore.querySelectorAll('a');
                        
                        var categorylist = document.querySelector('.is-category-list');
                        var categorylist_items = categorylist.querySelectorAll('a');                
                        Array.prototype.forEach.call(categorylist_items, function(elm){
                            elm.className = elm.className.replace('active', '');
                        });
                            
                        var more = document.querySelector('.more-snippets');
                        more.className = more.className.replace('active', '');
        
                        var items = designlist.querySelectorAll('div');
                        Array.prototype.forEach.call(items, function(elm){
                            elm.style.display = 'none';
                            elm.classList.remove('active');
                        });
                        Array.prototype.forEach.call(items, function(elm){
                            var catSplit = elm.getAttribute('data-cat').split(',');
                            for (var j = 0; j < catSplit.length; j++) {
                                if (catSplit[j] == cat) {
                                    elm.style.display = '';
                                    elm.classList.add('active');
                                }
                            }
                        });
        
                        elm.classList.add('active');
        
                        e.preventDefault();
                    });
        
                });
                */
        
                var close = document.querySelector('.is-pop-close');
                close.addEventListener('click', function(e){
                    var modal = parent.document.querySelector('.is-modal.snippets');
                    removeClass(modal, 'active');
                });
        
                // Add document Click event
                document.addEventListener('click', function(e){
                    e = e || window.event;
                    var target = e.target || e.srcElement;  
        
                    if(parentsHasClass(target, 'more-snippets')) return;
                    if(hasClass(target, 'more-snippets')) return;
                    
                    var more = document.querySelector('.more-snippets');
                    var moreCategories = document.querySelector('.is-more-categories');
                    
                    more.className = more.className.replace('active', '');
                    moreCategories.className = moreCategories.className.replace('active', '');
                });
        
                parent.document.addEventListener('click', function(e){
                    var more = document.querySelector('.more-snippets');
                    var moreCategories = document.querySelector('.is-more-categories');
                    
                    more.className = more.className.replace('active', '');
                    moreCategories.className = moreCategories.className.replace('active', '');
                });
        
                function addSnippet(snippetid) {
                    
                    // TODO: var framework = parent._cb.opts.framework;
                    var snippetPathReplace = parent._cb.opts.snippetPathReplace;
                    var emailMode = parent._cb.opts.emailMode;
                    
                    // 
                    for (let i = 0; i <snippets.length; i++) {
                        if(snippets[i].id + ''=== snippetid) {
                            
                            var html = snippets[i].html;
                            var noedit = snippets[i].noedit;
                            break;
                        }
                    }
        
                    var bSnippet;
                    if (html.indexOf('"row') === -1) {
                        bSnippet = true; // Just snippet (without row/column grid)
                    } else {
                        bSnippet = false; // Snippet is wrapped in row/colum
                    }
                    if (emailMode) bSnippet = false;

                    if(bSnippet) {
                        var quickadd = parent._cb.builderStuff.querySelector('.quickadd');
                        var mode = quickadd.getAttribute('data-mode');
                        if(!mode) {
                            // in case of using viewSnippets() to open the dialog (mode=null) => change to non snippet.
                            html = '<div class="row">' +
                                '<div class="column full">' +
                                html +
                                '</div>' +
                            '</div>';
                            bSnippet=false;
                        }
                    }
         
                    // Convert snippet into your defined 12 columns grid   
                    var rowClass = parent._cb.opts.row; //row
                    var colClass = parent._cb.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
                    if(rowClass!=='' && colClass.length===12){

                        //html = html.replace(new RegExp('row clearfix', 'g'), rowClass);
                        html = html.replace(new RegExp('row clearfix', 'g'), 'row'); // backward
                        html = html.replace(new RegExp('"row', 'g'), '"' + rowClass);
                        
                        html = html.replace(new RegExp('column full', 'g'), colClass[11]);
                        html = html.replace(new RegExp('column half', 'g'), colClass[5]);
                        html = html.replace(new RegExp('column third', 'g'), colClass[3]);
                        html = html.replace(new RegExp('column fourth', 'g'), colClass[2]);
                        html = html.replace(new RegExp('column fifth', 'g'), colClass[1]);
                        html = html.replace(new RegExp('column sixth', 'g'), colClass[1]);
                        html = html.replace(new RegExp('column two-third', 'g'), colClass[7]);
                        html = html.replace(new RegExp('column two-fourth', 'g'), colClass[8]);
                        html = html.replace(new RegExp('column two-fifth', 'g'), colClass[9]);
                        html = html.replace(new RegExp('column two-sixth', 'g'), colClass[9]);
                    }
                    
                    html = html.replace(/{id}/g, makeid()); // Replace {id} with auto generated id (for custom code snippet)
                    
                    if(parent._cb.opts.onAdd){
                        html = parent._cb.opts.onAdd(html);
                    }

                    if(snippetPathReplace.length>0) {
                        if (snippetPathReplace[0] != '') {
                            var regex = new RegExp(snippetPathReplace[0], 'g');
                            html = html.replace(regex, snippetPathReplace[1]);

                            /* for encoded replace, change / to %2F  */
                            var slash = new RegExp('/', 'g');
                            var snippetPathReplace_0 = snippetPathReplace[0].replace(slash, '%2F');
                            var snippetPathReplace_1 = snippetPathReplace[1].replace(slash, '%2F');
                            regex = new RegExp(snippetPathReplace_0, 'g');
                            html = html.replace(regex, snippetPathReplace_1);
                        }
                    }
                    
                    parent._cb.addSnippet(html, bSnippet, noedit);
        
                    var modal = parent.document.querySelector('.is-modal.snippets');
                    removeClass(modal, 'active');
        
                }
        
                function hasClass(element, classname) {
                    if(!element) return false;
                    return element.classList ? element.classList.contains(classname) : new RegExp('\\b'+ classname+'\\b').test(element.className);
                }
        
                function removeClass(element, classname) {
                    if(!element) return;
                    if(element.classList.length>0) {
                        element.className = element.className.replace(classname, '');
                    }
                }
                
                function parentsHasClass(element, classname) {
                    while (element) {
                        if(element.tagName === 'BODY' || element.tagName === 'HTML') return false;
                        if(!element.classList) return false;
                        if (element.classList.contains(classname)) {
                            return true;
                        }
                        element = element.parentNode;
                    }
                }
        
                function makeid() {//http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
                    var text = "";
                    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
                    for (var i = 0; i < 2; i++)
                        text += possible.charAt(Math.floor(Math.random() * possible.length));
        
                    var text2 = "";
                    var possible2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    for (var i = 0; i < 5; i++)
                        text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
        
                    return text + text2;
                }
        
            </script>
        
        </textarea>
        </body>
        
        </html>
        `;
    return html;
  }
}

const renderQuickAdd = builder => {
  const util = builder.util;
  const builderStuff = builder.builderStuff;
  const dom = builder.dom;
  let quickadd = builderStuff.querySelector('.quickadd');
  if (!quickadd) {
    const html = `<div class="is-pop quickadd arrow-right" style="z-index:10003;" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="is-pop-close" style="display:none;z-index:1;width:40px;height:40px;position:absolute;top:0px;right:0px;box-sizing:border-box;padding:0;line-height:40px;font-size: 12px;color:#777;text-align:center;cursor:pointer;"><svg class="is-icon-flex" style="width:40px;height:40px;"><use xlink:href="#ion-ios-close-empty"></use></svg></div>
        <div class="is-pop-tabs">
            <div class="is-pop-tab-item" data-value="left">${util.out('Add to Left')}</div>
            <div class="is-pop-tab-item active" data-value="right">${util.out('Add to Right')}</div>
        </div>
        <div style="padding:12px;display:flex;flex-direction:row;flex-flow: wrap;justify-content: center;align-items: center;">
            <button title="${util.out('Paragraph')}" class="add-paragraph"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#icon-align-full"></use></svg></span>${util.out('Paragraph')}</button>
            <button title="${util.out('Headline')}" class="add-headline"><span style="font-family:serif;display:block;margin:0 0 8px;font-size:11px;">H</span>${util.out('Headline')}</button>
            <button title="${util.out('Image')}" class="add-image"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex ion-image" style="width:14px;height:14px;"><use xlink:href="#ion-image"></use></svg></span>${util.out('Image')}</button>
            <button title="${util.out('List')}" class="add-list"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-list-bullet"></use></svg></span>${util.out('List')}</button>
            <button title="${util.out('Heading 1')}" class="add-heading1"><span style="font-family:serif;display:block;margin:0 0 8px;">H1</span>${util.out('Heading 1')}</button>
            <button title="${util.out('Heading 2')}" class="add-heading2"><span style="font-family:serif;display:block;margin:0 0 8px;">H2</span>${util.out('Heading 2')}</button>
            <button title="${util.out('Heading 3')}" class="add-heading3"><span style="font-family:serif;display:block;margin:0 0 8px;">H3</span>${util.out('Heading 3')}</button>
            <button title="${util.out('Heading 4')}" class="add-heading4"><span style="font-family:serif;display:block;margin:0 0 8px;">H4</span>${util.out('Heading 4')}</button>
            <button title="${util.out('Quote')}" class="add-quote"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-quote"></use></svg></span>${util.out('Quote')}</button>
            <button style="display:none" title="${util.out('Preformatted')}" class="add-preformatted"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-code"></use></svg></span>${util.out('Preformatted')}</button>
            ${builder.opts.emailMode ? '' : `<button title="${util.out('Button')}" class="add-button"><span style="display:block;margin:0 0 8px;"><span style="display:inline-block;border:#a1a1a1 1px solid;background:#f3f3f3;width:10px;height:4px;"></span></span>${util.out('Button')}</button>`}
            ${builder.opts.emailMode ? '' : `<button title="${util.out('Two Button')}" class="add-twobutton"><span style="display:block;margin:0 0 8px;"><span style="display:inline-block;border:#a1a1a1 1px solid;background:#f3f3f3;width:10px;height:4px;"></span></span>${util.out('Two Button')}</button>`}
            <button title="${util.out('Map')}" class="add-map"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-location"></use></svg></use></svg></svg></span>${util.out('Map')}</button>
            <button title="${util.out('Youtube')}" class="add-youtube"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-social-youtube-outline"></use></svg></use></svg></svg></span>${util.out('Youtube')}</button>
            <button title="${util.out('Video')}" class="add-video"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-ios-play"></use></svg></use></svg></svg></span>${util.out('Video')}</button>
            <button style="display:none" title="${util.out('Audio')}" class="add-audio"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-volume-medium"></use></svg></use></svg></svg></span>${util.out('Audio')}</button>
            <button title="${util.out('Icon')}" class="add-icon"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-android-happy"></use></svg></use></svg></svg></span>${util.out('Icon')}</button>
            <button title="${util.out('SVG')}" class="add-svg"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-5px"><use xlink:href="#icon-svg"></use></svg></use></svg></svg></span>${util.out('SVG')}</button>
            <button title="${util.out('Table')}" class="add-table"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-table"></use></svg></use></svg></svg></span>${util.out('Table')}</button>
            <button title="${util.out('Social Links')}" class="add-social"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-social-twitter"></use></svg></use></svg></svg></span>${util.out('Social Links')}</button>
            <button title="${util.out('HTML/JS')}" class="add-code"><span style="display:block;margin:0 0 8px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-code"></use></svg></use></svg></svg></span>${util.out('HTML/JS')}</button>
            <button title="${util.out('Spacer')}" class="add-spacer"><span style="display:block;margin:0 0 8px;"><span style="display:inline-block;background:#eee;width:30px;height:5px;"></span></span>${util.out('Spacer')}</button>
            <button style="display:none" title="${util.out('Line')}" class="add-line"><span style="display:block;margin:0 0 8px;"><span style="display:inline-block;background:#ddd;width:30px;height:2px;"></span></span>${util.out('Line')}</button>
            <div class="pop-separator"></div>
            <button title="${util.out('More...')}" class="add-more" style="flex-direction:initial;">${util.out('More...')}</button>
        </div>
        </div>
        `;
    dom.appendHtml(builderStuff, html);
    quickadd = builderStuff.querySelector('.quickadd');
    let tabs = quickadd.querySelectorAll('.is-pop-tab-item');
    Array.prototype.forEach.call(tabs, tab => {
      dom.addEventListener(tab, 'click', e => {
        let elms = quickadd.querySelectorAll('.is-pop-tab-item');
        Array.prototype.forEach.call(elms, elm => {
          dom.removeClass(elm, 'active');
        });
        dom.addClass(e.target, 'active');
        let val = quickadd.querySelector('.active').getAttribute('data-value');
        if (val === 'left') {
          quickadd.setAttribute('data-mode', 'cell-left');
        } else {
          quickadd.setAttribute('data-mode', 'cell-right');
        }
      });
    });
    let elm = quickadd.querySelector('.add-paragraph');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. 
            Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, 
            when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-headline');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<div class="display">
                <h1>Headline Goes Here</h1>
                <p>Lorem Ipsum is simply dummy text</p>
            </div>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-image');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      let html = `<img src="${builder.opts.snippetPath}example.png" alt="" />`;
      if (builder.opts.snippetSampleImage) {
        html = `<img src="${builder.opts.snippetSampleImage}" alt="" />`;
      }
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-heading1');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<h1>Heading 1 here</h1>';
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-heading2');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<h2>Heading 2 here</h2>';
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-heading3');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<h3>Heading 3 here</h3>';
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-heading4');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<h4>Heading 4 here</h4>';
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-preformatted');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<pre>Lorem Ipsum is simply dummy text of the printing and typesetting industry. 
            Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, 
            when an unknown printer took a galley of type and scrambled it to make a type specimen book.</pre>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-list');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<ul>
                <li>Lorem Ipsum is simply dummy text</li>
                <li>Lorem Ipsum is simply dummy text</li>
            </ul>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-quote');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');

      // const html = '<blockquote>Lorem Ipsum is simply dummy text</blockquote>';
      const html = `
            <div class="text-left">
                <i class="icon ion-quote size-28"></i>
            </div>
            <p class="size-21 leading-14">It's easy to use, customizable, and user-friendly. A truly amazing features.</p>
            `;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-button');
    if (elm) dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      let html = `<div>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Read More</a>
            </div>`;
      if (builder.opts.emailMode) {
        html = '<div><a href="#" role="button" style="margin-top: ;margin-right: ;margin-bottom: ;margin-left: ;display: inline-block; text-decoration: none; transition: all 0.16s ease 0s; border-style: solid; cursor: pointer; background-color: rgb(220, 220, 220); color: rgb(0, 0, 0); border-color: rgb(220, 220, 220); border-width: 2px; border-radius: 0px; padding: 13px 28px; line-height: 21px; text-transform: uppercase; font-weight: 400; font-size: 14px; letter-spacing: 3px;">Read More</a></div>';
      }
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-twobutton');
    if (elm) dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      let html = `<div>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Read More</a>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 border-current hover:border-current font-normal leading-14 rounded tracking-wide">Get Started</a>
            </div>`;
      if (builder.opts.emailMode) {
        html = `<div>
                <a href="#" role="button" style="margin-top: ;margin-right: ;margin-bottom: ;margin-left: ;display: inline-block; text-decoration: none; transition: all 0.16s ease 0s; border-style: solid; cursor: pointer; background-color: rgb(220, 220, 220); color: rgb(0, 0, 0); border-color: rgb(220, 220, 220); border-width: 2px; border-radius: 0px; padding: 13px 28px; line-height: 21px; text-transform: uppercase; font-weight: 400; font-size: 14px; letter-spacing: 3px;">Read More</a> &nbsp;
                <a href="#" role="button" style="display: inline-block; text-decoration: none; transition: all 0.16s ease 0s; border-style: solid; cursor: pointer; background-color: rgba(0, 0, 0, 0); border-color: rgb(53, 53, 53); border-width: 2px; border-radius: 0px; padding: 13px 28px; line-height: 21px; text-transform: uppercase; font-weight: 600; font-size: 14px; letter-spacing: 3px; color: rgb(53, 53, 53);">Get Started</a>
            </div>`;
      }
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-spacer');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<div class="spacer height-80"></div>';

      // util.addContent(html, mode, 'data-noedit');
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-line');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = '<hr>';

      // util.addContent(html, mode, 'data-noedit');
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-code');
    dom.addEventListener(elm, 'click', () => {
      // const mode = quickadd.getAttribute('data-mode');

      let html = '<div class="row">' + '<div class="column full" data-noedit data-html="' + encodeURIComponent('<h1 id="{id}">Lorem ipsum</h1>' + '<p>This is a code block. You can edit this block using the source dialog.</p>' + '<scr' + 'ipt>' + 'var docReady = function (fn) {' + 'var stateCheck = setInterval(function () {' + 'if (document.readyState !== "complete") return;' + 'clearInterval(stateCheck);' + 'try{fn()}catch(e){}' + '}, 1);' + '};' + 'docReady(function() {' + 'document.querySelector(\'#{id}\').innerHTML =\'<b>Hello World..!</b>\';' + '});' + '</scr' + 'ipt>') + '">' + '</div>' + '</div>';
      let noedit = true;
      let bSnippet = false;
      let snippetPathReplace = builder.opts.snippetPathReplace;

      // Convert snippet into your defined 12 columns grid   
      let rowClass = builder.opts.row; //row
      let colClass = builder.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
      if (rowClass !== '' && colClass.length === 12) {
        // html = html.replace(new RegExp('row clearfix', 'g'), rowClass);
        html = html.replace(new RegExp('row clearfix', 'g'), 'row'); // backward
        html = html.replace(new RegExp('"row', 'g'), '"' + rowClass);
        html = html.replace(new RegExp('column full', 'g'), colClass[11]);
        html = html.replace(new RegExp('column half', 'g'), colClass[5]);
        html = html.replace(new RegExp('column third', 'g'), colClass[3]);
        html = html.replace(new RegExp('column fourth', 'g'), colClass[2]);
        html = html.replace(new RegExp('column fifth', 'g'), colClass[1]);
        html = html.replace(new RegExp('column sixth', 'g'), colClass[1]);
        html = html.replace(new RegExp('column two-third', 'g'), colClass[7]);
        html = html.replace(new RegExp('column two-fourth', 'g'), colClass[8]);
        html = html.replace(new RegExp('column two-fifth', 'g'), colClass[9]);
        html = html.replace(new RegExp('column two-sixth', 'g'), colClass[9]);
      }
      html = html.replace(/{id}/g, util.makeId()); // Replace {id} with auto generated id (for custom code snippet)

      if (builder.opts.onAdd) {
        html = builder.opts.onAdd(html);
      }
      if (snippetPathReplace.length > 0) {
        if (snippetPathReplace[0] !== '') {
          let regex = new RegExp(snippetPathReplace[0], 'g');
          html = html.replace(regex, snippetPathReplace[1]);
        }
      }
      builder.addSnippet(html, bSnippet, noedit);
    });
    elm = quickadd.querySelector('.add-table');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<table class="default" style="border-collapse:collapse;width:100%;">
                <thead>
                <tr>
                    <td style="vertical-align:top;"><br></td>
                    <td style="vertical-align:top;"><br></td>
                </tr>
                </thead>
                <tr>
                    <td style="vertical-align:top;"><br></td>
                    <td style="vertical-align:top;"><br></td>
                </tr>
            </table>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-icon');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<div style="text-align: center;">
            <i class="icon ion-android-alarm-clock size-80"></i>
            </div>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-svg');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<div style="text-align: center;">
                            <svg viewBox="0 0 259.25 969.39" xmlns="http://www.w3.org/2000/svg" style="fill: rgb(100 177 45); width: 150px; height: 150px;">
                    <g>
                        <path d="M184,17.61S101.39,318.78,98.85,334,69.62,463.64,67.08,517s-16.52,141,19.06,202,86.41,110.56,151.21,75S320,675.85,320,675.85s16.52-179.17-58.45-414.26S184,17.61,184,17.61Z" transform="translate(-62.25 -17.61)"></path>
                        <path d="M190.34,179l-7.63,319s-28-17.79-30.49-24.15-20.34-26.68-20.34-26.68,15.25,36.85,20.34,40.66,26.68,34.31,26.68,34.31l-1.27,181.72,1.27,274.47s11.44,17.79,14,2.54,3.81-305,3.81-305,34.31-78.79,41.94-95.3,12.7-39.4,12.7-39.4-45.74,87.68-50.83,94-6.35-231.28-6.35-231.28,11.44,6.36,22.87-33,7.63-52.1,7.63-52.1-14,45.74-20.33,55.91S190.34,179,190.34,179Z" transform="translate(-62.25 -17.61)" style="fill:#ededed"></path>
                    </g>
                </svg>
            </div>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-social');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `
            <div class="is-social text-left">
                <a href="https://twitter.com/"><i class="bi bi-twitter-x"></i></a>
                <a href="https://www.facebook.com/"><i class="bi bi-facebook"></i></a>
                <a href="https://www.instagram.com/" title=""><i class="icon bi bi-instagram"></i></a>
            </div>
            `;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-map');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<div class="embed-responsive embed-responsive-16by9">
            <iframe width="100%" height="400" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" class="mg1" src="https://maps.google.com/maps?q=Melbourne,+Victoria,+Australia&amp;hl=en&amp;sll=-7.981898,112.626504&amp;sspn=0.009084,0.016512&amp;oq=melbourne&amp;hnear=Melbourne+Victoria,+Australia&amp;t=m&amp;z=10&amp;output=embed"></iframe>
            </div>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-youtube');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      const html = `<div class="embed-responsive embed-responsive-16by9">
                <iframe width="560" height="315" src="https://www.youtube.com/embed/P5yHEKqx86U?rel=0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
            </div>`;
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-video');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      let html = `<video style="width: 100%;" loop="" autoplay="">
                <source src="${builder.opts.snippetPath}example.mp4" type="video/mp4"></video>`;
      if (builder.opts.snippetSampleVideo) {
        html = `<video style="width: 100%;" loop="" autoplay="">
                    <source src="${builder.opts.snippetSampleVideo}" type="video/mp4"></video>`;
      }
      util.addContent(html, mode);
    });
    elm = quickadd.querySelector('.add-audio');
    dom.addEventListener(elm, 'click', () => {
      const mode = quickadd.getAttribute('data-mode');
      let html = `<div style="display:flex;width:100%;position:relative;margin:15px 0;background:transparent;">
                        <audio controls="" style="width:100%">
                            <source src="${builder.opts.snippetPath}example.mp3" type="audio/mpeg">
                            Your browser does not support the audio element.
                        </audio>
                    </div>`;
      if (builder.opts.snippetSampleAudio) {
        html = `<div style="display:flex;width:100%;position:relative;margin:15px 0;background:transparent;">
                            <audio controls="" style="width:100%">
                                <source src="${builder.opts.snippetSampleAudio}" type="audio/mpeg">
                                Your browser does not support the audio element.
                            </audio>
                    </div>`;
      }
      util.addContent(html, mode);
    });
    const snippets = new Snippets(builder);
    elm = quickadd.querySelector('.add-more');
    dom.addEventListener(elm, 'click', () => {
      let modal = builderStuff.querySelector('.snippets');
      util.showModal(modal, false, null, false);

      // let iframe = modal.querySelector('iframe');
      // if(iframe.src==='about:blank') {
      //     iframe.src = builder.opts.snippetData;
      // }
      const ifr = modal.querySelector('iframe');
      var doc = ifr.contentWindow.document;
      if (doc.body.innerHTML === '') {
        // doc.open();
        // doc.write(snippets.getSnippetsHtml());
        // doc.close();
        ifr.srcdoc = snippets.getSnippetsHtml();
      }

      // quickadd.style.display = '';
      util.hidePop(quickadd);
    });
  }
  return quickadd;
};

class Util {
  constructor(builder) {
    this.builder = builder;
    this.dom = this.builder.dom;
  }
  cellSelected() {
    return this.builder.doc.querySelector('.cell-active');
  }
  rowSelected() {
    return this.builder.doc.querySelector('.row-active');
  }
  builderStuff() {
    return document.querySelector('#_cbhtml');
  }
  cellNext(cell) {
    const dom = this.dom;
    let c = cell.nextElementSibling;
    if (c) {
      if (!dom.hasClass(c, 'is-row-tool') && !dom.hasClass(c, 'is-col-tool') && !dom.hasClass(c, 'is-rowadd-tool') && !dom.hasClass(c, 'is-row-overlay')) {
        return c;
      } else {
        return null;
      }
    }
    return null;
  }
  out(s) {
    if (this.builder) {
      let val = this.builder.opts.lang[s];
      if (val) return val;else {
        if (this.builder.checkLang) console.log(s);
        return s;
      }
    } else {
      return s;
    }
  }
  showMessage(message, focusOutline, callback) {
    const dom = this.dom;
    let html = '';
    html = `<div class="is-modal modalmessage" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="padding-top: 15px;padding-bottom: 20px;max-width: 450px;">
                <div style="margin: 20px 0 30px;font-size: 17px;">${message}</div>
                <button title="${this.out('Ok')}" class="input-ok classic">${this.out('Ok')}</button>
            </div>
        </div>`;
    const builderStuff = this.builder.builderStuff;
    let modalMessage = builderStuff.querySelector('.modalmessage');
    if (!modalMessage) {
      dom.appendHtml(builderStuff, html);
      modalMessage = builderStuff.querySelector('.modalmessage');
    }
    this.showModal(modalMessage, false, () => {
      modalMessage.parentNode.removeChild(modalMessage);
      if (callback) callback();
    });
    let buttonok = modalMessage.querySelector('.modalmessage .input-ok');
    dom.addEventListener(buttonok, 'click', () => {
      this.hideModal(modalMessage);
      if (modalMessage.parentNode) modalMessage.parentNode.removeChild(modalMessage);
      if (callback) callback();
    });
    buttonok.focus();
    if (focusOutline) {
      buttonok.classList.add('focus-outline');
    }
  }
  showChoice(message, yestext, callback) {
    const dom = this.dom;
    let html = '';
    html = `<div class="is-modal modalmessage" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="padding-top: 15px;padding-bottom: 20px;max-width: 450px;">
                <div style="margin: 20px 0 30px;font-size: 17px;">${message}</div>

                <div style="display:flex;">
                    <button title="${this.out('Cancel')}" class="input-cancel classic-secondary" style="width:100%;margin-right:4px;">${this.out('Cancel')}</button>
                    <button title="${yestext}" class="input-ok classic-primary" style="width:100%">${yestext}</button>
                </div>
            </div>
        </div>`;
    const builderStuff = this.builder.builderStuff;
    let modalMessage = builderStuff.querySelector('.modalmessage');
    if (!modalMessage) {
      dom.appendHtml(builderStuff, html);
      modalMessage = builderStuff.querySelector('.modalmessage');
    }
    this.showModal(modalMessage, false, () => {
      //this function runs when overlay is clicked. Remove modal.
      modalMessage.parentNode.removeChild(modalMessage);
      callback(false);
    });
    let btnCancel = modalMessage.querySelector('.modalmessage .input-cancel');
    dom.addEventListener(btnCancel, 'click', () => {
      this.hideModal(modalMessage);
      modalMessage.parentNode.removeChild(modalMessage); //remove modal

      callback(false);
    });
    btnCancel.focus();
    let btnOk = modalMessage.querySelector('.modalmessage .input-ok');
    dom.addEventListener(btnOk, 'click', () => {
      this.hideModal(modalMessage);
      modalMessage.parentNode.removeChild(modalMessage); //remove modal

      //do task
      callback(true);
    });
  }
  confirm(message, callback, yesno, yestext, forceOpen) {
    if (!this.builder.deleteConfirm && !forceOpen) {
      callback(true);
      return;
    }
    const dom = this.dom;
    let html = '';
    html = `<div class="is-modal is-confirm" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="padding-bottom:20px;">
                <div style="margin: 20px 0 30px;font-size: 14px;">${message}</div>
                <button title="${this.out('Delete')}" class="input-ok classic focus-warning">${this.out('Delete')}</button>
            </div>
        </div>`;
    if (yesno) {
      html = `<div class="is-modal is-confirm" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="padding-bottom:20px;">
                    <div style="margin: 20px 0 30px;font-size: 14px;">${message}</div>
                    <button title="${this.out('Cancel')}" class="input-cancel classic-secondary">${this.out('Cancel')}</button>
                    <button title="${yestext}" class="input-ok classic-primary">${yestext}</button>
                </div>
            </div>`;
    }
    const builderStuff = this.builder.builderStuff;
    let confirmmodal = builderStuff.querySelector('.is-confirm');
    if (!confirmmodal) {
      dom.appendHtml(builderStuff, html);
      confirmmodal = builderStuff.querySelector('.is-confirm');
    }
    this.showModal(confirmmodal, false, () => {
      //this function runs when overlay is clicked. Remove modal.
      confirmmodal.parentNode.removeChild(confirmmodal);

      //do task
      callback(false);
    }, true);
    let buttonok = confirmmodal.querySelector('.is-confirm .input-ok');
    dom.addEventListener(buttonok, 'click', () => {
      this.hideModal(confirmmodal);
      confirmmodal.parentNode.removeChild(confirmmodal); //remove modal

      //do task
      callback(true);
    });
    let buttoncancel = confirmmodal.querySelector('.is-confirm .input-cancel');
    dom.addEventListener(buttoncancel, 'click', e => {
      this.hideModal(confirmmodal);
      confirmmodal.parentNode.removeChild(confirmmodal); //remove modal

      //do task
      callback(false);
      e.preventDefault();
      e.stopImmediatePropagation();
    });
    if (buttonok) buttonok.focus();
  }
  showRtePop(pop, onShow, btn) {
    const dom = this.dom;
    pop.style.display = 'flex';
    if (onShow) onShow();
    dom.removeClass(pop, 'deactive');
    dom.addClass(pop, 'active');
    const handleClickOut = e => {
      let inputFocused = document.activeElement.tagName.toLowerCase() === 'input';
      if (inputFocused) {
        if (pop.contains(document.activeElement)) return;
      }
      if (!pop.contains(e.target) && !btn.contains(e.target) && !e.target.closest('.pickcolormore')) {
        // click outside

        this.hideRtePop(pop); // hide

        pop.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('click', handleClickOut);
        if (this.builder.iframeDocument) {
          this.builder.doc.removeEventListener('click', handleClickOut);
        }
      }
    };
    const handleKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key

        this.hideRtePop(pop); // hide

        pop.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('click', handleClickOut);
        if (this.builder.iframeDocument) {
          this.builder.doc.removeEventListener('click', handleClickOut);
        }
      }
    };
    pop.addEventListener('keydown', handleKeyDown);
    document.addEventListener('click', handleClickOut);
    if (this.builder.iframeDocument) {
      this.builder.doc.addEventListener('click', handleClickOut);
    }
  }
  hideRtePop(pop) {
    const dom = this.dom;
    pop.style.display = '';
    dom.removeClass(pop, 'active');
    dom.addClass(pop, 'deactive');
  }
  clearAllEventListener(pop) {
    for (let i = 0; i < 10; i++) {
      pop.removeEventListener('keydown', this.handlePopKeyDown);
      document.removeEventListener('click', this.handlePopClickOut);
      if (this.builder.iframeDocument) {
        this.builder.doc.removeEventListener('click', this.handlePopClickOut);
      }
    }
  }
  showPop(pop, cancelCallback, btn) {
    const dom = this.dom;

    // Hide other pops
    let elms = document.querySelectorAll('.is-pop.active');
    Array.prototype.forEach.call(elms, elm => {
      if (elm !== pop) {
        elm.style.display = '';
        dom.removeClass(elm, 'active');
        elm.setAttribute('aria-hidden', true);
      }
    });

    // if(pop.style.display === 'flex') return; 
    this.clearAllEventListener(pop); // for safety of uncleared events as a result of closing without hidePop()

    pop.style.display = 'flex';
    dom.addClass(pop, 'active');
    pop.setAttribute('aria-hidden', false);
    this.setupTabKeys(pop);
    pop.focus({
      preventScroll: true
    });
    this.handlePopClickOut = e => {
      if (!pop.contains(e.target) && !btn.contains(e.target)) {
        // click outside
        // hide
        this.hidePop(pop);

        // pop.removeEventListener('keydown', this.handlePopKeyDown);
        // document.removeEventListener('click', this.handlePopClickOut);

        if (cancelCallback) cancelCallback();
      }
    };
    this.handlePopKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key
        // hide
        this.hidePop(pop);

        // pop.removeEventListener('keydown', this.handlePopKeyDown);
        // document.removeEventListener('click', this.handlePopClickOut);

        if (cancelCallback) cancelCallback();
      }
    };
    pop.addEventListener('keydown', this.handlePopKeyDown);
    document.addEventListener('click', this.handlePopClickOut);
    if (this.builder.iframeDocument) {
      this.builder.doc.addEventListener('click', this.handlePopClickOut);
    }
  }
  hidePop(pop) {
    const dom = this.dom;
    pop.style.display = '';
    dom.removeClass(pop, 'active');
    pop.setAttribute('aria-hidden', true);

    // pop.removeEventListener('keydown', this.handlePopKeyDown);
    // document.removeEventListener('click', this.handlePopClickOut);
    this.clearAllEventListener(pop);
  }
  setupTabKeys(div) {
    let inputs = div.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]):not([tabindex="-1"]), iframe, object, embed, *[tabindex]:not([tabindex="-1"])');
    if (inputs.length === 0) return;
    let firstInput = inputs[0];
    let lastInput = inputs[inputs.length - 1];
    // firstInput.focus();

    // Redirect last tab to first input
    lastInput.addEventListener('keydown', e => {
      if (e.which === 9 && !e.shiftKey) {
        e.preventDefault();

        // re-select (because controls can enabled/disapbled)
        inputs = div.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]):not([tabindex="-1"]), iframe, object, embed, *[tabindex]:not([tabindex="-1"])');
        firstInput = inputs[0];
        firstInput.focus();
      }
    });

    // Redirect first shift+tab to last input
    firstInput.addEventListener('keydown', e => {
      if (e.which === 9 && e.shiftKey) {
        e.preventDefault();
        lastInput.focus();
      }
    });
    const iframes = div.querySelectorAll('iframe');
    iframes.forEach(iframe => {
      iframe.addEventListener('focus', () => {
        let doc = iframe.contentWindow.document;
        const ifrInputs = doc.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]):not([tabindex="-1"]), iframe, object, embed, *[tabindex]:not([tabindex="-1"])');
        if (ifrInputs.length === 0) return;
        let firstIfrInput = ifrInputs[0];
        if (firstIfrInput) firstIfrInput.focus();
      });
    });
  }

  /*
  Note:
  - hideModal will remove the modal element, so calling show modal multiple times won't attach multiple events (safe).
  */
  showModal(modal, overlayStay, cancelCallback, animated, overflowHidden) {
    const dom = this.dom;
    dom.addClass(modal, 'active');
    modal.setAttribute('aria-hidden', false);
    if (overflowHidden) document.body.style.overflow = 'hidden';
    const handleKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key

        if (overflowHidden) document.body.style.overflow = '';
        if (dom.hasClass(modal, 'active')) this.hideModal(modal); // check first in case programmatically ESC key that already call hideModal is triggered (see _hideModal)

        modal.removeEventListener('keydown', handleKeyDown);
        const btnClose = modal.querySelector('.is-modal-close');
        if (btnClose) btnClose.removeEventListener('click', close);
        if (cancelCallback) cancelCallback();
      }
    };
    modal.addEventListener('keydown', handleKeyDown);
    let content = modal.querySelector('.is-tab-content.active');
    if (content) {
      content.focus();
      this.builder.tabs.setupTabKey(content);
    } else {
      this.setupTabKeys(modal);
      modal.focus();
    }

    /* Disable Modal Animation */
    let animate = false;
    if (this.builder) {
      if (this.builder.opts.animateModal) {
        animate = true;
        if (!animated) {
          // if not set or false
          animate = false; // overide   
        }
      }
    } else {
      if (animated) {
        // if set true
        animate = true; // overide
      }
    }

    if (animate) {
      if (this.builder) {
        const buildercontainers = this.builder.doc.querySelectorAll(this.builder.opts.container);
        Array.prototype.forEach.call(buildercontainers, buildercontainer => {
          // buildercontainer.style.transform = 'scale(0.98)';
          // buildercontainer.style.WebkitTransform= 'scale(0.98)';
          // buildercontainer.style.MozTransform= 'scale(0.98)';
          buildercontainer.style.transform = `scale(${this.builder.opts.zoom - 0.02})`;
          buildercontainer.style.WebkitTransform = `scale(${this.builder.opts.zoom - 0.02})`;
          buildercontainer.style.MozTransform = `scale(${this.builder.opts.zoom - 0.02})`;
          buildercontainer.setAttribute('scaled-down', '1');
        });
      }
    }
    const ovl = modal.querySelector('.is-modal-overlay');
    if (ovl) ovl.parentNode.removeChild(ovl); // new

    if (!modal.querySelector('.is-modal-overlay')) {
      let html;
      if (overlayStay) {
        html = '<div class="is-modal-overlay overlay-stay"></div>';
      } else {
        html = '<div class="is-modal-overlay"></div>';
      }
      modal.insertAdjacentHTML('afterbegin', html);
      if (!overlayStay) {
        let overlay = modal.querySelector('.is-modal-overlay');
        dom.addEventListener(overlay, 'click', () => {
          if (overflowHidden) document.body.style.overflow = '';
          this.hideModal(modal);
          modal.removeEventListener('keydown', handleKeyDown);
          const btnClose = modal.querySelector('.is-modal-close');
          if (btnClose) btnClose.removeEventListener('click', close);
          if (cancelCallback) cancelCallback();
        });
      }
    }
    const close = () => {
      if (overflowHidden) document.body.style.overflow = '';
      if (dom.hasClass(modal, 'active')) this.hideModal(modal); // check first in case programmatically ESC key that already call hideModal is triggered (see _hideModal)

      modal.removeEventListener('keydown', handleKeyDown);
      const btnClose = modal.querySelector('.is-modal-close');
      if (btnClose) btnClose.removeEventListener('click', close);
      if (cancelCallback) cancelCallback();
    };
    const btnClose = modal.querySelector('.is-modal-close');
    if (btnClose) dom.addEventListener(btnClose, 'click', close);
  }
  _hideModal(modal) {
    let overlay = modal.querySelector('.is-modal-overlay');
    if (overlay) {
      if (overlay.classList.contains('overlay-stay')) {
        this.hideModal(modal); // just to make sure

        modal.dispatchEvent(new KeyboardEvent('keydown', {
          key: 'e',
          keyCode: 27,
          code: 'KeyE',
          which: 27,
          shiftKey: false,
          ctrlKey: false,
          metaKey: false
        })); // Programmatically call ESC so that cancelCallback can be triggered
      } else {
        overlay.click(); // so that cancelCallback can be triggered
      }
    } else {
      this.hideModal(modal); // just to make sure

      modal.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'e',
        keyCode: 27,
        code: 'KeyE',
        which: 27,
        shiftKey: false,
        ctrlKey: false,
        metaKey: false
      })); // Programmatically call ESC so that cancelCallback can be triggered
    }
  }

  hideModal(modal) {
    modal.setAttribute('aria-hidden', true);

    /* Disable Modal Animation */
    if (this.builder) {
      const buildercontainers = this.builder.doc.querySelectorAll(this.builder.opts.container);
      Array.prototype.forEach.call(buildercontainers, buildercontainer => {
        // buildercontainer.style.transform = '';
        // buildercontainer.style.WebkitTransform= '';
        // buildercontainer.style.MozTransform= '';
        if (buildercontainer.getAttribute('scaled-down')) {
          buildercontainer.style.transform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.style.WebkitTransform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.style.MozTransform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.removeAttribute('scaled-down');
        }
      });
    }
    const dom = this.dom;
    dom.removeClass(modal, 'active');
    modal.style.display = '';

    // document.body.style.overflow = '';
  }

  refreshModuleLayout(col) {
    let savedHeight;
    if (col.style.height) savedHeight = col.style.height;else col.style.height = `${col.offsetHeight}px`;
    col.style.opacity = 0;
    let html = decodeURIComponent(col.getAttribute('data-html'));
    html = html.replace(/{id}/g, this.builder.util.makeId());
    col.innerHTML = '';
    let range = document.createRange();
    range.setStart(col, 0);
    col.appendChild(range.createContextualFragment(html));
    let subblocks = col.querySelectorAll('[data-subblock]');
    var i = 1;
    Array.prototype.forEach.call(subblocks, subblock => {
      if (col.getAttribute('data-html-' + i)) {
        subblock.innerHTML = decodeURIComponent(col.getAttribute('data-html-' + i));
        subblock.contentEditable = true;
      }
      i++;
    });
    setTimeout(() => {
      if (savedHeight) {
        col.style.height = savedHeight;
      } else {
        col.style.height = '';
      }
      col.style.opacity = '';
    }, 100);
  }
  removeColClasses(cell) {
    cell.classList.remove('full');
    cell.classList.remove('two-third');
    cell.classList.remove('two-fourth');
    cell.classList.remove('two-fifth');
    cell.classList.remove('two-sixth');
    cell.classList.remove('half');
    cell.classList.remove('third');
    cell.classList.remove('fourth');
    cell.classList.remove('fifth');
    cell.classList.remove('sixth');
    cell.classList.remove('seventh');
    cell.classList.remove('eighth');
    cell.classList.remove('ninth');
    cell.classList.remove('tenth');
    cell.classList.remove('eleventh');
    cell.classList.remove('twelfth');
  }
  getAllColumns(row) {
    let arrCells = [];
    const dom = this.dom;
    const cols = dom.elementChildren(row);
    cols.forEach(col => {
      if (dom.hasClass(col, 'is-row-tool') || dom.hasClass(col, 'is-col-tool') || dom.hasClass(col, 'is-rowadd-tool') || dom.hasClass(col, 'is-row-overlay')) return;
      arrCells.push(col);
    });
    return arrCells;
  }
  fixLayout(row) {
    const dom = this.dom;
    let smHidden = false;
    let mdHidden = false;
    Array.from(row.children).map(item => {
      if (item.classList.contains('is-row-tool')) return;
      if (item.classList.contains('is-col-tool')) return;
      if (item.classList.contains('is-rowadd-tool')) return;

      // item.style.width = '';
      // item.style.flex = '';
      if (item.getAttribute('data-html')) {
        // Don't change width on custom block
        if (!item.style.width) {
          // But if width is not set, add default 50%
          item.style.width = '50%';
          item.style.flex = '0 0 auto';
        }
        if (this.getAllColumns(row).length === 1) {
          // only 1 col in a row
          item.style.width = '';
          item.style.flex = '';
        }
      } else {
        item.style.width = '';
        item.style.flex = '';
      }
      if (item.classList.contains('sm-hidden')) {
        smHidden = true;
      }
      if (item.classList.contains('md-hidden')) {
        mdHidden = true;
      }
    });
    if (smHidden) {
      row.classList.add('sm-autofit');
    } else {
      row.classList.remove('sm-autofit');
    }
    if (mdHidden) {
      row.classList.add('md-autofit');
    } else {
      row.classList.remove('md-autofit');
    }
    if (this.builder.useDefaultGrid) {
      const cols = dom.elementChildren(row);
      cols.forEach(col => {
        if (dom.hasClass(col, 'is-row-tool') || dom.hasClass(col, 'is-col-tool') || dom.hasClass(col, 'is-rowadd-tool') || dom.hasClass(col, 'is-row-overlay')) return;
        this.removeColClasses(col);
      });

      // Refresh Module
      Array.from(row.children).map(item => {
        if (item.classList.contains('is-row-tool')) return;
        if (item.classList.contains('is-rowadd-tool')) return;
        if (item.classList.contains('is-col-tool')) return;
        if (item.getAttribute('data-module')) {
          this.refreshModuleLayout(item);
        }
      });
      return;
    }
    let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
    if (row.querySelector('.is-row-overlay')) {
      num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
    }

    const cellCount = row.childElementCount - num;
    const rowClass = this.builder.opts.row;
    let colClass = this.builder.opts.cols;
    const colEqual = this.builder.opts.colequal;
    if (colEqual.length > 0) {
      const cols = dom.elementChildren(row);
      cols.forEach(col => {
        if (dom.hasClass(col, 'is-row-tool') || dom.hasClass(col, 'is-col-tool') || dom.hasClass(col, 'is-rowadd-tool') || dom.hasClass(col, 'is-row-overlay')) return;
        for (let i = 0; i <= colClass.length - 1; i++) {
          dom.removeClass(col, colClass[i]);
        }
        for (let i = 0; i <= colEqual.length - 1; i++) {
          if (colEqual[i].length === cellCount) {
            dom.addClass(col, colEqual[i][0]);
            break;
          }
        }
        if (cellCount === 1) {
          dom.addClass(col, colClass[colClass.length - 1]);
        }
      });

      // Refresh Module
      Array.from(row.children).map(item => {
        if (item.classList.contains('is-row-tool')) return;
        if (item.classList.contains('is-rowadd-tool')) return;
        if (item.classList.contains('is-col-tool')) return;
        if (item.getAttribute('data-module')) {
          this.refreshModuleLayout(item);
        }
      });
      return;
    }

    //others (12 columns grid)
    if (rowClass !== '' && colClass.length > 0) {
      let n = 0;
      const cols = dom.elementChildren(row);
      cols.forEach(col => {
        if (dom.hasClass(col, 'is-row-tool') || dom.hasClass(col, 'is-col-tool') || dom.hasClass(col, 'is-rowadd-tool') || dom.hasClass(col, 'is-row-overlay')) return;

        // Bootstrap stuff
        if (col.className.indexOf('col-md-') !== -1) ; else if (col.className.indexOf('col-sm-') !== -1) {
          colClass = ['col-sm-1', 'col-sm-2', 'col-sm-3', 'col-sm-4', 'col-sm-5', 'col-sm-6', 'col-sm-7', 'col-sm-8', 'col-sm-9', 'col-sm-10', 'col-sm-11', 'col-sm-12'];
        } else if (col.className.indexOf('col-xs-') !== -1) {
          colClass = ['col-xs-1', 'col-xs-2', 'col-xs-3', 'col-xs-4', 'col-xs-5', 'col-xs-6', 'col-xs-7', 'col-xs-8', 'col-xs-9', 'col-xs-10', 'col-xs-11', 'col-xs-12'];
        } else if (col.className.indexOf('col-lg-') !== -1) {
          colClass = ['col-lg-1', 'col-lg-2', 'col-lg-3', 'col-lg-4', 'col-lg-5', 'col-lg-6', 'col-lg-7', 'col-lg-8', 'col-lg-9', 'col-lg-10', 'col-lg-11', 'col-lg-12'];
        } else if (col.className.indexOf('col-xl-') !== -1) {
          colClass = ['col-xl-1', 'col-xl-2', 'col-xl-3', 'col-xl-4', 'col-xl-5', 'col-xl-6', 'col-xl-7', 'col-xl-8', 'col-xl-9', 'col-xl-10', 'col-xl-11', 'col-xl-12'];
        } else if (col.className.indexOf('col-xxl-') !== -1) {
          colClass = ['col-xxl-1', 'col-xxl-2', 'col-xxl-3', 'col-xxl-4', 'col-xxl-5', 'col-xxl-6', 'col-xxl-7', 'col-xxl-8', 'col-xxl-9', 'col-xxl-10', 'col-xxl-11', 'col-xxl-12'];
        }
        n++;
        for (var i = 0; i <= colClass.length - 1; i++) {
          dom.removeClass(col, colClass[i]);
        }
        if (cellCount === 1) dom.addClass(col, colClass[11]);
        if (cellCount === 2) dom.addClass(col, colClass[5]);
        if (cellCount === 3) dom.addClass(col, colClass[3]);
        if (cellCount === 4) {
          dom.addClass(col, colClass[2]);
        }
        if (cellCount === 5) {
          // 2, 2, 2, 2, 4
          if (n === 5) dom.addClass(col, colClass[3]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 6) dom.addClass(col, colClass[1]); // 2, 2, 2, 2, 2, 2

        if (cellCount === 7) {
          // 2, 2, 2, 2, 2, 1, 1
          if (n >= 6) dom.addClass(col, colClass[0]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 8) {
          // 2, 2, 2, 2, 1, 1, 1, 1
          if (n >= 5) dom.addClass(col, colClass[0]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 9) {
          // 2, 2, 2, 1, 1, 1, 1, 1, 1
          if (n >= 4) dom.addClass(col, colClass[0]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 10) {
          // 2, 2, 1, 1, 1, 1, 1, 1, 1, 1
          if (n >= 3) dom.addClass(col, colClass[0]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 11) {
          // 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
          if (n >= 2) dom.addClass(col, colClass[0]);else dom.addClass(col, colClass[1]);
        }
        if (cellCount === 12) dom.addClass(col, colClass[0]); // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      });
    }

    // Refresh Module
    Array.from(row.children).map(item => {
      if (item.classList.contains('is-row-tool')) return;
      if (item.classList.contains('is-rowadd-tool')) return;
      if (item.classList.contains('is-col-tool')) return;
      if (item.getAttribute('data-module')) {
        this.refreshModuleLayout(item);
      }
    });
  }
  addContent(html, mode, attr) {
    const dom = this.dom;
    if (this.builder.opts.onAdd) {
      html = this.builder.opts.onAdd(html);
    }
    const cell = this.cellSelected();
    let row;
    if (!cell) {
      let elm = this.builder.activeElement;
      if (elm && elm.closest('.is-block')) ; else {
        // If no active cell, check if it is from .row-add-initial (empty info)
        row = this.builder.doc.querySelector('.row-active');
        if (!row) return;else {
          // Empty content will always use 'row' mode to insert block.
          mode = 'row';
        }
      }
    } else {
      row = cell.parentNode;
    }
    if (mode === 'cell' || mode === 'cell-left' || mode === 'cell-right') {
      let maxCols = 4;
      if (this.builder.maxColumns) {
        maxCols = this.builder.maxColumns;
      }
      //Limit up to 4 cells in a row

      let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
      if (row.querySelector('.is-row-overlay')) {
        num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
      }

      if (row.childElementCount >= maxCols + num) {
        //+3 => includes is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
        alert(this.out('You have reached the maximum number of columns'));
        return false;
      }
      this.builder.uo.saveForUndo();
      let cellElement;
      if (this.builder.opts.row === '') {
        // TODO: Test using in old Insite
        let s = this.builder.opts.cellFormat;
        let pos = s.indexOf('</');
        html = s.substring(0, pos) + html + s.substring(pos);
        cellElement = this.createElementFromHTML(html);
      } else {
        cellElement = cell.cloneNode(true);

        // Cleanup from module related clone
        cellElement.removeAttribute('data-noedit');
        cellElement.removeAttribute('data-protected');
        cellElement.removeAttribute('data-module');
        cellElement.removeAttribute('data-module-desc');
        cellElement.removeAttribute('data-dialog-width');
        cellElement.removeAttribute('data-html');
        cellElement.removeAttribute('data-settings');
        for (let i = 1; i <= 20; i++) {
          cellElement.removeAttribute('data-html-' + i);
        }
        cellElement.removeAttribute('data-noedit');
        dom.removeClass(cellElement, 'cell-active');
        dom.removeClass(cellElement, 'is-light-text');
        dom.removeClass(cellElement, 'is-dark-text');
        dom.removeClass(cellElement, 'padding-0');
        dom.removeClass(cellElement, 'p-0');
        cellElement.removeAttribute('data-click');
        cellElement.removeAttribute('style');
        if (attr) {
          cellElement.setAttribute(attr, '');
        }
        cellElement.innerHTML = html;
      }
      row.insertBefore(cellElement, cell);
      if (mode === 'cell' || mode === 'cell-right') {
        dom.moveAfter(cellElement, cell);
      }
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);
      this.fixLayout(row);
      cellElement.click(); //change active block to the newly created
    }

    if (mode === 'row') {
      this.builder.uo.saveForUndo();
      let rowElement, cellElement;
      if (this.builder.opts.row === '') {
        rowElement = this.htmlToElement(this.builder.opts.rowFormat);
        let s = this.builder.opts.cellFormat;
        let pos = s.indexOf('</');
        html = s.substring(0, pos) + html + s.substring(pos);

        // go to last deeper level
        let targetrow = dom.elementChildren(rowElement);
        while (targetrow.length > 0) {
          targetrow = targetrow[0];
          if (dom.elementChildren(targetrow).length > 0) {
            targetrow = dom.elementChildren(targetrow);
          } else {
            break;
          }
        }
        targetrow.innerHTML = html;
        cellElement = targetrow.firstChild;
        if (attr) {
          cellElement.setAttribute(attr, '');
        }
      } else {
        cellElement = dom.createElement('div');
        dom.addClass(cellElement, this.builder.opts.cols[this.builder.opts.cols.length - 1]);
        cellElement.innerHTML = html;
        if (attr) {
          cellElement.setAttribute(attr, '');
        }
        rowElement = dom.createElement('div');
        dom.addClass(rowElement, this.builder.opts.row);
        dom.appendChild(rowElement, cellElement);
      }
      row.parentNode.insertBefore(rowElement, row);
      dom.moveAfter(rowElement, row);
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);
      cellElement.click(); //change active block to the newly created
    }

    if (mode === 'elm') {
      let elm = this.builder.activeElement; // See elementtool.js line 195-196. // document.querySelector('.elm-active');
      if (!elm) return;
      this.builder.uo.saveForUndo();
      let element = elm;
      let newelement;
      if (!element.nextElementSibling) {
        // active element is div.display > p.
        let activeCol = this.builder.activeCol;
        let current;
        const elms = dom.elementChildren(activeCol);
        elms.forEach(child => {
          if (child.contains(element)) {
            current = child;
          }
        });
        if (current) {
          current.insertAdjacentHTML('afterend', html); // add new element after div.display
          newelement = current.nextElementSibling;
        }
      } else {
        element.insertAdjacentHTML('afterend', html);
        newelement = element.nextElementSibling;
      }
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);
      if (newelement.tagName.toLowerCase() === 'img') {
        let checkLoad = setInterval(() => {
          if (newelement.complete) {
            newelement.click();
            clearInterval(checkLoad);
          }
        }, 30);
      } else {
        newelement.click();
      }
      const builderStuff = this.builder.builderStuff;
      let quickadd = builderStuff.querySelector('.quickadd');
      this.hidePop(quickadd);

      // LATER: auto scroll

      // LATER: If image, then it needs time to load (resulting incorrect position), so hide element tool. 
    }

    if (this.builder.useCssClasses) {
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) dom.contentReformat(builderActive, this.builder.cssClasses);
    }

    //Trigger Change event
    this.builder.opts.onChange();

    //Trigger Render event
    this.builder.opts.onRender();
  }

  // https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro
  htmlToElement(html) {
    var template = document.createElement('template');
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
  }
  addSnippet(html, bSnippet, noedit) {
    this.builder.uo.saveForUndo();
    const dom = this.dom;
    let rowElement;
    let bAddLast = false;
    let cell;
    let cellElement;
    const builderStuff = this.builder.builderStuff;
    let quickadd = builderStuff.querySelector('.quickadd');
    let mode;
    if (quickadd) {
      mode = quickadd.getAttribute('data-mode');
    } else {
      mode = 'row';
    }
    if (bSnippet && (mode === 'cell' || mode === 'cell-left' || mode === 'cell-right')) {
      if (noedit) {
        this.addContent(html, mode, 'data-noedit');
      } else {
        this.addContent(html, mode);
      }
      return;
    } else if (bSnippet && mode === 'row') {
      /*
      Buttons, line, social, video, map (Grid layout not included).
      Can be inserted after current row, cell, element, or last row.
      */

      // NEW: See contentbuilder.js line 328
      // OLD: See contentbuilder-jquery.js addSnippet() line 16529

      // Just snippet (without row/column grid), ex. buttons, line, social, video, map.
      // Can be inserted after current row, column (cell), element, or last row.

      // html = `<div class="${this.builder.opts.row}"><div class="${this.builder.opts.cols[this.builder.opts.cols.length-1]}"${(noedit? ' data-noedit': '')}>${html}</div></div>`;
      // OR like addContent() in util.js line 245)

      cellElement = document.createElement('div');
      cellElement.className = this.builder.opts.cols[this.builder.opts.cols.length - 1];
      cellElement.innerHTML = html;
      if (noedit) {
        cellElement.setAttribute('data-noedit', '');
      }
      rowElement = document.createElement('div');
      rowElement.className = this.builder.opts.row;
      rowElement.appendChild(cellElement);

      // Add after selected row
      cell = this.builder.cellSelected();
      let row;
      if (cell) {
        row = cell.parentNode;
      } else {
        // If no active cell, check if it is from .row-add-initial (empty info)
        row = this.builder.doc.querySelector('.row-active');
        if (!row) {
          bAddLast = true;
        }
      }
      // Add after last row
      if (bAddLast) {
        const nodes = this.builder.doc.querySelectorAll('.is-builder');
        const last = nodes[nodes.length - 1];
        const rows = dom.elementChildren(last);
        const lastrow = rows[rows.length - 1];
        row = lastrow;
      }
      row.parentNode.insertBefore(rowElement, row);
      dom.moveAfter(rowElement, row);

      // checkEmpty & onRender called here
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);else {
        builderActive = this.builder.doc.querySelector('.is-builder');
        this.builder.applyBehaviorOn(builderActive);
      }
      cellElement.click(); //change active block to the newly created

      // Change to row selection
      rowElement.className = rowElement.className.replace('row-outline', '');

      //Hide Column tool (new!)
      this.builder.util.hideColumnTool();
    } else if (bSnippet) {
      if (noedit) {
        this.addContent(html, mode, 'data-noedit');
      } else {
        this.addContent(html, mode);
      }
      return;
    } else {
      /*
      Complete with grid layout. Also may containes custom script(data-html)
      Can be inserted after current row or last row.
      */

      // NEW: See contentbuilder.js line 341 AND contentbuilder-jquery.js (addContentMore) line 11526
      // OLD: See contentbuilder-jquery.js (addContentMore) line 11526

      // Snippet is wrapped in row/colum (may contain custom code or has [data-html] attribute)
      // Can only be inserted after current row or last row (not on column or element).

      var snippet = document.createElement('div');
      snippet.innerHTML = html;
      var blocks = snippet.querySelectorAll('[data-html]');
      Array.prototype.forEach.call(blocks, block => {
        // Render custom code block
        html = decodeURIComponent(block.getAttribute('data-html'));
        html = html.replace(/{id}/g, this.makeId());
        html = html.replace(/<script>/g, `${this.builder.nonce ? `<script nonce="${this.builder.nonce}">` : '<script>'}`);
        for (var i = 1; i <= 20; i++) {
          html = html.replace('[%HTML' + i + '%]', block.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-' + i))); //render editable area
        }

        block.innerHTML = html;
      });

      //html = snippet.innerHTML; 

      // NEW: This allows snippets with complete row & column format (should be single row/col) can be added as a column
      if (snippet.childNodes.length === 1) if (snippet.childNodes[0].childNodes.length === 1 && (mode === 'cell' || mode === 'cell-left' || mode === 'cell-right')) {
        // this.addContent(html, mode, 'data-noedit');

        const cell = this.cellSelected();
        let row = cell.parentNode;
        let maxCols = 4;
        if (this.builder.maxColumns) {
          maxCols = this.builder.maxColumns;
        }
        //Limit up to 4 cells in a row
        if (row.querySelector('.is-row-overlay')) {
          if (row.childElementCount >= maxCols + 4) {
            //+4 => includes is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
            alert(this.out('You have reached the maximum number of columns'));
            return false;
          }
        } else {
          if (row.childElementCount >= maxCols + 3) {
            //+3 => includes is-row-tool, is-col-tool & is-rowadd-tool
            alert(this.out('You have reached the maximum number of columns'));
            return false;
          }
        }
        this.builder.uo.saveForUndo();
        let cellElement = snippet.childNodes[0].childNodes[0];

        // row.insertBefore(cellElement, cell);
        var range = document.createRange();
        cell.parentNode.insertBefore(range.createContextualFragment(cellElement.outerHTML), cell);
        if (mode === 'cell' || mode === 'cell-right') {
          // dom.moveAfter(cellElement, cell);
          cell.parentNode.insertBefore(cell.previousElementSibling, cell);
          cell.parentNode.insertBefore(cell, cell.previousElementSibling);
        }
        let builderActive = this.builder.doc.querySelector('.builder-active');
        if (builderActive) this.builder.applyBehaviorOn(builderActive);else {
          builderActive = this.builder.doc.querySelector('.is-builder');
          this.builder.applyBehaviorOn(builderActive);
        }
        this.fixLayout(row);

        // cellElement.click(); //change active block to the newly created
        if (mode === 'cell' || mode === 'cell-right') {
          cell.nextElementSibling.click();
        } else {
          cell.previousElementSibling.click();
        }

        //Trigger Change event
        this.builder.opts.onChange();

        //Trigger Render event
        this.builder.opts.onRender();
        return;
      }

      // Add after selected row
      cell = this.builder.activeCol;
      let row;
      if (cell) {
        row = cell.parentNode; // in email mode, cell active is also under row active (incorrect, but cell active is not needed in email mode. So this line works!)
      } else {
        // If no active cell, check if it is from .row-add-initial (empty info)
        row = this.builder.doc.querySelector('.row-active');
        if (!row) {
          bAddLast = true;
        }
      }
      // Add after last row
      if (bAddLast) {
        const nodes = this.builder.doc.querySelectorAll('.is-builder');
        const last = nodes[nodes.length - 1];
        const rows = dom.elementChildren(last);
        const lastrow = rows[rows.length - 1];
        row = lastrow;
      }

      // Use createContextualFragment() to make embedded script executable
      // https://ghinda.net/article/script-tags/
      range = document.createRange();
      row.parentNode.insertBefore(range.createContextualFragment(snippet.innerHTML), row.nextSibling);
      rowElement = snippet.childNodes[0];

      // Auto scroll
      // const y = row.getBoundingClientRect().top +  row.offsetHeight + window.pageYOffset - 120;
      // window.scroll({
      //     top: y,
      //     behavior: 'smooth'
      // });
      // window.scrollTo(0, y);

      // setTimeout(()=>{
      //     row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // }, 600);

      rowElement = row.nextElementSibling; // a must. Must be before applyBehavior to prevent element delete during fixLayout

      // checkEmpty & onRender called here
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);else {
        builderActive = this.builder.doc.querySelector('.is-builder');
        this.builder.applyBehaviorOn(builderActive);
      }
      cellElement = rowElement.querySelector('div');
      if (cellElement) cellElement.click(); //change active block to the newly created

      // Change to row selection
      rowElement.className = rowElement.className.replace('row-outline', '');

      //Hide Column tool (new!)
      this.builder.util.hideColumnTool();
    }
    if (this.builder.useCssClasses) {
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) dom.contentReformat(builderActive, this.builder.cssClasses);
    }

    //Trigger Change event
    this.builder.opts.onChange();

    //Trigger Render event
    this.builder.opts.onRender();
  }
  clearActiveCell() {
    // this.builder.lastActiveCol = this.cellSelected(); // get active cell before cleared (will be used by snippets dialog)

    const builderStuff = this.builder.builderStuff;
    if (!builderStuff) return; // in case the builder is destroyed

    let divs = this.builder.doc.getElementsByClassName('cell-active');
    while (divs.length) divs[0].classList.remove('cell-active');
    divs = this.builder.doc.getElementsByClassName('row-outline');
    while (divs.length) divs[0].classList.remove('row-outline');
    divs = this.builder.doc.getElementsByClassName('row-active');
    while (divs.length) divs[0].classList.remove('row-active');
    divs = this.builder.doc.getElementsByClassName('builder-active');
    while (divs.length) divs[0].classList.remove('builder-active');
    this.builder.activeCol = null;
    this.builder.dom.removeClass(this.builder.doc.body, 'content-edit');
  }
  clearAfterUndoRedo() {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    let tools = builderStuff.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      tool.style.display = '';
      dom.removeClass(tool, 'active');
    });
    if (this.builder.iframe) {
      tools = this.builder.contentStuff.querySelectorAll('.is-tool');
      Array.prototype.forEach.call(tools, tool => {
        tool.style.display = '';
        dom.removeClass(tool, 'active');
      });
    }
    if (this.builder.moveable) this.builder.moveable.updateRect();
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none';
    this.builder.activeSpacer = null;
    this.builder.activeCodeBlock = null;
    this.builder.activeLink = null;
    this.builder.activeLinkButton = null;
    this.builder.activeButton = null;
    this.builder.activeIframe = null;
    this.builder.activeTd = null;
    this.builder.activeTable = null;
    this.builder.activeModule = null;
    this.builder.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
    this.builder.activeIcon = null;

    // RTE
    if (!this.builder.controlPanel) {
      let rteTool = builderStuff.querySelector('.is-rte-tool');
      // rteTool.style.display = 'none';
      let rteButtons = rteTool.querySelectorAll('button');
      Array.prototype.forEach.call(rteButtons, rteButton => {
        dom.removeClass(rteButton, 'on');
      });
      let elementRteTool = builderStuff.querySelector('.is-elementrte-tool');
      // rteTool.style.display = 'none';
      rteButtons = elementRteTool.querySelectorAll('button');
      Array.prototype.forEach.call(rteButtons, rteButton => {
        dom.removeClass(rteButton, 'on');
      });
    }
    let pops = builderStuff.querySelectorAll('.is-pop');
    Array.prototype.forEach.call(pops, pop => {
      pop.style.display = '';
    });
  }
  hidePops() {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    let tools = builderStuff.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      // if(tool.classList.contains('is-row-tool')||
      // tool.classList.contains('is-column-tool')||
      // tool.classList.contains('is-element-tool')) return;

      tool.style.display = '';
      dom.removeClass(tool, 'active');
    });
    let pops = builderStuff.querySelectorAll('.is-pop.active');
    Array.prototype.forEach.call(pops, pop => {
      pop.style.transition = 'all 200ms ease';
      setTimeout(() => {
        pop.style.opacity = '0';
      }, 10);
      setTimeout(() => {
        pop.style.display = '';
        dom.removeClass(pop, 'active');
        pop.style.opacity = '';
        pop.style.transition = '';
      }, 200);
    });
    const movControlBox = document.querySelector('.moveable-control-box');
    const imageResizer = document.querySelector('#divImageResizer');
    if (movControlBox && imageResizer && !imageResizer.getAttribute('data-resizing')) {
      // this.builder.moveable.updateRect();
      movControlBox.style.display = 'none';
    }
  }
  hideControls() {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    let tools = builderStuff.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      tool.style.display = '';
      dom.removeClass(tool, 'active');
    });
    if (this.builder.iframe) {
      tools = this.builder.contentStuff.querySelectorAll('.is-tool');
      Array.prototype.forEach.call(tools, tool => {
        tool.style.display = '';
        dom.removeClass(tool, 'active');
      });
    }
    if (this.builder.moveable) this.builder.moveable.updateRect();
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none';
  }
  clearActiveElement(all) {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    this.builder.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
    this.builder.activeIcon = null;
    let elms = this.builder.doc.querySelectorAll('.elm-inspected');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-inspected');
    });
    this.builder.inspectedElement = null;
    elms = this.builder.doc.querySelectorAll('.elm-active');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-active');
    });
    this.builder.activeElement = null;
    let elmTool = this.builder.doc.querySelector('.is-element-tool');
    elmTool.style.display = '';
    let linkTool = this.builder.doc.querySelector('#divLinkTool');
    if (linkTool) linkTool.style.display = '';
    if (all && !this.builder.controlPanel) {
      // RTE
      let rtetool = builderStuff.querySelector('.is-rte-tool');
      if (rtetool) rtetool.style.display = 'none';
      let elementRtetool = builderStuff.querySelector('.is-elementrte-tool');
      if (elementRtetool) elementRtetool.style.display = 'flex';

      // Click ok on code view should hide these as well
      let rtetoolmore = builderStuff.querySelector('.rte-more-options');
      if (rtetoolmore) rtetoolmore.style.display = '';
      let elementRtetoolmore = builderStuff.querySelector('.elementrte-more-options');
      if (elementRtetoolmore) elementRtetoolmore.style.display = '';
      let btns = elementRtetool.querySelectorAll('button[data-align]');
      Array.prototype.forEach.call(btns, btn => {
        btn.style.display = 'none';
      });
      this.builder.rte.positionToolbar();
    }
  }
  clearPops() {
    // Simplified version of clearControls(), used only on window resize

    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    if (!builderStuff) return; // in case the builder is destroyed

    let tools = builderStuff.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      tool.style.display = '';
      dom.removeClass(tool, 'active');
    });
    if (this.builder.iframe) {
      tools = this.builder.contentStuff.querySelectorAll('.is-tool');
      Array.prototype.forEach.call(tools, tool => {
        tool.style.display = '';
        dom.removeClass(tool, 'active');
      });
    }
    if (this.builder.moveable) this.builder.moveable.updateRect();
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none';

    // show iframe overlay to make it clickable
    let ovls = this.builder.doc.querySelectorAll('.ovl');
    Array.prototype.forEach.call(ovls, ovl => {
      ovl.style.display = 'block';
    });
    let pops = builderStuff.querySelectorAll('.is-pop');
    Array.prototype.forEach.call(pops, pop => {
      pop.style.display = '';
      dom.removeClass(pop, 'active');
      pop.setAttribute('aria-hidden', true);
    });
    this.builder.colTool.lockIndicator.style.display = '';
    if (this.builder.resize) {
      this.builder.resize.destroy(); // destroy previous instance
    }
  }

  clearControls() {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    if (!builderStuff) return; // in case the builder is destroyed

    let tools = builderStuff.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      tool.style.display = '';
      dom.removeClass(tool, 'active');
    });
    if (this.builder.iframe) {
      tools = this.builder.contentStuff.querySelectorAll('.is-tool');
      Array.prototype.forEach.call(tools, tool => {
        tool.style.display = '';
        dom.removeClass(tool, 'active');
      });
    }
    if (this.builder.moveable) this.builder.moveable.updateRect();
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none';
    this.builder.activeSpacer = null;
    this.builder.activeCodeBlock = null;
    this.builder.activeLink = null;
    this.builder.activeLinkButton = null;
    this.builder.activeButton = null;
    this.builder.activeIframe = null;
    this.builder.activeTd = null;
    this.builder.activeTable = null;
    this.builder.activeModule = null;
    this.builder.activeImage = null;
    this.builder.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
    this.builder.activeIcon = null;

    // show iframe overlay to make it clickable
    let ovls = this.builder.doc.querySelectorAll('.ovl');
    Array.prototype.forEach.call(ovls, ovl => {
      ovl.style.display = 'block';
    });

    // Element Panel & Snippets sidebar
    var panels = builderStuff.querySelectorAll('.is-side.elementstyles');
    Array.prototype.forEach.call(panels, panel => {
      dom.removeClass(panel, 'active');
    });

    // Element Panel things
    let elms = this.builder.doc.querySelectorAll('[data-saveforundo]');
    Array.prototype.forEach.call(elms, elm => {
      elm.removeAttribute('data-saveforundo');
    });
    elms = this.builder.doc.querySelectorAll('.elm-inspected');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-inspected');
    });

    // RTE
    if (!this.builder.controlPanel) {
      if (this.builder.toolbarDisplay === 'auto') {
        let rtetool = builderStuff.querySelector('.is-rte-tool');
        if (rtetool) rtetool.style.display = 'none';
        let elementRtetool = builderStuff.querySelector('.is-elementrte-tool');
        if (elementRtetool) elementRtetool.style.display = 'none';

        // Click ok on code view should hide these as well
        let rtetoolmore = builderStuff.querySelector('.rte-more-options');
        if (rtetoolmore) rtetoolmore.style.display = '';
        let elementRtetoolmore = builderStuff.querySelector('.elementrte-more-options');
        if (elementRtetoolmore) elementRtetoolmore.style.display = '';
      }
    }

    // Element
    elms = this.builder.doc.querySelectorAll('.elm-active');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-active');
    });
    if (!this.builder.controlPanel) {
      let rtepops = builderStuff.querySelectorAll('.is-rte-pop');
      Array.prototype.forEach.call(rtepops, rtepop => {
        rtepop.style.display = '';
        dom.removeClass(rtepop, 'active');
        dom.removeClass(rtepop, 'deactive');
        // dom.addClass(rtepop, 'deactive');
      });
    }

    let pops = builderStuff.querySelectorAll('.is-pop');
    Array.prototype.forEach.call(pops, pop => {
      pop.style.display = '';
      dom.removeClass(pop, 'active');
      pop.setAttribute('aria-hidden', true);
    });
    this.builder.colTool.lockIndicator.style.display = '';
    if (this.builder.resize) {
      this.builder.resize.destroy(); // destroy previous instance
    }
  }

  // source: http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
  makeId() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  getSelection() {
    //used only by createlink (elementhyperlink.js)
    const blocks = this.builder.dom.getSelectedBlocks();
    if (blocks.length > 0) {
      this.builder.selectionMulti = true;
    } else {
      this.builder.selectionMulti = false;
      const selection = this.builder.win.getSelection();
      const container = this.builder.dom.getElm();
      if (!container) return;
      const sameSelection = container && container.innerText === selection.toString().trim();
      if (sameSelection || selection.toString().trim() === '') {
        this.builder.selectionElm = container;

        // extra
        let link = container.closest('a');
        if (link) {
          this.builder.activeLink = link;
        } else {
          this.builder.activeLink = null;
        }
      } else {
        this.builder.selectionText = selection;

        // extra
        this.builder.activeLink = null;
      }
    }
  }

  // source: http://stackoverflow.com/questions/5605401/insert-link-in-contenteditable-element 
  saveSelection() {
    if (this.builder.win.getSelection) {
      let sel = this.builder.win.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        let ranges = [];
        for (let i = 0, len = sel.rangeCount; i < len; ++i) {
          ranges.push(sel.getRangeAt(i));
        }
        this.builder.selection = ranges;
        return ranges;
      }
    } else if (this.builder.doc.selection && this.builder.doc.selection.createRange) {
      this.builder.selection = this.builder.doc.selection.createRange();
      return this.builder.doc.selection.createRange();
    }
    this.builder.selection = null;
    return null;
  }
  restoreSelection() {
    let savedSel = this.builder.selection;
    if (savedSel) {
      if (this.builder.win.getSelection) {
        let sel = this.builder.win.getSelection();
        // sel.removeAllRanges();
        if (this.builder.doc.body.createTextRange) {
          // All IE but Edge
          var range = this.builder.doc.body.createTextRange();
          range.collapse();
          range.select();
        } else if (this.builder.win.getSelection) {
          if (this.builder.win.getSelection().empty) {
            this.builder.win.getSelection().empty();
          } else if (this.builder.win.getSelection().removeAllRanges) {
            this.builder.win.getSelection().removeAllRanges();
          }
        } else if (this.builder.doc.selection) {
          this.builder.doc.selection.empty();
        }
        for (var i = 0, len = savedSel.length; i < len; ++i) {
          sel.addRange(savedSel[i]);
        }
      } else if (this.builder.doc.selection && savedSel.select) {
        savedSel.select();
      }
    }
  }

  // Clean Word. Source: 
  // http://patisserie.keensoftware.com/en/pages/remove-word-formatting-from-rich-text-editor-with-javascript
  // http://community.sitepoint.com/t/strip-unwanted-formatting-from-pasted-content/16848/3
  // http://www.1stclassmedia.co.uk/developers/clean-ms-word-formatting.php
  cleanHTML(input, cleanstyle) {
    let stringStripper = /(\n|\r| class=(")?Mso[a-zA-Z]+(")?)/g;
    let output = input.replace(stringStripper, ' ');
    let commentSripper = new RegExp('<!--(.*?)-->', 'g');
    output = output.replace(commentSripper, '');
    let tagStripper;
    if (cleanstyle) {
      tagStripper = new RegExp('<(/)*(meta|link|span|\\?xml:|st1:|o:|font)(.*?)>', 'gi');
    } else {
      tagStripper = new RegExp('<(/)*(meta|link|\\?xml:|st1:|o:|font)(.*?)>', 'gi');
    }
    output = output.replace(tagStripper, '');
    let badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'];
    for (let i = 0; i < badTags.length; i++) {
      tagStripper = new RegExp('<' + badTags[i] + '.*?' + badTags[i] + '(.*?)>', 'gi');
      output = output.replace(tagStripper, '');
    }
    let badAttributes;
    if (cleanstyle) {
      badAttributes = ['style', 'start'];
    } else {
      badAttributes = ['start'];
    }
    for (let i = 0; i < badAttributes.length; i++) {
      let attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"', 'gi');
      output = output.replace(attributeStripper, '');
    }

    // https://gist.github.com/sbrin/6801034
    //output = output.replace(/<!--[\s\S]+?-->/gi, ''); //done (see above)
    //output = output.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');
    output = output.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s/>]))[^>]*>/gi, '');
    output = output.replace(/<(\/?)s>/gi, '<$1strike>');
    output = output.replace(/&nbsp;/gi, ' ');
    //output = output.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function(str, spaces) {
    //    return (spaces.length > 0) ? spaces.replace(/./, " ").slice(Math.floor(spaces.length/2)).split("").join("\u00a0") : '';
    //});

    //clean copied elm-active background-color (LATER: improve)
    output = output.replace(/background-color: rgba\(200, 200, 201, 0.11\);/gi, '');
    output = output.replace(/background-color: rgba\(200, 200, 201, 0.11\)/gi, '');
    return output;
  }
  checkEmpty() {
    // Get all builder areas
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      this.checkEmptyOn(builder);
    });
  }
  checkEmptyOn(builder) {
    const dom = this.dom;
    const rows = dom.elementChildren(builder);
    let empty = true;
    rows.forEach(row => {
      if (dom.hasClass(row, 'row-add-initial')) return;
      if (dom.hasClass(row, 'dummy-space')) return;
      if (row.tagName.toLowerCase() === 'link') return;
      empty = false;
    });
    if (empty) {
      let emptyinfo = builder.querySelector('.row-add-initial');
      if (!emptyinfo) {
        builder.innerHTML = `<button type="button" class="row-add-initial">${this.out('Empty')}<br><span class="block">${this.out('+ Click to add content')}</span></div>`;
        emptyinfo = builder.querySelector('.row-add-initial');
      }
      emptyinfo.addEventListener('click', () => {
        this.clearActiveCell();
        const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
        Array.prototype.forEach.call(builders, item => {
          dom.removeClass(item, 'builder-active');
        });
        dom.addClass(builder, 'builder-active');
        dom.addClass(emptyinfo, 'row-active'); // Needed for addContent(). Directly apply class in Util is fine.

        const quickadd = renderQuickAdd(this.builder);
        // const builderStuff = this.builder.builderStuff;
        // let quickadd = builderStuff.querySelector('.quickadd'); // see quickadd.js. Directly select by class in Util is fine.

        let tabs = quickadd.querySelector('.is-pop-tabs');
        tabs.style.display = 'none';
        const viewportHeight = window.innerHeight;
        // let top = emptyinfo.getBoundingClientRect().top;
        // const left = emptyinfo.getBoundingClientRect().left + (emptyinfo.offsetWidth * this.builder.opts.zoom)/2 - 11;

        /*
        let top, left;
        if(!this.builder.iframe) {
            top = emptyinfo.getBoundingClientRect().top;
            left = emptyinfo.getBoundingClientRect().left + (emptyinfo.offsetWidth * this.builder.opts.zoom)/2 - 11;
        } else {
            let adjY = this.builder.iframe.getBoundingClientRect().top;
            let adjX = this.builder.iframe.getBoundingClientRect().left;
             top = emptyinfo.getBoundingClientRect().top + adjY;
            left = emptyinfo.getBoundingClientRect().left  + ((emptyinfo.offsetWidth * this.builder.opts.zoom)/2 - 11) + adjX;
        }
        */
        const newPos = this.getElementPosition(emptyinfo);
        let top = newPos.top;
        let left = newPos.left;
        let scaleX = newPos.scaleX;
        let scaleY = newPos.scaleY;
        left = left + (emptyinfo.offsetWidth * (scaleX * this.builder.opts.zoom) / 2 - 11);
        top = top - (emptyinfo.offsetHeight - emptyinfo.offsetHeight * scaleY);
        quickadd.style.display = 'flex';
        this.showPop(quickadd, false, emptyinfo);
        const w = quickadd.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        const h = quickadd.offsetHeight;
        if (viewportHeight - top > h) {
          top = top + emptyinfo.offsetHeight * this.builder.opts.zoom - 19;
          quickadd.style.top = top + window.pageYOffset + 27 + 'px';
          quickadd.style.left = left - w / 2 + 7 + 'px';
          dom.removeClass(quickadd, 'arrow-bottom');
          dom.removeClass(quickadd, 'arrow-right');
          dom.removeClass(quickadd, 'arrow-left');
          dom.removeClass(quickadd, 'center');
          dom.addClass(quickadd, 'arrow-top');
          dom.addClass(quickadd, 'center');
        } else {
          quickadd.style.top = top + window.pageYOffset - h - 8 + 'px';
          quickadd.style.left = left - w / 2 + 7 + 'px';
          dom.removeClass(quickadd, 'arrow-top');
          dom.removeClass(quickadd, 'arrow-right');
          dom.removeClass(quickadd, 'arrow-left');
          dom.removeClass(quickadd, 'center');
          dom.addClass(quickadd, 'arrow-bottom');
          dom.addClass(quickadd, 'center');
        }
        quickadd.setAttribute('data-mode', 'row');
      });
    } else {
      let emptyinfo = builder.querySelector('.row-add-initial');
      if (emptyinfo) emptyinfo.parentNode.removeChild(emptyinfo);
    }
  }
  clearPreferences() {
    localStorage.removeItem('_theme'); //zoom
    localStorage.removeItem('_zoom'); //zoom
    localStorage.removeItem('_buildermode'); //builderMode
    localStorage.removeItem('_editingtoolbar'); //toolbar
    localStorage.removeItem('_editingtoolbardisplay'); //toolbarDisplay
    localStorage.removeItem('_hidecelltool'); //columnTool
    localStorage.removeItem('_rowtool'); //rowTool
    localStorage.removeItem('_hideelementtool'); //elementTool
    localStorage.removeItem('_hidesnippetaddtool'); //snippetAddTool
    localStorage.removeItem('_outlinemode'); //outlineMode
    localStorage.removeItem('_hiderowcoloutline'); //rowcolOutline
    localStorage.removeItem('_outlinestyle'); //outlineStyle
    localStorage.removeItem('_hideelementhighlight'); //elementHighlight
    localStorage.removeItem('_opensnippets'); //snippetOpen
    localStorage.removeItem('_toolstyle'); //toolStyle
    localStorage.removeItem('_snippetssidebardisplay'); //snippetsSidebarDisplay
    localStorage.removeItem('_htmlview');
    localStorage.removeItem('_pasteresult'); //DON'T HAVE PROP
    localStorage.removeItem('_livepreview');
    localStorage.removeItem('_dictation');
    localStorage.removeItem('_mic');
    localStorage.removeItem('_autosendcommand');
    localStorage.removeItem('_disclaimershown');
    localStorage.removeItem('_temp');
    localStorage.removeItem('_top_p');
    localStorage.removeItem('_autosend_delay');
    localStorage.removeItem('_auto_editblock');
    localStorage.removeItem('_command_lang');
    localStorage.removeItem('_ai_panel_open');
    localStorage.removeItem('_pagesize');

    //NOT USED
    localStorage.removeItem('_scrollableeditor');
    localStorage.removeItem('_animatedsorting');
    localStorage.removeItem('_addbuttonplace');
    localStorage.removeItem('_hiderowtool');
    localStorage.removeItem('_dragwithouthandle');
    localStorage.removeItem('_advancedhtmleditor');
    localStorage.removeItem('_hidecolhtmleditor');
    localStorage.removeItem('_hiderowhtmleditor');
    localStorage.removeItem('_sampleshown');
  }

  // source: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div */
  pasteHtmlAtCaret(html, selectPastedContent) {
    this.restoreSelection();
    var sel, range;
    let elm = this.builder.dom.getElm();
    if (!elm.closest('.is-container')) return; // protection to prevent inserting ooutside the editable container

    if (this.builder.win.getSelection) {
      if (!this.builder.activeCol) return;
      sel = this.builder.win.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        range = sel.getRangeAt(0);
        range.deleteContents();
        var el = this.builder.doc.createElement('div');
        el.innerHTML = html;
        var frag = this.builder.doc.createDocumentFragment(),
          node,
          lastNode;
        while (node = el.firstChild) {
          lastNode = frag.appendChild(node);
        }
        var firstNode = frag.firstChild;
        range.insertNode(frag);
        if (lastNode) {
          range = range.cloneRange();
          range.setStartAfter(lastNode);
          if (selectPastedContent) {
            range.setStartBefore(firstNode);
          } else {
            range.collapse(true);
          }
          sel.removeAllRanges();
          if (!this.builder.isTouchSupport) sel.addRange(range);
        }
      }
    } else if ((sel = this.builder.doc.selection) && sel.type !== 'Control') {
      if (!this.builder.activeCol) return;
      var originalRange = sel.createRange();
      originalRange.collapse(true);
      sel.createRange().pasteHTML(html);
      if (selectPastedContent) {
        range = sel.createRange();
        range.setEndPoint('StartToStart', originalRange);
        if (!this.builder.isTouchSupport) range.select();
      }
    }
  }
  refreshModule() {
    let module = this.builder.activeModule;
    if (!module) return;
    let index = 1;
    let subblocks = module.querySelectorAll('[data-subblock]');
    Array.prototype.forEach.call(subblocks, subblock => {
      let builderhtml = subblock.innerHTML;
      module.setAttribute('data-html-' + index, encodeURIComponent(builderhtml));
      index++;
    });
    let html = decodeURIComponent(module.getAttribute('data-html'));
    html = html.replace(/{id}/g, this.makeId());
    module.innerHTML = '';
    var range = document.createRange();
    range.setStart(module, 0);
    module.appendChild(range.createContextualFragment(html));
    subblocks = module.querySelectorAll('[data-subblock]');
    var i = 1;
    Array.prototype.forEach.call(subblocks, subblock => {
      if (module.getAttribute('data-html-' + i)) {
        subblock.innerHTML = decodeURIComponent(module.getAttribute('data-html-' + i));
      }
      i++;
    });
    this.repositionColumnTool(true);
    if (this.builder.onRefreshTool) this.builder.onRefreshTool();
  }

  // Quick reposition column tool
  repositionColumnTool() {
    let col = this.builder.activeCol;
    if (!col) return;
    let row = col.parentNode;
    if (!col.parentNode) {
      // when column has just been deleted
      row = this.rowSelected();
    }
    this.colTool = row.querySelector('.is-col-tool');
    if (!this.colTool) return; // when drag block as a new section

    if (!col.parentNode) {
      // when column has just been deleted
      this.colTool.style.display = 'none';
    }
    this.colTool.style.left = col.offsetLeft + 'px';

    // if columnMore is opened
    const columnMore = this.builder.builderStuff.querySelector('.columnmore.active');
    if (columnMore) {
      const btnCellMore = this.colTool.querySelector('.cell-more');
      columnMore.classList.add('transition1');
      setTimeout(() => {
        const newPos = this.getElementPosition(btnCellMore);
        let top = newPos.top;
        let left = newPos.left;
        columnMore.style.top = top + 35 + 'px';
        columnMore.style.left = left - 7 + 'px';
        setTimeout(() => {
          columnMore.classList.remove('transition1');
        }, 300);
      }, 30);
    }
  }
  hideColumnTool() {
    let tools = this.builder.doc.querySelectorAll('.is-col-tool');
    tools.forEach(tool => {
      tool.style.display = 'none';
    });
  }
  isTouchSupport() {
    /*
    if(('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)) {
        return true;
    }else {
        return false;
    }
    */

    // https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
    if (window.matchMedia('(pointer: coarse)').matches) {
      return true;
    } else {
      return false;
    }
  }
  detectIE() {
    // https://stackoverflow.com/questions/49986720/how-to-detect-internet-explorer-11-and-below-versions/49986758
    if (document.documentMode) {
      return true;
    }
    return false;
  }

  // Source: https://css-tricks.com/snippets/javascript/lighten-darken-color/
  LightenDarkenColor(col, amt) {
    var usePound = false;
    if (col[0] === '#') {
      col = col.slice(1);
      usePound = true;
    }
    var num = parseInt(col, 16);
    var r = (num >> 16) + amt;
    if (r > 255) r = 255;else if (r < 0) r = 0;
    var b = (num >> 8 & 0x00FF) + amt;
    if (b > 255) b = 255;else if (b < 0) b = 0;
    var g = (num & 0x0000FF) + amt;
    if (g > 255) g = 255;else if (g < 0) g = 0;

    //return (usePound ? '#' : '') + (g | (b << 8) | (r << 16)).toString(16);
    return (usePound ? '#' : '') + String('000000' + (g | b << 8 | r << 16).toString(16)).slice(-6);
  }
  getUIStyles() {
    const dom = this.dom;
    const html = `
        <input type="text" class="style-helper-input" id="__style_helper_input" style="display:none;">
        <button class="style-helper-button-classic classic" style="display:none;"><svg><use xlink:href="#ion-code-working"></use></svg></button>
        <select class="style-helper-select" id="__style_helper_select" style="display:none;"><option value=""></option></select>

        <div class="style-helper modal-color"></div>
        <div class="style-helper modal-background"></div>
        <div class="style-helper button-pickcolor-border"></div>
        <div class="style-helper button-pickcolor-background"></div>

        <button class="style-helper base"><svg><use xlink:href="#ion-code-working"></use></svg></button>
        <div class="style-helper base on"></div>
        <div class="style-helper base hover"></div>

        <div class="style-helper snippet-color"></div>
        <div class="style-helper snippet-background"></div>
        <div class="style-helper snippet-tabs-background"></div>
        <div class="style-helper snippet-tab-item-background"></div>
        <div class="style-helper snippet-tab-item-background-active"></div>
        <div class="style-helper snippet-tab-item-background-hover"></div>
        <div class="style-helper snippet-tab-item-color"></div>

        <div class="style-helper snippet-more-item-background"></div>
        <div class="style-helper snippet-more-item-background-active"></div>
        <div class="style-helper snippet-more-item-background-hover"></div>
        <div class="style-helper snippet-more-item-color"></div>

        <div class="style-helper tabs-background"></div>
        <div class="style-helper tab-item-active-border-bottom"></div>
        <div class="style-helper tab-item-color"></div>
        <div class="style-helper tabs-more-background"></div>
        <div class="style-helper tabs-more-border"></div>
        <div class="style-helper tabs-more-item-color"></div>
        <div class="style-helper tabs-more-item-background-hover"></div>
        <div class="style-helper separator-color"></div>
        <div class="style-helper outline-color"></div>
        `;
    dom.appendHtml(this.builder.builderStuff, html);

    // new method
    const getVal = (selector, rule) => {
      const stuff = this.builder.builderStuff.querySelector('.style-helper' + selector);
      return window.getComputedStyle(stuff, null).getPropertyValue(rule);
    };
    const getSvgFill = () => {
      const btn = this.builder.builderStuff.querySelector('.style-helper.base');
      return window.getComputedStyle(btn.querySelector('svg'), null).getPropertyValue('fill');
    };
    const inp = this.builder.builderStuff.querySelector('.style-helper-input');
    const sel = this.builder.builderStuff.querySelector('.style-helper-select');
    const btnClassic = this.builder.builderStuff.querySelector('.style-helper-button-classic');
    this.builder.styleModalColor = getVal('.modal-color', 'background-color');
    this.builder.styleModalBackground = getVal('.modal-background', 'background-color');
    this.builder.styleButtonPickColorBorder = getVal('.button-pickcolor-border', 'border');
    this.builder.styleButtonPickColorBackground = getVal('.button-pickcolor-background', 'background-color');
    this.builder.styleToolBackground = getVal('.base', 'background-color');
    this.builder.styleButtonColor = getVal('.base', 'color');
    this.builder.styleButtonSvgFill = getSvgFill();
    // this.builder.styleButtonBackgroundOn = getVal('.base.on', 'background-color');
    this.builder.styleButtonBackgroundHover = getVal('.base.hover', 'background-color');
    this.builder.styleSnippetColor = getVal('.snippet-color', 'background-color');
    this.builder.styleSnippetBackground = getVal('.snippet-background', 'background-color');
    this.builder.styleSnippetTabsBackground = getVal('.snippet-tabs-background', 'background-color');
    this.builder.styleSnippetTabItemBackground = getVal('.snippet-tab-item-background', 'background-color');
    this.builder.styleSnippetTabItemBackgroundActive = getVal('.snippet-tab-item-background-active', 'background-color');
    this.builder.styleSnippetTabItemBackgroundHover = getVal('.snippet-tab-item-background-hover', 'background-color');
    this.builder.styleSnippetTabItemColor = getVal('.snippet-tab-item-color', 'background-color');
    this.builder.styleSnippetMoreItemBackground = getVal('.snippet-more-item-background', 'background-color');
    this.builder.styleSnippetMoreItemBackgroundActive = getVal('.snippet-more-item-background-active', 'background-color');
    this.builder.styleSnippetMoreItemBackgroundHover = getVal('.snippet-more-item-background-hover', 'background-color');
    this.builder.styleSnippetMoreItemColor = getVal('.snippet-more-item-color', 'background-color');

    // Normal Tabs (ex. used in 'Symbol' plugin)
    this.builder.styleTabsBackground = getVal('.tabs-background', 'background-color');
    this.builder.styleTabItemBorderBottomActive = getVal('.tab-item-active-border-bottom', 'border');
    this.builder.styleTabItemColor = getVal('.tab-item-color', 'background-color');
    this.builder.styleTabsMoreBackground = getVal('.tabs-more-background', 'background-color');
    this.builder.styleTabsMoreBorder = getVal('.tabs-more-border', 'border');
    this.builder.styleTabsMoreItemColor = getVal('.tabs-more-item-color', 'background-color');
    this.builder.styleTabsMoreBackgroundHover = getVal('.tabs-more-item-background-hover', 'background-color');
    this.builder.styleSeparatorColor = getVal('.separator-color', 'background-color');
    this.builder.styleOutlineColor = getVal('.outline-color', 'background-color');

    // Select (ex. used in 'Button Editor' plugin, 'Slider' plugin, 'Slider Content' plugin)
    this.builder.styleSelectBackground = window.getComputedStyle(sel, null).getPropertyValue('background-color');
    this.builder.styleSelectColor = window.getComputedStyle(sel, null).getPropertyValue('color');
    this.builder.styleSelectOptionBackground = window.getComputedStyle(sel.querySelector('option'), null).getPropertyValue('background-color');

    // Input (ex. used in 'Search & Replace' plugin)
    this.builder.styleInputBackground = window.getComputedStyle(inp, null).getPropertyValue('background-color');
    this.builder.styleInputBorderBottom = window.getComputedStyle(inp, null).getPropertyValue('border-bottom');
    this.builder.styleInputColor = window.getComputedStyle(inp, null).getPropertyValue('color');

    // Button Classic (ex. used in 'Search & Replace' plugin)
    this.builder.styleButtonClassicBackground = window.getComputedStyle(btnClassic, null).getPropertyValue('background-color');
    this.builder.styleButtonClassicColor = window.getComputedStyle(btnClassic, null).getPropertyValue('color');
    this.builder.styleButtonClassicBackgroundHover = this.getUIStyleValue(btnClassic, 'hover', 'background-color');
    this.builder.styleDark = false;
    this.builder.styleColored = false;
    this.builder.styleColoredDark = false;
    this.builder.styleLight = false;
    if (document.body.getAttribute('class')) {
      if (document.body.getAttribute('class').indexOf('colored-dark') !== -1) {
        this.builder.styleColoredDark = true;
      } else if (document.body.getAttribute('class').indexOf('dark') !== -1) {
        this.builder.styleDark = true;
      } else if (document.body.getAttribute('class').indexOf('colored') !== -1) {
        this.builder.styleColored = true;
      } else if (document.body.getAttribute('class').indexOf('light') !== -1) {
        this.builder.styleLight = true;
      }
    }
  }
  getUIStyleValue(elm, classname, prop) {
    const dom = this.dom;
    dom.addClass(elm, classname);
    let val = window.getComputedStyle(elm, null).getPropertyValue(prop);
    dom.removeClass(elm, classname);
    return val;
  }
  getPageTemplate(framework) {
    let pageTemplate = '';
    if (framework === '') {
      pageTemplate = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="utf-8">
                <title>Page</title>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <meta name="description" content="">
                <link rel="shortcut icon" href="#">
                
                <link href="[%PATH%]/assets/minimalist-blocks/content.css" rel="stylesheet">
                
                <link href="[%PATH%]/assets/scripts/glide/css/glide.core.css" rel="stylesheet">
                <link href="[%PATH%]/assets/scripts/glide/css/glide.theme.css" rel="stylesheet">
                <script src="[%PATH%]/assets/scripts/glide/glide.js"></script>
                
                <style>
                    .container {
                        margin: 150px auto 0;
                        max-width: 800px;
                        width: 100%;
                        padding: 0 20px;
                        box-sizing: border-box;
                    }
                </style>
            </head>
            <body>
            
            <div class="container">
            [%CONTENT%]
            </div>
            
            </body>
            </html>
            `;
    } else if (framework === 'tailwind') {
      pageTemplate = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="utf-8">
                <title>Page</title>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <meta name="description" content="">
                <link rel="shortcut icon" href="#">
                
                <link href="[%PATH%]/assets/minimalist-blocks/content-tailwind.css" rel="stylesheet">
                
                <link href="[%PATH%]/assets/scripts/glide/css/glide.core.css" rel="stylesheet">
                <link href="[%PATH%]/assets/scripts/glide/css/glide.theme.css" rel="stylesheet">
                <script src="[%PATH%]/assets/scripts/glide/glide.js"></script>
                
                <link rel="stylesheet" href="[%PATH%]/assets/frameworks/tailwindcss/styles.css">
                <!-- To build your own, please see: https://tailwindcss.com/docs/installation -->
                
                <style>
                    .container {
                        margin: 150px auto 0;
                        max-width: 800px;
                        width: 100%;
                        padding: 0 20px;
                        box-sizing: border-box;
                    }
                </style>
            </head>
            <body>
            
            <div class="container">
            [%CONTENT%]
            </div>
            
            </body>
            </html>
            `;
    } else if (framework === 'bootstrap') {
      pageTemplate = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="utf-8">
                <title>Page</title>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <meta name="description" content="">
                <link rel="shortcut icon" href="#">

                <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
                <link href="[%PATH%]/assets/minimalist-blocks/content.css" rel="stylesheet">
                
                <link href="[%PATH%]/assets/scripts/glide/css/glide.core.css" rel="stylesheet">
                <link href="[%PATH%]/assets/scripts/glide/css/glide.theme.css" rel="stylesheet">
                <script src="[%PATH%]/assets/scripts/glide/glide.js"></script>
                
                <style>
                    .container {margin: 140px auto; max-width: 800px; width:100%; padding:0 35px; box-sizing: border-box;}
                    /* Bootstrap css adjustment to enable column drag to resize */
                    .row > *,
                    .column {
                        max-width: unset !important;
                    }
                </style>
            </head>
            <body>
            
            <div class="container">
            [%CONTENT%]
            </div>
            
            </body>
            </html>
            `;
    } else if (framework === 'foundation') {
      pageTemplate = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="utf-8">
                <title>Page</title>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <meta name="description" content="">
                <link rel="shortcut icon" href="#">

                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/6.5.3/css/foundation.min.css">
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/6.5.3/css/foundation-float.min.css">
            
                <link href="[%PATH%]/assets/minimalist-blocks/content.css" rel="stylesheet">
                
                <link href="[%PATH%]/assets/scripts/glide/css/glide.core.css" rel="stylesheet">
                <link href="[%PATH%]/assets/scripts/glide/css/glide.theme.css" rel="stylesheet">
                <script src="[%PATH%]/assets/scripts/glide/glide.js"></script>
                
                <style>
                    .container {
                        margin: 150px auto 0;
                        max-width: 800px;
                        width: 100%;
                        padding: 0 20px;
                        box-sizing: border-box;
                    }
                </style>
            </head>
            <body>
            
            <div class="container">
            [%CONTENT%]
            </div>
            
            </body>
            </html>
            `;
    } else {
      pageTemplate = '[%CONTENT%]';
    }
    return pageTemplate;
  }
  getElementPosition(element) {
    const iframe = this.builder.iframe;
    let top, left;
    let scaleX, scaleY;
    if (this.builder.iframe) {
      let divContentView = document.querySelector('.is-content-view');
      if (!divContentView) divContentView = iframe.parentNode;
      const divContentViewStyles = window.getComputedStyle(divContentView);
      const transform = divContentViewStyles.transform;
      if (transform !== 'none') {
        const matrixValues = transform.match(/matrix\(([0-9., -]+)\)/)[1].split(',');
        scaleX = parseFloat(matrixValues[0]);
        scaleY = parseFloat(matrixValues[3]);
      } else {
        scaleX = 1;
        scaleY = 1;
      }
      const iframeRect = iframe.getBoundingClientRect();
      top = element.getBoundingClientRect().top * scaleY + iframeRect.top;
      left = element.getBoundingClientRect().left * scaleX + iframeRect.left;
    } else {
      top = element.getBoundingClientRect().top;
      left = element.getBoundingClientRect().left;
      scaleX = 1;
      scaleY = 1;
    }
    return {
      top,
      left,
      scaleX,
      scaleY
    };
  }
}
class Dom {
  constructor(builder) {
    this.builder = builder;
  }
  getScale(container) {
    let matrix = window.getComputedStyle(container).transform;
    if (matrix === 'none') return 1;
    let values = matrix.split('(')[1];
    values = values.split(')')[0];
    values = values.split(',');
    let a = values[0];
    let b = values[1];
    let scale = Math.sqrt(a * a + b * b);
    return scale;
  }
  createElement(tag) {
    return document.createElement(tag);
  }
  appendChild(parent, child) {
    if (parent) parent.appendChild(child);
  }
  appendHtml(parent, html) {
    if (parent) parent.insertAdjacentHTML('beforeend', html);
  }
  addEventListener(parent, type, listener) {
    if (parent) parent.addEventListener(type, listener);
  }
  addClass(element, classname) {
    if (!element) return;
    if (this.hasClass(element, classname)) return;
    if (element.classList.length === 0) element.className = classname;else element.className = element.className + ' ' + classname;
    element.className = element.className.replace(/  +/g, ' ');
    //else element.classList.add(classname); //error if there is -
  }

  removeClass(element, classname) {
    if (!element) return;
    if (element.classList.length > 0) {
      // element.className = element.className.replace(new RegExp('\\b'+ classname+'\\b', 'g'), '');
      // element.className = element.className.replace(/  +/g, ' ');

      let i, j, imax, jmax;
      let classesToDel = classname.split(' ');
      for (i = 0, imax = classesToDel.length; i < imax; ++i) {
        if (!classesToDel[i]) continue;
        let classtoDel = classesToDel[i];

        // https://jsperf.com/removeclass-methods 
        let sClassName = '';
        let currentClasses = element.className.split(' ');
        for (j = 0, jmax = currentClasses.length; j < jmax; ++j) {
          if (!currentClasses[j]) continue;
          if (currentClasses[j] !== classtoDel) sClassName += currentClasses[j] + ' ';
        }
        element.className = sClassName.trim();
      }
      if (element.className === '') element.removeAttribute('class');
    }
  }
  removeClassesByPrefix(element, prefix) {
    if (element.classList) {
      element.classList.forEach(item => {
        if (item.indexOf(prefix) === 0) {
          this.removeClass(element, item);
        }
      });
    }
  }
  hasClass(element, className) {
    if (!element) return false;
    if (!element.className) return false;
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }
  moveAfter(element, targetElement) {
    targetElement.parentNode.insertBefore(element, targetElement);
    targetElement.parentNode.insertBefore(targetElement, targetElement.previousElementSibling);
  }

  // https://stackoverflow.com/questions/10381296/best-way-to-get-child-nodes
  elementChildren(element) {
    const childNodes = element.childNodes;
    let children = [];
    let i = childNodes.length;
    while (i--) {
      if (childNodes[i].nodeType === 1 /*&& childNodes[i].tagName === 'DIV'*/) {
        children.unshift(childNodes[i]);
      }
    }
    return children;
  }
  getElementOffset(el) {
    const rect = el.getBoundingClientRect();
    return {
      top: rect.top + window.pageYOffset,
      left: rect.left + window.pageXOffset,
      width: rect.width,
      height: rect.height
    };
  }
  parentsHasClass(element, classname) {
    while (element) {
      // if(classname==='is-side') console.log(element.nodeName); // NOTE: click on svg can still returns undefined in IE11
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      // if(!element.classList) {
      //     return false;
      // }
      if (this.hasClass(element, classname)) {
        return true;
      }
      // TODO: if(element.nodeName.toLowerCase() === 'svg') console.log(element);
      element = element.parentNode;
    }
  }
  parentsHasId(element, id) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      if (element.id === id) {
        return true;
      }
      element = element.parentNode;
    }
  }
  parentsHasTag(element, tagname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      if (element.tagName.toLowerCase() === tagname.toLowerCase()) {
        return true;
      }
      element = element.parentNode;
    }
  }
  parentsHasAttribute(element, attrname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      try {
        if (element.hasAttribute(attrname)) {
          // error on svg element
          return true;
        }
      } catch (e) {
        // Do Nothing
        // return false;
      }
      element = element.parentNode;
    }
  }
  getParentByTag(element, tagname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      if (element.tagName.toLowerCase() === tagname.toLowerCase()) {
        return element;
      }
      element = element.parentNode;
    }
  }
  getParentByAttribute(element, attrname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      try {
        if (element.hasAttribute(attrname)) {
          // error on svg element
          return element;
        }
      } catch (e) {
        // Do Nothing
        // return false;
      }
      element = element.parentNode;
    }
  }
  parentsHasElement(element, tagname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      element = element.parentNode;
      if (!element) return false;
      if (!element.tagName) return false;
      if (element.tagName.toLowerCase() === tagname) {
        return true;
      }
    }
  }
  getParentElement(element, tagname) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      element = element.parentNode;
      if (!element) return false;
      if (!element.tagName) return false;
      if (element.tagName.toLowerCase() === tagname) {
        return element;
      }
    }
  }
  removeClasses(elms, classname) {
    for (let i = 0; i < elms.length; i++) {
      elms[i].classList.remove(classname);
    }
  }
  removeAttributes(elms, attrname) {
    for (let i = 0; i < elms.length; i++) {
      elms[i].removeAttribute(attrname);
    }
  }
  removeElements(elms) {
    Array.prototype.forEach.call(elms, el => {
      el.parentNode.removeChild(el);
    });
  }

  // source: https://stackoverflow.com/questions/2871081/jquery-setting-cursor-position-in-contenteditable-div
  moveCursorToElement(element) {
    var sel, range;
    if (window.getSelection && this.builder.doc.createRange) {
      range = this.builder.doc.createRange();
      range.selectNodeContents(element);
      range.collapse(false);
      sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (this.builder.doc.body.createTextRange) {
      range = this.builder.doc.body.createTextRange();
      range.moveToElementText(element);
      range.collapse(false);
      range.select();
    }
  }

  // source: https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element
  selectElementContents(el) {
    var range = this.builder.doc.createRange();
    range.selectNodeContents(el);
    var sel = this.builder.win.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  // Get selected text
  getSelected() {
    if (this.builder.win.getSelection) {
      return this.builder.win.getSelection().toString();
    } else if (this.builder.doc.getSelection) {
      return this.builder.doc.getSelection().toString();
    } else {
      var selection = this.builder.doc.selection && this.builder.doc.selection.createRange();
      if (selection.text) {
        return selection.text;
      }
      return false;
    }
  }
  checkEditable() {
    try {
      var el;
      var curr;
      if (this.builder.win.getSelection) {
        curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
        if (curr.nodeType === 3) {
          //ini text node
          el = curr.parentNode;
        } else {
          el = curr;
        }
      } else if (this.builder.doc.selection) {
        curr = this.builder.doc.selection.createRange();
        el = this.builder.doc.selection.createRange().parentElement();
      }
      if (this.parentsHasAttribute(el, 'contenteditable')) return true;else return false;
    } catch (e) {
      return false;
    }
  }
  textSelection() {
    const selection = this.getSelection();
    const anchorNode = selection.anchorNode;
    if (!anchorNode) return false;
    const container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
    return container;
  }
  getStyle(element, property) {
    return window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue(property) : element.style[property.replace(/-([a-z])/g, function (g) {
      return g[1].toUpperCase();
    })];
  }

  //https://stackoverflow.com/questions/32383349/detect-input-value-change-with-mutationobserver/61975440#61975440
  observeElement(element, property, callback, delay = 0) {
    let elementPrototype = Object.getPrototypeOf(element);
    if (Object.prototype.hasOwnProperty.call(elementPrototype, property)) {
      let descriptor = Object.getOwnPropertyDescriptor(elementPrototype, property);
      Object.defineProperty(element, property, {
        get: function () {
          return descriptor.get.apply(this, arguments);
        },
        set: function () {
          let oldValue = this[property];
          descriptor.set.apply(this, arguments);
          let newValue = this[property];
          if (typeof callback == 'function') {
            setTimeout(callback.bind(this, oldValue, newValue), delay);
          }
          // return newValue;
        }
      });
    }
  }

  baseName(str) {
    if (typeof str !== 'string') return;
    var frags = str.split('.');
    return frags.splice(0, frags.length - 1).join('.');
  }

  /** added by Jack */
  doFunction(elm, fn, incChilds) {
    fn(elm);
    if (incChilds) {
      let elmns = Array.prototype.slice.call(elm.getElementsByTagName('*'));
      for (var i = 0; i < elmns.length; i++) {
        fn(elmns[i]);
      }
    }
  }
  // ---

  // execCommand replacement
  execCommand(action, value, callback) {
    const blocks = this.getSelectedBlocks();
    if (blocks.length > 0) {
      blocks.forEach(item => {
        callback(true, item);
      });
    } else {
      const selection = this.builder.win.getSelection();
      const container = this.getElm();
      if (!container) {
        if (callback) callback(false);
        return;
      }
      const sameSelection = container && container.innerText === selection.toString().trim();
      let newElement;
      if (sameSelection || selection.toString().trim() === '') {
        newElement = this.updateSelection(action, value, container);
      } else {
        newElement = this.replaceSelection(action, value, selection, container);
      }
      if (callback) callback(true, newElement);
    }
  }
  updateSelection(action, value, container) {
    // container.style[action] = value; //APPLY => Use getStyleValue to check if toggle is needed.
    container.style[action] = this.getStyleValue(container, action, value);

    // Optional, better if used: check if the style is the same as its parent. If so, clear it.
    this.checkStyleIfSameAsParent(container, action);
    this.cleanChildren(action, container);
    this.cleanUnusedSpan(container); // REVIEW

    return container;
  }
  replaceSelection(action, value, selection, container) {
    const range = selection.getRangeAt(0);
    const fragment = range.extractContents();
    const span = this.createSpan(container, action, value);
    span.appendChild(fragment);
    this.cleanChildren(action, span);
    this.cleanUnusedSpan(span); // REVIEW

    range.insertNode(span);
    selection.selectAllChildren(span);

    // Optional, better if used: check if the style is the same as its parent. If so, clear it.
    this.checkStyleIfSameAsParent(span, action);
    return span;
  }
  checkStyleIfSameAsParent(element, action) {
    if (element.parentNode) {
      if (element.parentNode.style[action] === element.style[action] || window.getComputedStyle(element.parentNode, null).getPropertyValue(action) === element.style[action]) {
        element.style[action] = '';
        if (element.getAttribute('style') === '' || element.style === null) {
          element.removeAttribute('style');
        }

        // REVIEW
        let unused = element.attributes.length === 0 || element.attributes.length === 1 && element.hasAttribute('data-keep');
        if (element.nodeName.toLowerCase() === 'span' && unused) {
          const text = document.createTextNode(element.textContent);
          element.parentElement.replaceChild(text, element);
        }
      }
    }
  }
  createSpan(container, action, value) {
    const span = document.createElement('span');

    // span.style[action] = value; //APPLY => Use getStyleValue to check if toggle is needed.
    span.style[action] = this.getStyleValue(container, action, value);
    return span;
  }
  findParentStyle(node, action) {
    if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
      return null;
    }
    if (!node.parentNode) {
      return null;
    }
    const hasStyle = node.style[action] !== null && node.style[action] !== undefined && node.style[action] !== '';
    if (hasStyle) {
      return node;
    }
    this.findParentStyle(node.parentNode, action);
  }
  getStyleValue(container, action, value) {
    if (action === 'font-weight' || action === 'font-style' || action === 'text-decoration' || action === 'text-transform') {
      // Toggle
      // let currentValue = window.getComputedStyle(container, null).getPropertyValue(action);
      let parent = this.findParentStyle(container, action);
      let currentValue;
      if (parent) {
        currentValue = parent.style[action];
      }
      if (value === currentValue) {
        //toggle here
        // value = 'initial'; // the problem with initial is that it is always refer to font-weight: 400 (won;t work for custom 300 for normal paragraph)
        // so we'll do the test first, to find the actuat initial value
        container.style[action] = ''; // test
        let initialValue = window.getComputedStyle(container, null).getPropertyValue(action); // get the actual initial value
        // console.log('initial:' +initialValue);
        container.style[action] = currentValue; //return back from test
        value = initialValue;
      }
    }
    return value;
  }
  getParentBlock(element) {
    while (element) {
      if (!element.tagName) return false;
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      if (this.getStyle(element, 'display') !== 'inline') {
        return element;
      }
      element = element.parentNode;
    }
  }

  // execCommand replacement => for general, apply class to current element
  execCommandClass(newClassName, classList, currentElement = true, mode) {
    // USed by line height & letter spacing (rte,js)
    const blocks = this.getSelectedBlocks();
    if (blocks.length > 0) {
      blocks.forEach(item => {
        for (let i = 0; i < Object.keys(classList).length; i++) {
          let className = Object.values(classList)[i];
          this.removeClass(item, className);
        }
        if (newClassName !== '') this.addClass(item, newClassName);
        this.cleanChildrenClass(item, classList);
        this.cleanUnusedSpan(item); // REVIEW
      });
    } else {
      const selection = this.builder.win.getSelection();
      let container = this.getElm();
      if (!container) return;
      const sameSelection = container && container.innerText === selection.toString().trim();
      if (currentElement) {
        if (mode === 'block') if (this.getStyle(container, 'display') === 'inline') {
          container = this.getParentBlock(container);
        }
        this.updateSelectionClass(newClassName, classList, container);
      } else {
        if (sameSelection || selection.toString().trim() === '') {
          if (mode === 'block') if (this.getStyle(container, 'display') === 'inline') {
            container = this.getParentBlock(container);
          }
          this.updateSelectionClass(newClassName, classList, container);
        }
      }
    }
  }
  updateSelectionClass(newClassName, classList, container) {
    for (let i = 0; i < Object.keys(classList).length; i++) {
      let className = Object.values(classList)[i];
      this.removeClass(container, className);
    }
    if (newClassName !== '') this.addClass(container, newClassName);
    this.cleanChildrenClass(container, classList);
    this.cleanUnusedSpan(container); // REVIEW

    return container;
  }
  cleanChildrenClass(span, classList) {
    if (!span.hasChildNodes()) {
      return;
    }
    Array.from(span.children).map(element => {
      for (let i = 0; i < Object.keys(classList).length; i++) {
        let className = Object.values(classList)[i];
        this.removeClass(element, className);
      }
    });

    // Deeper childrens
    const cleanChildrenChildren = Array.from(span.children).map(element => {
      return this.cleanChildrenClass(element, classList);
    });
    if (!cleanChildrenChildren || cleanChildrenChildren.length <= 0) {
      return;
    }
  }
  getSelectedBlocks() {
    let multiSelectBlocks = false;
    let selection = this.builder.win.getSelection();
    let elements = [];
    if (!selection.isCollapsed) {
      let range = selection.getRangeAt(0);
      let container = range.commonAncestorContainer;
      const traverse = node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (range.intersectsNode(node)) {
            elements.push(node);
          }
        }
        if (node.childNodes.length > 0) {
          for (let i = 0; i < node.childNodes.length; i++) {
            traverse(node.childNodes[i]);
          }
        }
      };
      traverse(container);

      // Remove the first item if it's the parent element
      if (elements.length > 0 && elements[0] === container) {
        elements.shift();
      }
    }
    let blocks = [];
    const blockElms = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'pre', 'td', 'th', 'li'];
    elements.forEach(item => {
      const tagName = item.tagName.toLowerCase();
      if (blockElms.includes(tagName)) {
        multiSelectBlocks = true;
        blocks.push(item);
      }
    });

    /*
    If a block is double clicked to select the block, the selection goes to the next block as well.
    This seems a default behavior (tested with simple contentEditable div). So the blocks contains 2 blocks.
    To fix this, perform an extra test here:
    */
    if (blocks.length === 2) {
      // console.log(blocks[0].innerText.trim());
      // console.log(selection.toString().trim());
      if (blocks[0].innerText.trim() === selection.toString().trim()) {
        blocks.pop();
        // console.log('remove last')
      }
    }

    if (multiSelectBlocks) {
      return blocks;
    } else {
      return [];
    }
  }

  // execCommand replacement => for CLASS
  execCommandToggle(action, value, config) {
    const blocks = this.getSelectedBlocks();
    if (blocks.length > 0) {
      blocks.forEach(item => {
        if (action === 'fontWeight') {
          let bold = false;
          if (this.hasClass(item, config.fontWeight.defaultBold)) {
            bold = true;
          }
          // const num = parseInt(window.getComputedStyle(item, null).getPropertyValue('font-weight'));
          // if(num>=500) bold = true;
          this.removeClass(item, config.fontWeight.thin);
          this.removeClass(item, config.fontWeight.extralight);
          this.removeClass(item, config.fontWeight.light);
          this.removeClass(item, config.fontWeight.normal);
          this.removeClass(item, config.fontWeight.medium);
          this.removeClass(item, config.fontWeight.semibold);
          this.removeClass(item, config.fontWeight.bold);
          this.removeClass(item, config.fontWeight.extrabold);
          this.removeClass(item, config.fontWeight.black);
          if (bold) ; else {
            this.addClass(item, config.fontWeight.defaultBold);
          }
        }
        if (action === 'fontStyle') {
          let italic = false;
          if (this.hasClass(item, config.fontStyle.italic)) {
            italic = true;
          }
          this.removeClass(item, config.fontStyle.italic);
          this.removeClass(item, config.fontStyle.normal);
          if (italic) ; else {
            this.addClass(item, config.fontStyle.italic);
          }
        }
        if (action === 'textUnderline') {
          let underline = false;
          if (this.hasClass(item, config.textDecoration.underline)) {
            underline = true;
          }
          this.removeClass(item, config.textDecoration.linethrough);
          this.removeClass(item, config.textDecoration.underline);
          this.removeClass(item, config.textDecoration.normal);
          if (underline) ; else {
            this.addClass(item, config.textDecoration.underline);
          }
        }
        if (action === 'textLinethrough') {
          let linethrough = false;
          if (this.hasClass(item, config.textDecoration.linethrough)) {
            linethrough = true;
          }
          this.removeClass(item, config.textDecoration.underline);
          this.removeClass(item, config.textDecoration.linethrough);
          this.removeClass(item, config.textDecoration.normal);
          if (linethrough) ; else {
            this.addClass(item, config.textDecoration.linethrough);
          }
        }
        /*
        if(action === 'textTransform') {
            let val = '';
            if(this.hasClass(item, config.textTransform.uppercase)) {
                val = 'uppercase';
            } else if(this.hasClass(item, config.textTransform.lowercase)) {
                val = 'lowercase';
            } else if(this.hasClass(item, config.textTransform.capitalize)) {
                val = 'capitalize';
            } else if(this.hasClass(item, config.textTransform.normal)) {
                val = 'normal';
            } 
            this.removeClass(item, config.textTransform.uppercase);
            this.removeClass(item, config.textTransform.lowercase);
            this.removeClass(item, config.textTransform.capitalize);
            this.removeClass(item, config.textTransform.normal);
            if (val === '') {
                this.addClass(item, config.textTransform.uppercase);
            } else if (val === 'uppercase') {
                this.addClass(item, config.textTransform.lowercase);
            } else if (val === 'lowercase') {
                this.addClass(item, config.textTransform.capitalize);
            } else if (val === 'capitalize') {
                // Do Nothing
                // this.addClass(item, config.textTransform.normal);
            } else if (val === 'normal') {
                this.addClass(item, config.textTransform.uppercase);
            } 
        }
        */

        if (action === 'textTransform') {
          let val = '';
          if (this.hasClass(item, config.textTransform.uppercase)) {
            val = 'uppercase';
          }
          this.removeClass(item, config.textTransform.uppercase);
          this.removeClass(item, config.textTransform.lowercase);
          this.removeClass(item, config.textTransform.capitalize);
          this.removeClass(item, config.textTransform.normal);
          if (val === '') {
            this.addClass(item, config.textTransform.uppercase);
          }
        }
        if (action === 'clean') {
          item.className = '';
          item.style.cssText = '';
        }
        if (action === 'extend') {
          let toggle = false;
          if (this.hasClass(item, config.extend[value])) {
            toggle = true;
          }
          if (toggle) {
            this.removeClass(item, config.extend[value]);
          } else {
            this.addClass(item, config.extend[value]);
          }
        }
        this.cleanChildrenToggle(action, value, item, config);
        this.cleanUnusedSpan(item); // REVIEW
      });
    } else {
      const selection = this.builder.win.getSelection();
      const container = this.getElm();
      if (!container) return;
      const sameSelection = container && container.innerText === selection.toString().trim();
      if (sameSelection || selection.toString().trim() === '') {
        this.updateSelectionToggle(action, value, config, container);
      } else {
        this.replaceSelectionToggle(action, value, config, selection, container);
      }
    }
  }
  getElm() {
    const selection = this.builder.win.getSelection();
    if (!selection) return false;
    const anchorNode = selection.anchorNode;
    if (!anchorNode) return false;
    const container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
    return container;
  }
  updateSelectionToggle(action, value, config, container) {
    // container.setAttribute('data-dummy','1');

    if (action === 'fontWeight') {
      let bold = false;
      if (this.hasClass(container, config.fontWeight.defaultBold)) {
        bold = true;
      }
      const num = parseInt(window.getComputedStyle(container, null).getPropertyValue('font-weight'));
      if (num >= 500) bold = true;
      this.removeClass(container, config.fontWeight.thin);
      this.removeClass(container, config.fontWeight.extralight);
      this.removeClass(container, config.fontWeight.light);
      this.removeClass(container, config.fontWeight.normal);
      this.removeClass(container, config.fontWeight.medium);
      this.removeClass(container, config.fontWeight.semibold);
      this.removeClass(container, config.fontWeight.bold);
      this.removeClass(container, config.fontWeight.extrabold);
      this.removeClass(container, config.fontWeight.black);
      if (bold) {
        // A must to keep selection no change, otherwise, removing class & then span makes the selection changes (to check, click B/bold 3 times to toggle. The third will not work)
        this.addClass(container, config.fontWeight.defaultNormal);
      } else {
        this.addClass(container, config.fontWeight.defaultBold);
      }
    }
    if (action === 'fontStyle') {
      let italic = false;
      if (this.hasClass(container, config.fontStyle.italic)) {
        italic = true;
      }
      this.removeClass(container, config.fontStyle.italic);
      this.removeClass(container, config.fontStyle.normal);
      if (italic) {
        this.addClass(container, config.fontStyle.normal);
      } else {
        this.addClass(container, config.fontStyle.italic);
      }
    }
    if (action === 'textUnderline') {
      let underline = false;
      if (this.hasClass(container, config.textDecoration.underline)) {
        underline = true;
      }
      this.removeClass(container, config.textDecoration.underline);
      this.removeClass(container, config.textDecoration.linethrough);
      this.removeClass(container, config.textDecoration.normal);
      if (underline) {
        this.addClass(container, config.textDecoration.normal);
      } else {
        this.addClass(container, config.textDecoration.underline);
      }
    }
    if (action === 'textLinethrough') {
      let linethrough = false;
      if (this.hasClass(container, config.textDecoration.linethrough)) {
        linethrough = true;
      }
      this.removeClass(container, config.textDecoration.underline);
      this.removeClass(container, config.textDecoration.linethrough);
      this.removeClass(container, config.textDecoration.normal);
      if (linethrough) {
        this.addClass(container, config.textDecoration.normal);
      } else {
        this.addClass(container, config.textDecoration.linethrough);
      }
    }

    /*
    if(action === 'textTransform') {
        let val = '';
        if(this.hasClass(container, config.textTransform.uppercase)) {
            val = 'uppercase';
        } else if(this.hasClass(container, config.textTransform.lowercase)) {
            val = 'lowercase';
        } else if(this.hasClass(container, config.textTransform.capitalize)) {
            val = 'capitalize';
        } else if(this.hasClass(container, config.textTransform.normal)) {
            val = 'normal';
        } 
        this.removeClass(container, config.textTransform.uppercase);
        this.removeClass(container, config.textTransform.lowercase);
        this.removeClass(container, config.textTransform.capitalize);
        this.removeClass(container, config.textTransform.normal);
        if (val === '') {
            this.addClass(container, config.textTransform.uppercase);
        } else if (val === 'uppercase') {
            this.addClass(container, config.textTransform.lowercase);
        } else if (val === 'lowercase') {
            this.addClass(container, config.textTransform.capitalize);
        } else if (val === 'capitalize') {
            this.addClass(container, config.textTransform.normal);
        } else if (val === 'normal') {
            this.addClass(container, config.textTransform.uppercase);
        } 
    }
    */
    if (action === 'textTransform') {
      let val = '';
      if (this.hasClass(container, config.textTransform.uppercase)) {
        val = 'uppercase';
      }
      this.removeClass(container, config.textTransform.uppercase);
      this.removeClass(container, config.textTransform.lowercase);
      this.removeClass(container, config.textTransform.capitalize);
      this.removeClass(container, config.textTransform.normal);
      if (val === '') {
        this.addClass(container, config.textTransform.uppercase);
      }
    }
    if (action === 'clean') {
      container.className = '';
      container.style.cssText = '';
    }
    if (action === 'extend') {
      let toggle = false;
      if (this.hasClass(container, config.extend[value])) {
        toggle = true;
      }
      if (toggle) {
        this.removeClass(container, config.extend[value]);
      } else {
        this.addClass(container, config.extend[value]);
      }
    }
    this.cleanChildrenToggle(action, value, container, config);
    this.cleanUnusedSpan(container); // REVIEW

    return container;
  }
  replaceSelectionToggle(action, value, config, selection, container) {
    const range = selection.getRangeAt(0);
    const fragment = range.extractContents();
    const span = document.createElement('span');
    if (action === 'fontWeight') {
      let bold = false;
      if (container.closest(`.${config.fontWeight.defaultBold}`)) {
        bold = true;
        if (this.hasClass(container, config.fontWeight.defaultNormal)) {
          bold = false;
        }
      }
      const num = parseInt(window.getComputedStyle(container, null).getPropertyValue('font-weight'));
      if (num >= 500) bold = true;
      if (bold) {
        this.addClass(span, config.fontWeight.defaultNormal);
      } else {
        this.addClass(span, config.fontWeight.defaultBold);
      }
    }
    if (action === 'fontStyle') {
      let italic = false;
      if (container.closest(`.${config.fontStyle.italic}`)) {
        italic = true;
        if (this.hasClass(container, config.fontStyle.normal)) {
          italic = false;
        }
      }
      if (italic) {
        this.addClass(span, config.fontStyle.normal);
      } else {
        this.addClass(span, config.fontStyle.italic);
      }
    }
    if (action === 'textUnderline') {
      let underline = false;
      if (container.closest(`.${config.textDecoration.underline}`)) {
        underline = true;
      }
      if (underline) ; else {
        this.addClass(span, config.textDecoration.underline);
      }
    }
    if (action === 'textLinethrough') {
      let linethrough = false;
      if (container.closest(`.${config.textDecoration.linethrough}`)) {
        linethrough = true;
      }
      if (linethrough) ; else {
        this.addClass(span, config.textDecoration.linethrough);
      }
    }
    /*
    if(action === 'textTransform') {
        let val = '';
        if(container.closest(`.${config.textTransform.uppercase}`)) {
            val = 'uppercase';
        } else if(container.closest(`.${config.textTransform.lowercase}`)) {
            val = 'lowercase';
        } else if(container.closest(`.${config.textTransform.capitalize}`)) {
            val = 'capitalize';
        } else if(container.closest(`.${config.textTransform.normal}`)) {
            val = 'normal';
        } 
        if (val === '') {
            this.addClass(span, config.textTransform.uppercase);
        } else if (val === 'uppercase') {
            this.addClass(span, config.textTransform.lowercase);
        } else if (val === 'lowercase') {
            this.addClass(span, config.textTransform.capitalize);
        } else if (val === 'capitalize') {
            this.addClass(span, config.textTransform.normal);
        } else if (val === 'normal') {
            this.addClass(span, config.textTransform.uppercase);
        } 
    }*/
    if (action === 'textTransform') {
      let val = '';
      if (container.closest(`.${config.textTransform.uppercase}`)) {
        val = 'uppercase';
      }
      this.removeClass(span, config.textTransform.uppercase);
      this.removeClass(span, config.textTransform.lowercase);
      this.removeClass(span, config.textTransform.capitalize);
      this.removeClass(span, config.textTransform.normal);
      if (val === '') {
        this.addClass(span, config.textTransform.uppercase);
      }
    }
    if (action === 'extend') {
      let exist = false;
      if (container.closest(`.${config.extend[value]}`)) {
        exist = true;
      }
      if (exist) ; else {
        this.addClass(span, config.extend[value]);
      }
    }
    span.appendChild(fragment);
    this.cleanChildrenToggle(action, value, span, config);
    this.cleanUnusedSpan(span); // REVIEW

    range.insertNode(span);
    selection.selectAllChildren(span);
    return span;
  }
  cleanChildrenToggle(action, value, span, config) {
    if (!span.hasChildNodes()) {
      return;
    }
    if (action === 'fontWeight') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.fontWeight.thin);
        this.removeClass(element, config.fontWeight.extralight);
        this.removeClass(element, config.fontWeight.light);
        this.removeClass(element, config.fontWeight.normal);
        this.removeClass(element, config.fontWeight.medium);
        this.removeClass(element, config.fontWeight.semibold);
        this.removeClass(element, config.fontWeight.bold);
        this.removeClass(element, config.fontWeight.extrabold);
        this.removeClass(element, config.fontWeight.black);
      });
    }
    if (action === 'fontStyle') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.fontStyle.italic);
        this.removeClass(element, config.fontStyle.normal);
      });
    }
    if (action === 'textUnderline') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.textDecoration.underline);
        this.removeClass(element, config.textDecoration.linethrough);
        this.removeClass(element, config.textDecoration.normal);
      });
    }
    if (action === 'textLinethrough') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.textDecoration.underline);
        this.removeClass(element, config.textDecoration.linethrough);
        this.removeClass(element, config.textDecoration.normal);
      });
    }
    if (action === 'textTransform') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.textTransform.uppercase);
        this.removeClass(element, config.textTransform.lowercase);
        this.removeClass(element, config.textTransform.capitalize);
        this.removeClass(element, config.textTransform.normal);
      });
    }
    if (action === 'clean') {
      Array.from(span.children).map(element => {
        element.className = '';
        element.style.cssText = '';
      });
    }
    if (action === 'extend') {
      Array.from(span.children).map(element => {
        this.removeClass(element, config.extend[value]);
      });
    }

    // Deeper childrens
    const cleanChildrenChildren = Array.from(span.children).map(element => {
      return this.cleanChildrenToggle(action, value, element, config);
    });
    if (!cleanChildrenChildren || cleanChildrenChildren.length <= 0) {
      return;
    }
  }
  getSelection() {
    if (this.builder.win && this.builder.win.getSelection) {
      return this.builder.win.getSelection();
    } else if (this.builder.doc && this.builder.doc.getSelection) {
      return this.builder.doc.getSelection();
    } else if (this.builder.doc && this.builder.doc.selection) {
      return this.builder.doc.selection.createRange().text;
    }
    return null;
  }
  cleanChildren(action, span) {
    if (!span.hasChildNodes()) {
      return;
    }

    // Direct children with same style rule
    const children = Array.from(span.children).filter(element => {
      return element.style[action] !== undefined && element.style[action.style] !== '';
    });
    if (children && children.length > 0) {
      children.forEach(element => {
        element.style[action] = '';
        if (element.getAttribute('style') === '' || element.style === null) {
          element.removeAttribute('style');
        }
      });
    }

    // Deeper childrens
    const cleanChildrenChildren = Array.from(span.children).map(element => {
      return this.cleanChildren(action, element);
    });
    if (!cleanChildrenChildren || cleanChildrenChildren.length <= 0) {
      return;
    }
  }
  addCssClass(elm, className, classes) {
    this.removeCssClasses(elm, classes);
    this.addClass(elm, className);
  }
  removeCssClasses(elm, classes) {
    for (let i = 0; i < Object.keys(classes).length; i++) {
      const item = Object.values(classes)[i];
      this.removeClass(elm, item);
    }
  }

  // Clean HTML stuff
  removeEmptyStyle(area) {
    if (!area.hasChildNodes()) {
      return;
    }
    const children = Array.from(area.children).filter(element => {
      return element.getAttribute('style');
    });
    if (children && children.length > 0) {
      children.forEach(element => {
        if (element.getAttribute('style').trim() === '' || element.style === null) {
          element.removeAttribute('style');
        }
      });
    }

    // Deeper childrens
    const removeEmptyStyleChildren = Array.from(area.children).map(element => {
      return this.removeEmptyStyle(element);
    });
    if (!removeEmptyStyleChildren || removeEmptyStyleChildren.length <= 0) {
      return;
    }
  }

  // Font Size stuff
  cleanClassSize(span, className) {
    // used in rte.js 2991
    if (!span.hasChildNodes()) {
      return;
    }

    // Direct children with same style rule
    const children = Array.from(span.children).filter(element => {
      return this.hasClass(element, className);
    });
    if (children && children.length > 0) {
      children.forEach(element => {
        this.removeClass(element, className);
      });
    }

    // Deeper childrens
    const cleanClassSizeChildren = Array.from(span.children).map(element => {
      return this.cleanClassSize(element, className);
    });
    if (!cleanClassSizeChildren || cleanClassSizeChildren.length <= 0) {
      return;
    }
  }

  // Remove Format stuff
  removeFormat() {
    const selection = this.getSelection();
    if (!selection) return;
    const anchorNode = selection.anchorNode;
    if (!anchorNode) return;
    const container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
    const sameSelection = container && container.innerText === selection.toString().trim();
    if (sameSelection || selection.toString().trim() === '') {
      this.cleanElement(container);
    } else {
      this.cleanSelection(selection);
    }
  }
  cleanElement(elm) {
    elm.style.fontWeight = '';
    elm.style.fontStyle = '';
    elm.style.textDecoration = '';
    elm.style.textTransform = '';
    elm.style.fontFamily = '';
    elm.style.fontSize = '';
    elm.style.color = '';
    elm.style.backgroundColor = '';
    elm.classList.forEach(item => {
      if (item.indexOf('size-') !== -1) {
        this.removeClass(elm, item);
      }
    });
    let elms = elm.querySelectorAll('*');
    elms.forEach(elm => {
      elm.style.fontWeight = '';
      elm.style.fontStyle = '';
      elm.style.textDecoration = '';
      elm.style.textTransform = '';
      elm.style.fontFamily = '';
      elm.style.fontSize = '';
      elm.style.color = '';
      elm.style.backgroundColor = '';
      elm.classList.forEach(item => {
        if (item.indexOf('size-') !== -1) {
          this.removeClass(elm, item);
        }
      });
    });
    this.cleanUnusedSpan(elm); // REVIEW (causes lost selection)
  }

  cleanSelection(selection) {
    const range = selection.getRangeAt(0);
    const fragment = range.extractContents();
    const span = document.createElement('span');
    span.appendChild(fragment);
    range.insertNode(span);
    selection.selectAllChildren(span);
    this.cleanElement(span);
  }

  /*
  cleanUnusedSpan(span) {
       if (!span.hasChildNodes()) {
          return;
      }
       // Direct children with no style
      const children = Array.from(span.children).filter((element) => {
          if (element.getAttribute('style') === '' || element.style === null) {
              element.removeAttribute('style');
          }
          let unused = ( element.attributes.length === 0 || (element.attributes.length === 1 && element.hasAttribute('data-keep')));
          return (element.nodeName.toLowerCase() === 'span' && unused);
      });
       if (children && children.length > 0) {
          children.forEach((element) => { 
              const text = document.createTextNode(element.textContent);
              element.parentElement.replaceChild(text, element);
          });
          return;
      }
       // Deeper childrens
      const cleanUnusedSpanChildren = Array.from(span.children).map((element) => {
          return this.cleanUnusedSpan(element);
      });
       if (!cleanUnusedSpanChildren || cleanUnusedSpanChildren.length <= 0) {
          return;
      }
  }
  */

  cleanUnusedSpan(area) {
    // for specific element only (during execCommand), 
    // not for the entire ContentBuilder container, 
    // because there can be custom blocks

    let spans = area.querySelectorAll('span');
    const filter = Array.prototype.filter;
    let children = filter.call(spans, element => {
      return element.attributes.length === 0;
    });

    // Remove empty spans
    if (children && children.length > 0) {
      children.forEach(element => {
        element.outerHTML = element.innerHTML;
      });
    }

    // Remove spans which have empty content
    spans = area.querySelectorAll('span');
    filter.call(spans, element => {
      if (element.innerHTML === '') {
        element.parentNode.removeChild(element);
      }
    });

    // Recheck
    spans = area.querySelectorAll('span');
    children = filter.call(spans, element => {
      return element.attributes.length === 0;
    });
    if (children && children.length > 0) {
      this.cleanUnusedSpan(area);
    } else {
      return;
    }
  }
  contentReformat(area, cssClasses) {
    this.replaceTag(area, 'b', cssClasses.fontWeight.defaultBold);
    this.replaceTag(area, 'i', cssClasses.fontStyle.italic);
    this.replaceTag(area, 'u', cssClasses.textDecoration.underline);
    this.replaceTag(area, 'strike', cssClasses.textDecoration.linethrough);
    this.replaceInline(area, 'font-weight', 'normal', cssClasses.fontWeight.defaultBold);
    this.replaceInline(area, 'font-weight', 'bold', cssClasses.fontWeight.defaultBold);
    this.replaceInline(area, 'font-weight', '600', cssClasses.fontWeight.semibold);
    this.replaceInline(area, 'text-align', 'left', cssClasses.textAlign.left);
    this.replaceInline(area, 'text-align', 'right', cssClasses.textAlign.right);
    this.replaceInline(area, 'text-align', 'center', cssClasses.textAlign.center);
    this.replaceInline(area, 'text-align', 'justify', cssClasses.textAlign.justify);
    this.replaceInline(area, 'display', 'flex', cssClasses.display.flex);
    this.replaceInline(area, 'justiify-content', 'flex-start', cssClasses.justifyContent.start);
    this.replaceInline(area, 'justiify-content', 'flex-end', cssClasses.justifyContent.end);
    this.replaceInline(area, 'justiify-content', 'center', cssClasses.justifyContent.center);
    this.replaceInline(area, 'justiify-content', 'space-between', cssClasses.justifyContent.between);
    this.replaceInline(area, 'flex-direction', 'column', cssClasses.flexDirection.column);
    this.replaceInline(area, 'flex-direction', 'row', cssClasses.flexDirection.row);
    this.replaceInline(area, 'align-items', 'flex-start', cssClasses.alignItems.start);
    this.replaceInline(area, 'align-items', 'flex-end', cssClasses.alignItems.end);
    this.replaceInline(area, 'align-items', 'center', cssClasses.alignItems.center);
    this.replaceInline(area, 'text-transform', 'uppercase', cssClasses.textTransform.uppercase);
    this.replaceInline(area, 'text-transform', 'lowercase', cssClasses.textTransform.lowercase);
    this.replaceInline(area, 'text-transform', 'none', cssClasses.textTransform.normal);
    this.replaceInline(area, 'line-height', '1', cssClasses.leading.leading_10);
    this.replaceInline(area, 'line-height', '1.1', cssClasses.leading.leading_11);
    this.replaceInline(area, 'line-height', '1.2', cssClasses.leading.leading_12);
    this.replaceInline(area, 'line-height', '1.25', cssClasses.leading.leading_125);
    this.replaceInline(area, 'line-height', '1.3', cssClasses.leading.leading_13);
    this.replaceInline(area, 'line-height', '1.375', cssClasses.leading.leading_1375);
    this.replaceInline(area, 'line-height', '1.4', cssClasses.leading.leading_14);
    this.replaceInline(area, 'line-height', '1.5', cssClasses.leading.leading_15);
    this.replaceInline(area, 'line-height', '1.6', cssClasses.leading.leading_16);
    this.replaceInline(area, 'line-height', '1.625', cssClasses.leading.leading_1625);
    this.replaceInline(area, 'line-height', '1.7', cssClasses.leading.leading_17);
    this.replaceInline(area, 'line-height', '1.8', cssClasses.leading.leading_18);
    this.replaceInline(area, 'line-height', '1.9', cssClasses.leading.leading_19);
    this.replaceInline(area, 'line-height', '2', cssClasses.leading.leading_20);
    this.replaceInline(area, 'line-height', '2.1', cssClasses.leading.leading_21);
    this.replaceInline(area, 'line-height', '2.2', cssClasses.leading.leading_22);
  }
  replaceTag(area, tag, className) {
    let elms = area.querySelectorAll(tag);
    const filter = Array.prototype.filter;
    let children = filter.call(elms, element => {
      return element.attributes.length === 0;
    });
    if (children && children.length > 0) {
      children.forEach(element => {
        const span = document.createElement('span');
        span.setAttribute('class', className);
        span.innerHTML = element.innerHTML;
        element.outerHTML = span.outerHTML;
      });
    }
  }
  replaceInline(builder, css, value, className) {
    let elms = builder.querySelectorAll('*');
    elms.forEach(elm => {
      if (css === 'justiify-content') {
        /*
        For some reason, cannot use elm.style[css] for 'justify-content'
        */
        if (elm.style.justifyContent === `${value}`) {
          this.addClass(elm, className);
          elm.style.justifyContent = '';
        }
      } else if (elm.style[css] === `${value}`) {
        this.addClass(elm, className);
        elm.style[css] = '';
      }
    });
  }
  countOccurrences(text, word) {
    // match the word globally and case insensitively
    const regex = new RegExp(word, 'gi');
    const matches = text.match(regex);
    return matches ? matches.length : 0;
  }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var js$1 = {exports: {}};

var src = {};

var javascript = {exports: {}};

var beautifier$2 = {};

var output = {};

/*jshint node:true */

function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output$3(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output$3.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output$3.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output$3.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output$3.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output$3.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output$3.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output$3.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output$3.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output$3.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output$3.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output$3.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output$3.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output$3.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output$3.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output$3.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output$3.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output$3.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

output.Output = Output$3;

var token = {};

/*jshint node:true */

function Token$2(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


token.Token = Token$2;

var acorn$2 = {};

/* jshint node: true, curly: false */

(function (exports) {

// acorn used char codes to squeeze the last bit of performance out
// Beautifier is okay without that, so we're using regex
// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
// 65 through 91 are uppercase letters.
// permit _ (95).
// 97 through 123 are lowercase letters.
var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

// inside an identifier @ is not allowed but 0-9 are.
var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
exports.identifierStart = new RegExp(identifierStart);
exports.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');
}(acorn$2));

var options$3 = {};

var options$2 = {};

/*jshint node:true */

function Options$9(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
}

Options$9.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options$9.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options$9.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options$9.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options$9.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options$9.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options$9.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

options$2.Options = Options$9;
options$2.normalizeOpts = _normalizeOpts;
options$2.mergeOpts = _mergeOpts;

/*jshint node:true */

var BaseOptions$2 = options$2.Options;

var validPositionValues$1 = ['before-newline', 'after-newline', 'preserve-newline'];

function Options$8(options) {
  BaseOptions$2.call(this, options, 'js');

  // compatibility, re
  var raw_brace_style = this.raw_options.brace_style || null;
  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
    this.raw_options.brace_style = "expand";
  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
    this.raw_options.brace_style = "collapse,preserve-inline";
  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    // } else if (!raw_brace_style) { //Nothing exists to set it
    //   raw_brace_style = "collapse";
  }

  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
  //else is considered a brace_style and the last one only will have an effect

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
  this.brace_style = "collapse";

  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] === "preserve-inline") {
      this.brace_preserve_inline = true;
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }

  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
  this.break_chained_methods = this._get_boolean('break_chained_methods');
  this.space_in_paren = this._get_boolean('space_in_paren');
  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
  this.jslint_happy = this._get_boolean('jslint_happy');
  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
  this.space_after_named_function = this._get_boolean('space_after_named_function');
  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
  this.unescape_strings = this._get_boolean('unescape_strings');
  this.e4x = this._get_boolean('e4x');
  this.comma_first = this._get_boolean('comma_first');
  this.operator_position = this._get_selection('operator_position', validPositionValues$1);

  // For testing of beautify preserve:start directive
  this.test_output_raw = this._get_boolean('test_output_raw');

  // force this._options.space_after_anon_function to true if this._options.jslint_happy
  if (this.jslint_happy) {
    this.space_after_anon_function = true;
  }

}
Options$8.prototype = new BaseOptions$2();



options$3.Options = Options$8;

var tokenizer$2 = {};

var inputscanner = {};

/*jshint node:true */

var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner$3(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner$3.prototype.restart = function() {
  this.__position = 0;
};

InputScanner$3.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner$3.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner$3.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner$3.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner$3.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner$3.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner$3.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner$3.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner$3.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner$3.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner$3.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner$3.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner$3.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner$3.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner$3.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

inputscanner.InputScanner = InputScanner$3;

var tokenizer$1 = {};

var tokenstream = {};

/*jshint node:true */

function TokenStream$1(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream$1.prototype.restart = function() {
  this.__position = 0;
};

TokenStream$1.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream$1.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream$1.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream$1.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream$1.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

tokenstream.TokenStream = TokenStream$1;

var whitespacepattern = {};

var pattern = {};

/*jshint node:true */

function Pattern$4(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern$4.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern$4.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern$4.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern$4.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern$4.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern$4.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern$4.prototype._create = function() {
  return new Pattern$4(this._input, this);
};

Pattern$4.prototype._update = function() {};

pattern.Pattern = Pattern$4;

/*jshint node:true */

var Pattern$3 = pattern.Pattern;

function WhitespacePattern$1(input_scanner, parent) {
  Pattern$3.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern$1.prototype = new Pattern$3();

WhitespacePattern$1.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern$1.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern$1.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern$1.prototype._create = function() {
  return new WhitespacePattern$1(this._input, this);
};

WhitespacePattern$1.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



whitespacepattern.WhitespacePattern = WhitespacePattern$1;

/*jshint node:true */

var InputScanner$2 = inputscanner.InputScanner;
var Token$1 = token.Token;
var TokenStream = tokenstream.TokenStream;
var WhitespacePattern = whitespacepattern.WhitespacePattern;

var TOKEN$4 = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer$4 = function(input_string, options) {
  this._input = new InputScanner$2(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern(this._input);
};

Tokenizer$4.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream();

  this._reset();

  var current;
  var previous = new Token$1(TOKEN$4.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream();

  while (previous.type !== TOKEN$4.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer$4.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer$4.prototype._reset = function() {};

Tokenizer$4.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN$4.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN$4.EOF, '');
  }
};

Tokenizer$4.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer$4.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer$4.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer$4.prototype._create_token = function(type, text) {
  var token = new Token$1(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer$4.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



tokenizer$1.Tokenizer = Tokenizer$4;
tokenizer$1.TOKEN = TOKEN$4;

var directives = {};

/*jshint node:true */

function Directives$3(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives$3.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives$3.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


directives.Directives = Directives$3;

var templatablepattern = {};

/*jshint node:true */

var Pattern$2 = pattern.Pattern;


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false,
  smarty: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern$2(input_scanner, parent) {
  Pattern$2.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern$2(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
  };
}
TemplatablePattern$2.prototype = new Pattern$2();

TemplatablePattern$2.prototype._create = function() {
  return new TemplatablePattern$2(this._input, this);
};

TemplatablePattern$2.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern$2.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern$2.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern$2.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern$2.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern$2.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    // The starting pattern for django is more complex because it has different
    // patterns for value, comment, and other sections
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }
  if (!this._disabled.smarty) {
    items.push(this.__patterns.smarty._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern$2.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
    if (!this._disabled.smarty) {
      // smarty cannot be enabled with django or handlebars enabled
      if (this._disabled.django && this._disabled.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.smarty_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty_literal.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty.read();
      }
    }
  }
  return resulting_string;
};


templatablepattern.TemplatablePattern = TemplatablePattern$2;

/*jshint node:true */

var InputScanner$1 = inputscanner.InputScanner;
var BaseTokenizer$1 = tokenizer$1.Tokenizer;
var BASETOKEN$1 = tokenizer$1.TOKEN;
var Directives$2 = directives.Directives;
var acorn$1 = acorn$2;
var Pattern$1 = pattern.Pattern;
var TemplatablePattern$1 = templatablepattern.TemplatablePattern;


function in_array$2(what, arr) {
  return arr.indexOf(what) !== -1;
}


var TOKEN$3 = {
  START_EXPR: 'TK_START_EXPR',
  END_EXPR: 'TK_END_EXPR',
  START_BLOCK: 'TK_START_BLOCK',
  END_BLOCK: 'TK_END_BLOCK',
  WORD: 'TK_WORD',
  RESERVED: 'TK_RESERVED',
  SEMICOLON: 'TK_SEMICOLON',
  STRING: 'TK_STRING',
  EQUALS: 'TK_EQUALS',
  OPERATOR: 'TK_OPERATOR',
  COMMA: 'TK_COMMA',
  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
  COMMENT: 'TK_COMMENT',
  DOT: 'TK_DOT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN$1.START,
  RAW: BASETOKEN$1.RAW,
  EOF: BASETOKEN$1.EOF
};


var directives_core$2 = new Directives$2(/\/\*/, /\*\//);

var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;

var digit = /[0-9]/;

// Dot "." must be distinguished from "..." and decimal
var dot_pattern = /[^\d\.]/;

var positionable_operators$1 = (
  ">>> === !== " +
  "<< && >= ** != == <= >> || ?? |> " +
  "< / - + > : & % ? ^ | *").split(' ');

// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
// Also, you must update possitionable operators separately from punct
var punct =
  ">>>= " +
  "... >>= <<= === >>> !== **= " +
  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
  "= ! ? > < : / ^ - + * & % ~ |";

punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
// ?. but not if followed by a number 
punct = '\\?\\.(?!\\d) ' + punct;
punct = punct.replace(/ /g, '|');

var punct_pattern = new RegExp(punct);

// words which should always start on new line.
var line_starters$1 = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
var reserved_words = line_starters$1.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);
var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

var in_html_comment;

var Tokenizer$3 = function(input_string, options) {
  BaseTokenizer$1.call(this, input_string, options);

  this._patterns.whitespace = this._patterns.whitespace.matching(
    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
    /\u2028\u2029/.source);

  var pattern_reader = new Pattern$1(this._input);
  var templatable = new TemplatablePattern$1(this._input)
    .read_options(this._options);

  this.__patterns = {
    template: templatable,
    identifier: templatable.starting_with(acorn$1.identifier).matching(acorn$1.identifierMatch),
    number: pattern_reader.matching(number_pattern),
    punct: pattern_reader.matching(punct_pattern),
    // comment ends just before nearest linefeed or end of file
    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
    //  /* ... */ comment ends with nearest */ or end of file
    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
    html_comment_start: pattern_reader.matching(/<!--/),
    html_comment_end: pattern_reader.matching(/-->/),
    include: pattern_reader.starting_with(/#include/).until_after(acorn$1.lineBreak),
    shebang: pattern_reader.starting_with(/#!/).until_after(acorn$1.lineBreak),
    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\]|)(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/),
    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
    template_text: templatable.until(/[`\\$]/),
    template_expression: templatable.until(/[`}\\]/)
  };

};
Tokenizer$3.prototype = new BaseTokenizer$1();

Tokenizer$3.prototype._is_comment = function(current_token) {
  return current_token.type === TOKEN$3.COMMENT || current_token.type === TOKEN$3.BLOCK_COMMENT || current_token.type === TOKEN$3.UNKNOWN;
};

Tokenizer$3.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$3.START_BLOCK || current_token.type === TOKEN$3.START_EXPR;
};

Tokenizer$3.prototype._is_closing = function(current_token, open_token) {
  return (current_token.type === TOKEN$3.END_BLOCK || current_token.type === TOKEN$3.END_EXPR) &&
    (open_token && (
      (current_token.text === ']' && open_token.text === '[') ||
      (current_token.text === ')' && open_token.text === '(') ||
      (current_token.text === '}' && open_token.text === '{')));
};

Tokenizer$3.prototype._reset = function() {
  in_html_comment = false;
};

Tokenizer$3.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$3.EOF, '');
  }

  token = token || this._read_non_javascript(c);
  token = token || this._read_string(c);
  token = token || this._read_word(previous_token);
  token = token || this._read_singles(c);
  token = token || this._read_comment(c);
  token = token || this._read_regexp(c, previous_token);
  token = token || this._read_xml(c, previous_token);
  token = token || this._read_punctuation();
  token = token || this._create_token(TOKEN$3.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$3.prototype._read_word = function(previous_token) {
  var resulting_string;
  resulting_string = this.__patterns.identifier.read();
  if (resulting_string !== '') {
    resulting_string = resulting_string.replace(acorn$1.allLineBreaks, '\n');
    if (!(previous_token.type === TOKEN$3.DOT ||
        (previous_token.type === TOKEN$3.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
      reserved_word_pattern.test(resulting_string)) {
      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators
        return this._create_token(TOKEN$3.OPERATOR, resulting_string);
      }
      return this._create_token(TOKEN$3.RESERVED, resulting_string);
    }
    return this._create_token(TOKEN$3.WORD, resulting_string);
  }

  resulting_string = this.__patterns.number.read();
  if (resulting_string !== '') {
    return this._create_token(TOKEN$3.WORD, resulting_string);
  }
};

Tokenizer$3.prototype._read_singles = function(c) {
  var token = null;
  if (c === '(' || c === '[') {
    token = this._create_token(TOKEN$3.START_EXPR, c);
  } else if (c === ')' || c === ']') {
    token = this._create_token(TOKEN$3.END_EXPR, c);
  } else if (c === '{') {
    token = this._create_token(TOKEN$3.START_BLOCK, c);
  } else if (c === '}') {
    token = this._create_token(TOKEN$3.END_BLOCK, c);
  } else if (c === ';') {
    token = this._create_token(TOKEN$3.SEMICOLON, c);
  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
    token = this._create_token(TOKEN$3.DOT, c);
  } else if (c === ',') {
    token = this._create_token(TOKEN$3.COMMA, c);
  }

  if (token) {
    this._input.next();
  }
  return token;
};

Tokenizer$3.prototype._read_punctuation = function() {
  var resulting_string = this.__patterns.punct.read();

  if (resulting_string !== '') {
    if (resulting_string === '=') {
      return this._create_token(TOKEN$3.EQUALS, resulting_string);
    } else if (resulting_string === '?.') {
      return this._create_token(TOKEN$3.DOT, resulting_string);
    } else {
      return this._create_token(TOKEN$3.OPERATOR, resulting_string);
    }
  }
};

Tokenizer$3.prototype._read_non_javascript = function(c) {
  var resulting_string = '';

  if (c === '#') {
    if (this._is_first_token()) {
      resulting_string = this.__patterns.shebang.read();

      if (resulting_string) {
        return this._create_token(TOKEN$3.UNKNOWN, resulting_string.trim() + '\n');
      }
    }

    // handles extendscript #includes
    resulting_string = this.__patterns.include.read();

    if (resulting_string) {
      return this._create_token(TOKEN$3.UNKNOWN, resulting_string.trim() + '\n');
    }

    c = this._input.next();

    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
    var sharp = '#';
    if (this._input.hasNext() && this._input.testChar(digit)) {
      do {
        c = this._input.next();
        sharp += c;
      } while (this._input.hasNext() && c !== '#' && c !== '=');
      if (c === '#') ; else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
        sharp += '[]';
        this._input.next();
        this._input.next();
      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
        sharp += '{}';
        this._input.next();
        this._input.next();
      }
      return this._create_token(TOKEN$3.WORD, sharp);
    }

    this._input.back();

  } else if (c === '<' && this._is_first_token()) {
    resulting_string = this.__patterns.html_comment_start.read();
    if (resulting_string) {
      while (this._input.hasNext() && !this._input.testChar(acorn$1.newline)) {
        resulting_string += this._input.next();
      }
      in_html_comment = true;
      return this._create_token(TOKEN$3.COMMENT, resulting_string);
    }
  } else if (in_html_comment && c === '-') {
    resulting_string = this.__patterns.html_comment_end.read();
    if (resulting_string) {
      in_html_comment = false;
      return this._create_token(TOKEN$3.COMMENT, resulting_string);
    }
  }

  return null;
};

Tokenizer$3.prototype._read_comment = function(c) {
  var token = null;
  if (c === '/') {
    var comment = '';
    if (this._input.peek(1) === '*') {
      // peek for comment /* ... */
      comment = this.__patterns.block_comment.read();
      var directives = directives_core$2.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core$2.readIgnored(this._input);
      }
      comment = comment.replace(acorn$1.allLineBreaks, '\n');
      token = this._create_token(TOKEN$3.BLOCK_COMMENT, comment);
      token.directives = directives;
    } else if (this._input.peek(1) === '/') {
      // peek for comment // ...
      comment = this.__patterns.comment.read();
      token = this._create_token(TOKEN$3.COMMENT, comment);
    }
  }
  return token;
};

Tokenizer$3.prototype._read_string = function(c) {
  if (c === '`' || c === "'" || c === '"') {
    var resulting_string = this._input.next();
    this.has_char_escapes = false;

    if (c === '`') {
      resulting_string += this._read_string_recursive('`', true, '${');
    } else {
      resulting_string += this._read_string_recursive(c);
    }

    if (this.has_char_escapes && this._options.unescape_strings) {
      resulting_string = unescape_string(resulting_string);
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();
    }

    resulting_string = resulting_string.replace(acorn$1.allLineBreaks, '\n');

    return this._create_token(TOKEN$3.STRING, resulting_string);
  }

  return null;
};

Tokenizer$3.prototype._allow_regexp_or_xml = function(previous_token) {
  // regex and xml can only appear in specific locations during parsing
  return (previous_token.type === TOKEN$3.RESERVED && in_array$2(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
    (previous_token.type === TOKEN$3.END_EXPR && previous_token.text === ')' &&
      previous_token.opened.previous.type === TOKEN$3.RESERVED && in_array$2(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
    (in_array$2(previous_token.type, [TOKEN$3.COMMENT, TOKEN$3.START_EXPR, TOKEN$3.START_BLOCK, TOKEN$3.START,
      TOKEN$3.END_BLOCK, TOKEN$3.OPERATOR, TOKEN$3.EQUALS, TOKEN$3.EOF, TOKEN$3.SEMICOLON, TOKEN$3.COMMA
    ]));
};

Tokenizer$3.prototype._read_regexp = function(c, previous_token) {

  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
    // handle regexp
    //
    var resulting_string = this._input.next();
    var esc = false;

    var in_char_class = false;
    while (this._input.hasNext() &&
      ((esc || in_char_class || this._input.peek() !== c) &&
        !this._input.testChar(acorn$1.newline))) {
      resulting_string += this._input.peek();
      if (!esc) {
        esc = this._input.peek() === '\\';
        if (this._input.peek() === '[') {
          in_char_class = true;
        } else if (this._input.peek() === ']') {
          in_char_class = false;
        }
      } else {
        esc = false;
      }
      this._input.next();
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();

      // regexps may have modifiers /regexp/MOD , so fetch those, too
      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
      resulting_string += this._input.read(acorn$1.identifier);
    }
    return this._create_token(TOKEN$3.STRING, resulting_string);
  }
  return null;
};

Tokenizer$3.prototype._read_xml = function(c, previous_token) {

  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
    var xmlStr = '';
    var match = this.__patterns.xml.read_match();
    // handle e4x xml literals
    //
    if (match) {
      // Trim root tag to attempt to
      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
      var isCurlyRoot = rootTag.indexOf('{') === 0;
      var depth = 0;
      while (match) {
        var isEndTag = !!match[1];
        var tagName = match[2];
        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
        if (!isSingletonTag &&
          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
          if (isEndTag) {
            --depth;
          } else {
            ++depth;
          }
        }
        xmlStr += match[0];
        if (depth <= 0) {
          break;
        }
        match = this.__patterns.xml.read_match();
      }
      // if we didn't close correctly, keep unformatted.
      if (!match) {
        xmlStr += this._input.match(/[\s\S]*/g)[0];
      }
      xmlStr = xmlStr.replace(acorn$1.allLineBreaks, '\n');
      return this._create_token(TOKEN$3.STRING, xmlStr);
    }
  }

  return null;
};

function unescape_string(s) {
  // You think that a regex would work for this
  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
  //         return String.fromCharCode(parseInt(val, 16));
  //     })
  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
  var out = '',
    escaped = 0;

  var input_scan = new InputScanner$1(s);
  var matched = null;

  while (input_scan.hasNext()) {
    // Keep any whitespace, non-slash characters
    // also keep slash pairs.
    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

    if (matched) {
      out += matched[0];
    }

    if (input_scan.peek() === '\\') {
      input_scan.next();
      if (input_scan.peek() === 'x') {
        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
      } else if (input_scan.peek() === 'u') {
        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
      } else {
        out += '\\';
        if (input_scan.hasNext()) {
          out += input_scan.next();
        }
        continue;
      }

      // If there's some error decoding, return the original string
      if (!matched) {
        return s;
      }

      escaped = parseInt(matched[1], 16);

      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
        // we bail out on \x7f..\xff,
        // leaving whole string escaped,
        // as it's probably completely binary
        return s;
      } else if (escaped >= 0x00 && escaped < 0x20) {
        // leave 0x00...0x1f escaped
        out += '\\' + matched[0];
        continue;
      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
        // single-quote, apostrophe, backslash - escape these
        out += '\\' + String.fromCharCode(escaped);
      } else {
        out += String.fromCharCode(escaped);
      }
    }
  }

  return out;
}

// handle string
//
Tokenizer$3.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
  var current_char;
  var pattern;
  if (delimiter === '\'') {
    pattern = this.__patterns.single_quote;
  } else if (delimiter === '"') {
    pattern = this.__patterns.double_quote;
  } else if (delimiter === '`') {
    pattern = this.__patterns.template_text;
  } else if (delimiter === '}') {
    pattern = this.__patterns.template_expression;
  }

  var resulting_string = pattern.read();
  var next = '';
  while (this._input.hasNext()) {
    next = this._input.next();
    if (next === delimiter ||
      (!allow_unescaped_newlines && acorn$1.newline.test(next))) {
      this._input.back();
      break;
    } else if (next === '\\' && this._input.hasNext()) {
      current_char = this._input.peek();

      if (current_char === 'x' || current_char === 'u') {
        this.has_char_escapes = true;
      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
        this._input.next();
      }
      next += this._input.next();
    } else if (start_sub) {
      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
        next += this._input.next();
      }

      if (start_sub === next) {
        if (delimiter === '`') {
          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
        } else {
          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
        }
        if (this._input.hasNext()) {
          next += this._input.next();
        }
      }
    }
    next += pattern.read();
    resulting_string += next;
  }

  return resulting_string;
};

tokenizer$2.Tokenizer = Tokenizer$3;
tokenizer$2.TOKEN = TOKEN$3;
tokenizer$2.positionable_operators = positionable_operators$1.slice();
tokenizer$2.line_starters = line_starters$1.slice();

/*jshint node:true */

var Output$2 = output.Output;
var Token = token.Token;
var acorn = acorn$2;
var Options$7 = options$3.Options;
var Tokenizer$2 = tokenizer$2.Tokenizer;
var line_starters = tokenizer$2.line_starters;
var positionable_operators = tokenizer$2.positionable_operators;
var TOKEN$2 = tokenizer$2.TOKEN;


function in_array$1(what, arr) {
  return arr.indexOf(what) !== -1;
}

function ltrim(s) {
  return s.replace(/^\s+/g, '');
}

function generateMapFromStrings(list) {
  var result = {};
  for (var x = 0; x < list.length; x++) {
    // make the mapped names underscored instead of dash
    result[list[x].replace(/-/g, '_')] = list[x];
  }
  return result;
}

function reserved_word(token, word) {
  return token && token.type === TOKEN$2.RESERVED && token.text === word;
}

function reserved_array(token, words) {
  return token && token.type === TOKEN$2.RESERVED && in_array$1(token.text, words);
}
// Unsure of what they mean, but they work. Worth cleaning up in future.
var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
  BlockStatement: 'BlockStatement', // 'BLOCK'
  Statement: 'Statement', // 'STATEMENT'
  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
  Conditional: 'Conditional', //'(COND-EXPRESSION)',
  Expression: 'Expression' //'(EXPRESSION)'
};

function remove_redundant_indentation(output, frame) {
  // This implementation is effective but has some issues:
  //     - can cause line wrap to happen too soon due to indent removal
  //           after wrap points are calculated
  // These issues are minor compared to ugly indentation.

  if (frame.multiline_frame ||
    frame.mode === MODE.ForInitializer ||
    frame.mode === MODE.Conditional) {
    return;
  }

  // remove one indent from each line inside this section
  output.remove_indent(frame.start_line_index);
}

// we could use just string.split, but
// IE doesn't like returning empty strings
function split_linebreaks(s) {
  //return s.split(/\x0d\x0a|\x0a/);

  s = s.replace(acorn.allLineBreaks, '\n');
  var out = [],
    idx = s.indexOf("\n");
  while (idx !== -1) {
    out.push(s.substring(0, idx));
    s = s.substring(idx + 1);
    idx = s.indexOf("\n");
  }
  if (s.length) {
    out.push(s);
  }
  return out;
}

function is_array(mode) {
  return mode === MODE.ArrayLiteral;
}

function is_expression(mode) {
  return in_array$1(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
}

function all_lines_start_with(lines, c) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (line.charAt(0) !== c) {
      return false;
    }
  }
  return true;
}

function each_line_matches_indent(lines, indent) {
  var i = 0,
    len = lines.length,
    line;
  for (; i < len; i++) {
    line = lines[i];
    // allow empty lines to pass through
    if (line && line.indexOf(indent) !== 0) {
      return false;
    }
  }
  return true;
}


function Beautifier$5(source_text, options) {
  options = options || {};
  this._source_text = source_text || '';

  this._output = null;
  this._tokens = null;
  this._last_last_text = null;
  this._flags = null;
  this._previous_flags = null;

  this._flag_store = null;
  this._options = new Options$7(options);
}

Beautifier$5.prototype.create_flags = function(flags_base, mode) {
  var next_indent_level = 0;
  if (flags_base) {
    next_indent_level = flags_base.indentation_level;
    if (!this._output.just_added_newline() &&
      flags_base.line_indent_level > next_indent_level) {
      next_indent_level = flags_base.line_indent_level;
    }
  }

  var next_flags = {
    mode: mode,
    parent: flags_base,
    last_token: flags_base ? flags_base.last_token : new Token(TOKEN$2.START_BLOCK, ''), // last token text
    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
    declaration_statement: false,
    declaration_assignment: false,
    multiline_frame: false,
    inline_frame: false,
    if_block: false,
    else_block: false,
    do_block: false,
    do_while: false,
    import_block: false,
    in_case_statement: false, // switch(..){ INSIDE HERE }
    in_case: false, // we're on the exact line with "case 0:"
    case_body: false, // the indented case-action block
    indentation_level: next_indent_level,
    alignment: 0,
    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
    start_line_index: this._output.get_line_number(),
    ternary_depth: 0
  };
  return next_flags;
};

Beautifier$5.prototype._reset = function(source_text) {
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._last_last_text = ''; // pre-last token text
  this._output = new Output$2(this._options, baseIndentString);

  // If testing the ignore directive, start with output disable set to true
  this._output.raw = this._options.test_output_raw;


  // Stack of parsing/formatting states, including MODE.
  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
  // and formatted output.  This makes the beautifier less accurate than full parsers
  // but also far more tolerant of syntax errors.
  //
  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
  // most full parsers would die, but the beautifier gracefully falls back to
  // MODE.BlockStatement and continues on.
  this._flag_store = [];
  this.set_mode(MODE.BlockStatement);
  var tokenizer = new Tokenizer$2(source_text, this._options);
  this._tokens = tokenizer.tokenize();
  return source_text;
};

Beautifier$5.prototype.beautify = function() {
  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var sweet_code;
  var source_text = this._reset(this._source_text);

  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && acorn.lineBreak.test(source_text || '')) {
      eol = source_text.match(acorn.lineBreak)[0];
    }
  }

  var current_token = this._tokens.next();
  while (current_token) {
    this.handle_token(current_token);

    this._last_last_text = this._flags.last_token.text;
    this._flags.last_token = current_token;

    current_token = this._tokens.next();
  }

  sweet_code = this._output.get_code(eol);

  return sweet_code;
};

Beautifier$5.prototype.handle_token = function(current_token, preserve_statement_flags) {
  if (current_token.type === TOKEN$2.START_EXPR) {
    this.handle_start_expr(current_token);
  } else if (current_token.type === TOKEN$2.END_EXPR) {
    this.handle_end_expr(current_token);
  } else if (current_token.type === TOKEN$2.START_BLOCK) {
    this.handle_start_block(current_token);
  } else if (current_token.type === TOKEN$2.END_BLOCK) {
    this.handle_end_block(current_token);
  } else if (current_token.type === TOKEN$2.WORD) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.RESERVED) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.SEMICOLON) {
    this.handle_semicolon(current_token);
  } else if (current_token.type === TOKEN$2.STRING) {
    this.handle_string(current_token);
  } else if (current_token.type === TOKEN$2.EQUALS) {
    this.handle_equals(current_token);
  } else if (current_token.type === TOKEN$2.OPERATOR) {
    this.handle_operator(current_token);
  } else if (current_token.type === TOKEN$2.COMMA) {
    this.handle_comma(current_token);
  } else if (current_token.type === TOKEN$2.BLOCK_COMMENT) {
    this.handle_block_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.COMMENT) {
    this.handle_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.DOT) {
    this.handle_dot(current_token);
  } else if (current_token.type === TOKEN$2.EOF) {
    this.handle_eof(current_token);
  } else if (current_token.type === TOKEN$2.UNKNOWN) {
    this.handle_unknown(current_token, preserve_statement_flags);
  } else {
    this.handle_unknown(current_token, preserve_statement_flags);
  }
};

Beautifier$5.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
  var newlines = current_token.newlines;
  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

  if (current_token.comments_before) {
    var comment_token = current_token.comments_before.next();
    while (comment_token) {
      // The cleanest handling of inline comments is to treat them as though they aren't there.
      // Just continue formatting and the behavior should be logical.
      // Also ignore unknown tokens.  Again, this should result in better behavior.
      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
      this.handle_token(comment_token, preserve_statement_flags);
      comment_token = current_token.comments_before.next();
    }
  }

  if (keep_whitespace) {
    for (var i = 0; i < newlines; i += 1) {
      this.print_newline(i > 0, preserve_statement_flags);
    }
  } else {
    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
      newlines = this._options.max_preserve_newlines;
    }

    if (this._options.preserve_newlines) {
      if (newlines > 1) {
        this.print_newline(false, preserve_statement_flags);
        for (var j = 1; j < newlines; j += 1) {
          this.print_newline(true, preserve_statement_flags);
        }
      }
    }
  }

};

var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

Beautifier$5.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

  // Never wrap the first token on a line
  if (this._output.just_added_newline()) {
    return;
  }

  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
  var operatorLogicApplies = in_array$1(this._flags.last_token.text, positionable_operators) ||
    in_array$1(current_token.text, positionable_operators);

  if (operatorLogicApplies) {
    var shouldPrintOperatorNewline = (
        in_array$1(this._flags.last_token.text, positionable_operators) &&
        in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
      ) ||
      in_array$1(current_token.text, positionable_operators);
    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
  }

  if (shouldPreserveOrForce) {
    this.print_newline(false, true);
  } else if (this._options.wrap_line_length) {
    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
      // These tokens should never have a newline inserted
      // between them and the following expression.
      return;
    }
    this._output.set_wrap_point();
  }
};

Beautifier$5.prototype.print_newline = function(force_newline, preserve_statement_flags) {
  if (!preserve_statement_flags) {
    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN$2.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement &&
        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
        !this._flags.do_block) {
        this.restore_mode();
      }
    }
  }

  if (this._output.add_new_line(force_newline)) {
    this._flags.multiline_frame = true;
  }
};

Beautifier$5.prototype.print_token_line_indentation = function(current_token) {
  if (this._output.just_added_newline()) {
    if (this._options.keep_array_indentation &&
      current_token.newlines &&
      (current_token.text === '[' || is_array(this._flags.mode))) {
      this._output.current_line.set_indent(-1);
      this._output.current_line.push(current_token.whitespace_before);
      this._output.space_before_token = false;
    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
      this._flags.line_indent_level = this._flags.indentation_level;
    }
  }
};

Beautifier$5.prototype.print_token = function(current_token) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    return;
  }

  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN$2.COMMA &&
    this._output.just_added_newline()) {
    if (this._output.previous_line.last() === ',') {
      var popped = this._output.previous_line.pop();
      // if the comma was already at the start of the line,
      // pull back onto that line and reprint the indentation
      if (this._output.previous_line.is_empty()) {
        this._output.previous_line.push(popped);
        this._output.trim(true);
        this._output.current_line.pop();
        this._output.trim();
      }

      // add the comma in front of the next token
      this.print_token_line_indentation(current_token);
      this._output.add_token(',');
      this._output.space_before_token = true;
    }
  }

  this.print_token_line_indentation(current_token);
  this._output.non_breaking_space = true;
  this._output.add_token(current_token.text);
  if (this._output.previous_token_wrapped) {
    this._flags.multiline_frame = true;
  }
};

Beautifier$5.prototype.indent = function() {
  this._flags.indentation_level += 1;
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};

Beautifier$5.prototype.deindent = function() {
  if (this._flags.indentation_level > 0 &&
    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
    this._flags.indentation_level -= 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier$5.prototype.set_mode = function(mode) {
  if (this._flags) {
    this._flag_store.push(this._flags);
    this._previous_flags = this._flags;
  } else {
    this._previous_flags = this.create_flags(null, mode);
  }

  this._flags = this.create_flags(this._previous_flags, mode);
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};


Beautifier$5.prototype.restore_mode = function() {
  if (this._flag_store.length > 0) {
    this._previous_flags = this._flags;
    this._flags = this._flag_store.pop();
    if (this._previous_flags.mode === MODE.Statement) {
      remove_redundant_indentation(this._output, this._previous_flags);
    }
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier$5.prototype.start_of_object_property = function() {
  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
};

Beautifier$5.prototype.start_of_statement = function(current_token) {
  var start = false;
  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD;
  start = start || reserved_word(this._flags.last_token, 'do');
  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
  start = start || reserved_word(this._flags.last_token, 'else') &&
    !(reserved_word(current_token, 'if') && !current_token.comments_before);
  start = start || (this._flags.last_token.type === TOKEN$2.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
  start = start || (this._flags.last_token.type === TOKEN$2.WORD && this._flags.mode === MODE.BlockStatement &&
    !this._flags.in_case &&
    !(current_token.text === '--' || current_token.text === '++') &&
    this._last_last_text !== 'function' &&
    current_token.type !== TOKEN$2.WORD && current_token.type !== TOKEN$2.RESERVED);
  start = start || (this._flags.mode === MODE.ObjectLiteral && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

  if (start) {
    this.set_mode(MODE.Statement);
    this.indent();

    this.handle_whitespace_and_comments(current_token, true);

    // Issue #276:
    // If starting a new statement with [if, for, while, do], push to a new line.
    // if (a) if (b) if(c) d(); else e(); else f();
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token,
        reserved_array(current_token, ['do', 'for', 'if', 'while']));
    }
    return true;
  }
  return false;
};

Beautifier$5.prototype.handle_start_expr = function(current_token) {
  // The conditional starts the statement if appropriate.
  if (!this.start_of_statement(current_token)) {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_mode = MODE.Expression;
  if (current_token.text === '[') {

    if (this._flags.last_token.type === TOKEN$2.WORD || this._flags.last_token.text === ')') {
      // this is array index specifier, break immediately
      // a[x], fn()[x]
      if (reserved_array(this._flags.last_token, line_starters)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      this.indent();
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      return;
    }

    next_mode = MODE.ArrayLiteral;
    if (is_array(this._flags.mode)) {
      if (this._flags.last_token.text === '[' ||
        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
        // ], [ goes to new line
        // }, [ goes to new line
        if (!this._options.keep_array_indentation) {
          this.print_newline();
        }
      }
    }

    if (!in_array$1(this._flags.last_token.type, [TOKEN$2.START_EXPR, TOKEN$2.END_EXPR, TOKEN$2.WORD, TOKEN$2.OPERATOR, TOKEN$2.DOT])) {
      this._output.space_before_token = true;
    }
  } else {
    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      if (this._flags.last_token.text === 'for') {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.ForInitializer;
      } else if (in_array$1(this._flags.last_token.text, ['if', 'while', 'switch'])) {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.Conditional;
      } else if (in_array$1(this._flags.last_word, ['await', 'async'])) {
        // Should be a space between await and an IIFE, or async and an arrow function
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
        this._output.space_before_token = false;
      } else if (in_array$1(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {
        this._output.space_before_token = true;
      }
    } else if (this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // Support of this kind of newline preservation.
      // a = (b &&
      //     (c || d));
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.last_token.type === TOKEN$2.WORD) {
      this._output.space_before_token = false;

      // function name() vs function name ()
      // function* name() vs function* name ()
      // async name() vs async name ()
      // In ES6, you can also define the method properties of an object
      // var obj = {a: function() {}}
      // It can be abbreviated
      // var obj = {a() {}}
      // var obj = { a() {}} vs var obj = { a () {}}
      // var obj = { * a() {}} vs var obj = { * a () {}}
      var peek_back_two = this._tokens.peek(-3);
      if (this._options.space_after_named_function && peek_back_two) {
        // peek starts at next character so -1 is current token
        var peek_back_three = this._tokens.peek(-4);
        if (reserved_array(peek_back_two, ['async', 'function']) ||
          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
          this._output.space_before_token = true;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
            this._output.space_before_token = true;
          }
        }
      }
    } else {
      // Support preserving wrapped arrow function expressions
      // a.b('c',
      //     () => d.e
      // )
      this.allow_wrap_or_preserved_newline(current_token);
    }

    // function() vs function ()
    // yield*() vs yield* ()
    // function*() vs function* ()
    if ((this._flags.last_token.type === TOKEN$2.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
      (this._flags.last_token.text === '*' &&
        (in_array$1(this._last_last_text, ['function', 'yield']) ||
          (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
      this._output.space_before_token = this._options.space_after_anon_function;
    }
  }

  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    this.print_newline();
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN$2.COMMA) {
    // do nothing on (( and )( and ][ and ]( and .(
    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
  }

  this.print_token(current_token);
  this.set_mode(next_mode);
  if (this._options.space_in_paren) {
    this._output.space_before_token = true;
  }

  // In all cases, if we newline while inside an expression it should be indented.
  this.indent();
};

Beautifier$5.prototype.handle_end_expr = function(current_token) {
  // statements inside expressions are not valid syntax, but...
  // statements must all be closed when their container closes
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  this.handle_whitespace_and_comments(current_token);

  if (this._flags.multiline_frame) {
    this.allow_wrap_or_preserved_newline(current_token,
      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
  }

  if (this._options.space_in_paren) {
    if (this._flags.last_token.type === TOKEN$2.START_EXPR && !this._options.space_in_empty_paren) {
      // () [] no inner space in empty parens like these, ever, ref #320
      this._output.trim();
      this._output.space_before_token = false;
    } else {
      this._output.space_before_token = true;
    }
  }
  this.deindent();
  this.print_token(current_token);
  this.restore_mode();

  remove_redundant_indentation(this._output, this._previous_flags);

  // do {} while () // no statement required after
  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
    this._previous_flags.mode = MODE.Expression;
    this._flags.do_block = false;
    this._flags.do_while = false;

  }
};

Beautifier$5.prototype.handle_start_block = function(current_token) {
  this.handle_whitespace_and_comments(current_token);

  // Check if this is should be treated as a ObjectLiteral
  var next_token = this._tokens.peek();
  var second_token = this._tokens.peek(1);
  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this.set_mode(MODE.BlockStatement);
    this._flags.in_case_statement = true;
  } else if (this._flags.case_body) {
    this.set_mode(MODE.BlockStatement);
  } else if (second_token && (
      (in_array$1(second_token.text, [':', ',']) && in_array$1(next_token.type, [TOKEN$2.STRING, TOKEN$2.WORD, TOKEN$2.RESERVED])) ||
      (in_array$1(next_token.text, ['get', 'set', '...']) && in_array$1(second_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]))
    )) {
    // We don't support TypeScript,but we didn't break it for a very long time.
    // We'll try to keep not breaking it.
    if (!in_array$1(this._last_last_text, ['class', 'interface'])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
  } else if (this._flags.last_token.type === TOKEN$2.OPERATOR && this._flags.last_token.text === '=>') {
    // arrow function: (param1, paramN) => { statements }
    this.set_mode(MODE.BlockStatement);
  } else if (in_array$1(this._flags.last_token.type, [TOKEN$2.EQUALS, TOKEN$2.START_EXPR, TOKEN$2.COMMA, TOKEN$2.OPERATOR]) ||
    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
  ) {
    // Detecting shorthand function syntax is difficult by scanning forward,
    //     so check the surrounding context.
    // If the block is being returned, imported, export default, passed as arg,
    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
    this.set_mode(MODE.ObjectLiteral);
  } else {
    this.set_mode(MODE.BlockStatement);
  }

  var empty_braces = !next_token.comments_before && next_token.text === '}';
  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
    this._flags.last_token.type === TOKEN$2.END_EXPR;

  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
  {
    // search forward for a newline wanted inside this block
    var index = 0;
    var check_token = null;
    this._flags.inline_frame = true;
    do {
      index += 1;
      check_token = this._tokens.peek(index - 1);
      if (check_token.newlines) {
        this._flags.inline_frame = false;
        break;
      }
    } while (check_token.type !== TOKEN$2.EOF &&
      !(check_token.type === TOKEN$2.END_BLOCK && check_token.opened === current_token));
  }

  if ((this._options.brace_style === "expand" ||
      (this._options.brace_style === "none" && current_token.newlines)) &&
    !this._flags.inline_frame) {
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR &&
      (empty_anonymous_function ||
        this._flags.last_token.type === TOKEN$2.EQUALS ||
        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
      this._output.space_before_token = true;
    } else {
      this.print_newline(false, true);
    }
  } else { // collapse || inline_frame
    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.COMMA)) {
      if (this._flags.last_token.type === TOKEN$2.COMMA || this._options.space_in_paren) {
        this._output.space_before_token = true;
      }

      if (this._flags.last_token.type === TOKEN$2.COMMA || (this._flags.last_token.type === TOKEN$2.START_EXPR && this._flags.inline_frame)) {
        this.allow_wrap_or_preserved_newline(current_token);
        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
        this._flags.multiline_frame = false;
      }
    }
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR && this._flags.last_token.type !== TOKEN$2.START_EXPR) {
      if (this._flags.last_token.type === TOKEN$2.START_BLOCK && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.space_before_token = true;
      }
    }
  }
  this.print_token(current_token);
  this.indent();

  // Except for specific cases, open braces are followed by a new line.
  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
    this.print_newline();
  }
};

Beautifier$5.prototype.handle_end_block = function(current_token) {
  // statements must all be closed when their container closes
  this.handle_whitespace_and_comments(current_token);

  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  var empty_braces = this._flags.last_token.type === TOKEN$2.START_BLOCK;

  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
    this._output.space_before_token = true;
  } else if (this._options.brace_style === "expand") {
    if (!empty_braces) {
      this.print_newline();
    }
  } else {
    // skip {}
    if (!empty_braces) {
      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
        // we REALLY need a newline here, but newliner would skip that
        this._options.keep_array_indentation = false;
        this.print_newline();
        this._options.keep_array_indentation = true;

      } else {
        this.print_newline();
      }
    }
  }
  this.restore_mode();
  this.print_token(current_token);
};

Beautifier$5.prototype.handle_word = function(current_token) {
  if (current_token.type === TOKEN$2.RESERVED) {
    if (in_array$1(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
      current_token.type = TOKEN$2.WORD;
    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {
      current_token.type = TOKEN$2.WORD;
    } else if (in_array$1(current_token.text, ['as', 'from']) && !this._flags.import_block) {
      current_token.type = TOKEN$2.WORD;
    } else if (this._flags.mode === MODE.ObjectLiteral) {
      var next_token = this._tokens.peek();
      if (next_token.text === ':') {
        current_token.type = TOKEN$2.WORD;
      }
    }
  }

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD) {
      this._flags.declaration_statement = true;
    }
  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
    (this._flags.last_token.type !== TOKEN$2.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
    this._flags.last_token.type !== TOKEN$2.EQUALS &&
    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
    this.handle_whitespace_and_comments(current_token);
    this.print_newline();
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.do_block && !this._flags.do_while) {
    if (reserved_word(current_token, 'while')) {
      // do {} ## while ()
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      this._flags.do_while = true;
      return;
    } else {
      // do {} should always have while as the next word.
      // if we don't see the expected while, recover
      this.print_newline();
      this._flags.do_block = false;
    }
  }

  // if may be followed by else, or not
  // Bare/inline ifs are tricky
  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
  if (this._flags.if_block) {
    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
      this._flags.else_block = true;
    } else {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this._flags.if_block = false;
      this._flags.else_block = false;
    }
  }

  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
    this.print_newline();
    if (this._flags.last_token.type !== TOKEN$2.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {
      // switch cases following one another
      this.deindent();
    }
    this._flags.case_body = false;

    this.print_token(current_token);
    this._flags.in_case = true;
    return;
  }

  if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  }

  if (reserved_word(current_token, 'function')) {
    if (in_array$1(this._flags.last_token.text, ['}', ';']) ||
      (this._output.just_added_newline() && !(in_array$1(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN$2.OPERATOR))) {
      // make sure there is a nice clean space of at least one blank line
      // before a new function definition
      if (!this._output.just_added_blankline() && !current_token.comments_before) {
        this.print_newline();
        this.print_newline(true);
      }
    }
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD) {
      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        this._output.space_before_token = true;
      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'declare') {
        // accomodates Typescript declare function formatting
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR || this._flags.last_token.text === '=') {
      // foo = function
      this._output.space_before_token = true;
    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ; else {
      this.print_newline();
    }

    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    return;
  }

  var prefix = 'NONE';

  if (this._flags.last_token.type === TOKEN$2.END_BLOCK) {

    if (this._previous_flags.inline_frame) {
      prefix = 'SPACE';
    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
      prefix = 'NEWLINE';
    } else {
      if (this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) {
        prefix = 'NEWLINE';
      } else {
        prefix = 'SPACE';
        this._output.space_before_token = true;
      }
    }
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
    // TODO: Should this be for STATEMENT as well?
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && is_expression(this._flags.mode)) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.STRING) {
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD ||
    (this._flags.last_token.text === '*' &&
      (in_array$1(this._last_last_text, ['function', 'yield']) ||
        (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    if (this._flags.inline_frame) {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this._output.space_before_token = true;
    prefix = 'NEWLINE';
  }

  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }

  }

  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
    if ((!(this._flags.last_token.type === TOKEN$2.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
        this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) &&
      !this._flags.inline_frame) {
      this.print_newline();
    } else {
      this._output.trim(true);
      var line = this._output.current_line;
      // If we trimmed and there's something other than a close block before us
      // put a newline back in.  Handles '} // comment' scenario.
      if (line.last() !== '}') {
        this.print_newline();
      }
      this._output.space_before_token = true;
    }
  } else if (prefix === 'NEWLINE') {
    if (reserved_array(this._flags.last_token, special_words)) {
      // no newline between 'return nnn'
      this._output.space_before_token = true;
    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
      // accomodates Typescript declare formatting
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type !== TOKEN$2.END_EXPR) {
      if ((this._flags.last_token.type !== TOKEN$2.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
        // no need to force newline on 'var': for (var x = 0...)
        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
          // no newline for } else if {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
      this.print_newline();
    }
  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
    this.print_newline(); // }, in lists get a newline treatment
  } else if (prefix === 'SPACE') {
    this._output.space_before_token = true;
  }
  if (current_token.previous && (current_token.previous.type === TOKEN$2.WORD || current_token.previous.type === TOKEN$2.RESERVED)) {
    this._output.space_before_token = true;
  }
  this.print_token(current_token);
  this._flags.last_word = current_token.text;

  if (current_token.type === TOKEN$2.RESERVED) {
    if (current_token.text === 'do') {
      this._flags.do_block = true;
    } else if (current_token.text === 'if') {
      this._flags.if_block = true;
    } else if (current_token.text === 'import') {
      this._flags.import_block = true;
    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
      this._flags.import_block = false;
    }
  }
};

Beautifier$5.prototype.handle_semicolon = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // Semicolon can be the start (and end) of a statement
    this._output.space_before_token = false;
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_token = this._tokens.peek();
  while (this._flags.mode === MODE.Statement &&
    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
    !this._flags.do_block) {
    this.restore_mode();
  }

  // hacky but effective for the moment
  if (this._flags.import_block) {
    this._flags.import_block = false;
  }
  this.print_token(current_token);
};

Beautifier$5.prototype.handle_string = function(current_token) {
  if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === '' && (current_token.previous.text === ')' || this._flags.last_token.type === TOKEN$2.WORD)) ; else if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // One difference - strings want at least a space before
    this._output.space_before_token = true;
  } else {
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD || this._flags.inline_frame) {
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if ((current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN$2.END_EXPR && (current_token.previous.text === ']' || current_token.previous.text === ')') && current_token.newlines === 0)) {
      this._output.space_before_token = true;
    } else {
      this.print_newline();
    }
  }
  this.print_token(current_token);
};

Beautifier$5.prototype.handle_equals = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.declaration_statement) {
    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
    this._flags.declaration_assignment = true;
  }
  this._output.space_before_token = true;
  this.print_token(current_token);
  this._output.space_before_token = true;
};

Beautifier$5.prototype.handle_comma = function(current_token) {
  this.handle_whitespace_and_comments(current_token, true);

  this.print_token(current_token);
  this._output.space_before_token = true;
  if (this._flags.declaration_statement) {
    if (is_expression(this._flags.parent.mode)) {
      // do not break on comma, for(var a = 1, b = 2)
      this._flags.declaration_assignment = false;
    }

    if (this._flags.declaration_assignment) {
      this._flags.declaration_assignment = false;
      this.print_newline(false, true);
    } else if (this._options.comma_first) {
      // for comma-first, we want to allow a newline before the comma
      // to turn into a newline after the comma, which we will fixup later
      this.allow_wrap_or_preserved_newline(current_token);
    }
  } else if (this._flags.mode === MODE.ObjectLiteral ||
    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
    if (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }

    if (!this._flags.inline_frame) {
      this.print_newline();
    }
  } else if (this._options.comma_first) {
    // EXPR or DO_BLOCK
    // for comma-first, we want to allow a newline before the comma
    // to turn into a newline after the comma, which we will fixup later
    this.allow_wrap_or_preserved_newline(current_token);
  }
};

Beautifier$5.prototype.handle_operator = function(current_token) {
  var isGeneratorAsterisk = current_token.text === '*' &&
    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
      (in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.COMMA, TOKEN$2.END_BLOCK, TOKEN$2.SEMICOLON]))
    );
  var isUnary = in_array$1(current_token.text, ['-', '+']) && (
    in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.START_EXPR, TOKEN$2.EQUALS, TOKEN$2.OPERATOR]) ||
    in_array$1(this._flags.last_token.text, line_starters) ||
    this._flags.last_token.text === ','
  );

  if (this.start_of_statement(current_token)) ; else {
    var preserve_statement_flags = !isGeneratorAsterisk;
    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    // "return" had a special handling in TK_WORD. Now we need to return the favor
    this._output.space_before_token = true;
    this.print_token(current_token);
    return;
  }

  // hack for actionscript's import .*;
  if (current_token.text === '*' && this._flags.last_token.type === TOKEN$2.DOT) {
    this.print_token(current_token);
    return;
  }

  if (current_token.text === '::') {
    // no spaces around exotic namespacing syntax operator
    this.print_token(current_token);
    return;
  }

  // Allow line wrapping between operators when operator_position is
  //   set to before or preserve
  if (this._flags.last_token.type === TOKEN$2.OPERATOR && in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
    this.allow_wrap_or_preserved_newline(current_token);
  }

  if (current_token.text === ':' && this._flags.in_case) {
    this.print_token(current_token);

    this._flags.in_case = false;
    this._flags.case_body = true;
    if (this._tokens.peek().type !== TOKEN$2.START_BLOCK) {
      this.indent();
      this.print_newline();
    } else {
      this._output.space_before_token = true;
    }
    return;
  }

  var space_before = true;
  var space_after = true;
  var in_ternary = false;
  if (current_token.text === ':') {
    if (this._flags.ternary_depth === 0) {
      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
      space_before = false;
    } else {
      this._flags.ternary_depth -= 1;
      in_ternary = true;
    }
  } else if (current_token.text === '?') {
    this._flags.ternary_depth += 1;
  }

  // let's handle the operator_position option prior to any conflicting logic
  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array$1(current_token.text, positionable_operators)) {
    var isColon = current_token.text === ':';
    var isTernaryColon = (isColon && in_ternary);
    var isOtherColon = (isColon && !in_ternary);

    switch (this._options.operator_position) {
      case OPERATOR_POSITION.before_newline:
        // if the current token is : and it's not a ternary statement then we set space_before to false
        this._output.space_before_token = !isOtherColon;

        this.print_token(current_token);

        if (!isColon || isTernaryColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.after_newline:
        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
        //   then print a newline.

        this._output.space_before_token = true;

        if (!isColon || isTernaryColon) {
          if (this._tokens.peek().newlines) {
            this.print_newline(false, true);
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else {
          this._output.space_before_token = false;
        }

        this.print_token(current_token);

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.preserve_newline:
        if (!isOtherColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        // if we just added a newline, or the current token is : and it's not a ternary statement,
        //   then we set space_before to false
        space_before = !(this._output.just_added_newline() || isOtherColon);

        this._output.space_before_token = space_before;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
    }
  }

  if (isGeneratorAsterisk) {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = false;
    var next_token = this._tokens.peek();
    space_after = next_token && in_array$1(next_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]);
  } else if (current_token.text === '...') {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = this._flags.last_token.type === TOKEN$2.START_BLOCK;
    space_after = false;
  } else if (in_array$1(current_token.text, ['--', '++', '!', '~']) || isUnary) {
    // unary operators (and binary +/- pretending to be unary) special cases
    if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR) {
      this.allow_wrap_or_preserved_newline(current_token);
    }

    space_before = false;
    space_after = false;

    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
    // if there is a newline between -- or ++ and anything else we should preserve it.
    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {
      this.print_newline(false, true);
    }

    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
      // for (;; ++i)
      //        ^^^
      space_before = true;
    }

    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      space_before = true;
    } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // a++ + ++b;
      // a - -b
      space_before = in_array$1(current_token.text, ['--', '-', '++', '+']) && in_array$1(this._flags.last_token.text, ['--', '-', '++', '+']);
      // + and - are not unary when preceeded by -- or ++ operator
      // a-- + b
      // a * +b
      // a - -b
      if (in_array$1(current_token.text, ['+', '-']) && in_array$1(this._flags.last_token.text, ['--', '++'])) {
        space_after = true;
      }
    }


    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
      // { foo; --i }
      // foo(); --bar;
      this.print_newline();
    }
  }

  this._output.space_before_token = this._output.space_before_token || space_before;
  this.print_token(current_token);
  this._output.space_before_token = space_after;
};

Beautifier$5.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    if (current_token.directives && current_token.directives.preserve === 'end') {
      // If we're testing the raw output behavior, do not allow a directive to turn it off.
      this._output.raw = this._options.test_output_raw;
    }
    return;
  }

  if (current_token.directives) {
    this.print_newline(false, preserve_statement_flags);
    this.print_token(current_token);
    if (current_token.directives.preserve === 'start') {
      this._output.raw = true;
    }
    this.print_newline(false, true);
    return;
  }

  // inline block
  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
    return;
  } else {
    this.print_block_commment(current_token, preserve_statement_flags);
  }
};

Beautifier$5.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
  var lines = split_linebreaks(current_token.text);
  var j; // iterator for this case
  var javadoc = false;
  var starless = false;
  var lastIndent = current_token.whitespace_before;
  var lastIndentLength = lastIndent.length;

  // block comment starts with a new line
  this.print_newline(false, preserve_statement_flags);

  // first line always indented
  this.print_token_line_indentation(current_token);
  this._output.add_token(lines[0]);
  this.print_newline(false, preserve_statement_flags);


  if (lines.length > 1) {
    lines = lines.slice(1);
    javadoc = all_lines_start_with(lines, '*');
    starless = each_line_matches_indent(lines, lastIndent);

    if (javadoc) {
      this._flags.alignment = 1;
    }

    for (j = 0; j < lines.length; j++) {
      if (javadoc) {
        // javadoc: reformat and re-indent
        this.print_token_line_indentation(current_token);
        this._output.add_token(ltrim(lines[j]));
      } else if (starless && lines[j]) {
        // starless: re-indent non-empty content, avoiding trim
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[j].substring(lastIndentLength));
      } else {
        // normal comments output raw
        this._output.current_line.set_indent(-1);
        this._output.add_token(lines[j]);
      }

      // for comments on their own line or  more than one line, make sure there's a new line after
      this.print_newline(false, preserve_statement_flags);
    }

    this._flags.alignment = 0;
  }
};


Beautifier$5.prototype.handle_comment = function(current_token, preserve_statement_flags) {
  if (current_token.newlines) {
    this.print_newline(false, preserve_statement_flags);
  } else {
    this._output.trim(true);
  }

  this._output.space_before_token = true;
  this.print_token(current_token);
  this.print_newline(false, preserve_statement_flags);
};

Beautifier$5.prototype.handle_dot = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token, true);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    this._output.space_before_token = false;
  } else {
    // allow preserved newlines before dots in general
    // force newlines on dots after close paren when break_chained - for bar().baz()
    this.allow_wrap_or_preserved_newline(current_token,
      this._flags.last_token.text === ')' && this._options.break_chained_methods);
  }

  // Only unindent chained method dot if this dot starts a new line.
  // Otherwise the automatic extra indentation removal will handle the over indent
  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
    this.deindent();
  }

  this.print_token(current_token);
};

Beautifier$5.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
  this.print_token(current_token);

  if (current_token.text[current_token.text.length - 1] === '\n') {
    this.print_newline(false, preserve_statement_flags);
  }
};

Beautifier$5.prototype.handle_eof = function(current_token) {
  // Unwind any open statements
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }
  this.handle_whitespace_and_comments(current_token);
};

beautifier$2.Beautifier = Beautifier$5;

/*jshint node:true */

var Beautifier$4 = beautifier$2.Beautifier,
  Options$6 = options$3.Options;

function js_beautify$1(js_source_text, options) {
  var beautifier = new Beautifier$4(js_source_text, options);
  return beautifier.beautify();
}

javascript.exports = js_beautify$1;
javascript.exports.defaultOptions = function() {
  return new Options$6();
};

var css$1 = {exports: {}};

var beautifier$1 = {};

var options$1 = {};

/*jshint node:true */

var BaseOptions$1 = options$2.Options;

function Options$5(options) {
  BaseOptions$1.call(this, options, 'css');

  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
  this.brace_style = 'collapse';
  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] !== 'expand') {
      // default to collapse, as only collapse|expand is implemented for now
      this.brace_style = 'collapse';
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }
}
Options$5.prototype = new BaseOptions$1();



options$1.Options = Options$5;

/*jshint node:true */

var Options$4 = options$1.Options;
var Output$1 = output.Output;
var InputScanner = inputscanner.InputScanner;
var Directives$1 = directives.Directives;

var directives_core$1 = new Directives$1(/\/\*/, /\*\//);

var lineBreak$1 = /\r\n|[\r\n]/;
var allLineBreaks$1 = /\r\n|[\r\n]/g;

// tokenizer
var whitespaceChar = /\s/;
var whitespacePattern = /(?:\s|\n)+/g;
var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

function Beautifier$3(source_text, options) {
  this._source_text = source_text || '';
  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  this._options = new Options$4(options);
  this._ch = null;
  this._input = null;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
  this.NESTED_AT_RULE = {
    "@page": true,
    "@font-face": true,
    "@keyframes": true,
    // also in CONDITIONAL_GROUP_RULE below
    "@media": true,
    "@supports": true,
    "@document": true
  };
  this.CONDITIONAL_GROUP_RULE = {
    "@media": true,
    "@supports": true,
    "@document": true
  };

}

Beautifier$3.prototype.eatString = function(endChars) {
  var result = '';
  this._ch = this._input.next();
  while (this._ch) {
    result += this._ch;
    if (this._ch === "\\") {
      result += this._input.next();
    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
      break;
    }
    this._ch = this._input.next();
  }
  return result;
};

// Skips any white space in the source text from the current position.
// When allowAtLeastOneNewLine is true, will output new lines for each
// newline character found; if the user has preserve_newlines off, only
// the first newline will be output
Beautifier$3.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
  var result = whitespaceChar.test(this._input.peek());
  var newline_count = 0;
  while (whitespaceChar.test(this._input.peek())) {
    this._ch = this._input.next();
    if (allowAtLeastOneNewLine && this._ch === '\n') {
      if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
        newline_count++;
        this._output.add_new_line(true);
      }
    }
  }
  return result;
};

// Nested pseudo-class if we are insideRule
// and the next special character found opens
// a new block
Beautifier$3.prototype.foundNestedPseudoClass = function() {
  var openParen = 0;
  var i = 1;
  var ch = this._input.peek(i);
  while (ch) {
    if (ch === "{") {
      return true;
    } else if (ch === '(') {
      // pseudoclasses can contain ()
      openParen += 1;
    } else if (ch === ')') {
      if (openParen === 0) {
        return false;
      }
      openParen -= 1;
    } else if (ch === ";" || ch === "}") {
      return false;
    }
    i++;
    ch = this._input.peek(i);
  }
  return false;
};

Beautifier$3.prototype.print_string = function(output_string) {
  this._output.set_indent(this._indentLevel);
  this._output.non_breaking_space = true;
  this._output.add_token(output_string);
};

Beautifier$3.prototype.preserveSingleSpace = function(isAfterSpace) {
  if (isAfterSpace) {
    this._output.space_before_token = true;
  }
};

Beautifier$3.prototype.indent = function() {
  this._indentLevel++;
};

Beautifier$3.prototype.outdent = function() {
  if (this._indentLevel > 0) {
    this._indentLevel--;
  }
};

/*_____________________--------------------_____________________*/

Beautifier$3.prototype.beautify = function() {
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak$1.test(source_text || '')) {
      eol = source_text.match(lineBreak$1)[0];
    }
  }


  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
  source_text = source_text.replace(allLineBreaks$1, '\n');

  // reset
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._output = new Output$1(this._options, baseIndentString);
  this._input = new InputScanner(source_text);
  this._indentLevel = 0;
  this._nestedLevel = 0;

  this._ch = null;
  var parenLevel = 0;

  var insideRule = false;
  // This is the value side of a property value pair (blue in the following ex)
  // label { content: blue }
  var insidePropertyValue = false;
  var enteringConditionalGroup = false;
  var insideAtExtend = false;
  var insideAtImport = false;
  var topCharacter = this._ch;
  var whitespace;
  var isAfterSpace;
  var previous_ch;

  while (true) {
    whitespace = this._input.read(whitespacePattern);
    isAfterSpace = whitespace !== '';
    previous_ch = topCharacter;
    this._ch = this._input.next();
    if (this._ch === '\\' && this._input.hasNext()) {
      this._ch += this._input.next();
    }
    topCharacter = this._ch;

    if (!this._ch) {
      break;
    } else if (this._ch === '/' && this._input.peek() === '*') {
      // /* css comment */
      // Always start block comments on a new line.
      // This handles scenarios where a block comment immediately
      // follows a property definition on the same line or where
      // minified code is being beautified.
      this._output.add_new_line();
      this._input.back();

      var comment = this._input.read(block_comment_pattern);

      // Handle ignore directive
      var directives = directives_core$1.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core$1.readIgnored(this._input);
      }

      this.print_string(comment);

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);

      // Block comments are followed by a new line so they don't
      // share a line with other properties
      this._output.add_new_line();
    } else if (this._ch === '/' && this._input.peek() === '/') {
      // // single line comment
      // Preserves the space before a comment
      // on the same line as a rule
      this._output.space_before_token = true;
      this._input.back();
      this.print_string(this._input.read(comment_pattern));

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);
    } else if (this._ch === '@') {
      this.preserveSingleSpace(isAfterSpace);

      // deal with less propery mixins @{...}
      if (this._input.peek() === '{') {
        this.print_string(this._ch + this.eatString('}'));
      } else {
        this.print_string(this._ch);

        // strip trailing space, if present, for hash property checks
        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

        if (variableOrRule.match(/[ :]$/)) {
          // we have a variable or pseudo-class, add it and insert one space before continuing
          variableOrRule = this.eatString(": ").replace(/\s$/, '');
          this.print_string(variableOrRule);
          this._output.space_before_token = true;
        }

        variableOrRule = variableOrRule.replace(/\s$/, '');

        if (variableOrRule === 'extend') {
          insideAtExtend = true;
        } else if (variableOrRule === 'import') {
          insideAtImport = true;
        }

        // might be a nesting at-rule
        if (variableOrRule in this.NESTED_AT_RULE) {
          this._nestedLevel += 1;
          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
            enteringConditionalGroup = true;
          }
          // might be less variable
        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      }
    } else if (this._ch === '#' && this._input.peek() === '{') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString('}'));
    } else if (this._ch === '{') {
      if (insidePropertyValue) {
        insidePropertyValue = false;
        this.outdent();
      }

      // when entering conditional groups, only rulesets are allowed
      if (enteringConditionalGroup) {
        enteringConditionalGroup = false;
        insideRule = (this._indentLevel >= this._nestedLevel);
      } else {
        // otherwise, declarations are also allowed
        insideRule = (this._indentLevel >= this._nestedLevel - 1);
      }
      if (this._options.newline_between_rules && insideRule) {
        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
          this._output.ensure_empty_line_above('/', ',');
        }
      }

      this._output.space_before_token = true;

      // The difference in print_string and indent order is necessary to indent the '{' correctly
      if (this._options.brace_style === 'expand') {
        this._output.add_new_line();
        this.print_string(this._ch);
        this.indent();
        this._output.set_indent(this._indentLevel);
      } else {
        this.indent();
        this.print_string(this._ch);
      }

      this.eatWhitespace(true);
      this._output.add_new_line();
    } else if (this._ch === '}') {
      this.outdent();
      this._output.add_new_line();
      if (previous_ch === '{') {
        this._output.trim(true);
      }
      insideAtImport = false;
      insideAtExtend = false;
      if (insidePropertyValue) {
        this.outdent();
        insidePropertyValue = false;
      }
      this.print_string(this._ch);
      insideRule = false;
      if (this._nestedLevel) {
        this._nestedLevel--;
      }

      this.eatWhitespace(true);
      this._output.add_new_line();

      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
        if (this._input.peek() !== '}') {
          this._output.add_new_line(true);
        }
      }
    } else if (this._ch === ":") {
      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
        // 'property: value' delimiter
        // which could be in a conditional group query
        this.print_string(':');
        if (!insidePropertyValue) {
          insidePropertyValue = true;
          this._output.space_before_token = true;
          this.eatWhitespace(true);
          this.indent();
        }
      } else {
        // sass/less parent reference don't use a space
        // sass nested pseudo-class don't use a space

        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
        if (this._input.lookBack(" ")) {
          this._output.space_before_token = true;
        }
        if (this._input.peek() === ":") {
          // pseudo-element
          this._ch = this._input.next();
          this.print_string("::");
        } else {
          // pseudo-class
          this.print_string(':');
        }
      }
    } else if (this._ch === '"' || this._ch === '\'') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString(this._ch));
      this.eatWhitespace(true);
    } else if (this._ch === ';') {
      if (parenLevel === 0) {
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        insideAtExtend = false;
        insideAtImport = false;
        this.print_string(this._ch);
        this.eatWhitespace(true);

        // This maintains single line comments on the same
        // line. Block comments are also affected, but
        // a new line is always output before one inside
        // that section
        if (this._input.peek() !== '/') {
          this._output.add_new_line();
        }
      } else {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        this._output.space_before_token = true;
      }
    } else if (this._ch === '(') { // may be a url
      if (this._input.lookBack("url")) {
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
        this._ch = this._input.next();
        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
          this._input.back();
        } else if (this._ch) {
          this.print_string(this._ch + this.eatString(')'));
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
        }
      } else {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
      }
    } else if (this._ch === ')') {
      if (parenLevel) {
        parenLevel--;
        this.outdent();
      }
      this.print_string(this._ch);
    } else if (this._ch === ',') {
      this.print_string(this._ch);
      this.eatWhitespace(true);
      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport && !insideAtExtend) {
        this._output.add_new_line();
      } else {
        this._output.space_before_token = true;
      }
    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
      //handle combinator spacing
      if (this._options.space_around_combinator) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
        this._output.space_before_token = true;
      } else {
        this.print_string(this._ch);
        this.eatWhitespace();
        // squash extra whitespace
        if (this._ch && whitespaceChar.test(this._ch)) {
          this._ch = '';
        }
      }
    } else if (this._ch === ']') {
      this.print_string(this._ch);
    } else if (this._ch === '[') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    } else if (this._ch === '=') { // no whitespace before or after
      this.eatWhitespace();
      this.print_string('=');
      if (whitespaceChar.test(this._ch)) {
        this._ch = '';
      }
    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
      this.print_string(' ');
      this.print_string(this._ch);
    } else {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    }
  }

  var sweetCode = this._output.get_code(eol);

  return sweetCode;
};

beautifier$1.Beautifier = Beautifier$3;

/*jshint node:true */

var Beautifier$2 = beautifier$1.Beautifier,
  Options$3 = options$1.Options;

function css_beautify$1(source_text, options) {
  var beautifier = new Beautifier$2(source_text, options);
  return beautifier.beautify();
}

css$1.exports = css_beautify$1;
css$1.exports.defaultOptions = function() {
  return new Options$3();
};

var html = {exports: {}};

var beautifier = {};

var options = {};

/*jshint node:true */

var BaseOptions = options$2.Options;

function Options$2(options) {
  BaseOptions.call(this, options, 'html');
  if (this.templating.length === 1 && this.templating[0] === 'auto') {
    this.templating = ['django', 'erb', 'handlebars', 'php'];
  }

  this.indent_inner_html = this._get_boolean('indent_inner_html');
  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
  this.wrap_attributes = this._get_selection('wrap_attributes',
    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

  // Block vs inline elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
  // https://www.w3.org/TR/html5/dom.html#phrasing-content
  this.inline = this._get_array('inline', [
    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
    'video', 'wbr', 'text',
    // obsolete inline tags
    'acronym', 'big', 'strike', 'tt'
  ]);
  this.void_elements = this._get_array('void_elements', [
    // HTLM void elements - aka self-closing tags - aka singletons
    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
    // NOTE: Optional tags are too complex for a simple list
    // they are hard coded in _do_optional_end_element

    // Doctype and xml elements
    '!doctype', '?xml',

    // obsolete tags
    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
    'basefont', 'isindex'
  ]);
  this.unformatted = this._get_array('unformatted', []);
  this.content_unformatted = this._get_array('content_unformatted', [
    'pre', 'textarea'
  ]);
  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

}
Options$2.prototype = new BaseOptions();



options.Options = Options$2;

var tokenizer = {};

/*jshint node:true */

var BaseTokenizer = tokenizer$1.Tokenizer;
var BASETOKEN = tokenizer$1.TOKEN;
var Directives = directives.Directives;
var TemplatablePattern = templatablepattern.TemplatablePattern;
var Pattern = pattern.Pattern;

var TOKEN$1 = {
  TAG_OPEN: 'TK_TAG_OPEN',
  TAG_CLOSE: 'TK_TAG_CLOSE',
  ATTRIBUTE: 'TK_ATTRIBUTE',
  EQUALS: 'TK_EQUALS',
  VALUE: 'TK_VALUE',
  COMMENT: 'TK_COMMENT',
  TEXT: 'TK_TEXT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};

var directives_core = new Directives(/<\!--/, /-->/);

var Tokenizer$1 = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);
  this._current_tag_name = '';

  // Words end at whitespace or when a tag starts
  // if we are indenting handlebars, they are considered tags
  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
  var pattern_reader = new Pattern(this._input);

  this.__patterns = {
    word: templatable_reader.until(/[\n\r\t <]/),
    single_quote: templatable_reader.until_after(/'/),
    double_quote: templatable_reader.until_after(/"/),
    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
    element_name: templatable_reader.until(/[\n\r\t >\/]/),

    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
    handlebars_raw_close: pattern_reader.until(/}}/),
    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
    // https://en.wikipedia.org/wiki/Conditional_comment
    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
  };

  if (this._options.indent_handlebars) {
    this.__patterns.word = this.__patterns.word.exclude('handlebars');
  }

  this._unformatted_content_delimiter = null;

  if (this._options.unformatted_content_delimiter) {
    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
    this.__patterns.unformatted_content_delimiter =
      pattern_reader.matching(literal_regexp)
      .until_after(literal_regexp);
  }
};
Tokenizer$1.prototype = new BaseTokenizer();

Tokenizer$1.prototype._is_comment = function(current_token) { // jshint unused:false
  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer$1.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$1.TAG_OPEN;
};

Tokenizer$1.prototype._is_closing = function(current_token, open_token) {
  return current_token.type === TOKEN$1.TAG_CLOSE &&
    (open_token && (
      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));
};

Tokenizer$1.prototype._reset = function() {
  this._current_tag_name = '';
};

Tokenizer$1.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$1.EOF, '');
  }

  token = token || this._read_open_handlebars(c, open_token);
  token = token || this._read_attribute(c, previous_token, open_token);
  token = token || this._read_close(c, open_token);
  token = token || this._read_raw_content(c, previous_token, open_token);
  token = token || this._read_content_word(c);
  token = token || this._read_comment_or_cdata(c);
  token = token || this._read_processing(c);
  token = token || this._read_open(c, open_token);
  token = token || this._create_token(TOKEN$1.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$1.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    // We treat all comments as literals, even more than preformatted tags
    // we only look for the appropriate closing marker
    if (peek1 === '!') {
      resulting_string = this.__patterns.comment.read();

      // only process directive on html comments
      if (resulting_string) {
        directives = directives_core.get_directives(resulting_string);
        if (directives && directives.ignore === 'start') {
          resulting_string += directives_core.readIgnored(this._input);
        }
      } else {
        resulting_string = this.__patterns.cdata.read();
      }
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$1.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$1.prototype._read_processing = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    if (peek1 === '!' || peek1 === '?') {
      resulting_string = this.__patterns.conditional_comment.read();
      resulting_string = resulting_string || this.__patterns.processing.read();
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$1.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$1.prototype._read_open = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (c === '<') {

      resulting_string = this._input.next();
      if (this._input.peek() === '/') {
        resulting_string += this._input.next();
      }
      resulting_string += this.__patterns.element_name.read();
      token = this._create_token(TOKEN$1.TAG_OPEN, resulting_string);
    }
  }
  return token;
};

Tokenizer$1.prototype._read_open_handlebars = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {
      if (this._input.peek(2) === '!') {
        resulting_string = this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
        token = this._create_token(TOKEN$1.COMMENT, resulting_string);
      } else {
        resulting_string = this.__patterns.handlebars_open.read();
        token = this._create_token(TOKEN$1.TAG_OPEN, resulting_string);
      }
    }
  }
  return token;
};


Tokenizer$1.prototype._read_close = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (open_token) {
    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
      resulting_string = this._input.next();
      if (c === '/') { //  for close tag "/>"
        resulting_string += this._input.next();
      }
      token = this._create_token(TOKEN$1.TAG_CLOSE, resulting_string);
    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
      this._input.next();
      this._input.next();
      token = this._create_token(TOKEN$1.TAG_CLOSE, '}}');
    }
  }

  return token;
};

Tokenizer$1.prototype._read_attribute = function(c, previous_token, open_token) {
  var token = null;
  var resulting_string = '';
  if (open_token && open_token.text[0] === '<') {

    if (c === '=') {
      token = this._create_token(TOKEN$1.EQUALS, this._input.next());
    } else if (c === '"' || c === "'") {
      var content = this._input.next();
      if (c === '"') {
        content += this.__patterns.double_quote.read();
      } else {
        content += this.__patterns.single_quote.read();
      }
      token = this._create_token(TOKEN$1.VALUE, content);
    } else {
      resulting_string = this.__patterns.attribute.read();

      if (resulting_string) {
        if (previous_token.type === TOKEN$1.EQUALS) {
          token = this._create_token(TOKEN$1.VALUE, resulting_string);
        } else {
          token = this._create_token(TOKEN$1.ATTRIBUTE, resulting_string);
        }
      }
    }
  }
  return token;
};

Tokenizer$1.prototype._is_content_unformatted = function(tag_name) {
  // void_elements have no content and so cannot have unformatted content
  // script and style tags should always be read as unformatted content
  // finally content_unformatted and unformatted element contents are unformatted
  return this._options.void_elements.indexOf(tag_name) === -1 &&
    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
      this._options.unformatted.indexOf(tag_name) !== -1);
};


Tokenizer$1.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
  var resulting_string = '';
  if (open_token && open_token.text[0] === '{') {
    resulting_string = this.__patterns.handlebars_raw_close.read();
  } else if (previous_token.type === TOKEN$1.TAG_CLOSE &&
    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
    // ^^ empty tag has no content 
    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
    if (tag_name === 'script' || tag_name === 'style') {
      // Script and style tags are allowed to have comments wrapping their content
      // or just have regular content.
      var token = this._read_comment_or_cdata(c);
      if (token) {
        token.type = TOKEN$1.TEXT;
        return token;
      }
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    } else if (this._is_content_unformatted(tag_name)) {

      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    }
  }

  if (resulting_string) {
    return this._create_token(TOKEN$1.TEXT, resulting_string);
  }

  return null;
};

Tokenizer$1.prototype._read_content_word = function(c) {
  var resulting_string = '';
  if (this._options.unformatted_content_delimiter) {
    if (c === this._options.unformatted_content_delimiter[0]) {
      resulting_string = this.__patterns.unformatted_content_delimiter.read();
    }
  }

  if (!resulting_string) {
    resulting_string = this.__patterns.word.read();
  }
  if (resulting_string) {
    return this._create_token(TOKEN$1.TEXT, resulting_string);
  }
};

tokenizer.Tokenizer = Tokenizer$1;
tokenizer.TOKEN = TOKEN$1;

/*jshint node:true */

var Options$1 = options.Options;
var Output = output.Output;
var Tokenizer = tokenizer.Tokenizer;
var TOKEN = tokenizer.TOKEN;

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

  this.indent_level = 0;
  this.alignment_size = 0;
  this.max_preserve_newlines = options.max_preserve_newlines;
  this.preserve_newlines = options.preserve_newlines;

  this._output = new Output(options, base_indent_string);

};

Printer.prototype.current_line_has_match = function(pattern) {
  return this._output.current_line.has_match(pattern);
};

Printer.prototype.set_space_before_token = function(value, non_breaking) {
  this._output.space_before_token = value;
  this._output.non_breaking_space = non_breaking;
};

Printer.prototype.set_wrap_point = function() {
  this._output.set_indent(this.indent_level, this.alignment_size);
  this._output.set_wrap_point();
};


Printer.prototype.add_raw_token = function(token) {
  this._output.add_raw_token(token);
};

Printer.prototype.print_preserved_newlines = function(raw_token) {
  var newlines = 0;
  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
    newlines = raw_token.newlines ? 1 : 0;
  }

  if (this.preserve_newlines) {
    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
  }
  for (var n = 0; n < newlines; n++) {
    this.print_newline(n > 0);
  }

  return newlines !== 0;
};

Printer.prototype.traverse_whitespace = function(raw_token) {
  if (raw_token.whitespace_before || raw_token.newlines) {
    if (!this.print_preserved_newlines(raw_token)) {
      this._output.space_before_token = true;
    }
    return true;
  }
  return false;
};

Printer.prototype.previous_token_wrapped = function() {
  return this._output.previous_token_wrapped;
};

Printer.prototype.print_newline = function(force) {
  this._output.add_new_line(force);
};

Printer.prototype.print_token = function(token) {
  if (token.text) {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.add_token(token.text);
  }
};

Printer.prototype.indent = function() {
  this.indent_level++;
};

Printer.prototype.get_full_indent = function(level) {
  level = this.indent_level + (level || 0);
  if (level < 1) {
    return '';
  }

  return this._output.get_indent_string(level);
};

var get_type_attribute = function(start_token) {
  var result = null;
  var raw_token = start_token.next;

  // Search attributes for a type attribute
  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {
      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&
        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
        result = raw_token.next.next.text;
      }
      break;
    }
    raw_token = raw_token.next;
  }

  return result;
};

var get_custom_beautifier_name = function(tag_check, raw_token) {
  var typeAttribute = null;
  var result = null;

  if (!raw_token.closed) {
    return null;
  }

  if (tag_check === 'script') {
    typeAttribute = 'text/javascript';
  } else if (tag_check === 'style') {
    typeAttribute = 'text/css';
  }

  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
  // For those without a type attribute use default;
  if (typeAttribute.search('text/css') > -1) {
    result = 'css';
  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
    result = 'javascript';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
    result = 'html';
  } else if (typeAttribute.search(/test\/null/) > -1) {
    // Test only mime-type for testing the beautifier when null is passed as beautifing function
    result = 'null';
  }

  return result;
};

function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}

function TagFrame(parent, parser_token, indent_level) {
  this.parent = parent || null;
  this.tag = parser_token ? parser_token.tag_name : '';
  this.indent_level = indent_level || 0;
  this.parser_token = parser_token || null;
}

function TagStack(printer) {
  this._printer = printer;
  this._current_frame = null;
}

TagStack.prototype.get_parser_token = function() {
  return this._current_frame ? this._current_frame.parser_token : null;
};

TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
  this._current_frame = new_frame;
};

TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
  var parser_token = null;

  if (frame) {
    parser_token = frame.parser_token;
    this._printer.indent_level = frame.indent_level;
    this._current_frame = frame.parent;
  }

  return parser_token;
};

TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._current_frame;

  while (frame) { //till we reach '' (the initial value);
    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
      break;
    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
      frame = null;
      break;
    }
    frame = frame.parent;
  }

  return frame;
};

TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._get_frame([tag], stop_list);
  return this._try_pop_frame(frame);
};

TagStack.prototype.indent_to_tag = function(tag_list) {
  var frame = this._get_frame(tag_list);
  if (frame) {
    this._printer.indent_level = frame.indent_level;
  }
};

function Beautifier$1(source_text, options, js_beautify, css_beautify) {
  //Wrapper function to invoke all the necessary constructors and deal with the output.
  this._source_text = source_text || '';
  options = options || {};
  this._js_beautify = js_beautify;
  this._css_beautify = css_beautify;
  this._tag_stack = null;

  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  var optionHtml = new Options$1(options, 'html');

  this._options = optionHtml;

  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
}

Beautifier$1.prototype.beautify = function() {

  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text)) {
      eol = source_text.match(lineBreak)[0];
    }
  }

  // HACK: newline parsing inconsistent. This brute force normalizes the input.
  source_text = source_text.replace(allLineBreaks, '\n');

  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  var last_token = {
    text: '',
    type: ''
  };

  var last_tag_token = new TagOpenParserToken();

  var printer = new Printer(this._options, baseIndentString);
  var tokens = new Tokenizer(source_text, this._options).tokenize();

  this._tag_stack = new TagStack(printer);

  var parser_token = null;
  var raw_token = tokens.next();
  while (raw_token.type !== TOKEN.EOF) {

    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
      last_tag_token = parser_token;
    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||
      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {
      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
    } else if (raw_token.type === TOKEN.TAG_CLOSE) {
      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
    } else if (raw_token.type === TOKEN.TEXT) {
      parser_token = this._handle_text(printer, raw_token, last_tag_token);
    } else {
      // This should never happen, but if it does. Print the raw token
      printer.add_raw_token(raw_token);
    }

    last_token = parser_token;

    raw_token = tokens.next();
  }
  var sweet_code = printer._output.get_code(eol);

  return sweet_code;
};

Beautifier$1.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };
  printer.alignment_size = 0;
  last_tag_token.tag_complete = true;

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    if (last_tag_token.tag_start_char === '<') {
      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
        printer.print_newline(false);
      }
    }
    printer.print_token(raw_token);

  }

  if (last_tag_token.indent_content &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.indent();

    // only indent once per opened tag
    last_tag_token.indent_content = false;
  }

  if (!last_tag_token.is_inline_element &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.set_wrap_point();
  }

  return parser_token;
};

Beautifier$1.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
  var wrapped = last_tag_token.has_wrapped_attrs;
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {
    // For the insides of handlebars allow newlines or a single space between open and contents
    if (printer.print_preserved_newlines(raw_token)) {
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
    } else {
      printer.print_token(raw_token);
    }
  } else {
    if (raw_token.type === TOKEN.ATTRIBUTE) {
      printer.set_space_before_token(true);
      last_tag_token.attr_count += 1;
    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =
      printer.set_space_before_token(false);
    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value
      printer.set_space_before_token(false);
    }

    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
        printer.traverse_whitespace(raw_token);
        wrapped = wrapped || raw_token.newlines !== 0;
      }


      if (this._is_wrap_attributes_force) {
        var force_attr_wrap = last_tag_token.attr_count > 1;
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
          var is_only_attribute = true;
          var peek_index = 0;
          var peek_token;
          do {
            peek_token = tokens.peek(peek_index);
            if (peek_token.type === TOKEN.ATTRIBUTE) {
              is_only_attribute = false;
              break;
            }
            peek_index += 1;
          } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);

          force_attr_wrap = !is_only_attribute;
        }

        if (force_attr_wrap) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
    }
    printer.print_token(raw_token);
    wrapped = wrapped || printer.previous_token_wrapped();
    last_tag_token.has_wrapped_attrs = wrapped;
  }
  return parser_token;
};

Beautifier$1.prototype._handle_text = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: 'TK_CONTENT'
  };
  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    printer.print_token(raw_token);
  }
  return parser_token;
};

Beautifier$1.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
  var local = this;
  if (raw_token.text !== '') {

    var text = raw_token.text,
      _beautifier,
      script_indent_level = 1,
      pre = '',
      post = '';
    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
      _beautifier = this._js_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
      _beautifier = this._css_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'html') {
      _beautifier = function(html_source, options) {
        var beautifier = new Beautifier$1(html_source, options, local._js_beautify, local._css_beautify);
        return beautifier.beautify();
      };
    }

    if (this._options.indent_scripts === "keep") {
      script_indent_level = 0;
    } else if (this._options.indent_scripts === "separate") {
      script_indent_level = -printer.indent_level;
    }

    var indentation = printer.get_full_indent(script_indent_level);

    // if there is at least one empty line at the end of this text, strip it
    // we'll be adding one back after the text but before the containing tag.
    text = text.replace(/\n[ \t]*$/, '');

    // Handle the case where content is wrapped in a comment or cdata.
    if (last_tag_token.custom_beautifier_name !== 'html' &&
      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

      // if we start to wrap but don't finish, print raw
      if (!matched) {
        printer.add_raw_token(raw_token);
        return;
      }

      pre = indentation + matched[1] + '\n';
      text = matched[4];
      if (matched[5]) {
        post = indentation + matched[5];
      }

      // if there is at least one empty line at the end of this text, strip it
      // we'll be adding one back after the text but before the containing tag.
      text = text.replace(/\n[ \t]*$/, '');

      if (matched[2] || matched[3].indexOf('\n') !== -1) {
        // if the first line of the non-comment text has spaces
        // use that as the basis for indenting in null case.
        matched = matched[3].match(/[ \t]+$/);
        if (matched) {
          raw_token.whitespace_before = matched[0];
        }
      }
    }

    if (text) {
      if (_beautifier) {

        // call the Beautifier if avaliable
        var Child_options = function() {
          this.eol = '\n';
        };
        Child_options.prototype = this._options.raw_options;
        var child_options = new Child_options();
        text = _beautifier(indentation + text, child_options);
      } else {
        // simply indent the string otherwise
        var white = raw_token.whitespace_before;
        if (white) {
          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
        }

        text = indentation + text.replace(/\n/g, '\n' + indentation);
      }
    }

    if (pre) {
      if (!text) {
        text = pre + post;
      } else {
        text = pre + text + '\n' + post;
      }
    }

    printer.print_newline(false);
    if (text) {
      raw_token.text = text;
      raw_token.whitespace_before = '';
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
      printer.print_newline(true);
    }
  }
};

Beautifier$1.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
  var parser_token = this._get_tag_open_token(raw_token);

  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
    !last_tag_token.is_empty_element &&
    raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf('</') === 0) {
    // End element tags for unformatted or content_unformatted elements
    // are printed raw to keep any newlines inside them exactly the same.
    printer.add_raw_token(raw_token);
    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
  } else {
    printer.traverse_whitespace(raw_token);
    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
    if (!parser_token.is_inline_element) {
      printer.set_wrap_point();
    }
    printer.print_token(raw_token);
  }

  //indent attributes an auto, forced, aligned or forced-align line-wrap
  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
    parser_token.alignment_size = raw_token.text.length + 1;
  }

  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
    printer.alignment_size = parser_token.alignment_size;
  }

  return parser_token;
};

var TagOpenParserToken = function(parent, raw_token) {
  this.parent = parent || null;
  this.text = '';
  this.type = 'TK_TAG_OPEN';
  this.tag_name = '';
  this.is_inline_element = false;
  this.is_unformatted = false;
  this.is_content_unformatted = false;
  this.is_empty_element = false;
  this.is_start_tag = false;
  this.is_end_tag = false;
  this.indent_content = false;
  this.multiline_content = false;
  this.custom_beautifier_name = null;
  this.start_tag_token = null;
  this.attr_count = 0;
  this.has_wrapped_attrs = false;
  this.alignment_size = 0;
  this.tag_complete = false;
  this.tag_start_char = '';
  this.tag_check = '';

  if (!raw_token) {
    this.tag_complete = true;
  } else {
    var tag_check_match;

    this.tag_start_char = raw_token.text[0];
    this.text = raw_token.text;

    if (this.tag_start_char === '<') {
      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    } else {
      tag_check_match = raw_token.text.match(/^{{(?:[\^]|#\*?)?([^\s}]+)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';

      // handle "{{#> myPartial}}
      if (raw_token.text === '{{#>' && this.tag_check === '>' && raw_token.next !== null) {
        this.tag_check = raw_token.next.text;
      }
    }
    this.tag_check = this.tag_check.toLowerCase();

    if (raw_token.type === TOKEN.COMMENT) {
      this.tag_complete = true;
    }

    this.is_start_tag = this.tag_check.charAt(0) !== '/';
    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
    this.is_end_tag = !this.is_start_tag ||
      (raw_token.closed && raw_token.closed.text === '/>');

    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
    this.is_end_tag = this.is_end_tag ||
      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(2)))));
  }
};

Beautifier$1.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);

  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

  parser_token.is_end_tag = parser_token.is_end_tag ||
    in_array(parser_token.tag_check, this._options.void_elements);

  parser_token.is_empty_element = parser_token.tag_complete ||
    (parser_token.is_start_tag && parser_token.is_end_tag);

  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';

  return parser_token;
};

Beautifier$1.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

  if (!parser_token.is_empty_element) {
    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
    } else { // it's a start-tag
      // check if this tag is starting an element that has optional end element
      // and do an ending needed
      if (this._do_optional_end_element(parser_token)) {
        if (!parser_token.is_inline_element) {
          printer.print_newline(false);
        }
      }

      this._tag_stack.record_tag(parser_token); //push it on the tag stack

      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
      }
    }
  }

  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
    printer.print_newline(false);
    if (!printer._output.just_added_blankline()) {
      printer.print_newline(true);
    }
  }

  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

    // if you hit an else case, reset the indent level if you are inside an:
    // 'if', 'unless', or 'each' block.
    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
      parser_token.indent_content = true;
      // Don't add a newline if opening {{#if}} tag is on the current line
      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
      if (!foundIfOnCurrentLine) {
        printer.print_newline(false);
      }
    }

    // Don't add a newline before elements that should remain where they are.
    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&
      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) ; else {
      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
    var do_end_expand = false;

    // deciding whether a block is multiline should not be this hard
    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
      !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
      last_token.type !== 'TK_CONTENT'
    );

    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
      do_end_expand = false;
    }

    if (do_end_expand) {
      printer.print_newline(false);
    }
  } else { // it's a start-tag
    parser_token.indent_content = !parser_token.custom_beautifier_name;

    if (parser_token.tag_start_char === '<') {
      if (parser_token.tag_name === 'html') {
        parser_token.indent_content = this._options.indent_inner_html;
      } else if (parser_token.tag_name === 'head') {
        parser_token.indent_content = this._options.indent_head_inner_html;
      } else if (parser_token.tag_name === 'body') {
        parser_token.indent_content = this._options.indent_body_inner_html;
      }
    }

    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
      printer.print_newline(false);
    }

    this._calcluate_parent_multiline(printer, parser_token);
  }
};

Beautifier$1.prototype._calcluate_parent_multiline = function(printer, parser_token) {
  if (parser_token.parent && printer._output.just_added_newline() &&
    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
    parser_token.parent.multiline_content = true;
  }
};

//To be used for <p> tag special case:
var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

Beautifier$1.prototype._do_optional_end_element = function(parser_token) {
  var result = null;
  // NOTE: cases of "if there is no more content in the parent element"
  // are handled automatically by the beautifier.
  // It assumes parent or ancestor close tag closes all children.
  // https://www.w3.org/TR/html5/syntax.html#optional-tags
  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
    return;

  }

  if (parser_token.tag_name === 'body') {
    // A head elements end tag may be omitted if the head element is not immediately followed by a space character or a comment.
    result = result || this._tag_stack.try_pop('head');

    //} else if (parser_token.tag_name === 'body') {
    // DONE: A body elements end tag may be omitted if the body element is not immediately followed by a comment.

  } else if (parser_token.tag_name === 'li') {
    // An li elements end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);

  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
    // A dd elements end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
    // A dt elements end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
    result = result || this._tag_stack.try_pop('dt', ['dl']);
    result = result || this._tag_stack.try_pop('dd', ['dl']);


  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
    var p_parent = parser_token.parent.parent;
    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
      result = result || this._tag_stack.try_pop('p');
    }
  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
    // An rt elements end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    // An rp elements end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

  } else if (parser_token.tag_name === 'optgroup') {
    // An optgroup elements end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('optgroup', ['select']);
    //result = result || this._tag_stack.try_pop('option', ['select']);

  } else if (parser_token.tag_name === 'option') {
    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

  } else if (parser_token.tag_name === 'colgroup') {
    // DONE: A colgroup elements end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);

  } else if (parser_token.tag_name === 'thead') {
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);

    //} else if (parser_token.tag_name === 'caption') {
    // DONE: A caption elements end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
    // A thead elements end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
    // A tbody elements end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('thead', ['table']);
    result = result || this._tag_stack.try_pop('tbody', ['table']);

    //} else if (parser_token.tag_name === 'tfoot') {
    // DONE: A tfoot elements end tag may be omitted if there is no more content in the parent element.

  } else if (parser_token.tag_name === 'tr') {
    // A tr elements end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
    // A td elements end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
    // A th elements end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
  }

  // Start element omission not handled currently
  // A head elements start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
  // A tbody elements start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It cant be omitted if the element is empty.)
  // A colgroup elements start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It cant be omitted if the element is empty.)

  // Fix up the parent of the parser token
  parser_token.parent = this._tag_stack.get_parser_token();

  return result;
};

beautifier.Beautifier = Beautifier$1;

/*jshint node:true */

var Beautifier = beautifier.Beautifier,
  Options = options.Options;

function style_html$1(html_source, options, js_beautify, css_beautify) {
  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
  return beautifier.beautify();
}

html.exports = style_html$1;
html.exports.defaultOptions = function() {
  return new Options();
};

/*jshint node:true */

var js_beautify = javascript.exports;
var css_beautify = css$1.exports;
var html_beautify = html.exports;

function style_html(html_source, options, js, css) {
  js = js || js_beautify;
  css = css || css_beautify;
  return html_beautify(html_source, options, js, css);
}
style_html.defaultOptions = html_beautify.defaultOptions;

src.js = js_beautify;
src.css = css_beautify;
src.html = style_html;

/*jshint node:true */

(function (module) {

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
  // the default is js
  var beautify = function(src, config) {
    return js_beautify.js_beautify(src, config);
  };

  // short aliases
  beautify.js = js_beautify.js_beautify;
  beautify.css = css_beautify.css_beautify;
  beautify.html = html_beautify.html_beautify;

  // legacy aliases
  beautify.js_beautify = js_beautify.js_beautify;
  beautify.css_beautify = css_beautify.css_beautify;
  beautify.html_beautify = html_beautify.html_beautify;

  return beautify;
}

{
  (function(mod) {
    var beautifier = src;
    beautifier.js_beautify = beautifier.js;
    beautifier.css_beautify = beautifier.css;
    beautifier.html_beautify = beautifier.html;

    mod.exports = get_beautify(beautifier, beautifier, beautifier);

  })(module);
}
}(js$1));

var JsBeautify = js$1.exports;

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function (key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}

function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function compose$1() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduceRight(function (y, f) {
      return f(y);
    }, x);
  };
}

function curry$1(fn) {
  return function curried() {
    var _this = this;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return args.length >= fn.length ? fn.apply(this, args) : function () {
      for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nextArgs[_key3] = arguments[_key3];
      }

      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}

function isObject$3(value) {
  return {}.toString.call(value).includes('Object');
}

function isEmpty(obj) {
  return !Object.keys(obj).length;
}

function isFunction$2(value) {
  return typeof value === 'function';
}

function hasOwnProperty$1(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

function validateChanges(initial, changes) {
  if (!isObject$3(changes)) errorHandler$1('changeType');
  if (Object.keys(changes).some(function (field) {
    return !hasOwnProperty$1(initial, field);
  })) errorHandler$1('changeField');
  return changes;
}

function validateSelector(selector) {
  if (!isFunction$2(selector)) errorHandler$1('selectorType');
}

function validateHandler(handler) {
  if (!(isFunction$2(handler) || isObject$3(handler))) errorHandler$1('handlerType');
  if (isObject$3(handler) && Object.values(handler).some(function (_handler) {
    return !isFunction$2(_handler);
  })) errorHandler$1('handlersType');
}

function validateInitial(initial) {
  if (!initial) errorHandler$1('initialIsRequired');
  if (!isObject$3(initial)) errorHandler$1('initialType');
  if (isEmpty(initial)) errorHandler$1('initialContent');
}

function throwError$1(errorMessages, type) {
  throw new Error(errorMessages[type] || errorMessages["default"]);
}

var errorMessages$1 = {
  initialIsRequired: 'initial state is required',
  initialType: 'initial state should be an object',
  initialContent: 'initial state shouldn\'t be an empty object',
  handlerType: 'handler should be an object or a function',
  handlersType: 'all handlers should be a functions',
  selectorType: 'selector should be a function',
  changeType: 'provided value of changes should be an object',
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  "default": 'an unknown error accured in `state-local` package'
};
var errorHandler$1 = curry$1(throwError$1)(errorMessages$1);
var validators$1 = {
  changes: validateChanges,
  selector: validateSelector,
  handler: validateHandler,
  initial: validateInitial
};

function create(initial) {
  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  validators$1.initial(initial);
  validators$1.handler(handler);
  var state = {
    current: initial
  };
  var didUpdate = curry$1(didStateUpdate)(state, handler);
  var update = curry$1(updateState)(state);
  var validate = curry$1(validators$1.changes)(initial);
  var getChanges = curry$1(extractChanges)(state);

  function getState() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {
      return state;
    };
    validators$1.selector(selector);
    return selector(state.current);
  }

  function setState(causedChanges) {
    compose$1(didUpdate, update, validate, getChanges)(causedChanges);
  }

  return [getState, setState];
}

function extractChanges(state, causedChanges) {
  return isFunction$2(causedChanges) ? causedChanges(state.current) : causedChanges;
}

function updateState(state, changes) {
  state.current = _objectSpread2$2(_objectSpread2$2({}, state.current), changes);
  return changes;
}

function didStateUpdate(state, handler, changes) {
  isFunction$2(handler) ? handler(state.current) : Object.keys(changes).forEach(function (field) {
    var _handler$field;

    return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);
  });
  return changes;
}

var index$1 = {
  create: create
};

var config$1 = {
  paths: {
    vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs'
  }
};

function curry(fn) {
  return function curried() {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args.length >= fn.length ? fn.apply(this, args) : function () {
      for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nextArgs[_key2] = arguments[_key2];
      }

      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}

function isObject$2(value) {
  return {}.toString.call(value).includes('Object');
}

/**
 * validates the configuration object and informs about deprecation
 * @param {Object} config - the configuration object 
 * @return {Object} config - the validated configuration object
 */

function validateConfig(config) {
  if (!config) errorHandler('configIsRequired');
  if (!isObject$2(config)) errorHandler('configType');

  if (config.urls) {
    informAboutDeprecation();
    return {
      paths: {
        vs: config.urls.monacoBase
      }
    };
  }

  return config;
}
/**
 * logs deprecation message
 */


function informAboutDeprecation() {
  console.warn(errorMessages.deprecation);
}

function throwError(errorMessages, type) {
  throw new Error(errorMessages[type] || errorMessages["default"]);
}

var errorMessages = {
  configIsRequired: 'the configuration object is required',
  configType: 'the configuration object should be an object',
  "default": 'an unknown error accured in `@monaco-editor/loader` package',
  deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
};
var errorHandler = curry(throwError)(errorMessages);
var validators = {
  config: validateConfig
};

var compose = function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduceRight(function (y, f) {
      return f(y);
    }, x);
  };
};

function merge(target, source) {
  Object.keys(source).forEach(function (key) {
    if (source[key] instanceof Object) {
      if (target[key]) {
        Object.assign(source[key], merge(target[key], source[key]));
      }
    }
  });
  return _objectSpread2$3(_objectSpread2$3({}, target), source);
}

// The source (has been changed) is https://github.com/facebook/react/issues/5465#issuecomment-157888325
var CANCELATION_MESSAGE = {
  type: 'cancelation',
  msg: 'operation is manually canceled'
};

function makeCancelable(promise) {
  var hasCanceled_ = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) {
      return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);
    });
    promise["catch"](reject);
  });
  return wrappedPromise.cancel = function () {
    return hasCanceled_ = true;
  }, wrappedPromise;
}

/** the local state of the module */

var _state$create = index$1.create({
  config: config$1,
  isInitialized: false,
  resolve: null,
  reject: null,
  monaco: null
}),
    _state$create2 = _slicedToArray(_state$create, 2),
    getState = _state$create2[0],
    setState = _state$create2[1];
/**
 * set the loader configuration
 * @param {Object} config - the configuration object
 */


function config(globalConfig) {
  var _validators$config = validators.config(globalConfig),
      monaco = _validators$config.monaco,
      config = _objectWithoutProperties$1(_validators$config, ["monaco"]);

  setState(function (state) {
    return {
      config: merge(state.config, config),
      monaco: monaco
    };
  });
}
/**
 * handles the initialization of the monaco-editor
 * @return {Promise} - returns an instance of monaco (with a cancelable promise)
 */


function init() {
  var state = getState(function (_ref) {
    var monaco = _ref.monaco,
        isInitialized = _ref.isInitialized,
        resolve = _ref.resolve;
    return {
      monaco: monaco,
      isInitialized: isInitialized,
      resolve: resolve
    };
  });

  if (!state.isInitialized) {
    setState({
      isInitialized: true
    });

    if (state.monaco) {
      state.resolve(state.monaco);
      return makeCancelable(wrapperPromise);
    }

    if (window.monaco && window.monaco.editor) {
      storeMonacoInstance(window.monaco);
      state.resolve(window.monaco);
      return makeCancelable(wrapperPromise);
    }

    compose(injectScripts, getMonacoLoaderScript)(configureLoader);
  }

  return makeCancelable(wrapperPromise);
}
/**
 * injects provided scripts into the document.body
 * @param {Object} script - an HTML script element
 * @return {Object} - the injected HTML script element
 */


function injectScripts(script) {
  return document.body.appendChild(script);
}
/**
 * creates an HTML script element with/without provided src
 * @param {string} [src] - the source path of the script
 * @return {Object} - the created HTML script element
 */


function createScript(src) {
  var script = document.createElement('script');
  return src && (script.src = src), script;
}
/**
 * creates an HTML script element with the monaco loader src
 * @return {Object} - the created HTML script element
 */


function getMonacoLoaderScript(configureLoader) {
  var state = getState(function (_ref2) {
    var config = _ref2.config,
        reject = _ref2.reject;
    return {
      config: config,
      reject: reject
    };
  });
  var loaderScript = createScript("".concat(state.config.paths.vs, "/loader.js"));

  loaderScript.onload = function () {
    return configureLoader();
  };

  loaderScript.onerror = state.reject;
  return loaderScript;
}
/**
 * configures the monaco loader
 */


function configureLoader() {
  var state = getState(function (_ref3) {
    var config = _ref3.config,
        resolve = _ref3.resolve,
        reject = _ref3.reject;
    return {
      config: config,
      resolve: resolve,
      reject: reject
    };
  });
  var require = window.require;

  require.config(state.config);

  require(['vs/editor/editor.main'], function (monaco) {
    storeMonacoInstance(monaco);
    state.resolve(monaco);
  }, function (error) {
    state.reject(error);
  });
}
/**
 * store monaco instance in local state
 */


function storeMonacoInstance(monaco) {
  if (!getState().monaco) {
    setState({
      monaco: monaco
    });
  }
}
/**
 * internal helper function
 * extracts stored monaco instance
 * @return {Object|null} - the monaco instance
 */


function __getMonacoInstance() {
  return getState(function (_ref4) {
    var monaco = _ref4.monaco;
    return monaco;
  });
}

var wrapperPromise = new Promise(function (resolve, reject) {
  return setState({
    resolve: resolve,
    reject: reject
  });
});
var loader = {
  config: config,
  init: init,
  __getMonacoInstance: __getMonacoInstance
};

let hash$1 = {};
class HtmlUtil {
  constructor(builder) {
    this.builder = builder;
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let viewhtml = builderStuff.querySelector('.viewhtml');
    if (!viewhtml) {
      /*
      Note:
      - viewhtml => non syntax-highlighted. 
      - viewhtmlmonaco => syntax-highlighted.
       - viewhtmlexternal => external use.
      */
      const html = `<div class="is-modal viewhtml" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <textarea class="tabSupport" id="__tabsupport" style="width:100%;height:calc(100% - 50px);border:none;margin:0;box-sizing:border-box;"></textarea>
                    <div class="is-modal-footer" style="border-top:1px solid ${this.builder.styleSeparatorColor};width:100%;height:50px;position:absolute;left:0;bottom:0;overflow:hidden;text-align:right">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>

            <div class="is-modal viewhtmlmonaco" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="width:${this.builder.blockCodeEditorWidth};max-width:${this.builder.blockCodeEditorMaxWidth};padding:0">
                    <textarea id="__viewhtmlmonaco" style="position:absolute;display:none;"></textarea>
                    <div class="input-code-editor" style="width:100%;height:${this.builder.blockCodeEditorHeight};"></div>
                    <div class="is-modal-footer" style="display:flex;justify-content:flex-end;border-top:1px solid ${this.builder.styleSeparatorColor};">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>

            <div class="is-modal viewhtmlexternal" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="width:${this.builder.codeEditorWidth};max-width:${this.builder.codeEditorMaxWidth};padding:0">
                    <div class="input-code-editor" id="__input_code_editor" style="width:100%;height:${this.builder.codeEditorHeight};"></div>
                    <div class="is-modal-footer" style="display:flex;justify-content:flex-end;border-top:1px solid ${this.builder.styleSeparatorColor};">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            
            `;
      dom.appendHtml(builderStuff, html);
      viewhtml = builderStuff.querySelector('.viewhtml');
      let viewhtmlmonaco = builderStuff.querySelector('.viewhtmlmonaco');
      let viewhtmlexternal = builderStuff.querySelector('.viewhtmlexternal');
      let elm = viewhtml.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        this.applyHtml(viewhtml);
      });
      elm = viewhtml.querySelector('.input-cancel');
      dom.addEventListener(elm, 'click', () => {
        this.builder.hideModal(viewhtml);
      });
      elm = viewhtmlmonaco.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        this.applyHtml(viewhtmlmonaco);
      });
      elm = viewhtmlmonaco.querySelector('.input-cancel');
      dom.addEventListener(elm, 'click', () => {
        this.builder.hideModal(viewhtmlmonaco);
      });
      elm = viewhtmlexternal.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        const source = document.querySelector('textarea[data-source-active]');
        const selectorOk = source.getAttribute('data-source-ok');
        source.removeAttribute('data-source-active');
        source.removeAttribute('data-source-ok');
        source.removeAttribute('data-source-cancel');
        document.querySelector(selectorOk).click();
        this.builder.hideModal(viewhtmlexternal);
      });
      elm = viewhtmlexternal.querySelector('.input-cancel');
      dom.addEventListener(elm, 'click', () => {
        const source = document.querySelector('textarea[data-source-active]');
        const selectorCancel = source.getAttribute('data-source-cancel');
        source.removeAttribute('data-source-active');
        source.removeAttribute('data-source-ok');
        source.removeAttribute('data-source-cancel');
        document.querySelector(selectorCancel).click();
        this.builder.hideModal(viewhtmlexternal);
      });
    }
  }
  applyHtml(modal) {
    const util = this.builder.util;
    let mode = this.builder.codeEditorMode;
    let area = this.builder.codeEditorArea;
    this.builder.uo.saveForUndo();
    let textarea = modal.querySelector('textarea');
    let html = textarea.value;
    if (mode === 'code') {
      let codeblock = this.builder.activeCodeBlock;

      //this.builder.renderCustomCodeBlock($block, html);
      codeblock.setAttribute('data-html', encodeURIComponent(html)); // => important
      html = html.replace(/{id}/g, util.makeId());
      for (let i = 1; i <= 20; i++) {
        html = html.replace('[%HTML' + i + '%]', codeblock.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(codeblock.getAttribute('data-html-' + i))); //render editable area
      }

      //codeblock.innerHTML = html;
      codeblock.innerHTML = '';
      // Use createContextualFragment() to make embedded script executable
      // https://ghinda.net/article/script-tags/
      let range = document.createRange();
      range.setStart(codeblock, 0);
      codeblock.appendChild(range.createContextualFragment(html));
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);

      //Trigger Change event
      this.builder.opts.onChange();

      //Trigger Render event
      this.builder.opts.onRender();
      this.builder.hideModal(modal);
      util.hideControls();
      return;
    }
    html = this.fromViewToActual(html);
    if (mode === 'cell') {
      const cell = util.cellSelected();
      cell.innerHTML = html;
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);

      //Trigger Change event
      this.builder.opts.onChange();

      //Trigger Render event
      this.builder.opts.onRender();
    }
    if (mode === 'row') {
      let row;
      let cell = util.cellSelected();
      if (cell) {
        row = cell.parentNode;
      } else {
        row = util.rowSelected();
      }
      if (!row) return;
      row.innerHTML = html;
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);

      //Trigger Change event
      this.builder.opts.onChange();

      //Trigger Render event
      this.builder.opts.onRender();
    }
    if (mode === 'full') {
      // freeform
      if (this.builder.docContainer) {
        this.builder.loadHTML(html);
        util.clearControls();
        this.builder.hideModal(modal);
        return;
      }

      // area.innerHTML = html;
      area.innerHTML = '';
      // Use createContextualFragment() to make embedded script executable
      // https://ghinda.net/article/script-tags/
      let range = document.createRange();
      range.setStart(area, 0);
      area.appendChild(range.createContextualFragment(html));

      // let builderActive = this.builder.doc.querySelector('.builder-active');
      // if(builderActive) this.builder.applyBehaviorOn(builderActive);
      this.builder.applyBehaviorOn(area);
      /*else {
           const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
          if(builders.length > 1) {
              const cell = util.cellSelected();
              if(!cell) {
                  // Return first instance
                  area = builders[0];
              } else {
                  // Return active instance
                  area = cell.parentNode.parentNode;
              }
          } else {
              // Single instance
              area = builders[0];
          }
          this.builder.applyBehaviorOn(area);
       }*/

      //Trigger Change event
      this.builder.opts.onChange();

      //Trigger Render event
      this.builder.opts.onRender();
      util.clearActiveCell();
    }
    util.clearControls(); // NEW

    this.builder.hideModal(modal);
  }
  viewHtmlExternal() {
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.renderPanel();
    const viewhtmlexternal = builderStuff.querySelector('.viewhtmlexternal');
    if (document.activeElement) this.elmFocus = document.activeElement;
    util.showModal(viewhtmlexternal, true, () => {
      if (this.elmFocus) this.elmFocus.focus();
    }, false);
    let codeEditor = viewhtmlexternal.querySelector('.input-code-editor');
    codeEditor.style.opacity = 0.01;
    this._viewHtmlExternal();
  }
  _viewHtmlExternal() {
    const builderStuff = this.builder.builderStuff;
    const source = document.querySelector('textarea[data-source-active]');
    const viewhtmlexternal = builderStuff.querySelector('.viewhtmlexternal');
    let codeEditor = viewhtmlexternal.querySelector('.input-code-editor');
    if (!codeEditor.querySelector('.monaco-editor')) {
      // First time code editor load

      loader.init().then(monaco => {
        this.builder.monaco = monaco;
        if (!codeEditor.getAttribute('data-mode-id')) this.builder.codeEditorExternal = monaco.editor.create(codeEditor, {
          value: '',
          minimap: {
            enabled: false
          },
          automaticLayout: true,
          contextmenu: false,
          fontSize: 13,
          wordWrap: true,
          scrollbar: {
            useShadows: false,
            vertical: 'visible',
            horizontal: 'visible',
            horizontalScrollbarSize: 12,
            verticalScrollbarSize: 12
          },
          language: 'html',
          theme: this.builder.styleDark || this.builder.styleColoredDark ? 'vs-dark' : ''
        });
        this.builder.codeEditorExternal.onDidChangeModelContent(() => {
          // this.builder.codeEditorExternal.onKeyUp(()=>{
          const source = document.querySelector('textarea[data-source-active]');
          source.value = this.builder.codeEditorExternal.getModel().getValue();
        });
      });
      setTimeout(() => {
        this._viewHtmlExternal();
      }, 100);
      return;
    }

    // code editor
    const model = this.builder.monaco.editor.createModel(source.value, 'html');
    this.builder.codeEditorExternal.setModel(model);
    codeEditor.style.opacity = '';
  }
  view(mode, area, btn) {
    this.renderPanel();
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    let viewhtml;
    if (this.builder.opts.htmlSyntaxHighlighting) {
      viewhtml = builderStuff.querySelector('.viewhtmlmonaco');
    } else {
      viewhtml = builderStuff.querySelector('.viewhtml');
    }
    let modelContent = viewhtml.querySelector('.is-modal-content');
    let codeEditor = viewhtml.querySelector('.input-code-editor');
    codeEditor.style.opacity = 0.01;
    if (mode === 'full') {
      modelContent.style.width = this.builder.codeEditorWidth;
      modelContent.style.maxWidth = this.builder.codeEditorMaxWidth;
      codeEditor.style.height = this.builder.codeEditorHeight;
    } else {
      modelContent.style.width = this.builder.blockCodeEditorWidth;
      modelContent.style.maxWidth = this.builder.blockCodeEditorMaxWidth;
      codeEditor.style.height = this.builder.blockCodeEditorHeight;
    }
    util.showModal(viewhtml, true, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    });
    if (btn) btn.setAttribute('data-focus', true);
    this._view(mode, area);
  }
  _view(mode, area) {
    const dom = this.builder.dom;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    let viewhtml;
    if (this.builder.opts.htmlSyntaxHighlighting) {
      viewhtml = builderStuff.querySelector('.viewhtmlmonaco');
      let codeEditor = viewhtml.querySelector('.input-code-editor');
      if (!codeEditor.querySelector('.monaco-editor')) {
        // First time code editor load

        loader.init().then(monaco => {
          this.builder.monaco = monaco;
          if (!codeEditor.getAttribute('data-mode-id')) this.builder.codeEditor = monaco.editor.create(codeEditor, {
            value: '',
            minimap: {
              enabled: false
            },
            automaticLayout: true,
            contextmenu: false,
            fontSize: 13,
            wordWrap: true,
            scrollbar: {
              useShadows: false,
              vertical: 'visible',
              horizontal: 'visible',
              horizontalScrollbarSize: 12,
              verticalScrollbarSize: 12
            },
            language: 'html',
            theme: this.builder.styleDark || this.builder.styleColoredDark ? 'vs-dark' : ''
          });
          let textarea = viewhtml.querySelector('textarea');
          this.builder.codeEditor.onDidChangeModelContent(() => {
            // this.builder.codeEditor.onKeyUp(()=>{
            textarea.value = this.builder.codeEditor.getModel().getValue();
          });
        });
        setTimeout(() => {
          this._view(mode, area);
        }, 100);
        return;
      }
    } else {
      viewhtml = builderStuff.querySelector('.viewhtml');
    }
    let textarea = viewhtml.querySelector('textarea');
    if (mode === 'cell') {
      // old: 3550

      const cell = util.cellSelected();
      if (!cell) return;
      let textarea = viewhtml.querySelector('textarea');
      this.builder.cleanHtmlFormatting = true;
      textarea.value = this.readHtml(cell, true); // for view=true
      this.builder.cleanHtmlFormatting = false;
    }
    if (mode === 'row') {
      // old: 15534

      // const cell = util.cellSelected();
      // if(!cell) return;
      // const row = cell.parentNode;
      let row;
      let cell = util.cellSelected();
      if (cell) {
        row = cell.parentNode;
      } else {
        row = util.rowSelected();
      }
      if (!row) return;
      let textarea = viewhtml.querySelector('textarea');
      this.builder.cleanHtmlFormatting = true;
      textarea.value = this.readHtml(row, true); // for view=true
      this.builder.cleanHtmlFormatting = false;

      //Change to row selection
      dom.removeClass(row, 'row-outline');
    }
    if (mode === 'full') {
      // 

      if (area) ; else {
        const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
        if (builders.length > 1) {
          const cell = util.cellSelected();
          if (!cell) {
            // Return first instance
            area = builders[0];
          } else {
            // Return active instance
            area = cell.parentNode.parentNode;
          }
        } else {
          // Single instance
          area = builders[0];
        }
        if (this.builder.opts.page !== '') {
          const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
          if (wrapper) {
            //return wrapper
            area = wrapper;
          }
        }
      }
      let textarea = viewhtml.querySelector('textarea');
      this.builder.cleanHtmlFormatting = true;

      // textarea.value = this.readHtml(area, true); // for view=true
      if (this.builder.shortenHTML) {
        textarea.value = this.readHtml(area, true); // for view=true
      } else {
        textarea.value = this.readHtml(area, false); // actual
      }

      this.builder.cleanHtmlFormatting = false;
    }
    if (this.builder.opts.htmlSyntaxHighlighting) {
      // code editor
      const model = this.builder.monaco.editor.createModel(textarea.value, 'html');
      this.builder.codeEditor.setModel(model);
    }

    //Hide popup
    let columnMore = builderStuff.querySelector('.is-pop.columnmore');
    if (columnMore) columnMore.style.display = '';
    let rowMore = builderStuff.querySelector('.is-pop.rowmore');
    if (rowMore) rowMore.style.display = '';
    this.builder.codeEditorMode = mode;
    this.builder.codeEditorArea = area;
    let codeEditor = viewhtml.querySelector('.input-code-editor');
    codeEditor.style.opacity = '';
  }
  fromViewToActual(html) {
    for (var key in hash$1) {
      html = html.replace(key, hash$1[key]);
    }
    return html;
  }
  readHtml(content, view, multiple, excludeCustomBlock) {
    //view = true (hide internal attributes). view = false (actual html)

    const dom = this.builder.dom;

    //Make absolute
    if (this.builder.opts.absolutePath) {
      let links = content.querySelectorAll('a');
      Array.prototype.forEach.call(links, link => {
        let href = link.href;
        link.setAttribute('href', href);
      });
      let imgs = content.querySelectorAll('img');
      Array.prototype.forEach.call(imgs, img => {
        let src = img.src;
        img.setAttribute('src', src);
      });
    }
    if (this.builder.cleanHtmlFormatting) ;
    const util = this.builder.util;
    // const builderStuff = this.builder.builderStuff;

    // //Prepare temporary helpers: #tmp_content & #tmp_buildercontent
    // let elm = builderStuff.querySelector('#tmp_content');
    // if(elm) builderStuff.removeChild(elm);
    // elm = builderStuff.querySelector('#tmp_buildercontent');
    // if(elm) builderStuff.removeChild(elm);
    // let html = `<div id="tmp_content" style="position:absolute;top:0;left:0;width:1px;height:1px;overflow:hidden;visibility:hidden;"></div>
    //     <div id="tmp_buildercontent" style="position:absolute;top:0;left:0;width:1px;height:1px;overflow:hidden;visibility:hidden;"></div>`;
    // dom.appendHtml(builderStuff, html);
    let html;
    // let tmp = builderStuff.querySelector('#tmp_content');
    let tmp = document.createElement('div');
    tmp.innerHTML = content.innerHTML;

    //Find subblocks (previously is-builder) in custom code blocks and save them to data-html-1, data-html-2, and so on.
    let blocks = tmp.querySelectorAll('[data-html]');
    Array.prototype.forEach.call(blocks, block => {
      // NEW
      let index = 1;
      let subblocks = block.querySelectorAll('[data-subblock]');
      Array.prototype.forEach.call(subblocks, subblock => {
        if (subblock.closest('.glide__slide--clone')) return;
        let html = subblock.innerHTML;
        block.setAttribute('data-html-' + index, encodeURIComponent(html));
        index++;
      });
    });

    //Render custom code blocks (including any editable areas within)
    blocks = tmp.querySelectorAll('[data-html]');
    Array.prototype.forEach.call(blocks, block => {
      let blockhtml = decodeURIComponent(block.getAttribute('data-html'));
      blockhtml = blockhtml.replace(/{id}/g, util.makeId());

      /* OLD
      for(var i=1;i<=20;i++){ 
          blockhtml = blockhtml.replace('[%HTML'+i+'%]', (block.getAttribute('data-html-'+i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-'+i))));//render editable area
      }
      block.innerHTML = blockhtml; //embedded script is not (and should not) executed here
      */

      // NEW
      block.innerHTML = blockhtml; //embedded script is not (and should not) executed here  
      let subblocks = block.querySelectorAll('[data-subblock]');
      var i = 1;
      Array.prototype.forEach.call(subblocks, subblock => {
        subblock.innerHTML = block.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-' + i));
        i++;
      });
    });

    //For Viewing, hide data-html, data-html-1.., data-settings
    if (view) {
      hash$1 = {};
      blocks = tmp.querySelectorAll('[data-html]');
      Array.prototype.forEach.call(blocks, block => {
        let uniqueID = util.makeId();
        hash$1[uniqueID] = block.getAttribute('data-html');
        block.setAttribute('data-html', uniqueID);
        for (let i = 1; i <= 20; i++) {
          if (block.getAttribute('data-html-' + i) !== undefined) {
            uniqueID = util.makeId();
            hash$1[uniqueID] = block.getAttribute('data-html-' + i);
            block.getAttribute('data-html-' + i, uniqueID);
          }
        }
        if (block.getAttribute('data-settings') !== undefined) {
          uniqueID = util.makeId();
          hash$1[uniqueID] = block.getAttribute('data-settings');
          block.getAttribute('data-settings', uniqueID);
        }
      });
    }

    //Make absolute (for Export/Download)
    if (this.builder.makeAbsolute) {
      const convertMediaUrl = imgUrl => {
        // make absolute
        let img = document.createElement('img');
        img.src = imgUrl;
        img.setAttribute('data-absoluteurl', img.src);
        imgUrl = img.getAttribute('data-absoluteurl');
        return imgUrl;
      };
      const convertBgUrl = imgUrl => {
        // make absolute
        let img = document.createElement('img');
        img.src = imgUrl;
        img.setAttribute('data-absoluteurl', img.src);
        imgUrl = img.getAttribute('data-absoluteurl');

        // Do not use imgUrl directly, change base to [%PATH%] instead 
        // (to prevent auto converting back to relative path)

        let urlBase = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
        return imgUrl.replace(urlBase, '[%PATH%]');

        // Example:
        // url = http://localhost:8080/uploads/image.jpg 
        // urlBase = http://localhost:8080
        // become: [%PATH%]/uploads/image.jpg 
      };

      const convertMedia = (elm, attrName) => {
        if (elm.hasAttribute(attrName)) {
          if (!(elm.parentNode.tagName.toLowerCase() === 'video' || elm.parentNode.tagName.toLowerCase() === 'audio')) return;
          let imgUrl = elm.getAttribute(attrName);
          imgUrl = convertMediaUrl(imgUrl);
          elm.setAttribute(attrName, `${imgUrl}`);
        }
      };
      let imgs = tmp.querySelectorAll('img');
      Array.prototype.forEach.call(imgs, img => {
        let src = img.src;
        img.setAttribute('src', src);
      });
      let elms = tmp.querySelectorAll('*');
      elms.forEach(elm => {
        if (elm.style.backgroundImage) {
          let s = elm.style.backgroundImage;
          if (s.indexOf('url(') !== -1) {
            let imgUrl = s.slice(4, -1).replace(/["']/g, '');
            imgUrl = convertBgUrl(imgUrl);
            elm.style.backgroundImage = `url(${imgUrl})`;
          }
        }
        convertMedia(elm, 'src');
        convertMedia(elm, 'data-default');
        convertMedia(elm, 'data-240');
        convertMedia(elm, 'data-360');
        convertMedia(elm, 'data-480');
        convertMedia(elm, 'data-540');
        convertMedia(elm, 'data-720');
        convertMedia(elm, 'data-1080');
        convertMedia(elm, 'data-1440');
        convertMedia(elm, 'data-2160');
        if (elm.hasAttribute('href')) {
          if (elm.tagName.toLowerCase() === 'link') {
            let imgUrl = elm.getAttribute('href');
            imgUrl = convertMediaUrl(imgUrl);
            elm.setAttribute('href', `${imgUrl}`);
          }
        }
      });
    }

    //Cleaning
    let _builders = tmp.querySelectorAll('.is-builder');
    Array.prototype.forEach.call(_builders, _builder => {
      _builder.style.transform = '';
      _builder.style.WebkitTransform = '';
      _builder.style.MozTransform = '';
      _builder.removeAttribute('data-sort');
      dom.removeClass(_builder, 'builder-active');
      const rows = dom.elementChildren(_builder);
      rows.forEach(row => {
        const cols = dom.elementChildren(row);
        cols.forEach(col => {
          col.style.cursor = '';
        });
      });
    });

    // cleanup cursor from drag to resize columns
    const rows = dom.elementChildren(tmp);
    rows.forEach(row => {
      row.style.cursor = ''; //if tmp is row html, then this is a column
      const cols = dom.elementChildren(row);
      cols.forEach(col => {
        col.style.cursor = '';
      });
    });
    let elms;
    elms = tmp.querySelectorAll('.sortable-chosen, .sortable-ghost, .elm-active, .icon-active, .elm-inspected, .cell-active, .row-active, .row-outline, .is-builder');
    elms.forEach(elm => {
      elm.classList.remove('sortable-chosen');
      elm.classList.remove('sortable-ghost');
      elm.classList.remove('elm-active');
      elm.classList.remove('icon-active');
      elm.classList.remove('elm-inspected');
      elm.classList.remove('cell-active');
      elm.classList.remove('row-active');
      elm.classList.remove('row-outline');
      elm.classList.remove('is-builder');
    });
    elms = tmp.querySelectorAll('[data-click], [contenteditable], [draggridoutline], [between-blocks-left], [between-blocks-center], [hideelementhighlight], [data-module-active], [draggable]');
    elms.forEach(elm => {
      elm.removeAttribute('data-click');
      elm.removeAttribute('contenteditable');
      elm.removeAttribute('draggridoutline');
      elm.removeAttribute('between-blocks-left');
      elm.removeAttribute('between-blocks-center');
      elm.removeAttribute('hideelementhighlight');
      elm.removeAttribute('data-module-active');
      elm.removeAttribute('draggable');
    });
    elms = tmp.querySelectorAll('[data-animated], [data-saveforundo], [hidesnippetaddtool], [gray], [rowoutline], [hidecolumntool], [grayoutline], [hideoutline]');
    elms.forEach(elm => {
      elm.removeAttribute('data-animated');
      elm.removeAttribute('data-saveforundo');
      elm.removeAttribute('hidesnippetaddtool');
      elm.removeAttribute('gray');
      elm.removeAttribute('rowoutline');
      elm.removeAttribute('hidecolumntool');
      elm.removeAttribute('grayoutline');
      elm.removeAttribute('hideoutline');
    });
    elms = tmp.querySelectorAll('[leftrowtool], [minimal], [clean], [grideditor], [gridoutline]');
    elms.forEach(elm => {
      elm.removeAttribute('leftrowtool');
      elm.removeAttribute('minimal');
      elm.removeAttribute('clean');
      elm.removeAttribute('grideditor');
      elm.removeAttribute('gridoutline');
    });
    elms = tmp.querySelectorAll('.is-row-tool,.is-col-tool,.is-rowadd-tool,.is-canvas-tool,.is-canvasadd-tool,.h-ruler,.v-ruler');
    elms.forEach(elm => {
      if (elm.previousSibling && elm.previousSibling.nodeType === Node.TEXT_NODE) {
        elm.previousSibling.remove();
      }
      if (elm.nextSibling && elm.nextSibling.nodeType === Node.TEXT_NODE) {
        elm.nextSibling.remove();
      }
      elm.remove();
    });
    elms = tmp.querySelectorAll('.ovl,.row-add-initial');
    elms.forEach(elm => {
      elm.remove();
    });

    //Extra cleaning
    if (this.builder.cleanAOS) {
      elms = tmp.querySelectorAll('.aos-init, .aos-animate');
      elms.forEach(elm => {
        elm.classList.remove('aos-init');
        elm.classList.remove('aos-animate');
      });
    }
    elms = tmp.querySelectorAll('.skrollable, .skrollable-after, .skrollable-before, .skrollable-between, .is-inview');
    elms.forEach(elm => {
      elm.classList.remove('skrollable');
      elm.classList.remove('skrollable-after');
      elm.classList.remove('skrollable-before');
      elm.classList.remove('skrollable-between');
      elm.classList.remove('is-inview');
    });
    let emptyclasses = tmp.querySelectorAll('[class=""]');
    emptyclasses.forEach(emptyclass => {
      emptyclass.removeAttribute('class');
    });
    let unusedOverlays = tmp.querySelectorAll('.is-row-overlay');
    unusedOverlays.forEach(unusedOverlay => {
      if (!unusedOverlay.hasAttribute('style')) unusedOverlay.parentNode.removeChild(unusedOverlay);
    });
    dom.removeEmptyStyle(tmp);
    elms = tmp.querySelectorAll('[data-keep]');
    dom.removeAttributes(elms, 'data-keep');

    //Backward compatible: cleanup button <span contenteditable="false"><a contenteditable="true">button</a></span>
    let links = tmp.querySelectorAll('a');
    links.forEach(link => {
      if (link.style.display === 'inline-block') {
        if (link.parentNode.childElementCount === 1 && link.parentNode.tagName.toLowerCase() === 'span') {
          link.parentNode.outerHTML = link.parentNode.innerHTML;
        }
      }
    });
    if (excludeCustomBlock) {
      const elmCustomBlocks = tmp.querySelectorAll('[data-html]');
      elmCustomBlocks.forEach(elm => {
        elm.innerHTML = '';
      });
    }
    html = '';
    if (multiple) {
      //ContentBox

      // Remove dummy DIV after last section
      elms = tmp.querySelectorAll('.is-dummy');
      elms.forEach(elm => {
        elm.remove();
      });
      elms = tmp.querySelectorAll('[data-scroll], [data-scroll-once]');
      elms.forEach(elm => {
        elm.removeAttribute('data-scroll');
        elm.removeAttribute('data-scroll-once');
      });
      if (this.builder.shortenOutput) {
        elms = tmp.querySelectorAll('[data-noedit], [data-module], [data-module-desc], [data-dialog-width], [data-dialog-height], [data-html], [data-settings]');
        elms.forEach(elm => {
          elm.removeAttribute('data-noedit');
          elm.removeAttribute('data-module');
          elm.removeAttribute('data-module-desc');
          elm.removeAttribute('data-dialog-width');
          elm.removeAttribute('data-dialog-height');
          elm.removeAttribute('data-html');
          elm.removeAttribute('data-settings');
        });
        elms = tmp.querySelectorAll('[data-html-1], [data-html-2], [data-html-3], [data-html-4], [data-html-5], [data-html-6], [data-html-7], [data-html-8], [data-html-9], [data-html-10]');
        elms.forEach(elm => {
          elm.removeAttribute('data-html-1');
          elm.removeAttribute('data-html-2');
          elm.removeAttribute('data-html-3');
          elm.removeAttribute('data-html-4');
          elm.removeAttribute('data-html-5');
          elm.removeAttribute('data-html-6');
          elm.removeAttribute('data-html-7');
          elm.removeAttribute('data-html-8');
          elm.removeAttribute('data-html-9');
          elm.removeAttribute('data-html-10');
        });
      }

      // cleaning

      elms = tmp.querySelectorAll('[data-bottom-top],[data-center],[data-center-bottom],[data-100-top],[data-50-top],[data-top],[data-top-bottom],[data-center-top],[data--300-bottom],[data--150-bottom],[data--50-bottom],[data-bottom],[data-100-bottom],[data-150-bottom],[data-400-bottom],' + '[data--400-bottom],[data--200-bottom],[data--100-bottom],[data-50-bottom],[data-200-bottom],[data-300-bottom],' + '[data-in],[data-in-150],[data-in-300],' + '[data-cen--150],[data-cen],[data-cen-150],[data-out--300],[data-out--150],[data-out]' + '[data-t],[data-t-100],[data-t-200],[data-t-300],[data-t-400],' + '[data-t-500],[data-t-600],[data-t-700],[data-t-800],[data-t-900],[data-t-1000],' + '[data-t-1100],[data-t-1200],[data-t-1300],[data-t-1400],[data-t-1500],[data-t-1600],' + '[data-t-1700],[data-t-1800],[data-t-1900],[data-t-2000],[data-t-2100],[data-t-2200],' + '[data-t-2300],[data-t-2400],[data-t-2500],[data-t-2600],[data-t-2700],[data-t-2800]');
      Array.prototype.forEach.call(elms, elm => {
        elm.style.transition = '';
        elm.style.transform = '';
        elm.style.opacity = '';
      });
      elms = tmp.querySelectorAll('.is-animated');
      Array.prototype.forEach.call(elms, elm => {
        dom.removeClass(elm, 'animated');
        dom.removeClass(elm, 'pulse');
        dom.removeClass(elm, 'bounceIn');
        dom.removeClass(elm, 'fadeIn');
        dom.removeClass(elm, 'fadeOut'); //new
        dom.removeClass(elm, 'fadeInDown');
        dom.removeClass(elm, 'fadeInLeft');
        dom.removeClass(elm, 'fadeInRight');
        dom.removeClass(elm, 'fadeInUp');
        dom.removeClass(elm, 'flipInX');
        dom.removeClass(elm, 'flipInY');
        dom.removeClass(elm, 'slideInUp');
        dom.removeClass(elm, 'slideInDown');
        dom.removeClass(elm, 'slideInLeft');
        dom.removeClass(elm, 'slideInRight');
        dom.removeClass(elm, 'zoomIn');
        elm.style.animationDelay = '';
        elm.style.transitionDelay = '';
        elm.style.transitionDuration = '';
        elm.style.transitionTimingFunction = '';
        elm.style.transitionProperty = '';
      });
      let emptystyles = tmp.querySelectorAll('[style=""]');
      Array.prototype.forEach.call(emptystyles, emptystyle => {
        emptystyle.removeAttribute('style');
      });

      //Cleanup utils
      elms = tmp.querySelectorAll('.is-appeared, .box-active, .section-active, .section-select, .box-select');
      elms.forEach(elm => {
        elm.classList.remove('is-appeared');
        elm.classList.remove('box-active');
        elm.classList.remove('section-active');
        elm.classList.remove('section-select');
        elm.classList.remove('box-select');
      });
      elms = tmp.querySelectorAll('.is-section-tool, .is-box-tool, .is-box-info, .is-section-info');
      elms.forEach(elm => {
        if (elm.previousSibling && elm.previousSibling.nodeType === Node.TEXT_NODE) {
          elm.previousSibling.remove();
        }
        if (elm.nextSibling && elm.nextSibling.nodeType === Node.TEXT_NODE) {
          elm.nextSibling.remove();
        }
        elm.remove();
      });

      // freeform
      elms = tmp.querySelectorAll('.is-block .handle, .is-block .rotate-handle');
      dom.removeElements(elms);
      elms = tmp.querySelectorAll('.is-block');
      Array.prototype.forEach.call(elms, elm => {
        dom.removeClass(elm, 'active');
        dom.removeClass(elm, 'multi');
        dom.removeClass(elm, 'editable');
        dom.removeClass(elm, 'fluid');
        dom.removeClass(elm, 'cloned');
        elm.removeAttribute('data-fluid-val');
        elm.removeAttribute('data-fluid');
        elm.removeAttribute('data-prev');
      });
      tmp.querySelectorAll('.is-block.clone').forEach(elm => elm.parentNode.removeChild(elm));
      var html_content = '';
      var html_footer = '';
      var html_others = '';

      // Apply behavior on each row
      const sections = dom.elementChildren(tmp);
      sections.forEach(section => {
        let currentSection = section;
        if (dom.hasClass(currentSection, 'is-section')) {
          var secclass = '';
          // var secstyle = '';
          if (currentSection.getAttribute('class')) secclass = ' class="' + currentSection.getAttribute('class') + '"';
          // if (currentSection.getAttribute('style')) secstyle = ' style="' + currentSection.getAttribute('style') + '"';

          var copySection = currentSection.cloneNode(true);
          var htmlSection = copySection.outerHTML;
          html += htmlSection;

          //content & footer
          if (secclass.indexOf('is-static') === -1) {
            html_content += htmlSection + '\n\n';
          } else {
            html_footer += htmlSection + '\n\n';
          }
        } else {
          copySection = currentSection.cloneNode(true);
          htmlSection = copySection.outerHTML;
          html += htmlSection;

          //others
          html_others += htmlSection;
        }
      });

      // if (html_footer !== '') html_footer = '<!---FOOTER--->\n' + html_footer;
      // if (html_others !== '') html_others = '<!---OTHERS--->\n' + html_others;

      let contentbox = document.querySelector('[data-contentbox]');
      let disableStaticSection = false;
      if (contentbox) {
        disableStaticSection = contentbox.settings.disableStaticSection;
      }
      if (!disableStaticSection) {
        html = html_content + html_footer + html_others;
      }
      html = tmp.innerHTML.trim();
      html = html.replace(/<font/g, '<span').replace(/<\/font/g, '</span');
    } else {
      let emptystyles = tmp.querySelectorAll('[style=""]');
      Array.prototype.forEach.call(emptystyles, emptystyle => {
        emptystyle.removeAttribute('style');
      });
      if (this.builder.shortenOutput) {
        elms = tmp.querySelectorAll('[data-noedit], [data-module], [data-module-desc], [data-dialog-width], [data-dialog-height], [data-html], [data-settings]');
        elms.forEach(elm => {
          elm.removeAttribute('data-noedit');
          elm.removeAttribute('data-module');
          elm.removeAttribute('data-module-desc');
          elm.removeAttribute('data-dialog-width');
          elm.removeAttribute('data-dialog-height');
          elm.removeAttribute('data-html');
          elm.removeAttribute('data-settings');
        });
        elms = tmp.querySelectorAll('[data-html-1], [data-html-2], [data-html-3], [data-html-4], [data-html-5], [data-html-6], [data-html-7], [data-html-8], [data-html-9], [data-html-10]');
        elms.forEach(elm => {
          elm.removeAttribute('data-html-1');
          elm.removeAttribute('data-html-2');
          elm.removeAttribute('data-html-3');
          elm.removeAttribute('data-html-4');
          elm.removeAttribute('data-html-5');
          elm.removeAttribute('data-html-6');
          elm.removeAttribute('data-html-7');
          elm.removeAttribute('data-html-8');
          elm.removeAttribute('data-html-9');
          elm.removeAttribute('data-html-10');
        });
      }

      // freeform
      elms = tmp.querySelectorAll('.is-block .handle, .is-block .rotate-handle');
      dom.removeElements(elms);
      elms = tmp.querySelectorAll('.is-block');
      Array.prototype.forEach.call(elms, elm => {
        dom.removeClass(elm, 'active');
        dom.removeClass(elm, 'multi');
        dom.removeClass(elm, 'editable');
        dom.removeClass(elm, 'fluid');
        dom.removeClass(elm, 'cloned');
        elm.removeAttribute('data-fluid-val');
        elm.removeAttribute('data-fluid');
        elm.removeAttribute('data-prev');
      });
      tmp.querySelectorAll('.is-block.clone').forEach(elm => elm.parentNode.removeChild(elm));
      // tmp.querySelectorAll('.is-block.cloned').forEach(elm=>elm.classList.remove('cloned'));

      html = tmp.innerHTML.trim();
      html = html.replace(/<font/g, '<span').replace(/<\/font/g, '</span');
    }

    // elm = builderStuff.querySelector('#tmp_content');
    // if(elm) builderStuff.removeChild(elm);
    // elm = builderStuff.querySelector('#tmp_buildercontent');
    // if(elm) builderStuff.removeChild(elm);

    // return html;
    let beautify = JsBeautify.html;
    html = beautify(html);
    // https://stackoverflow.com/questions/22962220/remove-multiple-line-breaks-n-in-javascript
    // html = html.replace(/(\r\n|\r|\n){2}/g, '$1').replace(/(\r\n|\r|\n){3,}/g, '$1\n')
    html = html.replace(/(\r\n|\r|\n){3,}/g, '$1\n');
    return html;
  }
  beautify(html) {
    let beautify = JsBeautify.html;
    html = beautify(html);
    html = html.replace(/(\r\n|\r|\n){3,}/g, '$1\n');
    return html;
  }
}

// import HtmlUtil from './html.js';

class UndoRedo {
  constructor(builder) {
    this.builder = builder;
    const dom = this.builder.dom;
    this.dom = dom;
    this.undoList = [];
  }
  readStyles() {
    if (this.builder.opts.undoContainerOnly) return '';
    let css = '';
    let i, src;
    let links = this.builder.doc.getElementsByTagName('link');
    for (i = 0; i < links.length; i++) {
      src = links[i].href.toLowerCase();
      if (src.indexOf('basetype-') !== -1) {
        css += links[i].outerHTML;
      }
    }
    links = this.builder.doc.getElementsByTagName('link');
    for (i = 0; i < links.length; i++) {
      src = links[i].href.toLowerCase();
      if (src.indexOf('basetype-') !== -1) ; else if (src.indexOf('type-') !== -1) {
        css += links[i].outerHTML;
      }
    }
    return css;
  }
  writeStyles(styles) {
    const dom = this.dom;
    if (this.builder.opts.undoContainerOnly) return;
    let i, src;
    let links = this.builder.doc.getElementsByTagName('link');
    for (i = 0; i < links.length; i++) {
      src = links[i].href.toLowerCase();
      if (src.indexOf('basetype-') !== -1) {
        links[i].parentNode.removeChild(links[i]);
      } else if (src.indexOf('type-') !== -1) {
        links[i].parentNode.removeChild(links[i]);
      }
    }
    let head = this.builder.doc.getElementsByTagName('head')[0];
    dom.appendHtml(head, styles);
  }
  readHtml() {
    // const htmlutil = new HtmlUtil(this.builder); 
    if (this.builder.opts.page !== '' && !this.builder.opts.undoContainerOnly) {
      let wrapper = this.builder.doc.querySelector(this.builder.opts.page);
      // return htmlutil.readHtml(wrapper, false);
      return wrapper.innerHTML;
    } else if (this.builder.docContainer) {
      let docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      return docContainer.innerHTML;
    } else {
      const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
      let html = '';
      Array.prototype.forEach.call(builders, builder => {
        // if(html==='') {
        //     html = htmlutil.readHtml(builder, false);
        // } else {
        //     html+= '####|####' + htmlutil.readHtml(builder, false);
        // }
        // html += htmlutil.readHtml(builder, false) + '####|####'; //new
        html += builder.innerHTML + '####|####'; //new
      });

      html = html.substr(0, html.length - 9); //new
      return html;
    }
  }
  cleaning(tmp) {
    // See html.js readHtml's cleaning
    const dom = this.dom;
    let builders = tmp.querySelectorAll('.is-builder');
    Array.prototype.forEach.call(builders, builder => {
      builder.removeAttribute('data-sort');
    });
    let elms = tmp.querySelectorAll('[data-click]');
    dom.removeAttributes(elms, 'data-click');
    dom.removeElements(tmp.querySelectorAll('.is-row-tool'));
    dom.removeElements(tmp.querySelectorAll('.is-rowadd-tool'));
    dom.removeElements(tmp.querySelectorAll('.is-col-tool'));
    dom.removeElements(tmp.querySelectorAll('.is-canvas-tool'));
    dom.removeElements(tmp.querySelectorAll('.is-canvasadd-tool'));
    dom.removeElements(tmp.querySelectorAll('.ovl'));
    dom.removeElements(tmp.querySelectorAll('.row-add-initial'));
    dom.removeElements(tmp.querySelectorAll('.h-ruler'));
    dom.removeElements(tmp.querySelectorAll('.v-ruler'));

    // freeform
    elms = tmp.querySelectorAll('.is-block .handle, .is-block .rotate-handle');
    dom.removeElements(elms);
    elms = tmp.querySelectorAll('.is-block');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'active');
      dom.removeClass(elm, 'multi');
      dom.removeClass(elm, 'editable');
      dom.removeClass(elm, 'fluid');
      dom.removeClass(elm, 'cloned');
      elm.removeAttribute('data-fluid-val');
      elm.removeAttribute('data-fluid');
      elm.removeAttribute('data-prev');
    });
    tmp.querySelectorAll('.is-block.clone').forEach(elm => elm.parentNode.removeChild(elm));
    // tmp.querySelectorAll('.is-block.cloned').forEach(elm=>elm.classList.remove('cloned'));

    //ContentBox
    elms = tmp.querySelectorAll('.is-section-tool');
    dom.removeElements(elms);
  }
  writeHtml(html) {
    if (this.builder.opts.page !== '' && !this.builder.opts.undoContainerOnly) {
      let wrapper = this.builder.doc.querySelector(this.builder.opts.page);

      // wrapper.innerHTML = html;

      // Use createContextualFragment() to make embedded script executable
      // https://ghinda.net/article/script-tags/
      let range = document.createRange();
      wrapper.innerHTML = '';
      wrapper.appendChild(range.createContextualFragment(html));

      // applyBehavior (in ContentBox, unUndo will call pageSetup/applyBehavior)
      this.cleaning(wrapper);
    } else if (this.builder.docContainer) {
      let docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      let range = document.createRange();
      docContainer.innerHTML = '';
      docContainer.appendChild(range.createContextualFragment(html));
      this.cleaning(docContainer);
    } else {
      const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
      let n = 0;
      Array.prototype.forEach.call(builders, builder => {
        // builder.innerHTML = html.split('####|####')[n];

        // Use createContextualFragment() to make embedded script executable
        // https://ghinda.net/article/script-tags/
        var range = document.createRange();
        builder.innerHTML = '';
        builder.appendChild(range.createContextualFragment(html.split('####|####')[n]));

        // applyBehavior
        this.cleaning(builder);
        this.builder.applyBehaviorOn(builder);
        n++;
      });
    }
    this.builder.opts.onRender();
  }
  saveForUndo(checkLater) {
    if (this.builder.onBeforeSaveForUndo) this.builder.onBeforeSaveForUndo();
    if (this.builder.undoRedoStyles) {
      if (this.undoList[120]) {
        let saves = this.undoList[120][0];
        let html = saves.split('###$###')[1];

        // Styles doesn't need to be checked. saveForUndoCheck is true only after colorpicker or gradient picker opened
        // (because after opened, user may not make changes, so checking for content change is needed).
        // This relates to html content, not styles. So we always check html content, not styles. 

        if (this.builder.saveForUndoCheck) {
          if (html === this.readHtml()) {
            // no change
            // console.log('no change');

            if (checkLater === true) this.builder.saveForUndoCheck = true;else this.builder.saveForUndoCheck = false;
            return;
          }
        }
      }
    } else {
      if (this.undoList[120]) {
        let html = this.undoList[120][0];
        if (this.builder.saveForUndoCheck) {
          if (html === this.readHtml()) {
            // no change
            // console.log('no change');

            if (checkLater === true) this.builder.saveForUndoCheck = true;else this.builder.saveForUndoCheck = false;
            return;
          }
        }
      }
    }
    if (checkLater === true) this.builder.saveForUndoCheck = true;else this.builder.saveForUndoCheck = false;

    // console.log('save');

    this.undoList[140] = this.undoList[139]; // addition
    this.undoList[139] = this.undoList[138];
    this.undoList[138] = this.undoList[137];
    this.undoList[137] = this.undoList[136];
    this.undoList[136] = this.undoList[135];
    this.undoList[135] = this.undoList[134];
    this.undoList[134] = this.undoList[133];
    this.undoList[133] = this.undoList[132];
    this.undoList[132] = this.undoList[131];
    this.undoList[131] = this.undoList[130];
    this.undoList[130] = this.undoList[129];
    this.undoList[129] = this.undoList[128];
    this.undoList[128] = this.undoList[127];
    this.undoList[127] = this.undoList[126];
    this.undoList[126] = this.undoList[125];
    this.undoList[125] = this.undoList[124];
    this.undoList[124] = this.undoList[123];
    this.undoList[123] = this.undoList[122];
    this.undoList[122] = this.undoList[121];
    this.undoList[121] = this.undoList[120];
    if (this.builder.undoRedoStyles) {
      let styles = this.readStyles();
      let html = this.readHtml();
      let saves = ' ' + styles + '###$###' + html;
      this.undoList[120] = [saves, null];
    } else {
      this.undoList[120] = [this.readHtml(), null];
    }
  }
  doUndo() {
    const dom = this.dom;
    if (!this.undoList[120]) return;
    if (this.builder.undoRedoInProcess === true) return; // do not precess if previous operation is still running

    // console.log('undo');

    this.builder.undoRedoInProcess = true;
    this.undoList[99] = this.undoList[100];
    this.undoList[100] = this.undoList[101];
    this.undoList[101] = this.undoList[102];
    this.undoList[102] = this.undoList[103];
    this.undoList[103] = this.undoList[104];
    this.undoList[104] = this.undoList[105];
    this.undoList[105] = this.undoList[106];
    this.undoList[106] = this.undoList[107];
    this.undoList[107] = this.undoList[108];
    this.undoList[108] = this.undoList[109];
    this.undoList[109] = this.undoList[110];
    this.undoList[110] = this.undoList[111];
    this.undoList[111] = this.undoList[112];
    this.undoList[112] = this.undoList[113];
    this.undoList[113] = this.undoList[114];
    this.undoList[114] = this.undoList[115];
    this.undoList[115] = this.undoList[116];
    this.undoList[116] = this.undoList[117];
    this.undoList[117] = this.undoList[118];
    this.undoList[118] = this.undoList[119];
    if (this.builder.undoRedoStyles) {
      let styles = this.readStyles();
      let html = this.readHtml();
      let saves = ' ' + styles + '###$###' + html;
      this.undoList[119] = [saves, null];

      // -

      saves = this.undoList[120][0];
      styles = saves.split('###$###')[0].trim();
      html = saves.split('###$###')[1];
      this.writeStyles(styles);
      this.writeHtml(html);
    } else {
      this.undoList[119] = [this.readHtml(), null];
      let html = this.undoList[120][0];
      this.writeHtml(html);
    }
    this.builder.applyBehavior();
    this.builder.applyBehaviorCanvas();
    this.builder.opts.onChange();
    this.undoList[120] = this.undoList[121];
    this.undoList[121] = this.undoList[122];
    this.undoList[122] = this.undoList[123];
    this.undoList[123] = this.undoList[124];
    this.undoList[124] = this.undoList[125];
    this.undoList[125] = this.undoList[126];
    this.undoList[126] = this.undoList[127];
    this.undoList[127] = this.undoList[128];
    this.undoList[128] = this.undoList[129];
    this.undoList[129] = this.undoList[130];
    this.undoList[130] = this.undoList[131];
    this.undoList[131] = this.undoList[132];
    this.undoList[132] = this.undoList[133];
    this.undoList[133] = this.undoList[134];
    this.undoList[134] = this.undoList[135];
    this.undoList[135] = this.undoList[136];
    this.undoList[136] = this.undoList[137];
    this.undoList[137] = this.undoList[138];
    this.undoList[138] = this.undoList[139];
    this.undoList[139] = this.undoList[140];
    this.undoList[140] = this.undoList[141];
    const util = new Util(this.builder);
    util.clearActiveCell();
    util.clearAfterUndoRedo();
    let elm = this.builder.doc.querySelector('[data-saveforundo]');
    if (elm) {
      let panel = document.querySelector('.is-side.elementstyles');
      dom.addClass(panel, 'active');
      setTimeout(() => {
        elm.click();
      }, 700);
    } else {
      let panel = document.querySelector('.is-side.elementstyles');
      dom.removeClass(panel, 'active');
    }
    if (this.builder.opts.onUndo) {
      this.builder.opts.onUndo();
    }
    this.builder.undoRedoInProcess = false;
  }
  doRedo() {
    const dom = this.dom;
    if (!this.undoList[119]) return;
    if (this.builder.undoRedoInProcess === true) return; // do not precess if previous operation is still running

    // console.log('redo');

    this.builder.undoRedoInProcess = true;
    this.undoList[141] = this.undoList[140];
    this.undoList[140] = this.undoList[139];
    this.undoList[139] = this.undoList[138];
    this.undoList[138] = this.undoList[137];
    this.undoList[137] = this.undoList[136];
    this.undoList[136] = this.undoList[135];
    this.undoList[135] = this.undoList[134];
    this.undoList[134] = this.undoList[133];
    this.undoList[133] = this.undoList[132];
    this.undoList[132] = this.undoList[131];
    this.undoList[131] = this.undoList[130];
    this.undoList[130] = this.undoList[129];
    this.undoList[129] = this.undoList[128];
    this.undoList[128] = this.undoList[127];
    this.undoList[127] = this.undoList[126];
    this.undoList[126] = this.undoList[125];
    this.undoList[125] = this.undoList[124];
    this.undoList[124] = this.undoList[123];
    this.undoList[123] = this.undoList[122];
    this.undoList[122] = this.undoList[121];
    this.undoList[121] = this.undoList[120];
    if (this.builder.undoRedoStyles) {
      let styles = this.readStyles();
      let html = this.readHtml();
      let saves = ' ' + styles + '###$###' + html;
      this.undoList[120] = [saves, null];

      // -

      saves = this.undoList[119][0];
      styles = saves.split('###$###')[0].trim();
      html = saves.split('###$###')[1];
      this.writeStyles(styles);
      this.writeHtml(html);
    } else {
      this.undoList[120] = [this.readHtml(), null];
      let html = this.undoList[119][0];
      this.writeHtml(html);
    }
    this.builder.applyBehavior();
    this.builder.applyBehaviorCanvas();
    this.builder.opts.onChange();
    this.undoList[119] = this.undoList[118];
    this.undoList[118] = this.undoList[117];
    this.undoList[117] = this.undoList[116];
    this.undoList[116] = this.undoList[115];
    this.undoList[115] = this.undoList[114];
    this.undoList[114] = this.undoList[113];
    this.undoList[113] = this.undoList[112];
    this.undoList[112] = this.undoList[111];
    this.undoList[111] = this.undoList[110];
    this.undoList[110] = this.undoList[109];
    this.undoList[109] = this.undoList[108];
    this.undoList[108] = this.undoList[107];
    this.undoList[107] = this.undoList[106];
    this.undoList[106] = this.undoList[105];
    this.undoList[105] = this.undoList[104];
    this.undoList[104] = this.undoList[103];
    this.undoList[103] = this.undoList[102];
    this.undoList[102] = this.undoList[101];
    this.undoList[101] = this.undoList[100];
    this.undoList[100] = this.undoList[99];
    this.undoList[99] = null;
    const util = new Util(this.builder);
    util.clearActiveCell();
    util.clearAfterUndoRedo();
    let elm = this.builder.doc.querySelector('[data-saveforundo]');
    if (elm) {
      let panel = document.querySelector('.is-side.elementstyles');
      dom.addClass(panel, 'active');
      setTimeout(() => {
        elm.click();
      }, 700);
    } else {
      let panel = document.querySelector('.is-side.elementstyles');
      dom.removeClass(panel, 'active');
    }
    if (this.builder.opts.onRedo) {
      this.builder.opts.onRedo();
    }
    this.builder.undoRedoInProcess = false;
  }
}

/*!
Ionicons
License: MIT
Copyright (c) 2015-present Ionic (http://ionic.io/)
https://ionic.io/ionicons/v1
*/

/*!
Tabler Icons
License: MIT
Copyright (c) 2020 Pawe Kuna
https://github.com/tabler/tabler-icons
*/

const prepareSvgIcons = builder => {
  const html = `<svg width="0" height="0" style="position:absolute;display:none;">
        <defs>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-left"><path d="M352 115.4L331.3 96 160 256l171.3 160 20.7-19.3L201.5 256z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-right"><path d="M160 115.4L180.7 96 352 256 180.7 416 160 396.7 310.5 256z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-plus-outline"><path d="M256 48C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48zm0 398.7c-105.1 0-190.7-85.5-190.7-190.7S150.9 65.3 256 65.3 446.7 150.9 446.7 256 361.1 446.7 256 446.7z"></path><path d="M264.1 128h-16.8v119.9H128v16.8h119.3V384h16.8V264.7H384v-16.8H264.1z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-image"><path d="M368 224c26.5 0 48-21.5 48-48s-21.5-48-48-48-48 21.5-48 48 21.5 48 48 48z"></path><path d="M452 64H60c-15.6 0-28 12.7-28 28.3v327.4c0 15.6 12.4 28.3 28 28.3h392c15.6 0 28-12.7 28-28.3V92.3c0-15.6-12.4-28.3-28-28.3zM348.9 261.7c-3-3.5-7.6-6.2-12.8-6.2-5.1 0-8.7 2.4-12.8 5.7L304.6 277c-3.9 2.8-7 4.7-11.5 4.7-4.3 0-8.2-1.6-11-4.1-1-.9-2.8-2.6-4.3-4.1L224 215.3c-4-4.6-10-7.5-16.7-7.5-6.7 0-12.9 3.3-16.8 7.8L64 368.2V107.7c1-6.8 6.3-11.7 13.1-11.7h357.7c6.9 0 12.5 5.1 12.9 12l.3 260.4-99.1-106.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-photos-outline"><path d="M96 128v320h384V128H96zm368 304H112V144h352v288z"></path><path d="M32 64v320h48v-16H48V80h352v32h16V64z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-settings-strong"><path d="M32 376h283.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32h-91.35c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32M32 240h91.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32H196.65c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32M32 104h283.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32h-91.35c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-settings"><path d="M352 104c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM352 376c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM160 240c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM207.32 248H480v16H207.32c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM112 256c0 2.727.24 5.396.68 8H32v-16h80.68a47.955 47.955 0 0 0-.68 8zM399.32 384H480v16h-80.68c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM304 392c0 2.727.24 5.396.68 8H32v-16h272.68a47.955 47.955 0 0 0-.68 8zM399.32 112H480v16h-80.68c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM304.68 112c-.439 2.604-.68 5.273-.68 8s.24 5.396.68 8H32v-16h272.68z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-options"><path d="M32 384h272v32H32zM400 384h80v32h-80zM384 447.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path><g><path d="M32 240h80v32H32zM208 240h272v32H208zM192 303.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path></g><g><path d="M32 96h272v32H32zM400 96h80v32h-80zM384 159.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-list-number"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-1043.45,1024 C-1039.25,946.283 -1023.18,878.648 -995.249,821.096 C-967.313,763.544 -912.806,711.242 -831.728,664.192 L-710.742,594.247 C-656.55,562.74 -618.532,535.854 -596.687,513.589 C-562.24,478.722 -545.016,438.813 -545.016,393.863 C-545.016,341.352 -560.769,299.658 -592.276,268.781 C-623.783,237.904 -665.792,222.466 -718.304,222.466 C-796.02,222.466 -849.792,251.873 -879.619,310.685 C-895.582,342.192 -904.404,385.882 -906.084,441.754 L-1021.4,441.754 C-1020.14,363.197 -1005.65,299.133 -977.92,249.562 C-928.769,162.183 -842.02,118.494 -717.673,118.494 C-614.331,118.494 -538.82,146.43 -491.139,202.302 C-443.459,258.174 -419.619,320.347 -419.619,388.822 C-419.619,461.078 -445.034,522.831 -495.865,574.082 C-525.272,603.909 -577.993,640.037 -654.03,682.466 L-740.358,730.356 C-781.527,753.041 -813.874,774.676 -837.399,795.26 C-879.408,831.808 -905.874,872.347 -916.797,916.877 L-424.03,916.877 L-424.03,1024 L-1043.45,1024 Z "  /><path d="M-922.391,-764.384 L-922.391,-851.343 C-840.474,-859.324 -783.341,-872.662 -750.994,-891.356 C-718.647,-910.05 -694.492,-954.265 -678.529,-1024 L-589.049,-1024 L-589.049,-125.425 L-710.035,-125.425 L-710.035,-764.384 L-922.391,-764.384 Z "  /><path d="M-198.618,-510.942 L-198.618,-667.156 L1004.57,-667.156 L1004.57,-510.942 L-198.618,-510.942 Z "  /><path d="M-198.618,78.1071 L-198.618,-78.1071 L1004.57,-78.1071 L1004.57,78.1071 L-198.618,78.1071 Z "  /><path d="M-179.185,649.354 L-179.185,493.14 L1024,493.14 L1024,649.354 L-179.185,649.354 Z "  /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-list-bullet"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-379.801,-514.33 L-379.801,-670.545 L914.662,-670.545 L914.662,-514.33 L-379.801,-514.33 Z "  /><path d="M-379.801,78.1071 L-379.801,-78.1071 L914.662,-78.1071 L914.662,78.1071 L-379.801,78.1071 Z "  /><path d="M-379.801,670.545 L-379.801,514.33 L914.662,514.33 L914.662,670.545 L-379.801,670.545 Z "  /><path d="M-929.642,-469.441 L-929.642,-715.434 L-669.092,-715.434 L-669.092,-469.441 L-929.642,-469.441 Z "  /><path d="M-929.642,127.109 L-929.642,-118.885 L-669.092,-118.885 L-669.092,127.109 L-929.642,127.109 Z "  /><path d="M-929.642,715.434 L-929.642,469.441 L-669.092,469.441 L-669.092,715.434 L-929.642,715.434 Z "  /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-clean">
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                    <path d="M75.0013,893.849 L-1030.73,900.993 L-32.1518,-880.838 L1009.54,-880.838 L75.0013,893.849 Z " fill="currentColor" />
                    <path d="M-30.8571,780.685 L-845.2,787.828 L-508.893,193.749 L305.26,194.963 L-30.8571,780.685 Z " fill="#ffffff" fill-opacity="1.00" />
                </g>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-location"><path d="M256 64c-65.9 0-119.3 53.7-119.3 120 0 114.6 119.3 264 119.3 264s119.3-149.4 119.3-264c0-66.3-53.4-120-119.3-120zm0 178.2c-31.2 0-56.4-25.4-56.4-56.7 0-31.3 25.3-56.8 56.4-56.8 31.2 0 56.4 25.4 56.4 56.8 0 31.3-25.2 56.7-56.4 56.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-film-outline"><path d="M0 360h400v-336h-400v336zM72 40v48h-56v-48h56zM72 104v48h-56v-48h56zM72 168v48h-56v-48h56zM72 232v48h-56v-48h56zM72 296v48h-56v-48h56zM312 40v144h-224v-144h224zM312 200v144h-224v-144h224zM384 40v48h-56v-48h56zM384 104v48h-56v-48h56zM384 168v48h-56v-48
                h56zM384 232v48h-56v-48h56zM384 296v48h-56v-48h56z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-social-youtube-outline"><path d="M265 96c65.3 0 118.7 1.1 168.1 3.3h1.4c23.1 0 42 22 42 49.1v1.1l.1 1.1c2.3 34 3.4 69.3 3.4 104.9.1 35.6-1.1 70.9-3.4 104.9l-.1 1.1v1.1c0 13.8-4.7 26.6-13.4 36.1-7.8 8.6-18 13.4-28.6 13.4h-1.6c-52.9 2.5-108.8 3.8-166.4 3.8h-10.6.1-10.9c-57.8 0-113.7-1.3-166.2-3.7h-1.6c-10.6 0-20.7-4.8-28.5-13.4-8.6-9.5-13.4-22.3-13.4-36.1v-1.1l-.1-1.1c-2.4-34.1-3.5-69.4-3.3-104.7v-.2c-.1-35.3 1-70.5 3.3-104.6l.1-1.1v-1.1c0-27.2 18.8-49.3 41.9-49.3h1.4c49.5-2.3 102.9-3.3 168.2-3.3H265m0-32.2h-18c-57.6 0-114.2.8-169.6 3.3-40.8 0-73.9 36.3-73.9 81.3C1 184.4-.1 220 0 255.7c-.1 35.7.9 71.3 3.4 107 0 45 33.1 81.6 73.9 81.6 54.8 2.6 110.7 3.8 167.8 3.8h21.6c57.1 0 113-1.2 167.9-3.8 40.9 0 74-36.6 74-81.6 2.4-35.7 3.5-71.4 3.4-107.1.1-35.7-1-71.3-3.4-107.1 0-45-33.1-81.1-74-81.1C379.2 64.8 322.7 64 265 64z"></path><path d="M207 353.8V157.4l145 98.2-145 98.2z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-play"><path d="M128 96v320l256-160L128 96z"></path></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-full"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-770.219,-115.563 L-770.219,-271.777 L770.219,-271.777 L770.219,-115.563 L-770.219,-115.563 Z " /><path d="M-770.219,303.503 L-770.219,147.288 L770.219,147.288 L770.219,303.503 L-770.219,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-center"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-552.286,-107.697 L-552.286,-263.911 L552.286,-263.911 L552.286,-107.697 L-552.286,-107.697 Z " /><path d="M-467.355,319.234 L-467.355,163.02 L466.34,163.02 L466.34,319.234 L-467.355,319.234 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-left"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-770.219,-115.563 L-770.219,-271.777 L482.839,-271.777 L482.839,-115.563 L-770.219,-115.563 Z " /><path d="M-770.219,303.503 L-770.219,147.288 L122.787,147.288 L122.787,303.503 L-770.219,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-right"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-483.346,-118.081 L-483.346,-274.295 L769.712,-274.295 L769.712,-118.081 L-483.346,-118.081 Z " /><path d="M-123.871,303.503 L-123.871,147.288 L769.136,147.288 L769.136,303.503 L-123.871,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-indent"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-829.04,-514.33 L-829.04,-670.545 L808.959,-670.545 L808.959,-514.33 L-829.04,-514.33 Z " /><path d="M-829.04,670.545 L-829.04,514.33 L808.959,514.33 L808.959,670.545 L-829.04,670.545 Z " /><path d="M-254.279,-110.244 L-254.279,-266.458 L808.959,-266.458 L808.959,-110.244 L-254.279,-110.244 Z " /><path d="M-254.279,266.458 L-254.279,110.244 L808.959,110.244 L808.959,266.458 L-254.279,266.458 Z " /><path d="M-829.04,-195.117 L-490.958,-1.03508e-14 L-829.04,195.117 L-829.04,-195.117 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-outdent"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-829.04,-514.33 L-829.04,-670.545 L808.959,-670.545 L808.959,-514.33 L-829.04,-514.33 Z " /><path d="M-829.04,670.545 L-829.04,514.33 L808.959,514.33 L808.959,670.545 L-829.04,670.545 Z " /><path d="M-829.04,-110.244 L-829.04,-266.458 L234.198,-266.458 L234.198,-110.244 L-829.04,-110.244 Z " /><path d="M-829.04,266.458 L-829.04,110.244 L234.198,110.244 L234.198,266.458 L-829.04,266.458 Z " /><path d="M808.959,-195.117 L470.877,-1.03508e-14 L808.959,195.117 L808.959,-195.117 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-table"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-660.783,660.783 L660.783,660.783 L660.783,-660.783 L-660.783,-660.783 L-660.783,660.783 Z " fill="none" stroke-width="75.82" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /><path d="M-37.9645,698.933 L37.9645,698.933 L37.9645,-698.569 L-37.9645,-698.569 L-37.9645,698.933 Z " fill="currentColor" fill-opacity="1.00" stroke-width="0.25" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /><path d="M-698.933,-37.7825 L-698.933,38.1465 L698.569,38.1465 L698.569,-37.7825 L-698.933,-37.7825 Z " fill="currentColor" fill-opacity="1.00" stroke-width="0.25" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-happy"><path d="M256 48C140.563 48 48 141.6 48 256s92.563 208 208 208 208-93.6 208-208S370.401 48 256 48zm0 374.4c-91.518 0-166.404-74.883-166.404-166.4 0-91.518 74.887-166.4 166.404-166.4S422.404 164.482 422.404 256 347.518 422.4 256 422.4zm72.8-187.2c17.683 0 31.201-13.518 31.201-31.2s-13.519-31.2-31.201-31.2c-17.682 0-31.2 13.518-31.2 31.2s13.518 31.2 31.2 31.2zm-145.6 0c17.682 0 31.2-13.518 31.2-31.2s-13.519-31.2-31.2-31.2c-17.683 0-31.201 13.518-31.201 31.2s13.519 31.2 31.201 31.2zM256 370.4c48.883 0 89.436-30.164 106.081-72.801H149.919C166.564 340.236 207.117 370.4 256 370.4z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-create"><path d="M64 368v80h80l235.727-235.729-79.999-79.998L64 368zm377.602-217.602c8.531-8.531 8.531-21.334 0-29.865l-50.135-50.135c-8.531-8.531-21.334-8.531-29.865 0l-39.468 39.469 79.999 79.998 39.469-39.467z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-minus-empty"><path d="M384 265H128v-17h256v17z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-eye"><path d="M256 128c-81.9 0-145.7 48.8-224 128 67.4 67.7 124 128 224 128 99.9 0 173.4-76.4 224-126.6C428.2 198.6 354.8 128 256 128zm0 219.3c-49.4 0-89.6-41-89.6-91.3 0-50.4 40.2-91.3 89.6-91.3s89.6 41 89.6 91.3c0 50.4-40.2 91.3-89.6 91.3z"></path><path d="M256 224c0-7.9 2.9-15.1 7.6-20.7-2.5-.4-5-.6-7.6-.6-28.8 0-52.3 23.9-52.3 53.3s23.5 53.3 52.3 53.3 52.3-23.9 52.3-53.3c0-2.3-.2-4.6-.4-6.9-5.5 4.3-12.3 6.9-19.8 6.9-17.8 0-32.1-14.3-32.1-32z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-reply"><path d="M448 400s-36.8-208-224-208v-80L64 256l160 134.4v-92.3c101.6 0 171 8.9 224 101.9z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-folder-outline">
                <path d="M457 96H215c-2.791 0-4.271-.585-6.094-2.408l-22.501-22.501-.168-.162C181.365 66.333 177.361 64 169 64H57c-13.785 0-25 10.317-25 23v336c0 13.317 11.683 25 25 25h400c12.683 0 23-11.215 23-25V119c0-13.327-9.673-23-23-23zM57 80h112c3.497 0 3.737.189 6.175 2.488l22.417 22.418c4.84 4.84 10.372 7.094 17.408 7.094h242c4.448 0 7 2.552 7 7v42.376a23.885 23.885 0 0 0-8-1.376H56c-2.805 0-5.496.488-8 1.376V87c0-4.323 4.672-7 9-7zm407 343c0 4.328-2.677 9-7 9H57c-4.458 0-9-4.542-9-9V184c0-4.411 3.589-8 8-8h400c4.411 0 8 3.589 8 8v239z"/>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-cloud-outline">
                <path d="M399.3 232.8c0-1.2.2-2.4.2-3.6 0-64.3-52.8-117.2-116.8-117.2-46.1 0-85.8 27.9-104.4 67-8.1-4.1-17.1-6.4-26.8-6.4-29.6 0-54.1 23.7-58.9 52C57.4 236.8 32 268.8 32 308.4c0 49.8 40.1 91.6 89.6 91.6H398c45 0 82-38.9 82-84.3 0-45.6-35.4-82.8-80.7-82.9zm-1.8 150.8l-3.2.4H122.4c-40.9 0-74.2-34.9-74.2-76.1 0-31.9 20.2-58.4 50.2-68.8l8.4-3 1.5-8.8c3.6-21.6 22.1-39.3 43.9-39.3 6.9 0 13.7 1.6 19.9 4.8l13.5 6.8 6.5-13.7c16.6-34.9 52.1-58.2 90.4-58.2 55.3 0 100.9 44.1 100.9 99.7 0 13.3-.2 20.3-.2 20.3l15.2.1c36.7.5 65.6 30.5 65.6 67.4 0 36.9-29.8 68.2-66.5 68.4z"/>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-wrench"><path d="M461.9 114.9l-56.5 56.7-55.1-10-9.9-55.1 56.5-56.7c-12.7-12.7-30.8-18.5-44.2-17.8-13.5.7-42.3 8.3-64.6 32-21.6 22.8-44.3 65.3-24.2 112.5 2.4 5.7 5.1 13.2-2.9 21.2-8.1 8-215 202.8-215 202.8-19.4 16.7-18 47.6-.1 65.6 18.2 17.9 48.9 19 65.6-.3 0 0 193.2-205.8 202.7-215.1 8.5-8.3 16.1-5.5 21.2-2.9 35.6 18.4 86.3 2.4 112.6-23.9 26.3-26.3 31.1-51.7 31.9-64.7.8-12.9-3.7-30-18-44.3zM91.3 443.2c-6.3 6.2-16.5 6.2-22.7 0-6.2-6.3-6.2-16.5 0-22.7 6.3-6.2 16.5-6.2 22.7 0 6.2 6.3 6.2 16.5 0 22.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-more"><path d="M113.7 304C86.2 304 64 282.6 64 256c0-26.5 22.2-48 49.7-48 27.6 0 49.8 21.5 49.8 48 0 26.6-22.2 48-49.8 48zM256 304c-27.5 0-49.8-21.4-49.8-48 0-26.5 22.3-48 49.8-48 27.5 0 49.7 21.5 49.7 48 0 26.6-22.2 48-49.7 48zM398.2 304c-27.5 0-49.8-21.4-49.8-48 0-26.5 22.2-48 49.8-48 27.5 0 49.8 21.5 49.8 48 0 26.6-22.2 48-49.8 48z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-code-working"><circle cx="184.166" cy="256.166" r="24"></circle><circle cx="256.166" cy="256.166" r="24"></circle><circle cx="328.166" cy="256.166" r="24"></circle><g><path d="M168 392a23.929 23.929 0 0 1-16.971-7.029l-112-112c-9.373-9.373-9.373-24.569 0-33.941l112-112c9.373-9.372 24.568-9.372 33.941 0 9.371 9.372 9.371 24.568 0 33.941L89.941 256l95.029 95.029c9.371 9.372 9.371 24.568 0 33.941A23.925 23.925 0 0 1 168 392zM344 392a23.929 23.929 0 0 0 16.971-7.029l112-112c9.373-9.373 9.373-24.569 0-33.941l-112-112c-9.373-9.372-24.568-9.372-33.941 0-9.371 9.372-9.371 24.568 0 33.941L422.059 256l-95.029 95.029c-9.371 9.372-9.371 24.568 0 33.941A23.925 23.925 0 0 0 344 392z"></path></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-gear"><path d="M416.349 256.046c-.001-21.013 13.143-38.948 31.651-46.062a196.302 196.302 0 0 0-23.664-57.139 49.423 49.423 0 0 1-20.082 4.254c-12.621 0-25.238-4.811-34.871-14.442-14.863-14.863-18.248-36.846-10.18-54.97A196.274 196.274 0 0 0 302.074 64C294.971 82.529 277.027 95.69 256 95.69c-21.025 0-38.969-13.161-46.073-31.69a196.243 196.243 0 0 0-57.128 23.688c8.068 18.122 4.683 40.104-10.181 54.97-9.631 9.631-22.25 14.443-34.871 14.443a49.429 49.429 0 0 1-20.083-4.255A196.273 196.273 0 0 0 64 209.984c18.509 7.112 31.652 25.049 31.652 46.062 0 21.008-13.132 38.936-31.63 46.054a196.318 196.318 0 0 0 23.692 57.128 49.428 49.428 0 0 1 20.032-4.232c12.622 0 25.239 4.812 34.871 14.443 14.841 14.841 18.239 36.781 10.215 54.889a196.257 196.257 0 0 0 57.13 23.673c7.128-18.479 25.046-31.596 46.038-31.596 20.992 0 38.91 13.115 46.037 31.596a196.234 196.234 0 0 0 57.132-23.675c-8.023-18.106-4.626-40.046 10.216-54.887 9.629-9.632 22.248-14.444 34.868-14.444 6.836 0 13.67 1.411 20.033 4.233a196.318 196.318 0 0 0 23.692-57.128c-18.498-7.119-31.629-25.048-31.629-46.054zM256.9 335.9c-44.3 0-80-35.9-80-80 0-44.101 35.7-80 80-80 44.299 0 80 35.899 80 80 0 44.1-35.701 80-80 80z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-arrow-expand"><path d="M274 209.7l63.9-63.8L288 96h128v128l-49.9-49.9-63.8 63.9zM274 302.3l63.9 63.8L288 416h128V288l-49.9 49.9-63.8-63.9zM238 302.3l-63.9 63.8L224 416H96V288l49.9 49.9 63.8-63.9zM238 209.7l-63.9-63.8L224 96H96v128l49.9-49.9 63.8 63.9z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-expand"><path d="M396.795 396.8H320V448h128V320h-51.205zM396.8 115.205V192H448V64H320v51.205zM115.205 115.2H192V64H64v128h51.205zM115.2 396.795V320H64v128h128v-51.205z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-arrow-move"><path d="M480 256l-96-96v76H276V128h76l-96-96-96 96h76v108H128v-76l-96 96 96 96v-76h108v108h-76l96 96 96-96h-76.2l-.4-108.5 108.6.3V352z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-drag"><path d="M0 144h512v32H0zM0 240h512v32H0zM0 336h512v32H0z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-link"><path d="M74.6 256c0-38.3 31.1-69.4 69.4-69.4h88V144h-88c-61.8 0-112 50.2-112 112s50.2 112 112 112h88v-42.6h-88c-38.3 0-69.4-31.1-69.4-69.4zm85.4 22h192v-44H160v44zm208-134h-88v42.6h88c38.3 0 69.4 31.1 69.4 69.4s-31.1 69.4-69.4 69.4h-88V368h88c61.8 0 112-50.2 112-112s-50.2-112-112-112z"/></symbol>
            <symbol viewBox="0 0 512 512" id="ion-contrast"><path d="M256 32C132.3 32 32 132.3 32 256s100.3 224 224 224 224-100.3 224-224S379.7 32 256 32zm135.8 359.8C355.5 428 307 448 256 448V64c51 0 99.5 20 135.8 56.2C428 156.5 448 204.7 448 256c0 51.3-20 99.5-56.2 135.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-plus-empty"><path d="M384 265H264v119h-17V265H128v-17h119V128h17v120h120v17z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-up"><path d="M349.7 189.8c-3.1 3.1-8 3-11.3 0L264 123.4V408c0 4.4-3.6 8-8 8s-8-3.6-8-8V123.4l-74.4 66.3c-3.4 2.9-8.1 3.2-11.2.1-3.1-3.1-3.3-8.5-.1-11.4 0 0 87-79.2 88-80s2.8-2.4 5.7-2.4 4.9 1.6 5.7 2.4 88 80 88 80c1.5 1.5 2.3 3.6 2.3 5.7s-.8 4.1-2.3 5.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-down"><path d="M349.7 322.2c-3.1-3.1-8-3-11.3 0L264 388.6V104c0-4.4-3.6-8-8-8s-8 3.6-8 8v284.6l-74.4-66.3c-3.4-2.9-8.1-3.2-11.2-.1-3.1 3.1-3.3 8.5-.1 11.4 0 0 87 79.2 88 80s2.8 2.4 5.7 2.4 4.9-1.6 5.7-2.4 88-80 88-80c1.5-1.5 2.3-3.6 2.3-5.7s-.8-4.1-2.3-5.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-left"><path d="M189.8 349.7c3.1-3.1 3-8 0-11.3L123.4 264H408c4.4 0 8-3.6 8-8s-3.6-8-8-8H123.4l66.3-74.4c2.9-3.4 3.2-8.1.1-11.2-3.1-3.1-8.5-3.3-11.4-.1 0 0-79.2 87-80 88S96 253.1 96 256s1.6 4.9 2.4 5.7 80 88 80 88c1.5 1.5 3.6 2.3 5.7 2.3s4.1-.8 5.7-2.3z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-right"><path d="M322.2 349.7c-3.1-3.1-3-8 0-11.3l66.4-74.4H104c-4.4 0-8-3.6-8-8s3.6-8 8-8h284.6l-66.3-74.4c-2.9-3.4-3.2-8.1-.1-11.2 3.1-3.1 8.5-3.3 11.4-.1 0 0 79.2 87 80 88s2.4 2.8 2.4 5.7-1.6 4.9-2.4 5.7-80 88-80 88c-1.5 1.5-3.6 2.3-5.7 2.3s-4.1-.8-5.7-2.3z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-close-empty"><path d="M340.2 160l-84.4 84.3-84-83.9-11.8 11.8 84 83.8-84 83.9 11.8 11.7 84-83.8 84.4 84.2 11.8-11.7-84.4-84.3 84.4-84.2z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-more-vertical"><path d="M296 136c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0 240c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0-120c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-quote"><path d="M192 64c-40.646 0-72.483 11.229-94.627 33.373C75.229 119.517 64 151.354 64 192v256h160V192h-96c0-23.056 4.922-39.666 14.627-49.373C152.334 132.922 168.944 128 192 128M416 64c-40.646 0-72.483 11.229-94.627 33.373C299.229 119.517 288 151.354 288 192v256h160V192h-96c0-23.056 4.922-39.666 14.627-49.373C376.334 132.922 392.944 128 416 128"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-code"><path d="M168 392a23.929 23.929 0 0 1-16.971-7.029l-112-112c-9.373-9.373-9.373-24.569 0-33.941l112-112c9.373-9.372 24.568-9.372 33.941 0 9.371 9.372 9.371 24.568 0 33.941L89.941 256l95.029 95.029c9.371 9.373 9.371 24.568 0 33.941A23.925 23.925 0 0 1 168 392zM344 392a23.929 23.929 0 0 0 16.971-7.029l112-112c9.373-9.373 9.373-24.569 0-33.941l-112-112c-9.373-9.372-24.568-9.372-33.941 0-9.371 9.372-9.371 24.568 0 33.941L422.059 256l-95.029 95.029c-9.371 9.373-9.371 24.568 0 33.941A23.925 23.925 0 0 0 344 392z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-camera"><path d="M430.4 147h-67.5l-40.4-40.8s-.2-.2-.3-.2l-.2-.2c-6-6-14.1-9.8-23.3-9.8h-84c-9.8 0-18.5 4.2-24.6 10.9v.1l-39.5 40h-69C63 147 48 161.6 48 180.2v202.1c0 18.6 15 33.7 33.6 33.7h348.8c18.5 0 33.6-15.1 33.6-33.7V180.2c0-18.6-15.1-33.2-33.6-33.2zM256 365.5c-50.9 0-92.4-41.6-92.4-92.6 0-51.1 41.5-92.6 92.4-92.6 51 0 92.4 41.5 92.4 92.6 0 51-41.4 92.6-92.4 92.6zm168.1-165c-7.7 0-14-6.3-14-14.1s6.3-14.1 14-14.1 14 6.3 14 14.1-6.3 14.1-14 14.1z"></path><path d="M256 202.9c-38.6 0-69.8 31.3-69.8 70 0 38.6 31.2 70 69.8 70 38.5 0 69.8-31.3 69.8-70s-31.3-70-69.8-70z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-move"><path d="M475.9 246.2l-79.4-79.4c-5.4-5.4-14.2-5.4-19.6 0l-.2.2c-5.4 5.4-5.4 14.2 0 19.6l54.9 54.9-161.8.5.5-161.8 54.9 54.9c5.4 5.4 14.2 5.4 19.6 0l.2-.2c5.4-5.4 5.4-14.2 0-19.6l-79.4-79.4c-5.4-5.4-14.2-5.4-19.6 0l-79.4 79.4c-5.4 5.4-5.4 14.2 0 19.6l.2.2c5.4 5.4 14.2 5.4 19.6 0l54.9-54.9.5 161.8-161.8-.5 54.9-54.9c5.4-5.4 5.4-14.2 0-19.6l-.2-.2c-5.4-5.4-14.2-5.4-19.6 0l-79.4 79.4c-5.4 5.4-5.4 14.2 0 19.6l79.4 79.4c5.4 5.4 14.2 5.4 19.6 0l.2-.2c5.4-5.4 5.4-14.2 0-19.6L80 270.5l161.8-.5-.5 161.8-54.9-54.9c-5.4-5.4-14.2-5.4-19.6 0l-.2.2c-5.4 5.4-5.4 14.2 0 19.6l79.4 79.4c5.4 5.4 14.2 5.4 19.6 0l79.4-79.4c5.4-5.4 5.4-14.2 0-19.6l-.2-.2c-5.4-5.4-14.2-5.4-19.6 0l-54.9 54.9-.5-161.8 161.8.5-54.9 54.9c-5.4 5.4-5.4 14.2 0 19.6l.2.2c5.4 5.4 14.2 5.4 19.6 0l79.4-79.4c5.5-5.4 5.5-14.2 0-19.6z"/></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-ok">
                <rect x="0" y="0" width="2048.00" height="2048.00" fill="none" />
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                <path d="M330.323,493.628 L330.323,398.406 L-330.323,398.406 L-330.323,493.628 L330.323,493.628 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M230.718,468.568 L328.59,468.568 L328.59,-599.718 L230.718,-599.718 L230.718,468.568 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M-300.714,376.053 L-373.748,449.088 L-68.5805,754.255 L4.45387,681.221 L-300.714,376.053 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M-9.9476e-14,216.241 L-73.0344,143.207 L-378.202,448.375 L-305.168,521.409 L-9.9476e-14,216.241 Z " fill="currentColor" fill-opacity="1.00" />
                </g>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-grid"><path d="M160 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path><g><path d="M160 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path></g><g><path d="M160 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-gear-b"><path d="M448 294.4v-76.8h-42.8c-3.4-14.4-8.9-28-16.1-40.5l29.8-29.7-54.3-54.3-29.1 29.1c-12.6-7.7-26.4-13.5-41.1-17.3V64h-76.8v40.9c-14.7 3.8-28.5 9.7-41.1 17.3l-29.1-29.1-54.3 54.3 29.8 29.7c-7.2 12.5-12.6 26.1-16.1 40.5H64v76.8h44.1c3.8 13.7 9.5 26.6 16.7 38.6l-31.7 31.7 54.3 54.3 32.3-32.3c11.7 6.8 24.5 11.9 37.9 15.4v46h76.8v-46c13.5-3.5 26.2-8.6 37.9-15.4l32.3 32.3 54.3-54.3-31.6-31.7c7.2-11.9 12.9-24.8 16.7-38.6h44zm-192 15.4c-29.7 0-53.7-24.1-53.7-53.8s24-53.8 53.7-53.8 53.8 24.1 53.8 53.8-24.1 53.8-53.8 53.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-grid-view-outline"><path d="M448 192v-16H336V64h-16v112H192V64h-16v112H64v16h112v128H64v16h112v112h16V336h128v112h16V336h112v-16H336V192h112zM320 320H192V192h128v128z"></path></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-increase"><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M852.574,595.004 L852.574,507.837 L-852.574,507.837 L-852.574,595.004 L852.574,595.004 Z " /><path d="M852.574,224.232 L852.574,137.066 L-852.574,137.066 L-852.574,224.232 L852.574,224.232 Z " /><path d="M852.574,-134.971 L852.574,-222.138 L-852.574,-222.138 L-852.574,-134.971 L852.574,-134.971 Z " /><path d="M852.574,-505.743 L852.574,-592.909 L-852.574,-592.909 L-852.574,-505.743 L852.574,-505.743 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-decrease"><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M509.832,595.004 L509.832,507.837 L-509.832,507.837 L-509.832,595.004 L509.832,595.004 Z " /><path d="M509.832,224.232 L509.832,137.066 L-509.832,137.066 L-509.832,224.232 L509.832,224.232 Z " /><path d="M509.832,-136.947 L509.832,-224.113 L-509.832,-224.113 L-509.832,-136.947 L509.832,-136.947 Z " /><path d="M509.832,-505.743 L509.832,-592.909 L-509.832,-592.909 L-509.832,-505.743 L509.832,-505.743 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-strike">
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                <path d="M298.298,-653.766 C292.151,-624.873 284.005,-605.663 273.862,-596.135 C263.719,-586.607 250.656,-581.842 234.673,-581.842 C220.535,-581.842 196.253,-589.526 161.828,-604.895 C87.4454,-637.475 17.0588,-653.766 -49.3321,-653.766 C-155.68,-653.766 -243.28,-621.339 -312.129,-556.485 C-380.979,-491.631 -415.404,-414.328 -415.404,-324.578 C-415.404,-272.94 -403.724,-225.606 -380.364,-182.575 C-357.005,-139.544 -322.733,-100.201 -277.551,-64.5467 C-232.368,-28.8923 -156.295,18.903 -49.3321,78.8392 C57.631,138.775 123.1,177.964 147.074,196.406 C182.729,223.455 209.008,252.654 225.913,284.005 C242.819,315.357 251.271,346.401 251.271,377.137 C251.271,432.463 228.987,480.412 184.419,520.984 C139.851,561.556 79.1465,581.842 2.30524,581.842 C-64.0856,581.842 -125.098,567.089 -180.731,537.582 C-236.364,508.075 -277.704,471.037 -304.753,426.469 C-331.801,381.901 -353.316,314.742 -369.299,224.991 L-403.417,224.991 L-403.417,653.766 L-369.299,653.766 C-364.996,624.873 -358.388,605.817 -349.474,596.596 C-340.561,587.375 -328.42,582.764 -313.051,582.764 C-297.068,582.764 -259.109,592.446 -199.173,611.81 C-139.236,631.174 -99.74,642.393 -80.6834,645.467 C-48.7174,651 -14.5998,653.766 21.6692,653.766 C137.239,653.766 231.753,619.495 305.214,550.952 C378.674,482.41 415.404,400.804 415.404,306.136 C415.404,256.343 403.878,208.701 380.826,163.211 C357.773,117.721 324.885,78.2244 282.161,44.7216 C239.438,11.2188 159.676,-36.8838 42.8774,-99.5863 C-100.355,-176.428 -191.027,-237.901 -229.141,-284.005 C-255.574,-315.357 -268.791,-350.089 -268.791,-388.202 C-268.791,-437.995 -247.89,-482.41 -206.088,-521.445 C-164.287,-560.48 -111.42,-579.998 -47.4879,-579.998 C9.06727,-579.998 63.7783,-565.552 116.645,-536.66 C169.512,-507.767 210.238,-468.732 238.823,-419.554 C267.408,-370.375 287.233,-304.292 298.298,-221.303 L332.415,-221.303 L332.415,-653.766 L298.298,-653.766 Z " fill="currentColor" fill-opacity="1.00" /><path d="M-530.954,-41.4477 L-530.954,41.4477 L530.954,41.4477 L530.954,-41.4477 L-530.954,-41.4477 Z " fill="currentColor" fill-opacity="1.00" /></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-undo"><path d="M447.9 368.2c0-16.8 3.6-83.1-48.7-135.7-35.2-35.4-80.3-53.4-143.3-56.2V96L64 224l192 128v-79.8c40 1.1 62.4 9.1 86.7 20 30.9 13.8 55.3 44 75.8 76.6l19.2 31.2H448c0-10.1-.1-22.9-.1-31.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-redo"><path d="M64 400h10.3l19.2-31.2c20.5-32.7 44.9-62.8 75.8-76.6 24.4-10.9 46.7-18.9 86.7-20V352l192-128L256 96v80.3c-63 2.8-108.1 20.7-143.3 56.2C60.4 285.2 64 351.5 64 368.2c.1 8.9 0 21.7 0 31.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-arrow-dropdown"><path d="M128 192l128 128 128-128z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-social-twitter"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6-18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6.8 15 2.5 22.1-80.5-4-151.9-42.6-199.6-101.3-8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7-16-.4-31-4.8-44-12.1v1.2c0 47 33.4 86.1 77.7 95-8.1 2.2-16.7 3.4-25.5 3.4-6.2 0-12.3-.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3-33.1 26-74.9 41.5-120.3 41.5-7.8 0-15.5-.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-.1-8.4-.3-12.5C462.6 146 479 129 492 109.5z"></path></symbol>
            <symbol viewBox="0 0 24 24" id="icon-zoom-in" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <circle cx="10" cy="10" r="7"></circle>
                <line x1="7" y1="10" x2="13" y2="10"></line>
                <line x1="10" y1="7" x2="10" y2="13"></line>
                <line x1="21" y1="21" x2="15" y2="15"></line>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-contract"><path d="M64 371.2h76.795V448H192V320H64v51.2zm76.795-230.4H64V192h128V64h-51.205v76.8zM320 448h51.2v-76.8H448V320H320v128zm51.2-307.2V64H320v128h128v-51.2h-76.8z"></path></symbol>
            
            <symbol viewBox="0 0 24 24" id="icon-lock-off" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <line x1="3" y1="3" x2="21" y2="21" />
                <path d="M19 19a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6a2 2 0 0 1 2 -2h4m4 0h2a2 2 0 0 1 2 2v2" />
                <circle cx="12" cy="16" r="1" />
                <path d="M8 11v-3m.712 -3.278a4 4 0 0 1 7.288 2.278v4" />
            </symbol>
            <symbol viewBox="0 0 24 24" id="icon-lock" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <rect x="5" y="11" width="14" height="10" rx="2" />
                <circle cx="12" cy="16" r="1" />
                <path d="M8 11v-4a4 4 0 0 1 8 0v4" />
            </symbol>
            <symbol viewBox="0 0 24 24" id="icon-code" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z"/>
                <polyline points="7 8 3 12 7 16" />
                <polyline points="17 8 21 12 17 16" />
                <line x1="14" y1="4" x2="10" y2="20" />
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-cloud-upload-outline">
                <path d="M193.3 260.4l-11.6-11.6 74.5-74.3 74.5 74.3-11.7 11.6-54.6-54.6v241.8h-16.5V205.8z"/>
                <path d="M399.3 183.6c0-1.2.2-2.4.2-3.6 0-64.3-52.8-116.4-116.8-116.4-46.1 0-85.8 27.1-104.4 66.3-8.1-4.1-17.1-6.4-26.8-6.4-29.6 0-54.1 23.6-58.9 52C57.4 187.6 32 222.2 32 261.8c0 49.7 40.1 90.2 89.6 90.2H213v-16h-90.6c-40.9 0-74.2-33.5-74.2-74.6 0-31.8 20.2-61.2 50.2-71.6l8.4-2.9 1.5-8.8c3.6-21.6 22.1-39.3 43.9-39.3 6.9 0 13.7 1.6 19.9 4.8l13.5 6.8 6.5-13.7c16.6-34.9 52.1-57.4 90.4-57.4 55.3 0 100.9 43.3 100.9 98.9 0 13.3-.2 20.3-.2 20.3l15.2.1c36.6.5 65.6 33.4 65.6 70.3 0 36.8-29.8 66.9-66.5 67.1H297v16h101c45 0 82-37.3 82-82.8s-35.5-85.5-80.7-85.6z"/>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-volume-medium">
                <path d="M270 407.7V104.4L175.3 192H71v128h104.3zm56.3-52.1c20.5-27.8 32.8-62.3 32.8-99.6 0-37.4-12.3-71.8-32.8-99.6l-20.4 15.3c17.4 23.6 27.8 52.7 27.8 84.3 0 31.6-10.4 60.7-27.8 84.3l20.4 15.3zm66.5 46c30-40.7 48-91 48-145.6s-18-104.9-48-145.6l-20.4 15.3c26.9 36.4 43 81.4 43 130.3 0 48.9-16.1 93.8-43 130.3l20.4 15.3z"/>
            </symbol>

            <symbol id="icon-list-search" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M15 15m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0"></path>
                <path d="M18.5 18.5l2.5 2.5"></path>
                <path d="M4 6h16"></path>
                <path d="M4 12h4"></path>
                <path d="M4 18h4"></path>
            </symbol>
            <symbol id="icon-folder-media" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2"></path>

                <path d="M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5"></path>
                <path d="M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4"></path>
                <path d="M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598"></path>
            </symbol>

            <symbol id="icon-reload" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M19.933 13.041a8 8 0 1 1 -9.925 -8.788c3.899 -1.002 7.935 1.007 9.425 4.747"></path>
                <path d="M20 4v5h-5"></path>
            </symbol>
            <symbol id="icon-devices" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <rect x="13" y="8" width="8" height="12" rx="1"></rect>
                <path d="M18 8v-3a1 1 0 0 0 -1 -1h-13a1 1 0 0 0 -1 1v12a1 1 0 0 0 1 1h9"></path>
                <line x1="16" y1="9" x2="18" y2="9"></line>
            </symbol>  
            <symbol id="icon-device-desktop" viewBox="0 0 24 24" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <rect x="3" y="4" width="18" height="12" rx="1"></rect>
                <line x1="7" y1="20" x2="17" y2="20"></line>
                <line x1="9" y1="16" x2="9" y2="20"></line>
                <line x1="15" y1="16" x2="15" y2="20"></line>
            </symbol>
            <symbol id="icon-device-mobile" viewBox="0 0 24 24" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <rect x="6" y="3" width="12" height="18" rx="2"></rect>
                <line x1="11" y1="4" x2="13" y2="4"></line>
                <line x1="12" y1="17" x2="12" y2="17.01"></line>
            </symbol>
            <symbol id="icon-device-laptop" viewBox="0 0 24 24" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <line x1="3" y1="19" x2="21" y2="19"></line>
                <rect x="5" y="6" width="14" height="10" rx="1"></rect>
            </symbol>
            <symbol id="icon-device-tablet" viewBox="0 0 24 24" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <rect x="5" y="3" width="14" height="18" rx="1"></rect>
                <circle cx="12" cy="17" r="1"></circle>
            </symbol>

            <symbol id="icon-fullview" viewBox="0 0 24 24" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M4 8v-2a2 2 0 0 1 2 -2h2"></path>
                <path d="M4 16v2a2 2 0 0 0 2 2h2"></path>
                <path d="M16 4h2a2 2 0 0 1 2 2v2"></path>
                <path d="M16 20h2a2 2 0 0 0 2 -2v-2"></path>
            </symbol>

            <symbol id="icon-eye" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0m13 0c-2.667 4.667 -6 7 -10 7s-7.333 -2.333 -10 -7c2.667 -4.667 6 -7 10 -7s7.333 2.333 10 7"></path>
            </symbol>
            <symbol id="icon-eye-off" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M9.88 9.878a3 3 0 1 0 4.243 4.242m.581 -3.42a3.012 3.012 0 0 0 -1.45 -1.426m-3.877 -3.913a9.469 9.469 0 0 1 2.623 -.361c4 0 7.333 2.333 10 7c-.778 1.362 -1.613 2.524 -2.504 3.489m-2.138 1.859c-1.629 1.101 -3.415 1.652 -5.358 1.652c-4 0 -7.333 -2.333 -10 -7c1.374 -2.404 2.924 -4.189 4.652 -5.354m-3.652 -3.646l18 18"></path>
            </symbol>

            <symbol id="icon-download" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2"></path>
                <path d="M7 11l5 5l5 -5"></path>
                <path d="M12 4l0 12"></path>
            </symbol>

            <symbol id="icon-message-search" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M8 9h8"></path>
                <path d="M8 13h5"></path>
                <path d="M12 21l-.5 -.5l-2.5 -2.5h-3a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v4.5"></path>
                <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
                <path d="M20.2 20.2l1.8 1.8"></path>
            </symbol>

            <symbol id="icon-folder-old" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2"></path>
            </symbol>
            <symbol id="icon-folder" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M11 19h-6a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2.5"></path>
                <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
                <path d="M20.2 20.2l1.8 1.8"></path>
            </symbol>
            <symbol id="icon-folder2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M11 19h-6a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2.5"></path>
                <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
                <path d="M20.2 20.2l1.8 1.8"></path>
            </symbol>
            <symbol id="icon-message" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M8 9h8"></path>
                <path d="M8 13h6"></path>
                <path d="M18 4a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-5l-5 3v-3h-2a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3h12z"></path>
            </symbol>
            
            <symbol id="icon-undo" viewBox="0 0 512 512">
                <path d="M447.9 368.2c0-16.8 3.6-83.1-48.7-135.7-35.2-35.4-80.3-53.4-143.3-56.2V96L64 224l192 128v-79.8c40 1.1 62.4 9.1 86.7 20 30.9 13.8 55.3 44 75.8 76.6l19.2 31.2H448c0-10.1-.1-22.9-.1-31.8z"></path>
            </symbol>
            <symbol id="icon-redo" viewBox="0 0 512 512">
                <path d="M64 400h10.3l19.2-31.2c20.5-32.7 44.9-62.8 75.8-76.6 24.4-10.9 46.7-18.9 86.7-20V352l192-128L256 96v80.3c-63 2.8-108.1 20.7-143.3 56.2C60.4 285.2 64 351.5 64 368.2c.1 8.9 0 21.7 0 31.8z"></path>
            </symbol>
            

            <symbol id="icon-undo2" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M9 14l-4 -4l4 -4"></path>
                <path d="M5 10h11a4 4 0 1 1 0 8h-1"></path>
            </symbol>
            <symbol id="icon-redo2" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M15 14l4 -4l-4 -4"></path>
                <path d="M19 10h-11a4 4 0 1 0 0 8h1"></path>
            </symbol>
            <symbol id="icon-save" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2"></path>
                <path d="M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0"></path>
                <path d="M14 4l0 4l-6 0l0 -4"></path>
            </symbol>
            <symbol id="icon-back" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M9 14l-4 -4l4 -4"></path>
                <path d="M5 10h11a4 4 0 1 1 0 8h-1"></path>
            </symbol>
            <symbol id="icon-publish" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path>
                <path d="M9 12l2 2l4 -4"></path>
            </symbol>

            <symbol id="icon-align-box-top" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" />
                <path d="M15 10h-7" />
                <path d="M15 7h-7" />
            </symbol>
            <symbol id="icon-align-box-middle" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" />
                <path d="M15 13h-7" />
                <path d="M15 10h-7" />
            </symbol>
            <symbol id="icon-align-box-bottom" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" />
                <path d="M15 17h-7" />
                <path d="M15 14h-7" />
            </symbol>
            <symbol id="icon-align-box-stretch" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <path d="M3 5a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-14z" />
                <path d="M15 17h-7" />
                <path d="M15 7h-7" />
            </symbol>

            <symbol id="icon-align-box-left" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" /><path d="M9 15h-2" /><path d="M13 12h-6" /><path d="M11 9h-4" />
            </symbol>
            <symbol id="icon-align-box-center" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 19v-14a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" /><path d="M11 15h2" /><path d="M9 12h6" /><path d="M10 9h4" />
            </symbol>
            <symbol id="icon-align-box-right" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 15h2" /><path d="M3 5a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-14z" /><path d="M11 12h6" /><path d="M13 9h4" />
            </symbol>

            <symbol id="icon-stack-forward" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 5l-8 4l8 4l8 -4l-8 -4" fill="currentColor" /><path d="M10 12l-6 3l8 4l8 -4l-6 -3" />
            </symbol>
            <symbol id="icon-stack-backward" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 12l6 -3l-8 -4l-8 4l6 3" /><path d="M10 12l-6 3l8 4l8 -4l-6 -3l-2 1z" fill="currentColor" />
            </symbol>
            <symbol id="icon-arrow-down" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 5l0 14" /><path d="M18 13l-6 6" /><path d="M6 13l6 6" />
            </symbol>
            <symbol id="icon-arrow-up" viewBox="0 0 24 24" stroke-width="1.4" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 5l0 14" /><path d="M18 11l-6 -6" /><path d="M6 11l6 -6" />
            </symbol>

            <symbol id="icon-group" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 16v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-8a2 2 0 0 1 2 -2h2v-2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2" />
            </symbol>
            <symbol id="icon-ungroup" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 4m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" /><path d="M4 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" />
            </symbol>

            <symbol id="icon-group2" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6v-1a1 1 0 0 1 1 -1h1m5 0h2m5 0h1a1 1 0 0 1 1 1v1m0 5v2m0 5v1a1 1 0 0 1 -1 1h-1m-5 0h-2m-5 0h-1a1 1 0 0 1 -1 -1v-1m0 -5v-2" />
            </symbol>
            <symbol id="icon-group3" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 16v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-8a2 2 0 0 1 2 -2h2v-2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2" /><path d="M10 8l-2 0l0 2" /><path d="M8 14l0 2l2 0" /><path d="M14 8l2 0l0 2" /><path d="M16 14l0 2l-2 0" />
            </symbol>
            <symbol id="icon-group4" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 19a2 2 0 0 1 -2 -2" /><path d="M5 13v-2" /><path d="M5 7a2 2 0 0 1 2 -2" /><path d="M11 5h2" /><path d="M17 5a2 2 0 0 1 2 2" /><path d="M19 11v2" /><path d="M19 17v4" /><path d="M21 19h-4" /><path d="M13 19h-2" />
            </symbol>
            <symbol id="icon-ungroup2" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6c0 -.556 .227 -1.059 .593 -1.421" /><path d="M9 4h1.5" /><path d="M13.5 4h1.5" /><path d="M18 4a2 2 0 0 1 2 2" /><path d="M20 9v1.5" /><path d="M20 13.5v1.5" /><path d="M19.402 19.426a1.993 1.993 0 0 1 -1.402 .574" /><path d="M15 20h-1.5" /><path d="M10.5 20h-1.5" /><path d="M6 20a2 2 0 0 1 -2 -2" /><path d="M4 15v-1.5" /><path d="M4 10.5v-1.5" /><path d="M3 3l18 18" />
            </symbol>
            <symbol id="icon-ungroup3" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 16.572v2.42a2.01 2.01 0 0 1 -2.009 2.008h-7.981a2.01 2.01 0 0 1 -2.01 -2.009v-7.981a2.01 2.01 0 0 1 2.009 -2.01h2.954" /><path d="M9.167 4.511a2.04 2.04 0 0 1 2.496 -1.441l7.826 2.097a2.04 2.04 0 0 1 1.441 2.496l-2.097 7.826a2.04 2.04 0 0 1 -2.496 1.441l-7.827 -2.097a2.04 2.04 0 0 1 -1.441 -2.496l2.098 -7.827z" />
            </symbol>

            <symbol id="icon-duplicate2" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 16.572v2.42a2.01 2.01 0 0 1 -2.009 2.008h-7.981a2.01 2.01 0 0 1 -2.01 -2.009v-7.981a2.01 2.01 0 0 1 2.009 -2.01h2.954" /><path d="M9.167 4.511a2.04 2.04 0 0 1 2.496 -1.441l7.826 2.097a2.04 2.04 0 0 1 1.441 2.496l-2.097 7.826a2.04 2.04 0 0 1 -2.496 1.441l-7.827 -2.097a2.04 2.04 0 0 1 -1.441 -2.496l2.098 -7.827z" />
            </symbol>
            <symbol id="icon-duplicate" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" />
            </symbol>

            <symbol id="icon-trash" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M4 7l16 0"></path>
                <path d="M10 11l0 6"></path>
                <path d="M14 11l0 6"></path>
                <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12"></path>
                <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3"></path>
            </symbol>
            <symbol id="icon-chevron-down" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M6 9l6 6l6 -6"></path>
            </symbol>


            <symbol id="icon-settings" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </symbol>

            <symbol id="icon-microphone" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z"></path>
                <path d="M5 10a7 7 0 0 0 14 0"></path>
                <path d="M8 21l8 0"></path>
                <path d="M12 17l0 4"></path>
            </symbol>
            <symbol id="icon-microphone-off" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M3 3l18 18"></path>
                <path d="M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1"></path>
                <path d="M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85"></path>
                <path d="M8 21l8 0"></path>
                <path d="M12 17l0 4"></path>
            </symbol>
            <symbol id="icon-eraser" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3"></path>
                <path d="M18 13.3l-6.3 -6.3"></path>
            </symbol>
            <symbol id="icon-snippets" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19 8h-14" /><path d="M5 12h9" /><path d="M11 16h-6" /><path d="M15 16h6" /><path d="M18 13v6" />
            </symbol>
            <symbol id="icon-svg" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 8h-2a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h2v-4h-1" /><path d="M7 8h-3a1 1 0 0 0 -1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-3" /><path d="M10 8l1.5 8h1l1.5 -8" />
            </symbol>

            <symbol id="icon-pagesize" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 4h11a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-11a1 1 0 0 1 -1 -1v-14a1 1 0 0 1 1 -1m3 0v18" /><path d="M13 8l2 0" /><path d="M13 12l2 0" />
            </symbol>
            <symbol id="icon-print" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 17h2a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2h-14a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h2" /><path d="M17 9v-4a2 2 0 0 0 -2 -2h-6a2 2 0 0 0 -2 2v4" /><path d="M7 13m0 2a2 2 0 0 1 2 -2h6a2 2 0 0 1 2 2v4a2 2 0 0 1 -2 2h-6a2 2 0 0 1 -2 -2z" />
            </symbol>

            <symbol id="icon-plus" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </symbol>
            <symbol id="icon-plus2" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M12 5l0 14"></path>
                <path d="M5 12l14 0"></path>
            </symbol>
        </svg>`;
  builder.dom.appendHtml(builder.builderStuff, html);
};

class Grid {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    this.rowTool = new RowTool$1(builder);
  }
  moveColumnPrevious() {
    let util = this.util;
    const cell = util.cellSelected();
    if (!cell) return;
    if (cell.previousElementSibling) {
      this.builder.uo.saveForUndo();
      this.builder.hideTools();
      cell.parentElement.insertBefore(cell, cell.previousElementSibling);
      this.builder.opts.onChange();
    }
  }
  moveColumnNext() {
    let util = this.util;
    const cell = util.cellSelected();
    if (!cell) return;
    const cellnext = util.cellNext(cell);
    if (cellnext) {
      this.builder.uo.saveForUndo();
      this.builder.hideTools();
      cell.parentElement.insertBefore(cellnext, cell);
      this.builder.opts.onChange();
    }
  }
  moveColumnUp() {
    let builder = this.builder;
    let util = this.util;
    const cell = util.cellSelected();
    if (!cell) return;
    let row = cell.parentNode;
    let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
    if (row.querySelector('.is-row-overlay')) {
      num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
    }

    if (row.childElementCount - num === 1) {
      //-num => minus is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
      if (row.previousElementSibling) {
        let maxCols = 4;
        if (this.builder.maxColumns) {
          maxCols = this.builder.maxColumns;
        }
        if (row.previousElementSibling.childElementCount >= maxCols + num || row.previousElementSibling.hasAttribute('data-protected')) {
          //+2 => includes is-row-tool & is-rowaddtool

          this.builder.uo.saveForUndo();
          this.builder.hideTools();

          //Move row up
          row.parentNode.insertBefore(row, row.previousElementSibling);
          this.builder.opts.onChange();
          return;
        } else {
          this.builder.uo.saveForUndo();
          this.builder.hideTools();

          //Add inside prev row
          let tool = row.previousElementSibling.querySelector('.is-row-tool');
          row.previousElementSibling.removeChild(tool); //remove next row tool
          tool = row.previousElementSibling.querySelector('.is-rowadd-tool');
          row.previousElementSibling.removeChild(tool); //remove
          tool = row.previousElementSibling.querySelector('.is-col-tool');
          row.previousElementSibling.removeChild(tool); //remove

          row.previousElementSibling.appendChild(cell); //add

          row.parentNode.removeChild(row); //remove current (empty) row (including its overlay)

          //re-add tool
          let builderActive = this.builder.doc.querySelector('.builder-active');
          builder.applyBehaviorOn(builderActive);
          setTimeout(() => {
            cell.click(); //refresh active cell/row
          }, 30);
          this.builder.opts.onChange();
        }
      } else {
        //move outside container (move to previous container)
        return;
      }
    } else {
      this.builder.uo.saveForUndo();
      this.builder.hideTools();
      var rowElement = row.cloneNode(true);
      rowElement.innerHTML = '';
      rowElement.appendChild(cell);
      row.parentNode.insertBefore(rowElement, row);

      //re-add tool
      let builderActive = this.builder.doc.querySelector('.builder-active');
      builder.applyBehaviorOn(builderActive);
      setTimeout(() => {
        cell.click(); //refresh active cell/row
      }, 30);
      this.builder.opts.onChange();
    }

    //fix layout
    row = cell.parentNode; //update active row
    util.fixLayout(row);
    if (row.nextElementSibling) util.fixLayout(row.nextElementSibling);
  }
  moveColumnDown() {
    let builder = this.builder;
    let util = this.util;
    let dom = this.dom;
    const cell = util.cellSelected();
    if (!cell) return;
    let row = cell.parentNode;
    let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
    if (row.querySelector('.is-row-overlay')) {
      num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
    }

    if (row.childElementCount - num === 1) {
      //-2 => minus is-row-tool & is-rowadd-tool

      if (row.nextElementSibling) {
        let maxCols = 4;
        if (this.builder.maxColumns) {
          maxCols = this.builder.maxColumns;
        }
        if (row.nextElementSibling.childElementCount >= maxCols + num || row.nextElementSibling.hasAttribute('data-protected')) {
          //+2 => includes is-row-tool & is-rowadd-tool

          this.builder.uo.saveForUndo();
          this.builder.hideTools();

          //Move row down
          row.parentNode.insertBefore(row.nextElementSibling, row);
          this.builder.opts.onChange();
          return;
        } else {
          this.builder.uo.saveForUndo();
          this.builder.hideTools();

          //Add inside next row
          let tool = row.nextElementSibling.querySelector('.is-row-tool');
          row.nextElementSibling.removeChild(tool); //remove next row tool
          tool = row.nextElementSibling.querySelector('.is-rowadd-tool');
          row.nextElementSibling.removeChild(tool); //remove
          tool = row.nextElementSibling.querySelector('.is-col-tool');
          row.nextElementSibling.removeChild(tool); //remove

          row.nextElementSibling.appendChild(cell); //add

          row.parentNode.removeChild(row); //remove current (empty) row (including its overlay)

          //re-add tool
          let builderActive = this.builder.doc.querySelector('.builder-active');
          builder.applyBehaviorOn(builderActive);
          setTimeout(() => {
            cell.click(); //refresh active cell/row
          }, 30);
          this.builder.opts.onChange();
        }
      } else {
        //move outside container (move to next container)
        return;
      }
    } else {
      this.builder.uo.saveForUndo();
      this.builder.hideTools();
      var rowElement = row.cloneNode(true);
      rowElement.innerHTML = '';
      rowElement.appendChild(cell);
      dom.moveAfter(rowElement, row);

      //re-add tool
      let builderActive = this.builder.doc.querySelector('.builder-active');
      builder.applyBehaviorOn(builderActive);
      setTimeout(() => {
        cell.click(); //refresh active cell/row
      }, 30);
      this.builder.opts.onChange();
    }

    //fix layout
    row = cell.parentNode; //update active row
    util.fixLayout(row);
    if (row.previousElementSibling) util.fixLayout(row.previousElementSibling);
  }
  duplicateColumn() {
    let builder = this.builder;
    let util = this.util;
    let dom = this.dom;
    const cell = util.cellSelected();
    if (!cell) return;
    this.builder.uo.saveForUndo();
    var cellElement = cell.cloneNode(true);
    dom.removeClass(cellElement, 'cell-active');
    cellElement.removeAttribute('data-click');
    if (this.builder.opts.enableDragResize) {
      cell.style.width = '';
      cell.style.flex = '';
    }
    let row = cell.parentNode;
    let num = 3;
    if (row.querySelector('.is-row-overlay')) {
      num = 4;
    }
    let maxCols = 4;
    if (this.builder.maxColumns) {
      maxCols = this.builder.maxColumns;
    }
    if (row.childElementCount >= maxCols + num) {
      alert(util.out('You have reached the maximum number of columns'));
      return false;
    }
    row.insertBefore(cellElement, cell);
    util.fixLayout(row);

    //re-add tool
    let builderActive = this.builder.doc.querySelector('.builder-active');
    builder.applyBehaviorOn(builderActive);
    setTimeout(() => {
      cell.click(); //refresh active cell/row
    }, 30);
    this.builder.opts.onChange();
  }
  removeColumn() {
    let util = this.util;
    const cell = util.cellSelected();
    if (!cell) return;
    let row = cell.parentNode;
    let num = 3;
    if (row.querySelector('.is-row-overlay')) {
      num = 4;
    }
    util.confirm(util.out('Are you sure you want to delete this block?'), ok => {
      if (ok) {
        this.builder.uo.saveForUndo();
        if (row.childElementCount - num === 1) {
          row.parentNode.removeChild(row);
          util.checkEmpty();
        } else {
          row.removeChild(cell);
          util.fixLayout(row);
        }
        util.clearActiveCell();
        this.builder.opts.onChange();
      }
    });
  }
  removeColClasses(cell) {
    cell.classList.remove('full');
    cell.classList.remove('two-third');
    cell.classList.remove('two-fourth');
    cell.classList.remove('two-fifth');
    cell.classList.remove('two-sixth');
    cell.classList.remove('half');
    cell.classList.remove('third');
    cell.classList.remove('fourth');
    cell.classList.remove('fifth');
    cell.classList.remove('sixth');
    cell.classList.remove('seventh');
    cell.classList.remove('eighth');
    cell.classList.remove('ninth');
    cell.classList.remove('tenth');
    cell.classList.remove('eleventh');
    cell.classList.remove('twelfth');
  }
  getAllColumns(cell) {
    let arrCells = [];
    let dom = this.dom;
    const cols = dom.elementChildren(cell.parentNode);
    cols.forEach(col => {
      if (dom.hasClass(col, 'is-row-tool') || dom.hasClass(col, 'is-col-tool') || dom.hasClass(col, 'is-rowadd-tool') || dom.hasClass(col, 'is-row-overlay')) return;
      if (cell !== col) {
        arrCells.push(col);
      }
    });
    const newArray = [cell].concat(arrCells);
    return newArray;
  }
  getCellWidth(cell) {
    if (cell.classList.contains('two-third')) {
      return 66.666;
    }
    if (cell.classList.contains('two-fourth')) {
      return 75;
    }
    if (cell.classList.contains('two-fifth')) {
      return 80;
    }
    if (cell.classList.contains('two-sixth')) {
      return 83.333;
    }
    if (cell.classList.contains('half')) {
      return 50;
    }
    if (cell.classList.contains('third')) {
      return 33.333;
    }
    if (cell.classList.contains('fourth')) {
      return 25;
    }
    if (cell.classList.contains('fifth')) {
      return 20;
    }
    if (cell.classList.contains('sixth')) {
      return 16.666;
    }
    if (cell.classList.contains('seventh')) {
      return 14.2857;
    }
    if (cell.classList.contains('eighth')) {
      return 12.5;
    }
    if (cell.classList.contains('ninth')) {
      return 11.111;
    }
    if (cell.classList.contains('tenth')) {
      return 10;
    }
    if (cell.classList.contains('eleventh')) {
      return 9.09;
    }
    if (cell.classList.contains('twelfth')) {
      return 8.333;
    }
    return false;
  }
  resizeColumn(cell, increase, num) {
    let cellWidth = this.getCellWidth(cell);
    if (!cellWidth) {
      let cellW = parseFloat(window.getComputedStyle(cell).getPropertyValue('width'));
      let rowW = parseFloat(window.getComputedStyle(cell.parentNode).getPropertyValue('width'));
      cellWidth = cellW / rowW * 100;
    }
    if (increase) {
      if (num === 3) {
        if (cellWidth >= 28 && cellWidth <= 30) {
          return '33.333%';
        } else if (cellWidth > 30 && cellWidth < 38) {
          return '40%';
        }
        //max 80%
        if (cellWidth >= 68 && cellWidth <= 90) {
          return '75%';
        }
      }
      if (num === 4) {
        //max 70%
        if (cellWidth >= 48 && cellWidth <= 90) {
          return '60%';
        }
      }
      if (num === 5) {
        //max 50%
        if (cellWidth >= 38 && cellWidth <= 90) {
          return '50%';
        }
      }
      if (num === 6) {
        if (cellWidth >= 10 && cellWidth < 13) {
          return '16.666%';
        }
        //max 40%
        if (cellWidth >= 28 && cellWidth <= 90) {
          return '40%';
        }
      }
      if (num === 7) {
        //max 30%
        if (cellWidth >= 23 && cellWidth <= 90) {
          return '30%';
        }
      }
      if (num === 8) {
        //max 20%
        if (cellWidth >= 13 && cellWidth <= 90) {
          return '20%';
        }
      }
      if (cellWidth >= 78 && cellWidth <= 90) {
        return '90%';
      } else if (cellWidth >= 73 && cellWidth < 78) {
        return '80%';
      } else if (cellWidth >= 68 && cellWidth < 73) {
        return '75%';
      } else if (cellWidth >= 58 && cellWidth < 68) {
        return '70%';
      } else if (cellWidth >= 48 && cellWidth < 58) {
        return '60%';
      } else if (cellWidth >= 38 && cellWidth < 48) {
        return '50%';
      } else if (cellWidth >= 28 && cellWidth < 38) {
        return '40%';
      } else if (cellWidth >= 23 && cellWidth < 28) {
        return '30%';
      } else if (cellWidth >= 18 && cellWidth < 23) {
        return '25%';
      } else if (cellWidth >= 13 && cellWidth < 18) {
        return '20%';
      } else if (cellWidth >= 10 && cellWidth < 13) {
        return '15%';
      }
    } else {
      // decrease

      if (num === 3) {
        if (cellWidth > 35 && cellWidth <= 43) {
          return '33.333%';
        }
        if (cellWidth > 33 && cellWidth <= 35) {
          return '30%';
        }
      }
      if (num === 6) {
        if (cellWidth > 18 && cellWidth <= 23) {
          return '16.666%';
        }
      }
      if (cellWidth > 93 && cellWidth <= 100) {
        return '90%';
      } else if (cellWidth > 83 && cellWidth <= 93) {
        return '80%';
      } else if (cellWidth > 78 && cellWidth <= 83) {
        return '75%';
      } else if (cellWidth > 73 && cellWidth <= 78) {
        return '70%';
      } else if (cellWidth > 63 && cellWidth <= 73) {
        return '60%';
      } else if (cellWidth > 53 && cellWidth <= 63) {
        return '50%';
      } else if (cellWidth > 43 && cellWidth <= 53) {
        return '40%';
      } else if (cellWidth > 33 && cellWidth <= 43) {
        return '30%';
      } else if (cellWidth > 28 && cellWidth <= 33) {
        return '25%';
      } else if (cellWidth > 23 && cellWidth <= 28) {
        return '20%';
      } else if (cellWidth > 18 && cellWidth <= 23) {
        return '15%';
      } else if (cellWidth >= 10 && cellWidth <= 18) {
        return '10%';
      }
    }
    return false;
  }
  increaseColumn() {
    let builder = this.builder;
    let util = this.util;
    let dom = this.dom;
    let cell = util.cellSelected();
    if (!cell) return;
    if (this.builder.useDefaultGrid) {
      let arrColumns = this.getAllColumns(cell);
      if (arrColumns.length > 1 && arrColumns.length < 9) {
        this.builder.uo.saveForUndo();
        let w = this.resizeColumn(cell, true, arrColumns.length);
        if (w) {
          cell.style.width = w;
          cell.style.flex = '0 0 auto';
          this.removeColClasses(cell);
          for (let i = 1; i < arrColumns.length; i++) {
            let cellNext = arrColumns[i];
            if (cellNext !== cell) {
              // cellNext.style.width = '';
              // cellNext.style.flex = '';
              if (!cellNext.getAttribute('data-html')) {
                cellNext.style.width = '';
                cellNext.style.flex = '';
              } else {
                // For module, don't change width, except if there are 2 columns only
                if (arrColumns.length === 2) {
                  cellNext.style.width = 100 - parseFloat(w) + '%';
                  cellNext.style.flex = '0 0 auto';
                }
              }
              this.removeColClasses(cellNext);
            }
          }
        }
        this.builder.opts.onChange();
      }
      return;
    }
    let cellnext, cellnext2;
    let arrColumns = this.getAllColumns(cell);
    if (arrColumns[1]) cellnext = arrColumns[1];
    if (arrColumns[2]) cellnext2 = arrColumns[2];
    const rowClass = builder.opts.row;
    let colClass = builder.opts.cols;
    const colSizes = builder.opts.colsizes;
    if (rowClass !== '' && colClass.length > 0 && colSizes.length > 0) {
      if (cellnext2) {
        for (let i = 0; i < colSizes.length; i++) {
          let group = colSizes[i];
          for (let j = 0; j < group.length; j++) {
            if (group[j].length === 3) {
              if (dom.hasClass(cell, group[j][0]) && dom.hasClass(cellnext, group[j][1]) && dom.hasClass(cellnext2, group[j][2])) {
                if (j + 1 === group.length) ; else {
                  this.builder.uo.saveForUndo();
                  dom.removeClass(cell, group[j][0]);
                  dom.removeClass(cellnext, group[j][1]);
                  dom.removeClass(cellnext2, group[j][2]);
                  dom.addClass(cell, group[j + 1][0]);
                  dom.addClass(cellnext, group[j + 1][1]);
                  dom.addClass(cellnext2, group[j + 1][2]);
                  this.builder.opts.onChange();
                  return;
                }
              }
            }
          }
        }
      }
      for (let i = 0; i < colSizes.length; i++) {
        let group = colSizes[i];
        for (let j = 0; j < group.length; j++) {
          if (group[j].length === 2) {
            if (dom.hasClass(cell, group[j][0]) && dom.hasClass(cellnext, group[j][1])) {
              if (j + 1 === group.length) ; else {
                this.builder.uo.saveForUndo();
                dom.removeClass(cell, group[j][0]);
                dom.removeClass(cellnext, group[j][1]);
                dom.addClass(cell, group[j + 1][0]);
                dom.addClass(cellnext, group[j + 1][1]);
                this.builder.opts.onChange();
                return;
              }
            }
          }
        }
      }
      return;
    }

    //others (12 columns grid)       
    if (rowClass !== '' && colClass.length > 0) {
      // Bootstrap stuff
      if (cell.className.indexOf('col-md-') !== -1) ; else if (cell.className.indexOf('col-sm-') !== -1) {
        colClass = ['col-sm-1', 'col-sm-2', 'col-sm-3', 'col-sm-4', 'col-sm-5', 'col-sm-6', 'col-sm-7', 'col-sm-8', 'col-sm-9', 'col-sm-10', 'col-sm-11', 'col-sm-12'];
      } else if (cell.className.indexOf('col-xs-') !== -1) {
        colClass = ['col-xs-1', 'col-xs-2', 'col-xs-3', 'col-xs-4', 'col-xs-5', 'col-xs-6', 'col-xs-7', 'col-xs-8', 'col-xs-9', 'col-xs-10', 'col-xs-11', 'col-xs-12'];
      } else if (cell.className.indexOf('col-lg-') !== -1) {
        colClass = ['col-lg-1', 'col-lg-2', 'col-lg-3', 'col-lg-4', 'col-lg-5', 'col-lg-6', 'col-lg-7', 'col-lg-8', 'col-lg-9', 'col-lg-10', 'col-lg-11', 'col-lg-12'];
      } else if (cell.className.indexOf('col-xl-') !== -1) {
        colClass = ['col-xl-1', 'col-xl-2', 'col-xl-3', 'col-xl-4', 'col-xl-5', 'col-xl-6', 'col-xl-7', 'col-xl-8', 'col-xl-9', 'col-xl-10', 'col-xl-11', 'col-xl-12'];
      } else if (cell.className.indexOf('col-xxl-') !== -1) {
        colClass = ['col-xxl-1', 'col-xxl-2', 'col-xxl-3', 'col-xxl-4', 'col-xxl-5', 'col-xxl-6', 'col-xxl-7', 'col-xxl-8', 'col-xxl-9', 'col-xxl-10', 'col-xxl-11', 'col-xxl-12'];
      }
      if (!dom.hasClass(cell, colClass[11])) {
        //if not column full

        if (dom.hasClass(cell, colClass[11])) {
          return;
        }
        if (dom.hasClass(cellnext, colClass[0])) {
          return;
        }
        this.builder.uo.saveForUndo();
        if (dom.hasClass(cell, colClass[10])) {
          dom.removeClass(cell, colClass[10]);
          dom.addClass(cell, colClass[11]);
        } else if (dom.hasClass(cell, colClass[9])) {
          dom.removeClass(cell, colClass[9]);
          dom.addClass(cell, colClass[10]);
        } else if (dom.hasClass(cell, colClass[8])) {
          dom.removeClass(cell, colClass[8]);
          dom.addClass(cell, colClass[9]);
        } else if (dom.hasClass(cell, colClass[7])) {
          dom.removeClass(cell, colClass[7]);
          dom.addClass(cell, colClass[8]);
        } else if (dom.hasClass(cell, colClass[6])) {
          dom.removeClass(cell, colClass[6]);
          dom.addClass(cell, colClass[7]);
        } else if (dom.hasClass(cell, colClass[5])) {
          dom.removeClass(cell, colClass[5]);
          dom.addClass(cell, colClass[6]);
        } else if (dom.hasClass(cell, colClass[4])) {
          dom.removeClass(cell, colClass[4]);
          dom.addClass(cell, colClass[5]);
        } else if (dom.hasClass(cell, colClass[3])) {
          dom.removeClass(cell, colClass[3]);
          dom.addClass(cell, colClass[4]);
        } else if (dom.hasClass(cell, colClass[2])) {
          dom.removeClass(cell, colClass[2]);
          dom.addClass(cell, colClass[3]);
        } else if (dom.hasClass(cell, colClass[1])) {
          dom.removeClass(cell, colClass[1]);
          dom.addClass(cell, colClass[2]);
        } else if (dom.hasClass(cell, colClass[0])) {
          dom.removeClass(cell, colClass[0]);
          dom.addClass(cell, colClass[1]);
        }
        if (dom.hasClass(cellnext, colClass[1])) {
          dom.removeClass(cellnext, colClass[1]);
          dom.addClass(cellnext, colClass[0]);
        } else if (dom.hasClass(cellnext, colClass[2])) {
          dom.removeClass(cellnext, colClass[2]);
          dom.addClass(cellnext, colClass[1]);
        } else if (dom.hasClass(cellnext, colClass[3])) {
          dom.removeClass(cellnext, colClass[3]);
          dom.addClass(cellnext, colClass[2]);
        } else if (dom.hasClass(cellnext, colClass[4])) {
          dom.removeClass(cellnext, colClass[4]);
          dom.addClass(cellnext, colClass[3]);
        } else if (dom.hasClass(cellnext, colClass[5])) {
          dom.removeClass(cellnext, colClass[5]);
          dom.addClass(cellnext, colClass[4]);
        } else if (dom.hasClass(cellnext, colClass[6])) {
          dom.removeClass(cellnext, colClass[6]);
          dom.addClass(cellnext, colClass[5]);
        } else if (dom.hasClass(cellnext, colClass[7])) {
          dom.removeClass(cellnext, colClass[7]);
          dom.addClass(cellnext, colClass[6]);
        } else if (dom.hasClass(cellnext, colClass[8])) {
          dom.removeClass(cellnext, colClass[8]);
          dom.addClass(cellnext, colClass[7]);
        } else if (dom.hasClass(cellnext, colClass[9])) {
          dom.removeClass(cellnext, colClass[9]);
          dom.addClass(cellnext, colClass[8]);
        } else if (dom.hasClass(cellnext, colClass[10])) {
          dom.removeClass(cellnext, colClass[10]);
          dom.addClass(cellnext, colClass[9]);
        } else if (dom.hasClass(cellnext, colClass[11])) {
          dom.removeClass(cellnext, colClass[11]);
          dom.addClass(cellnext, colClass[10]);
        }
        this.builder.opts.onChange();
      }
    }
  }
  decreaseColumn() {
    let builder = this.builder;
    let util = this.util;
    let dom = this.dom;
    const cell = util.cellSelected();
    if (!cell) return;
    if (this.builder.useDefaultGrid) {
      let arrColumns = this.getAllColumns(cell);
      if (arrColumns.length > 1 && arrColumns.length < 9) {
        this.builder.uo.saveForUndo();
        let w = this.resizeColumn(cell, false, arrColumns.length);
        if (w) {
          cell.style.width = w;
          cell.style.flex = '0 0 auto';
          this.removeColClasses(cell);
          for (let i = 1; i < arrColumns.length; i++) {
            let cellNext = arrColumns[i];
            if (cellNext !== cell) {
              // cellNext.style.width = '';
              // cellNext.style.flex = '';
              if (!cellNext.getAttribute('data-html')) {
                cellNext.style.width = '';
                cellNext.style.flex = '';
              } else {
                // For module, don't change width, except if there are 2 columns only
                if (arrColumns.length === 2) {
                  cellNext.style.width = 100 - parseFloat(w) + '%';
                  cellNext.style.flex = '0 0 auto';
                }
              }
              this.removeColClasses(cellNext);
            }
          }
        }
        this.builder.opts.onChange();
      }
      return;
    }
    let cellnext, cellnext2;
    let arrColumns = this.getAllColumns(cell);
    if (arrColumns[1]) cellnext = arrColumns[1];
    if (arrColumns[2]) cellnext2 = arrColumns[2];
    const rowClass = builder.opts.row;
    let colClass = builder.opts.cols;
    const colSizes = builder.opts.colsizes;
    if (rowClass !== '' && colClass.length > 0 && colSizes.length > 0) {
      if (cellnext2) {
        for (let i = 0; i < colSizes.length; i++) {
          let group = colSizes[i];
          for (let j = 0; j < group.length; j++) {
            if (group[j].length === 3) {
              if (dom.hasClass(cell, group[j][0]) && dom.hasClass(cellnext, group[j][1]) && dom.hasClass(cellnext2, group[j][2])) {
                if (j === 0) ; else {
                  this.builder.uo.saveForUndo();
                  dom.removeClass(cell, group[j][0]);
                  dom.removeClass(cellnext, group[j][1]);
                  dom.removeClass(cellnext2, group[j][2]);
                  dom.addClass(cell, group[j - 1][0]);
                  dom.addClass(cellnext, group[j - 1][1]);
                  dom.addClass(cellnext2, group[j - 1][2]);
                  this.builder.opts.onChange();
                  return;
                }
              }
            }
          }
        }
      }
      for (let i = 0; i < colSizes.length; i++) {
        let group = colSizes[i];
        for (let j = 0; j < group.length; j++) {
          if (group[j].length === 2) {
            if (dom.hasClass(cell, group[j][0]) && dom.hasClass(cellnext, group[j][1])) {
              if (j === 0) ; else {
                this.builder.uo.saveForUndo();
                dom.removeClass(cell, group[j][0]);
                dom.removeClass(cellnext, group[j][1]);
                dom.addClass(cell, group[j - 1][0]);
                dom.addClass(cellnext, group[j - 1][1]);
                this.builder.opts.onChange();
                return;
              }
            }
          }
        }
      }
      return;
    }

    //others (12 columns grid)       
    // const rowClass = builder.opts.row; //row
    // const colClass = builder.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
    if (rowClass !== '' && colClass.length > 0) {
      // Bootstrap stuff
      if (cell.className.indexOf('col-md-') !== -1) ; else if (cell.className.indexOf('col-sm-') !== -1) {
        colClass = ['col-sm-1', 'col-sm-2', 'col-sm-3', 'col-sm-4', 'col-sm-5', 'col-sm-6', 'col-sm-7', 'col-sm-8', 'col-sm-9', 'col-sm-10', 'col-sm-11', 'col-sm-12'];
      } else if (cell.className.indexOf('col-xs-') !== -1) {
        colClass = ['col-xs-1', 'col-xs-2', 'col-xs-3', 'col-xs-4', 'col-xs-5', 'col-xs-6', 'col-xs-7', 'col-xs-8', 'col-xs-9', 'col-xs-10', 'col-xs-11', 'col-xs-12'];
      } else if (cell.className.indexOf('col-lg-') !== -1) {
        colClass = ['col-lg-1', 'col-lg-2', 'col-lg-3', 'col-lg-4', 'col-lg-5', 'col-lg-6', 'col-lg-7', 'col-lg-8', 'col-lg-9', 'col-lg-10', 'col-lg-11', 'col-lg-12'];
      } else if (cell.className.indexOf('col-xl-') !== -1) {
        colClass = ['col-xl-1', 'col-xl-2', 'col-xl-3', 'col-xl-4', 'col-xl-5', 'col-xl-6', 'col-xl-7', 'col-xl-8', 'col-xl-9', 'col-xl-10', 'col-xl-11', 'col-xl-12'];
      } else if (cell.className.indexOf('col-xxl-') !== -1) {
        colClass = ['col-xxl-1', 'col-xxl-2', 'col-xxl-3', 'col-xxl-4', 'col-xxl-5', 'col-xxl-6', 'col-xxl-7', 'col-xxl-8', 'col-xxl-9', 'col-xxl-10', 'col-xxl-11', 'col-xxl-12'];
      }
      if (!dom.hasClass(cell, colClass[11])) {
        //if not column full

        if (dom.hasClass(cell, colClass[0])) {
          return;
        }
        if (dom.hasClass(cellnext, colClass[11])) {
          return;
        }
        this.builder.uo.saveForUndo();
        if (dom.hasClass(cell, colClass[11])) {
          dom.removeClass(cell, colClass[11]);
          dom.addClass(cell, colClass[10]);
        } else if (dom.hasClass(cell, colClass[10])) {
          dom.removeClass(cell, colClass[10]);
          dom.addClass(cell, colClass[9]);
        } else if (dom.hasClass(cell, colClass[9])) {
          dom.removeClass(cell, colClass[9]);
          dom.addClass(cell, colClass[8]);
        } else if (dom.hasClass(cell, colClass[8])) {
          dom.removeClass(cell, colClass[8]);
          dom.addClass(cell, colClass[7]);
        } else if (dom.hasClass(cell, colClass[7])) {
          dom.removeClass(cell, colClass[7]);
          dom.addClass(cell, colClass[6]);
        } else if (dom.hasClass(cell, colClass[6])) {
          dom.removeClass(cell, colClass[6]);
          dom.addClass(cell, colClass[5]);
        } else if (dom.hasClass(cell, colClass[5])) {
          dom.removeClass(cell, colClass[5]);
          dom.addClass(cell, colClass[4]);
        } else if (dom.hasClass(cell, colClass[4])) {
          dom.removeClass(cell, colClass[4]);
          dom.addClass(cell, colClass[3]);
        } else if (dom.hasClass(cell, colClass[3])) {
          dom.removeClass(cell, colClass[3]);
          dom.addClass(cell, colClass[2]);
        } else if (dom.hasClass(cell, colClass[2])) {
          dom.removeClass(cell, colClass[2]);
          dom.addClass(cell, colClass[1]);
        } else if (dom.hasClass(cell, colClass[1])) {
          dom.removeClass(cell, colClass[1]);
          dom.addClass(cell, colClass[0]);
        }
        if (dom.hasClass(cellnext, colClass[0])) {
          dom.removeClass(cellnext, colClass[0]);
          dom.addClass(cellnext, colClass[1]);
        } else if (dom.hasClass(cellnext, colClass[1])) {
          dom.removeClass(cellnext, colClass[1]);
          dom.addClass(cellnext, colClass[2]);
        } else if (dom.hasClass(cellnext, colClass[2])) {
          dom.removeClass(cellnext, colClass[2]);
          dom.addClass(cellnext, colClass[3]);
        } else if (dom.hasClass(cellnext, colClass[3])) {
          dom.removeClass(cellnext, colClass[3]);
          dom.addClass(cellnext, colClass[4]);
        } else if (dom.hasClass(cellnext, colClass[4])) {
          dom.removeClass(cellnext, colClass[4]);
          dom.addClass(cellnext, colClass[5]);
        } else if (dom.hasClass(cellnext, colClass[5])) {
          dom.removeClass(cellnext, colClass[5]);
          dom.addClass(cellnext, colClass[6]);
        } else if (dom.hasClass(cellnext, colClass[6])) {
          dom.removeClass(cellnext, colClass[6]);
          dom.addClass(cellnext, colClass[7]);
        } else if (dom.hasClass(cellnext, colClass[7])) {
          dom.removeClass(cellnext, colClass[7]);
          dom.addClass(cellnext, colClass[8]);
        } else if (dom.hasClass(cellnext, colClass[8])) {
          dom.removeClass(cellnext, colClass[8]);
          dom.addClass(cellnext, colClass[9]);
        } else if (dom.hasClass(cellnext, colClass[9])) {
          dom.removeClass(cellnext, colClass[9]);
          dom.addClass(cellnext, colClass[10]);
        } else if (dom.hasClass(cellnext, colClass[10])) {
          dom.removeClass(cellnext, colClass[10]);
          dom.addClass(cellnext, colClass[11]);
        }
        this.builder.opts.onChange();
      }
    }
  }

  // ROW

  removeRow() {
    // let builder = this.builder;
    let util = this.util;
    let dom = this.dom;

    // const cell = util.cellSelected();
    // if(!cell) return;
    // const row = cell.parentNode;
    let row;
    let cell = util.cellSelected();
    if (cell) {
      row = cell.parentNode;
    } else {
      row = util.rowSelected();
    }
    if (!row) return;

    //Change to row selection
    dom.removeClass(row, 'row-outline');
    util.confirm(util.out('Are you sure you want to delete this block?'), ok => {
      // const cell = util.cellSelected();
      // if(!cell) return;
      // const row = cell.parentNode; 
      let row;
      let cell = util.cellSelected();
      if (cell) {
        row = cell.parentNode;
      } else {
        row = util.rowSelected();
      }
      if (!row) return;
      if (ok) {
        this.builder.uo.saveForUndo();
        row.parentNode.removeChild(row);
        util.checkEmpty();
        util.clearActiveCell();
        this.builder.opts.onChange();
      }
    });
  }
  moveRowUp() {
    // let builder = this.builder;
    let util = this.util;
    let dom = this.dom;

    // const cell = util.cellSelected();
    // if(!cell) return;
    // let row = cell.parentNode;
    let row;
    let cell = util.cellSelected();
    if (cell) {
      row = cell.parentNode;
    } else {
      row = util.rowSelected();
    }
    if (!row) return;

    //Change to row selection
    dom.removeClass(row, 'row-outline');
    if (row.previousElementSibling) {
      this.builder.uo.saveForUndo();
      row.parentNode.insertBefore(row, row.previousElementSibling);
      this.rowTool.position(row);
      this.builder.opts.onChange();
    } else {
      // Move to previous container

      let currContainer = row.parentNode;
      let prev = null;
      const builders = document.querySelectorAll(this.builder.opts.container);
      Array.prototype.forEach.call(builders, builder => {
        if (builder.innerHTML === currContainer.innerHTML) {
          if (prev) {
            dom.moveAfter(row, prev.lastChild);
            this.rowTool.position(row);
            util.checkEmpty();
            this.builder.opts.onChange();
            return false;
          }
        }
        prev = builder;
      });
    }
  }
  moveRowDown() {
    // let builder = this.builder;
    let util = this.util;
    let dom = this.dom;

    // const cell = util.cellSelected();
    // if(!cell) return;
    // let row = cell.parentNode;
    let row;
    let cell = util.cellSelected();
    if (cell) {
      row = cell.parentNode;
    } else {
      row = util.rowSelected();
    }
    if (!row) return;

    //Change to row selection
    dom.removeClass(row, 'row-outline');
    if (row.nextElementSibling) {
      this.builder.uo.saveForUndo();
      row.parentNode.insertBefore(row.nextElementSibling, row);
      this.rowTool.position(row);
      this.builder.opts.onChange();
    } else {
      // Move to next container

      let currContainer = row.parentNode;
      let flag = false;
      const builders = document.querySelectorAll(this.builder.opts.container);
      Array.prototype.forEach.call(builders, builder => {
        if (flag) {
          builder.insertBefore(row, builder.firstChild);
          this.rowTool.position(row);
          util.checkEmpty();
          this.builder.opts.onChange();
          return false;
        }
        if (builder.innerHTML === currContainer.innerHTML) {
          flag = true;
        }
      });
    }
  }
  duplicateRow() {
    let builder = this.builder;
    let util = this.util;
    let dom = this.dom;

    // const cell = util.cellSelected();
    // if(!cell) return;
    // let row = cell.parentNode;
    let row;
    let cell = util.cellSelected();
    if (cell) {
      row = cell.parentNode;
    } else {
      row = util.rowSelected();
    }
    if (!row) return;

    //Change to row selection
    dom.removeClass(row, 'row-outline');
    this.builder.uo.saveForUndo();

    //Clone row & cleanup attached tool & event
    const rowElement = row.cloneNode(true);
    rowElement.removeChild(rowElement.querySelector('.is-row-tool'));
    rowElement.removeChild(rowElement.querySelector('.is-col-tool'));
    let cols = dom.elementChildren(rowElement);
    cols.forEach(col => {
      col.removeAttribute('data-click');
      if (col.classList.contains('cell-active')) {
        builder.activeCol = col;
      }
    });
    dom.moveAfter(rowElement, row);

    //Unselect current row
    dom.removeClass(row, 'row-active');
    dom.removeClass(row, 'row-outline');
    cols = dom.elementChildren(row);
    cols.forEach(col => {
      dom.removeClass(col, 'cell-active');
    });

    //re-add tool
    let builderActive = this.builder.doc.querySelector('.builder-active');
    builder.applyBehaviorOn(builderActive);
    this.rowTool.position(rowElement);
    this.builder.opts.onChange();
  }
}
class RowTool$1 {
  constructor(builder) {
    this.builder = builder;
    const dom = this.builder.dom;
    this.dom = dom;
  }
  position(row) {
    let dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    let rowTool = row.querySelector('.is-row-tool');
    let rowMore = builderStuff.querySelector('.rowmore');
    if (!rowMore) return;
    dom.addClass(rowMore, 'transition1');
    const elm = rowTool.querySelector('.row-more');

    /*
    let top, left;
    if(!this.builder.iframe) {
        top = elm.getBoundingClientRect().top + window.pageYOffset;
        left = elm.getBoundingClientRect().left + window.pageXOffset;
    } else {
        let adjY = this.builder.iframe.getBoundingClientRect().top + window.pageYOffset;
        let adjX = this.builder.iframe.getBoundingClientRect().left + window.pageXOffset;
         top = elm.getBoundingClientRect().top;
        left = elm.getBoundingClientRect().left;
        top = top + adjY;
        left = left + adjX;
    }
    */
    const newPos = this.builder.util.getElementPosition(elm);
    let top = newPos.top;
    let left = newPos.left;

    // const w = rowMore.offsetWidth; 
    rowMore.style.top = top - 8 + 'px';
    dom.removeClass(rowMore, 'arrow-bottom');
    dom.removeClass(rowMore, 'arrow-left');
    dom.removeClass(rowMore, 'arrow-right');
    dom.removeClass(rowMore, 'center');
    dom.removeClass(rowMore, 'right');
    dom.removeClass(rowMore, 'left');
    if (this.builder.opts.rowTool === 'right') {
      rowMore.style.left = left - rowMore.offsetWidth - 10 + 'px';
      dom.addClass(rowMore, 'arrow-right');
      dom.addClass(rowMore, 'left');
    } else {
      rowMore.style.left = left + 35 + 'px';
      dom.addClass(rowMore, 'arrow-left');
      dom.addClass(rowMore, 'left');
    }
    setTimeout(() => {
      dom.removeClass(rowMore, 'transition1');
    }, 300);
  }
}

class Draggable$2 {
  constructor(opts = {}) {
    this.opts = opts;
    this.dragStart = this.dragStart.bind(this);
    this.dragEnd = this.dragEnd.bind(this);
    this.drag = this.drag.bind(this);
    const elms = document.querySelectorAll(this.opts.selector);
    Array.prototype.forEach.call(elms, elm => {
      elm.setAttribute('draggable', '');
      elm.addEventListener('mousedown', this.dragStart, false);
      elm.addEventListener('touchstart', this.dragStart, {
        passive: true
      });
      elm.addEventListener('mouseup', this.dragEnd, false);
      elm.addEventListener('touchend', this.dragEnd, false);
    });
  }
  dragStart(e) {
    if (!e.target.hasAttribute('draggable')) return; //any child element (ex. close button) should not be draggable. LATER: revew.

    if (e.type === 'touchstart' && e.touches.length !== 1) {
      return; // Do nothing if more than one touch point is detected
    }

    if (e.type === 'mousedown' && e.button !== 0) {
      return; // Do nothing if the right mouse button is clicked
    }

    e.target.parentNode.style.transition = 'none';
    this.dragActive = true;
    this.activeDraggableBox = e.target.parentElement;
    let xOffset;
    let yOffset;
    if (!this.activeDraggableBox.getAttribute('data-xOffset')) {
      this.activeDraggableBox.setAttribute('data-xOffset', 0);
      xOffset = 0;
    } else {
      xOffset = this.activeDraggableBox.getAttribute('data-xOffset');
    }
    if (!this.activeDraggableBox.getAttribute('data-yOffset')) {
      this.activeDraggableBox.setAttribute('data-yOffset', 0);
      yOffset = 0;
    } else {
      yOffset = this.activeDraggableBox.getAttribute('data-yOffset');
    }
    let initialX, initialY;
    if (e.type === 'touchstart') {
      initialX = e.touches[0].clientX - xOffset;
      initialY = e.touches[0].clientY - yOffset;
    } else {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
    }
    this.activeDraggableBox.setAttribute('data-initialX', initialX);
    this.activeDraggableBox.setAttribute('data-initialY', initialY);
    document.addEventListener('touchmove', this.drag, false);
    document.addEventListener('mousemove', this.drag, false);
  }
  dragEnd(e) {
    if (!e.target.hasAttribute('draggable')) return; //any child element (ex. close button) should not be draggable. LATER: revew.

    if (!this.activeDraggableBox) return;
    e.target.parentNode.style.transition = '';

    //Update
    let currentX = this.activeDraggableBox.getAttribute('data-currentX');
    let currentY = this.activeDraggableBox.getAttribute('data-currentY');
    let initialX = currentX;
    let initialY = currentY;
    this.activeDraggableBox.setAttribute('data-initialX', initialX);
    this.activeDraggableBox.setAttribute('data-initialY', initialY);
    this.dragActive = false;
    document.removeEventListener('touchmove', this.drag);
    document.removeEventListener('mousemove', this.drag);
  }
  drag(e) {
    if (this.dragActive) {
      e.preventDefault();
      let initialX = this.activeDraggableBox.getAttribute('data-initialX');
      let initialY = this.activeDraggableBox.getAttribute('data-initialY');
      let currentX, currentY;
      if (e.type === 'touchmove') {
        currentX = e.touches[0].clientX - initialX;
        currentY = e.touches[0].clientY - initialY;
      } else {
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
      }
      this.activeDraggableBox.style.transform = 'translate3d(' + currentX + 'px, ' + currentY + 'px, 0)';

      //Save
      this.activeDraggableBox.setAttribute('data-currentX', currentX);
      this.activeDraggableBox.setAttribute('data-currentY', currentY);
      let xOffset = currentX;
      let yOffset = currentY;
      this.activeDraggableBox.setAttribute('data-xOffset', xOffset);
      this.activeDraggableBox.setAttribute('data-yOffset', yOffset);
    }
  }
}

const renderGridEditor = builder => {
  const util = builder.util;
  const builderStuff = builder.builderStuff;
  const grid = new Grid(builder);
  const htmlutil = new HtmlUtil(builder);
  const dom = builder.dom;
  let rowhtmlbutton = '';
  if (builder.opts.rowHtmlEditor) rowhtmlbutton = `<button tabindex="-1" title="${util.out('HTML')}" class="row-html">
            <svg class="is-icon-flex" style="margin-right:-3px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>
        </button>`;
  let colhtmlbutton = '';
  if (builder.opts.columnHtmlEditor) colhtmlbutton = `<button tabindex="-1" title="${util.out('HTML')}" class="cell-html">
            <svg class="is-icon-flex" style="margin-right:-3px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>
        </button>`;
  const html = `<div class="is-modal is-modal-content grideditor" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="is-modal-bar is-draggable">
            <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
        </div>
        <div style="padding:13px 0 5px 18px;font-size:10px;text-transform:uppercase;letter-spacing:1px;">${util.out('Row')}</div>
        <div style="display:flex;flex-flow:wrap;">
            <button tabindex="-1" title="${util.out('Add')}" class="row-add"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            <button tabindex="-1" title="${util.out('Duplicate')}" class="row-duplicate" style="display: block;"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Up')}" class="row-up" style="display: block;"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Down')}" class="row-down" style="display: block;"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></button>
            ${rowhtmlbutton}
            <button tabindex="-1" title="${util.out('Delete')}" class="row-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
        </div>
        <div style="padding:8px 0 5px 18px;font-size:11px;text-transform:uppercase;letter-spacing:1px;">${util.out('Column')}</div>
        <div style="display:flex;flex-flow:wrap;">
            <button tabindex="-1" title="${util.out('Add')}" class="cell-add"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            <button tabindex="-1" title="${util.out('Duplicate')}" class="cell-duplicate"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Up')}" class="cell-up"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Down')}" class="cell-down"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Left')}" class="cell-prev"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-left"></use></svg></button>
            <button tabindex="-1" title="${util.out('Move Right')}" class="cell-next"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-right"></use></svg></button>
            <button tabindex="-1" title="${util.out('Increase')}" class="cell-increase"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-increase"></use></svg></button>
            <button tabindex="-1" title="${util.out('Decrease')}" class="cell-decrease"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-decrease"></use></svg></button>
            ${colhtmlbutton}
            <button tabindex="-1" title="${util.out('Delete')}" class="cell-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            <button tabindex="-1" title="${util.out('Lock')}" class="cell-locking"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#icon-lock"></use></svg></button>
            <button tabindex="-1" title="${util.out('Column Settings')}" class="cell-settings"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></button>
               
            <div class="is-separator">
                <button tabindex="-1" title="${util.out('Outline')}" class="grid-outline"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-grid-view-outline"></use></svg></button>
                <!--<button tabindex="-1" title="${util.out('Element Tool')}" class="cell-elmtool"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></button>-->
            </div>
        </div>
    </div>`;

  //LATER:
  //<button title="${util.out('Element Tool')}" class="cell-elmtool"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></button>

  dom.appendHtml(builderStuff, html);
  new Draggable$2({
    selector: '.is-draggable'
  });
  const grideditor = document.querySelector('.grideditor');
  let elm = grideditor.querySelector('.is-modal-close');
  dom.addEventListener(elm, 'click', () => {
    builder._rowTool.hideGridEditor();
  });
  const btnGridOutline = grideditor.querySelector('.grid-outline');
  dom.addEventListener(btnGridOutline, 'click', () => {
    const builders = builder.doc.querySelectorAll(builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (builder.hasAttribute('gridoutline')) {
        builder.removeAttribute('gridoutline');
        dom.removeClass(btnGridOutline, 'on');
      } else {
        builder.setAttribute('gridoutline', '');
        dom.addClass(btnGridOutline, 'on');
      }
    });
  });

  // CELL
  const btnAdd = grideditor.querySelector('.cell-add');
  dom.addEventListener(btnAdd, 'click', () => {
    const quickadd = renderQuickAdd(builder);
    let tabs = quickadd.querySelector('.is-pop-tabs');
    tabs.style.display = 'flex';
    const top = btnAdd.getBoundingClientRect().top + window.pageYOffset;
    const left = btnAdd.getBoundingClientRect().left + window.pageXOffset;
    // quickadd.style.display = 'flex';
    util.showPop(quickadd, false, btnAdd);
    const w = quickadd.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    //const h = quickadd.offsetHeight;
    quickadd.style.top = top + 'px';
    quickadd.style.left = left - w - 8 + 'px';
    dom.removeClass(quickadd, 'arrow-bottom');
    dom.removeClass(quickadd, 'arrow-left');
    dom.removeClass(quickadd, 'arrow-top');
    dom.removeClass(quickadd, 'center');
    dom.removeClass(quickadd, 'left');
    dom.addClass(quickadd, 'arrow-right');
    dom.addClass(quickadd, 'right');
    let val = quickadd.querySelector('.active').getAttribute('data-value');
    if (val === 'left') {
      quickadd.setAttribute('data-mode', 'cell-left');
    } else {
      quickadd.setAttribute('data-mode', 'cell-right');
    }

    //handleQuickAddClickOut
    const handleQuickAddClickOut = e => {
      // console.log('handleQuickAddClickOut');
      let elm = e.target;
      if (!elm) return;
      if (!elm.closest('.quickadd') && !elm.closest('.row-add') && !elm.closest('.is-rowadd-tool') && !elm.closest('.cell-add') && !elm.closest('.elm-add') && !elm.closest('.row-add-initial')) {
        // click outside

        // hide
        const quickadd = builderStuff.querySelector('.quickadd');
        util.hidePop(quickadd);
        // console.log('HIDE');

        // clear events
        document.removeEventListener('click', handleQuickAddClickOut);
        if (builder.iframeDocument) {
          builder.doc.removeEventListener('click', handleQuickAddClickOut);
        }
        builder.handleQuickAddClickOut_ = false;
      }
    };
    if (!builder.handleQuickAddClickOut_) {
      document.addEventListener('click', handleQuickAddClickOut);
      if (builder.iframeDocument) {
        builder.doc.addEventListener('click', handleQuickAddClickOut);
      }
      builder.handleQuickAddClickOut_ = true;
    }
  });
  elm = grideditor.querySelector('.cell-prev');
  dom.addEventListener(elm, 'click', () => {
    grid.moveColumnPrevious();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-next');
  dom.addEventListener(elm, 'click', () => {
    grid.moveColumnNext();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-increase');
  dom.addEventListener(elm, 'click', () => {
    grid.increaseColumn();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-decrease');
  dom.addEventListener(elm, 'click', () => {
    grid.decreaseColumn();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-up');
  dom.addEventListener(elm, 'click', () => {
    grid.moveColumnUp();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-down');
  dom.addEventListener(elm, 'click', () => {
    grid.moveColumnDown();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-duplicate');
  dom.addEventListener(elm, 'click', () => {
    grid.duplicateColumn();
    util.clearControls();
  });
  elm = grideditor.querySelector('.cell-remove');
  dom.addEventListener(elm, 'click', () => {
    grid.removeColumn();
    util.clearControls();
  });
  const btnCellHtml = grideditor.querySelector('.cell-html');
  if (btnCellHtml) dom.addEventListener(btnCellHtml, 'click', () => {
    const cell = util.cellSelected();
    if (!cell) return;
    htmlutil.view('cell', false, btnCellHtml);
  });
  const btnCellSettings = grideditor.querySelector('.cell-settings');
  if (btnCellSettings) dom.addEventListener(btnCellSettings, 'click', () => {
    const cell = util.cellSelected();
    if (!cell) return;
    builder.colTool.renderPanel();
    builder.colTool.readCellStyles(cell);

    //save selection
    util.saveSelection();
    const cellSettings = document.querySelector('.is-modal.columnsettings');
    util.showModal(cellSettings, false, () => {
      let rtetool = builder.builderStuff.querySelector('.is-rte-tool');
      if (rtetool.style.display === 'flex') {
        // means text selection

        util.restoreSelection();

        // if(builder.activeElement) {
        //     dom.addClass(builder.activeElement, 'elm-active');
        //     builder.elmTool.repositionElementTool();
        // }

        btnCellSettings.removeAttribute('data-focus');
        btnCellSettings.focus();
      }
    });
    btnCellSettings.setAttribute('data-focus', true);
  });

  // Lock/Unlock Column
  const btnCellLocking = grideditor.querySelector('.cell-locking');
  if (btnCellLocking) dom.addEventListener(btnCellLocking, 'click', e => {
    let cell = util.cellSelected();
    if (!cell) return;
    if (!cell.hasAttribute('data-noedit')) {
      cell.setAttribute('data-noedit', '');
      cell.contentEditable = false;
      dom.addClass(btnCellLocking, 'on');
      util.clearActiveElement(true);
    } else {
      cell.removeAttribute('data-noedit');
      cell.contentEditable = true;
      dom.removeClass(btnCellLocking, 'on');
    }
    builder.colTool.showHideLockIndicator(cell);
    builder.element.applyBehavior(cell);
    e.preventDefault();
  });

  // ROW

  const btnRowAdd = grideditor.querySelector('.row-add');
  dom.addEventListener(btnRowAdd, 'click', () => {
    const quickadd = renderQuickAdd(builder);
    let tabs = quickadd.querySelector('.is-pop-tabs');
    tabs.style.display = 'none';
    const top = btnRowAdd.getBoundingClientRect().top + window.pageYOffset;
    const left = btnRowAdd.getBoundingClientRect().left + window.pageXOffset;
    // quickadd.style.display = 'flex';
    util.showPop(quickadd, false, btnRowAdd);
    const w = quickadd.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    //const h = quickadd.offsetHeight;
    quickadd.style.top = top + 'px';
    quickadd.style.left = left - w - 8 + 'px';
    dom.removeClass(quickadd, 'arrow-bottom');
    dom.removeClass(quickadd, 'arrow-left');
    dom.removeClass(quickadd, 'arrow-top');
    dom.removeClass(quickadd, 'center');
    dom.removeClass(quickadd, 'left');
    dom.addClass(quickadd, 'arrow-right');
    dom.addClass(quickadd, 'right');
    quickadd.setAttribute('data-mode', 'row');
  });
  elm = grideditor.querySelector('.row-up');
  dom.addEventListener(elm, 'click', () => {
    grid.moveRowUp();
    util.clearControls();
  });
  elm = grideditor.querySelector('.row-down');
  dom.addEventListener(elm, 'click', () => {
    grid.moveRowDown();
    util.clearControls();
  });
  elm = grideditor.querySelector('.row-duplicate');
  dom.addEventListener(elm, 'click', () => {
    grid.duplicateRow();
    util.clearControls();
  });
  elm = grideditor.querySelector('.row-remove');
  dom.addEventListener(elm, 'click', () => {
    grid.removeRow();
    util.clearControls();
  });
  const btnRowHtml = grideditor.querySelector('.row-html');
  if (btnRowHtml) dom.addEventListener(btnRowHtml, 'click', () => {
    const cell = util.cellSelected();
    if (!cell) return;
    htmlutil.view('row', false, btnRowHtml);
  });
};

/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$1(obj);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var version$1 = "1.15.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass$1(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find$2(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect$1(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect$1(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect$1(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle$1(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect$1(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect$1(child)
        });
        var fromRect = _objectSpread2$1({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect$1(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2$1({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2$1({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent$1(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2$1(_objectSpread2$1({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2$1({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent$1(_objectSpread2$1({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect$1(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect$1(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect$1(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof$1(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect$1(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass$1(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find$2(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass$1(dragEl, options.dragClass, false);
      toggleClass$1(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect$1(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass$1(ghostEl, options.ghostClass, false);
      toggleClass$1(ghostEl, options.fallbackClass, true);
      toggleClass$1(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass$1(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass$1(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2$1({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect$1(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass$1(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect$1(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect$1(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect$1(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect$1(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect$1(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass$1(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect$1(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect$1(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect$1(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find$2,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle$1,
  closest: closest,
  toggleClass: toggleClass$1,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2$1(_objectSpread2$1({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version$1;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle$1(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect$1(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

class CustomSelect {
  constructor(selector, config = {}) {
    this.select = document.querySelector(selector);

    // Construct
    const template = `
            <div class="select-styled" tabindex="0">
                <span></span>
                <span><svg><use xlink:href="#icon-chevron-down"></use></svg></span>
            </div>
            <input type="text">
            <ul class="select-options" aria-haspopup="listbox">
            </ul>
        `;
    if (this.select.innerHTML.trim() === '') {
      this.select.innerHTML = template;
    }
    this.select.setAttribute('role', 'combobox');
    this.select.classList.add('custom-select');
    this.selectStyled = this.select.querySelector('.select-styled');
    this.selectOptions = this.select.querySelector('.select-options');
    this.selectSearch = this.select.querySelector('input');
    this.selectSearch.setAttribute('id', `__${this.uniqueId()}`);
    const defaultConfig = {
      search: true
      // Add more default parameters here if needed in the future
    };

    // Merge default config with the provided config
    this.config = {
      ...defaultConfig,
      ...config
    };
    if (this.config.search) this.select.classList.add('has-search');
    if (this.config.data) {
      this.selectOptions.innerHTML = ''; //clear
      this.config.data.forEach(choice => {
        const option = document.createElement('li');
        option.setAttribute('data-value', choice.value);
        option.innerHTML = choice.label;
        this.selectOptions.appendChild(option);
      });
    }
    this.selectStyled.addEventListener('keydown', this.handleKeydown.bind(this));
    this.selectStyled.addEventListener('click', this.toggleOptions.bind(this));
    this.selectOptions.addEventListener('click', this.handleOptionClick.bind(this));
    this.selectSearch.addEventListener('input', this.handleFilterInput.bind(this));

    // this.selectStyled.addEventListener('mousedown', ()=>{
    //     this.select.classList.add('clicked');
    // });
  }

  handleKeydown(event) {
    if (!this.selectOptions.classList.contains('active')) {
      switch (event.key) {
        case 'Enter':
          this.openOptions();
          event.preventDefault();
          break;
        case ' ':
          this.openOptions();
          event.preventDefault();
          break;
      }
    }
  }
  toggleOptions() {
    if (this.selectOptions.classList.contains('active')) {
      this.closeOptions();
    } else {
      this.openOptions();
    }
  }
  openOptions() {
    this.clearFilter();
    this.selectOptions.classList.add('active');
    this.selectStyled.setAttribute('aria-expanded', 'true');
    setTimeout(() => {
      // Delay to attach only after options is opened
      // document.addEventListener('keydown', this.handleGlobalKeydown.bind(this));
      // document.addEventListener('click', this.handleGlobalClick.bind(this));

      document.addEventListener('keydown', this.AA = event => {
        this.handleGlobalKeydown(event);
      });
      document.addEventListener('click', this.BB = event => {
        this.handleGlobalClick(event);
      });
      if (this.config.search) this.selectSearch.focus(); // focus after delay so that SPACE key to open dropdown doesn't get entered into the textbox
    }, 100);
    if (this.config.search) this.selectSearch.style.display = 'block';

    // Select value
    const value = this.select.getAttribute('data-value');
    const options = this.selectOptions.querySelectorAll('li');
    options.forEach(option => {
      if (value === option.getAttribute('data-value')) {
        option.classList.add('selected');
        option.scrollIntoView();
      } else option.classList.remove('selected');
    });
  }
  closeOptions() {
    this.selectOptions.classList.remove('active');
    this.selectStyled.setAttribute('aria-expanded', 'false');

    // document.removeEventListener('keydown', this.handleGlobalKeydown.bind(this));
    // document.removeEventListener('click', this.handleGlobalClick.bind(this));

    document.removeEventListener('keydown', this.AA);
    document.removeEventListener('click', this.BB);
    this.selectSearch.style.display = 'none';

    // this.select.classList.remove('clicked');
  }

  handleGlobalClick(event) {
    const target = event.target;
    const isClickInsideSelect = this.select.contains(target);
    if (!isClickInsideSelect) {
      this.closeOptions();
      this.selectStyled.blur(); // Remove focus from the select styled div
    }
  }

  handleGlobalKeydown(event) {
    if (this.selectOptions.classList.contains('active')) {
      const options = this.selectOptions.querySelectorAll('li');
      const currentIndex = Array.from(options).findIndex(option => option.classList.contains('selected'));
      let nextIndex;
      switch (event.key) {
        case 'ArrowUp':
          nextIndex = this.findPreviousVisibleIndex(options, currentIndex);
          this.highlightOption(options, nextIndex);
          event.preventDefault();
          break;
        case 'ArrowDown':
          nextIndex = this.findNextVisibleIndex(options, currentIndex);
          this.highlightOption(options, nextIndex);
          break;
        case 'Enter':
          if (currentIndex !== -1) {
            this.selectOption(options[currentIndex]);
            this.selectStyled.focus();
          }
          break;
        // case ' ':
        //     event.preventDefault(); // Prevent scrolling
        //     if (currentIndex !== -1) {
        //         this.selectOption(options[currentIndex]);
        //         this.selectStyled.focus();
        //     }
        //     break;
        case 'Escape':
          this.closeOptions();
          this.selectStyled.focus();
          break;
        case 'Tab':
          this.closeOptions();
          this.selectStyled.focus();
          break;
      }
    }
  }
  highlightOption(options, index) {
    options.forEach(option => option.classList.remove('selected'));
    if (index < 0) {
      index = options.length - 1;
    } else if (index >= options.length) {
      index = 0;
    }
    options[index].classList.add('selected');
    options[index].scrollIntoView({
      block: 'nearest',
      inline: 'start'
    });
  }
  handleOptionClick(event) {
    const options = this.selectOptions.querySelectorAll('li');
    options.forEach(option => option.classList.remove('selected'));
    const li = event.target.closest('li');
    if (li) {
      this.selectOption(li);
      this.selectStyled.focus();
      li.classList.add('selected');
    }
  }
  selectOption(option) {
    const value = option.getAttribute('data-value');
    this.select.setAttribute('data-value', value);
    const options = this.selectOptions.querySelectorAll('li');
    options.forEach(option => {
      if (value === option.getAttribute('data-value')) {
        const span = this.selectStyled.querySelector('span');
        span.innerHTML = option.innerHTML;
      }
    });
    this.closeOptions();

    // Trigger custom change event
    // const changeEvent = new Event('change');
    // this.select.dispatchEvent(changeEvent);

    if (this.config.onChange) this.config.onChange(value);
  }
  setValue(value) {
    this.select.setAttribute('data-value', value);
    const options = this.selectOptions.querySelectorAll('li');
    options.forEach(option => {
      if (value === option.getAttribute('data-value')) {
        option.classList.add('selected');
        const span = this.selectStyled.querySelector('span');
        span.innerHTML = option.innerHTML;
      } else option.classList.remove('selected');
    });
  }
  getValue() {
    return this.select.getAttribute('data-value');
  }
  clearFilter() {
    this.selectSearch.value = '';
    const options = this.selectOptions.querySelectorAll('li');
    options.forEach(option => {
      option.style.display = 'flex';
    });
  }
  handleFilterInput() {
    if (this.selectOptions.classList.contains('active')) {
      const filterValue = this.selectSearch.value.toLowerCase();
      const options = this.selectOptions.querySelectorAll('li');
      options.forEach(option => option.classList.remove('selected'));
      let visibleOptions = [];
      options.forEach(option => {
        const optionValue = option.getAttribute('data-value');
        // const startsWithFilter = optionValue.startsWith(filterValue);
        const startsWithFilter = optionValue.includes(filterValue);
        if (startsWithFilter) {
          option.style.display = 'flex';
          visibleOptions.push(option);
        } else {
          option.style.display = 'none';
        }
      });
      if (visibleOptions.length > 0) {
        this.highlightOption(visibleOptions, 0);
      } else {
        this.clearFilter();
      }
    }
  }
  findNextVisibleIndex(options, currentIndex) {
    let nextIndex = currentIndex + 1;
    while (nextIndex < options.length) {
      if (options[nextIndex].style.display !== 'none') {
        return nextIndex;
      }
      nextIndex++;
    }
    return currentIndex; // If no next visible option, stay on the current index
  }

  findPreviousVisibleIndex(options, currentIndex) {
    let previousIndex = currentIndex - 1;
    while (previousIndex >= 0) {
      if (options[previousIndex].style.display !== 'none') {
        return previousIndex;
      }
      previousIndex--;
    }
    return currentIndex; // If no previous visible option, stay on the current index
  }

  uniqueId() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
}

const renderSnippetPanel = (builder, snippetOpen) => {
  const util = builder.util;
  const builderStuff = builder.builderStuff;
  const dom = builder.dom;
  let hideHandle = '';
  let sidePanel = builder.opts.sidePanel;
  if (builder.opts.snippetList === '#divSnippetList') {
    const html = `<div id="divSnippetList" class="is-side ${sidePanel === 'right' ? '' : ' fromleft'} snippetlist scroll-darker" tabindex="-1" role="dialog" aria-modal="true" title="${util.out('Snippets')}">
            </div>`;
    dom.appendHtml(builderStuff, html);
    if (!builder.opts.snippetHandle) {
      hideHandle = 'display:none;';
    }
  } else {
    hideHandle = 'display:none;';
    sidePanel = 'left';
  }
  let defaultcatval = '';
  if (builder.opts.emailMode) {
    defaultcatval = builder.opts.defaultEmailSnippetCategory;
  } else {
    defaultcatval = builder.opts.defaultSnippetCategory;
  }
  let html_snippets = '' + `
        <div style="position:absolute;top:0;right:0;padding: 0;width:100%;z-index:2;">
            <div class="inp-snippets">
            </div>
        </div>

        ` + (sidePanel === 'right' ? '<div id="divSnippetScrollUp" role="button" tabindex="-1" style="top:calc(50% - 27px);right:25px;">&#9650;</div>' + '<div id="divSnippetScrollDown" role="button" tabindex="-1" style="top:calc(50% + 27px);right:25px;">&#9660;</div>' + '<div id="divSnippetHandle" role="button" tabindex="-1" title="' + util.out('Snippets') + '" data-title="' + util.out('Snippets') + '" style="' + hideHandle + '">' + '<svg class="is-icon-flex"><use xlink:href="#ion-ios-arrow-left"></use></svg>' + '</div>' : '<div id="divSnippetScrollUp" role="button" tabindex="-1" style="top:calc(50% - 27px);left:10px;">&#9650;</div>' + '<div id="divSnippetScrollDown" role="button" tabindex="-1" style="top:calc(50% + 27px);left:10px;">&#9660;</div>' + '<div id="divSnippetHandle" role="button" tabindex="-1" title="' + util.out('Snippets') + '" data-title="' + util.out('Snippets') + '" style="' + hideHandle + '">' + '<svg class="is-icon-flex"><use xlink:href="#ion-ios-arrow-right"></use></svg>' + '</div>') + '<div class="is-design-list" tabindex="0">' + '</div>';
  if (builder.opts.snippetModal) {
    builder.opts.snippetList = '#divSnippetWindow';
    let html = `
        <div class="is-modal active is-modal-content snippetwindow scroll-darker" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-bar is-draggable">
                <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
            </div>
            <div id="divSnippetWindow">
            </div>   
        </div>
        `;
    dom.appendHtml(builder.builderStuff, html);
    builder.draggable('.snippetwindow .is-draggable');
    const snippetModal = builder.builderStuff.querySelector('.is-modal.snippetwindow');
    const btnClose = snippetModal.querySelector('.is-modal-close');
    btnClose.addEventListener('click', () => {
      snippetModal.classList.remove('active');
    });
    if (builder.snippetModalLeft) {
      snippetModal.classList.add('left');
    }
  }
  let snippetPanel = document.querySelector(builder.opts.snippetList);
  snippetPanel.innerHTML = ''; //clear
  dom.appendHtml(snippetPanel, html_snippets);
  const snippetList = [];
  builder.opts.snippetCategories.forEach(item => {
    const jsonItem = {};
    jsonItem.value = item[0];
    jsonItem.label = item[1];
    snippetList.push(jsonItem);
  });
  const inpSnippet = new CustomSelect('.inp-snippets', {
    data: snippetList,
    search: false,
    onChange: value => {
      let cat = value;
      let elms = snippetlist.querySelectorAll('.snippet-item');
      let exist = false;
      Array.prototype.forEach.call(elms, elm => {
        if (elm.getAttribute('data-cat') === cat) exist = true;
      });
      if (!exist) {
        builder.opts.snippetJSON.snippets.forEach(item => {
          if (item.category === cat) {
            dom.appendHtml(snippetlist, '<div class="snippet-item" data-id="' + item.id + '" data-cat="' + item.category + '"><img alt="' + util.out('Snippet') + '" alt="" src="' + snippetPath + item.thumbnail + '"><span class="is-overlay"></span></div>');
          }
        });
      }
      if (cat) {
        Array.prototype.forEach.call(elms, elm => {
          dom.addClass(elm, 'hide');
        });
        Array.prototype.forEach.call(elms, elm => {
          if (elm.getAttribute('data-cat') === cat) {
            elm.className = elm.className.replace(/hide/g, '');
          }
        });
      }
    }
  });
  inpSnippet.setValue(defaultcatval + '');
  inpSnippet.closeOptions();
  if (builder.opts.snippetList === '#divSnippetList') {
    snippetPanel.querySelector('.is-design-list').style.display = 'none';

    // Hide snippet panel on content click
    builder.doc.addEventListener('click', builder.doHideSnippetHandler = e => {
      e = e || window.event;
      var target = e.target || e.srcElement;
      if (builder.opts.snippetsSidebarDisplay === 'auto') {
        if (dom.hasClass(snippetPanel, 'active')) {
          // let a = dom.parentsHasAttribute(target, 'contenteditable');
          // let b = dom.parentsHasClass(target, 'is-builder'); // builder area
          // if(a||b) {
          //     hideSnippets(builder);
          // }
          let a = dom.parentsHasClass(target, 'is-builder'); // builder area
          if (a) {
            hideSnippets(builder);
          }
        }
      }
    }, false);
  }
  const snippetlist = document.querySelector('.is-design-list');
  let snippetPath = builder.opts.snippetPath;

  /*
  Hide slider snippets (backward compatible)
  let bHideSliderSnippet = false;
  try{
      if (typeof jQuery.fn.slick === 'undefined') {
          bHideSliderSnippet = true;
      }
  } catch(e){
      bHideSliderSnippet = true;
  }
  */

  let snippets = builder.opts.snippetJSON.snippets;
  let slider = builder.opts.slider;
  if (typeof slider !== 'undefined' && slider !== null) {
    if (slider === 'slick') {
      //remove glide
      const predicate = item => item.type !== 'glide';
      builder.opts.snippetJSON.snippets = snippets.filter(predicate);
    } else if (slider === 'glide') {
      //remove slick
      const predicate = item => item.type !== 'slick';
      builder.opts.snippetJSON.snippets = snippets.filter(predicate);
    } else if (slider === 'all') ; else {
      // remove all slider (if incorrect settings)
      const predicate = item => item.type !== 'glide' && item.type !== 'slick';
      builder.opts.snippetJSON.snippets = snippets.filter(predicate);
    }

    // for (let i = 0; i < builder.opts.snippetJSON.snippets.length; i++) {
    //     console.log(builder.opts.snippetJSON.snippets[i].type)
    // }
  } else {
    // Backward compatible OR if slider param not set

    // Hide slider snippet if slick is not included
    var bHideSliderSnippet = true;
    if (builder.win.jQuery) {
      if (builder.win.jQuery.fn.slick) {
        bHideSliderSnippet = false;
      }
    }
    if (bHideSliderSnippet) {
      const result = snippets.filter(item => {
        return item.type !== 'slick';
      });
      snippets = [...result];
    }
    if (!builder.win.Glide) {
      const result = snippets.filter(item => {
        return !(item.glide || item.type === 'glide');
      });
      snippets = [...result];
    }

    // for (let i = 0; i < snippets.length; i++) {
    //     console.log(snippets[i].type)
    // }

    builder.opts.snippetJSON.snippets = [...snippets];
  }
  let index = 1;
  if (builder.opts.emailMode) {
    builder.opts.snippetJSON.snippets.forEach(item => {
      item.id = index; //Give id to each record
      if (item.category === builder.opts.defaultEmailSnippetCategory + '') {
        dom.appendHtml(snippetlist, '<div class="snippet-item" data-id="' + item.id + '" data-cat="' + item.category + '"><img alt="' + util.out('Snippet') + '" src="' + snippetPath + item.thumbnail + '"><span class="is-overlay"></span></div>');
      }
      index++;
    });
  } else {
    builder.opts.snippetJSON.snippets.forEach(item => {
      item.id = index; //Give id to each record
      if (item.category === builder.opts.defaultSnippetCategory + '') {
        dom.appendHtml(snippetlist, '<div class="snippet-item" data-id="' + item.id + '" data-cat="' + item.category + '"><img alt="' + util.out('Snippet') + '" src="' + snippetPath + item.thumbnail + '"><span class="is-overlay"></span></div>');
      }
      index++;
    });
  }

  /*
  let userAgentString = navigator.userAgent; 
  let safariAgent = userAgentString.indexOf('Safari') > -1; 
  let chromeAgent = userAgentString.indexOf('Chrome') > -1; 
  if ((chromeAgent) && (safariAgent)) safariAgent = false;
  */
  // let safariAgent = false;

  let activeBuilderArea;
  let itemHeight;
  new Sortable(snippetlist, {
    // forceFallback: safariAgent,
    group: {
      name: 'shared',
      pull: 'clone',
      put: false // Do not allow items to be put into this list
    },

    sort: false,
    animation: 150,
    onChoose: evt => {
      // Adjust temmporary
      const newCss = `
            <style id="css-scale">
                .sortable-ghost {
                    height: 50px;
                }
                .sortable-ghost * {
                    display: none
                }
            </style>
            `;
      itemHeight = evt.item.offsetHeight;
      if (builder.iframe) {
        const oldCss = builder.contentStuff.querySelector('#css-scale');
        if (oldCss) oldCss.parentNode.removeChild(oldCss);
        builder.contentStuff.insertAdjacentHTML('afterbegin', newCss);
      } else {
        const oldCss = builder.builderStuff.querySelector('#css-scale');
        if (oldCss) oldCss.parentNode.removeChild(oldCss);
        builder.builderStuff.insertAdjacentHTML('afterbegin', newCss);
      }
      builder.uo.saveForUndo(true); // Must be called before sectionDropSetup() to prevent saving extra 'block-dummy' helpers.

      builder.sectionDropSetup();
      builder.util.clearPops();
      builder.hideElementTools();
    },
    onClone: evt => {
      // fix broken image on cloned element
      var cloneEl = evt.clone;
      let img = cloneEl.querySelector('img');
      img.style.opacity = 0.0001;
      cloneEl.style.height = itemHeight + 'px';
      let timestamp = new Date().getTime();
      img.src = img.src + '?' + timestamp;
      img.style.opacity = '';
    },
    onMove: () => {
      let emptyinfo = builder.doc.querySelector('.row-add-initial'); // if there is empty info, remove it during snippet drag drop
      // if(emptyinfo) emptyinfo.parentNode.removeChild(emptyinfo);
      if (emptyinfo) emptyinfo.style.display = 'none';

      // if(builder.sortableOnPage) if(evt.related.getBoundingClientRect().top<0 ||
      //     evt.related.getBoundingClientRect().top>window.innerHeight) {
      //     return false;
      // }

      // to prevent flicker caused by snippet panel above wrapper (see contentbuilder.js sectionDropSetup)
      if (builder.page && builder.page === '.is-wrapper') {
        const wrapper = builder.doc.querySelector(builder.page);
        if (wrapper) wrapper.style.marginLeft = '';
      }
    },
    onSort: evt => {
      if (!builder.canvas) return;
      let snippetX = evt.originalEvent.clientX;
      let snippetY = evt.originalEvent.clientY;
      const block = builder.doc.querySelector('[data-new-dummy]');
      if (block) {
        const docContainer = block.parentNode;
        const rectContainer = docContainer.getBoundingClientRect();
        block.offsetWidth / 2;
        let x = (snippetX - block.offsetWidth / 2 - rectContainer.left) / docContainer.offsetWidth * 100;
        let y = (snippetY - block.offsetHeight / 2 - rectContainer.top) / docContainer.offsetHeight * 100;
        block.style.top = y + '%';
        block.style.left = x + '%';
        block.removeAttribute('data-new-dummy');
      }
    },
    onStart: () => {
      // Remove .builder-active during dragging (because this class makes rows have border-right/left 120px)
      activeBuilderArea = null;
      const area = builder.doc.querySelector('.builder-active');
      if (area) {
        activeBuilderArea = area;
        dom.removeClass(activeBuilderArea, 'builder-active');
      }

      // builder.uo.saveForUndo(); // Even if cancelled, saveForUndo will make sure not to save if there is no change => commented (moved to onChoose). 

      let elm = document.querySelector('.is-sidebar-overlay');
      if (elm) elm.style.display = 'none'; // LATER: ContentBox
    },

    onEnd: () => {
      let elm = document.querySelector('.is-sidebar-overlay');
      if (elm) elm.style.display = 'block'; // LATER: ContentBox
      util.checkEmpty(); // In case container is still empty (drag drop snippet cancelled)

      let emptyinfo = builder.doc.querySelector('.row-add-initial');
      if (emptyinfo) emptyinfo.style.display = '';

      // Return back the .builder-active
      if (activeBuilderArea) {
        dom.addClass(activeBuilderArea, 'builder-active');
      }
    },
    onUnchoose: () => {
      setTimeout(() => {
        // Give time for onAdd to finish
        // Destroy placed in onUnchoose in case a snippet is just clicked (no drag/drop) so that onAdd is not triggered.
        // destroy
        if (builder.sortableOnCanvas) {
          builder.sortableOnCanvas.forEach(obj => {
            if (obj) {
              obj.destroy();
            }
          });
          builder.sortableOnCanvas = [];
        }
        if (builder.sortableOnPage) {
          builder.sortableOnPage.destroy();
          builder.sortableOnPage = null;
        }
        let dummies = builder.doc.querySelectorAll('.block-dummy');
        dummies.forEach(elm => elm.parentNode.removeChild(elm));

        // to prevent flicker caused by snippet panel above wrapper (see contentbuilder.js sectionDropSetup)
        if (builder.page && builder.page === '.is-wrapper') {
          const wrapper = builder.doc.querySelector(builder.page);
          if (wrapper) wrapper.style.marginLeft = '';
        }
      }, 10);
    }
  });
  if (builder.opts.snippetList === '#divSnippetList') {
    const snippethandle = snippetPanel.querySelector('#divSnippetHandle');
    dom.addEventListener(snippethandle, 'click', () => {
      toggleSnippets(builder);
      util.clearActiveCell();
      util.clearControls();
    });
    const viewportWidth = window.innerWidth;
    if ((builder.opts.snippetOpen || snippetOpen) && viewportWidth >= 960) {
      snippetPanel.style.cssText = 'transition: all ease 0.8s;';
      setTimeout(function () {
        toggleSnippets(builder);
      }, 100);
      setTimeout(function () {
        snippetPanel.style.cssText = '';
      }, 1300);
    }
  }

  //Scroll helper
  let scrollup = snippetPanel.querySelector('#divSnippetScrollUp');
  let scrolldown = snippetPanel.querySelector('#divSnippetScrollDown');
  // if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i)) || (navigator.userAgent.match(/iPad/i))) {

  // } else {
  //     scrollup.style.display = 'none';
  //     scrolldown.style.display = 'none';
  // }
  scrollup.style.display = 'none';
  scrolldown.style.display = 'none';

  /*
  TODO
  
  var maxScroll=100000000;       
  jQuery('#divSnippetScrollUp').css('display','none');
  jQuery('#divSnippetScrollUp').on("click touchup", function(e) { 
      jQuery(".is-design-list").animate({ scrollTop: (jQuery(".is-design-list").scrollTop() - (jQuery(".is-design-list").height()-150) ) + "px" },300, function(){
          if(jQuery(".is-design-list").scrollTop()!=0){
              jQuery('#divSnippetScrollUp').fadeIn(300);
          } else {
                  jQuery('#divSnippetScrollUp').fadeOut(300);
          }
          if(jQuery(".is-design-list").scrollTop() != maxScroll){
              jQuery('#divSnippetScrollDown').fadeIn(300);
          } else {
                  jQuery('#divSnippetScrollDown').fadeOut(300);
          }  
      });           
       e.preventDefault();
      e.stopImmediatePropagation();
      return false;
  });            
  jQuery('#divSnippetScrollDown').on("click touchup", function(e) {                         
      jQuery(".is-design-list").animate({ scrollTop: (jQuery(".is-design-list").scrollTop() + (jQuery(".is-design-list").height()-150) ) + "px" }, 300, function() {
          if(jQuery(".is-design-list").scrollTop()!=0){
              jQuery('#divSnippetScrollUp').fadeIn(300);
          } else {
              jQuery('#divSnippetScrollUp').fadeOut(300);
      
          }
          if(maxScroll===100000000){
              maxScroll = jQuery('.is-design-list').prop('scrollHeight') - jQuery('.is-design-list').height() - 30;
          }  
          
          if(jQuery(".is-design-list").scrollTop() != maxScroll){
              jQuery('#divSnippetScrollDown').fadeIn(300);
          } else {
              jQuery('#divSnippetScrollDown').fadeOut(300);
          }  
      });
       e.preventDefault();
      e.stopImmediatePropagation();
      return false;
  });
  */
};

function openSnippets(builder) {
  const snippetPanel = document.querySelector('#divSnippetList');
  const snippethandle = snippetPanel.querySelector('#divSnippetHandle');
  snippetPanel.style.cssText = 'transition: all ease 0.8s;';
  snippetPanel.querySelector('.is-design-list').style.display = 'block';
  snippetPanel.classList.add('active');
  if (builder.opts.sidePanel === 'right') {
    snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>';
  } else {
    snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-left"></use></svg>';
  }
  setTimeout(function () {
    snippetPanel.style.cssText = '';
  }, 800);
}
function toggleSnippets(builder) {
  const dom = builder.dom;
  let snippetPanel = document.querySelector('#divSnippetList');
  const snippethandle = snippetPanel.querySelector('#divSnippetHandle');
  if (dom.hasClass(snippetPanel, 'active')) {
    dom.removeClass(snippetPanel, 'active');
    if (builder.opts.sidePanel === 'right') {
      snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-left"></use></svg>';
    } else {
      snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>';
    }
    setTimeout(() => {
      snippetPanel.querySelector('.is-design-list').style.display = 'none';
    }, 300);
  } else {
    snippetPanel.querySelector('.is-design-list').style.display = 'block';
    setTimeout(() => {
      dom.addClass(snippetPanel, 'active');
      if (builder.opts.sidePanel === 'right') {
        snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>';
      } else {
        snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-left"></use></svg>';
      }
    }, 10);
  }
}
function hideSnippets(builder) {
  const dom = builder.dom;
  let snippetPanel = document.querySelector('#divSnippetList');
  const snippethandle = snippetPanel.querySelector('#divSnippetHandle');
  dom.removeClass(snippetPanel, 'active');
  if (builder.opts.sidePanel === 'right') {
    snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-left"></use></svg>';
  } else {
    snippethandle.innerHTML = '<svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-ios-arrow-right"></use></svg>';
  }
  setTimeout(() => {
    snippetPanel.querySelector('.is-design-list').style.display = 'none';
  }, 300);
}

/*!
 * Cropper.js v1.5.12
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2021-06-12T08:00:17.411Z
 */

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
var WINDOW = IS_BROWSER ? window : {};
var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
var NAMESPACE = 'cropper'; // Actions

var ACTION_ALL = 'all';
var ACTION_CROP = 'crop';
var ACTION_MOVE = 'move';
var ACTION_ZOOM = 'zoom';
var ACTION_EAST = 'e';
var ACTION_WEST = 'w';
var ACTION_SOUTH = 's';
var ACTION_NORTH = 'n';
var ACTION_NORTH_EAST = 'ne';
var ACTION_NORTH_WEST = 'nw';
var ACTION_SOUTH_EAST = 'se';
var ACTION_SOUTH_WEST = 'sw'; // Classes

var CLASS_CROP = "".concat(NAMESPACE, "-crop");
var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

var DATA_ACTION = "".concat(NAMESPACE, "Action");
var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

var DRAG_MODE_CROP = 'crop';
var DRAG_MODE_MOVE = 'move';
var DRAG_MODE_NONE = 'none'; // Events

var EVENT_CROP = 'crop';
var EVENT_CROP_END = 'cropend';
var EVENT_CROP_MOVE = 'cropmove';
var EVENT_CROP_START = 'cropstart';
var EVENT_DBLCLICK = 'dblclick';
var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
var EVENT_READY = 'ready';
var EVENT_RESIZE = 'resize';
var EVENT_WHEEL = 'wheel';
var EVENT_ZOOM = 'zoom'; // Mime types

var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
var REGEXP_DATA_URL = /^data:/;
var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc
// Inspired by the default width and height of a canvas element.

var MIN_CONTAINER_WIDTH = 200;
var MIN_CONTAINER_HEIGHT = 100;

var DEFAULTS = {
  // Define the view mode of the cropper
  viewMode: 0,
  // 0, 1, 2, 3
  // Define the dragging mode of the cropper
  dragMode: DRAG_MODE_CROP,
  // 'crop', 'move' or 'none'
  // Define the initial aspect ratio of the crop box
  initialAspectRatio: NaN,
  // Define the aspect ratio of the crop box
  aspectRatio: NaN,
  // An object with the previous cropping result data
  data: null,
  // A selector for adding extra containers to preview
  preview: '',
  // Re-render the cropper when resize the window
  responsive: true,
  // Restore the cropped area after resize the window
  restore: true,
  // Check if the current image is a cross-origin image
  checkCrossOrigin: true,
  // Check the current image's Exif Orientation information
  checkOrientation: true,
  // Show the black modal
  modal: true,
  // Show the dashed lines for guiding
  guides: true,
  // Show the center indicator for guiding
  center: true,
  // Show the white modal to highlight the crop box
  highlight: true,
  // Show the grid background
  background: true,
  // Enable to crop the image automatically when initialize
  autoCrop: true,
  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,
  // Enable to move the image
  movable: true,
  // Enable to rotate the image
  rotatable: true,
  // Enable to scale the image
  scalable: true,
  // Enable to zoom the image
  zoomable: true,
  // Enable to zoom the image by dragging touch
  zoomOnTouch: true,
  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: true,
  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,
  // Enable to move the crop box
  cropBoxMovable: true,
  // Enable to resize the crop box
  cropBoxResizable: true,
  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: true,
  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: MIN_CONTAINER_WIDTH,
  minContainerHeight: MIN_CONTAINER_HEIGHT,
  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
};

var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

/**
 * Check if the given value is not a number.
 */

var isNaN$1 = Number.isNaN || WINDOW.isNaN;
/**
 * Check if the given value is a number.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a number, else `false`.
 */

function isNumber$1(value) {
  return typeof value === 'number' && !isNaN$1(value);
}
/**
 * Check if the given value is a positive number.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
 */

var isPositiveNumber = function isPositiveNumber(value) {
  return value > 0 && value < Infinity;
};
/**
 * Check if the given value is undefined.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
 */

function isUndefined$1(value) {
  return typeof value === 'undefined';
}
/**
 * Check if the given value is an object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is an object, else `false`.
 */

function isObject$1(value) {
  return _typeof(value) === 'object' && value !== null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Check if the given value is a plain object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
 */

function isPlainObject(value) {
  if (!isObject$1(value)) {
    return false;
  }

  try {
    var _constructor = value.constructor;
    var prototype = _constructor.prototype;
    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
  } catch (error) {
    return false;
  }
}
/**
 * Check if the given value is a function.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a function, else `false`.
 */

function isFunction$1(value) {
  return typeof value === 'function';
}
var slice = Array.prototype.slice;
/**
 * Convert array-like or iterable object to an array.
 * @param {*} value - The value to convert.
 * @returns {Array} Returns a new array.
 */

function toArray(value) {
  return Array.from ? Array.from(value) : slice.call(value);
}
/**
 * Iterate the given data.
 * @param {*} data - The data to iterate.
 * @param {Function} callback - The process function for each element.
 * @returns {*} The original data.
 */

function forEach(data, callback) {
  if (data && isFunction$1(callback)) {
    if (Array.isArray(data) || isNumber$1(data.length)
    /* array-like */
    ) {
        toArray(data).forEach(function (value, key) {
          callback.call(data, value, key, data);
        });
      } else if (isObject$1(data)) {
      Object.keys(data).forEach(function (key) {
        callback.call(data, data[key], key, data);
      });
    }
  }

  return data;
}
/**
 * Extend the given object.
 * @param {*} target - The target object to extend.
 * @param {*} args - The rest objects for merging to the target object.
 * @returns {Object} The extended object.
 */

var assign = Object.assign || function assign(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (isObject$1(target) && args.length > 0) {
    args.forEach(function (arg) {
      if (isObject$1(arg)) {
        Object.keys(arg).forEach(function (key) {
          target[key] = arg[key];
        });
      }
    });
  }

  return target;
};
var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
/**
 * Normalize decimal number.
 * Check out {@link https://0.30000000000000004.com/}
 * @param {number} value - The value to normalize.
 * @param {number} [times=100000000000] - The times for normalizing.
 * @returns {number} Returns the normalized number.
 */

function normalizeDecimalNumber(value) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
}
var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
/**
 * Apply styles to the given element.
 * @param {Element} element - The target element.
 * @param {Object} styles - The styles for applying.
 */

function setStyle(element, styles) {
  var style = element.style;
  forEach(styles, function (value, property) {
    if (REGEXP_SUFFIX.test(property) && isNumber$1(value)) {
      value = "".concat(value, "px");
    }

    style[property] = value;
  });
}
/**
 * Check if the given element has a special class.
 * @param {Element} element - The element to check.
 * @param {string} value - The class to search.
 * @returns {boolean} Returns `true` if the special class was found.
 */

function hasClass$1(element, value) {
  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
}
/**
 * Add classes to the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be added.
 */

function addClass$1(element, value) {
  if (!value) {
    return;
  }

  if (isNumber$1(element.length)) {
    forEach(element, function (elem) {
      addClass$1(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.add(value);
    return;
  }

  var className = element.className.trim();

  if (!className) {
    element.className = value;
  } else if (className.indexOf(value) < 0) {
    element.className = "".concat(className, " ").concat(value);
  }
}
/**
 * Remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be removed.
 */

function removeClass$1(element, value) {
  if (!value) {
    return;
  }

  if (isNumber$1(element.length)) {
    forEach(element, function (elem) {
      removeClass$1(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.remove(value);
    return;
  }

  if (element.className.indexOf(value) >= 0) {
    element.className = element.className.replace(value, '');
  }
}
/**
 * Add or remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be toggled.
 * @param {boolean} added - Add only.
 */

function toggleClass(element, value, added) {
  if (!value) {
    return;
  }

  if (isNumber$1(element.length)) {
    forEach(element, function (elem) {
      toggleClass(elem, value, added);
    });
    return;
  } // IE10-11 doesn't support the second parameter of `classList.toggle`


  if (added) {
    addClass$1(element, value);
  } else {
    removeClass$1(element, value);
  }
}
var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
/**
 * Transform the given string from camelCase to kebab-case
 * @param {string} value - The value to transform.
 * @returns {string} The transformed value.
 */

function toParamCase(value) {
  return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
}
/**
 * Get data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to get.
 * @returns {string} The data value.
 */

function getData(element, name) {
  if (isObject$1(element[name])) {
    return element[name];
  }

  if (element.dataset) {
    return element.dataset[name];
  }

  return element.getAttribute("data-".concat(toParamCase(name)));
}
/**
 * Set data to the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to set.
 * @param {string} data - The data value.
 */

function setData(element, name, data) {
  if (isObject$1(data)) {
    element[name] = data;
  } else if (element.dataset) {
    element.dataset[name] = data;
  } else {
    element.setAttribute("data-".concat(toParamCase(name)), data);
  }
}
/**
 * Remove data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to remove.
 */

function removeData(element, name) {
  if (isObject$1(element[name])) {
    try {
      delete element[name];
    } catch (error) {
      element[name] = undefined;
    }
  } else if (element.dataset) {
    // #128 Safari not allows to delete dataset property
    try {
      delete element.dataset[name];
    } catch (error) {
      element.dataset[name] = undefined;
    }
  } else {
    element.removeAttribute("data-".concat(toParamCase(name)));
  }
}
var REGEXP_SPACES = /\s\s*/;

var onceSupported = function () {
  var supported = false;

  if (IS_BROWSER) {
    var once = false;

    var listener = function listener() {};

    var options = Object.defineProperty({}, 'once', {
      get: function get() {
        supported = true;
        return once;
      },

      /**
       * This setter can fix a `TypeError` in strict mode
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
       * @param {boolean} value - The value to set
       */
      set: function set(value) {
        once = value;
      }
    });
    WINDOW.addEventListener('test', listener, options);
    WINDOW.removeEventListener('test', listener, options);
  }

  return supported;
}();
/**
 * Remove event listener from the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Function} listener - The event listener.
 * @param {Object} options - The event options.
 */


function removeListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function (event) {
    if (!onceSupported) {
      var listeners = element.listeners;

      if (listeners && listeners[event] && listeners[event][listener]) {
        handler = listeners[event][listener];
        delete listeners[event][listener];

        if (Object.keys(listeners[event]).length === 0) {
          delete listeners[event];
        }

        if (Object.keys(listeners).length === 0) {
          delete element.listeners;
        }
      }
    }

    element.removeEventListener(event, handler, options);
  });
}
/**
 * Add event listener to the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Function} listener - The event listener.
 * @param {Object} options - The event options.
 */

function addListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function (event) {
    if (options.once && !onceSupported) {
      var _element$listeners = element.listeners,
          listeners = _element$listeners === void 0 ? {} : _element$listeners;

      _handler = function handler() {
        delete listeners[event][listener];
        element.removeEventListener(event, _handler, options);

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        listener.apply(element, args);
      };

      if (!listeners[event]) {
        listeners[event] = {};
      }

      if (listeners[event][listener]) {
        element.removeEventListener(event, listeners[event][listener], options);
      }

      listeners[event][listener] = _handler;
      element.listeners = listeners;
    }

    element.addEventListener(event, _handler, options);
  });
}
/**
 * Dispatch event on the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Object} data - The additional event data.
 * @returns {boolean} Indicate if the event is default prevented or not.
 */

function dispatchEvent(element, type, data) {
  var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

  if (isFunction$1(Event) && isFunction$1(CustomEvent)) {
    event = new CustomEvent(type, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, data);
  }

  return element.dispatchEvent(event);
}
/**
 * Get the offset base on the document.
 * @param {Element} element - The target element.
 * @returns {Object} The offset data.
 */

function getOffset(element) {
  var box = element.getBoundingClientRect();
  return {
    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: box.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
var location = WINDOW.location;
var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
/**
 * Check if the given URL is a cross origin URL.
 * @param {string} url - The target URL.
 * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
 */

function isCrossOriginURL(url) {
  var parts = url.match(REGEXP_ORIGINS);
  return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
}
/**
 * Add timestamp to the given URL.
 * @param {string} url - The target URL.
 * @returns {string} The result URL.
 */

function addTimestamp(url) {
  var timestamp = "timestamp=".concat(new Date().getTime());
  return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
}
/**
 * Get transforms base on the given object.
 * @param {Object} obj - The target object.
 * @returns {string} A string contains transform values.
 */

function getTransforms(_ref) {
  var rotate = _ref.rotate,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      translateX = _ref.translateX,
      translateY = _ref.translateY;
  var values = [];

  if (isNumber$1(translateX) && translateX !== 0) {
    values.push("translateX(".concat(translateX, "px)"));
  }

  if (isNumber$1(translateY) && translateY !== 0) {
    values.push("translateY(".concat(translateY, "px)"));
  } // Rotate should come first before scale to match orientation transform


  if (isNumber$1(rotate) && rotate !== 0) {
    values.push("rotate(".concat(rotate, "deg)"));
  }

  if (isNumber$1(scaleX) && scaleX !== 1) {
    values.push("scaleX(".concat(scaleX, ")"));
  }

  if (isNumber$1(scaleY) && scaleY !== 1) {
    values.push("scaleY(".concat(scaleY, ")"));
  }

  var transform = values.length ? values.join(' ') : 'none';
  return {
    WebkitTransform: transform,
    msTransform: transform,
    transform: transform
  };
}
/**
 * Get the max ratio of a group of pointers.
 * @param {string} pointers - The target pointers.
 * @returns {number} The result ratio.
 */

function getMaxZoomRatio(pointers) {
  var pointers2 = _objectSpread2({}, pointers);

  var maxRatio = 0;
  forEach(pointers, function (pointer, pointerId) {
    delete pointers2[pointerId];
    forEach(pointers2, function (pointer2) {
      var x1 = Math.abs(pointer.startX - pointer2.startX);
      var y1 = Math.abs(pointer.startY - pointer2.startY);
      var x2 = Math.abs(pointer.endX - pointer2.endX);
      var y2 = Math.abs(pointer.endY - pointer2.endY);
      var z1 = Math.sqrt(x1 * x1 + y1 * y1);
      var z2 = Math.sqrt(x2 * x2 + y2 * y2);
      var ratio = (z2 - z1) / z1;

      if (Math.abs(ratio) > Math.abs(maxRatio)) {
        maxRatio = ratio;
      }
    });
  });
  return maxRatio;
}
/**
 * Get a pointer from an event object.
 * @param {Object} event - The target event object.
 * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
 * @returns {Object} The result pointer contains start and/or end point coordinates.
 */

function getPointer(_ref2, endOnly) {
  var pageX = _ref2.pageX,
      pageY = _ref2.pageY;
  var end = {
    endX: pageX,
    endY: pageY
  };
  return endOnly ? end : _objectSpread2({
    startX: pageX,
    startY: pageY
  }, end);
}
/**
 * Get the center point coordinate of a group of pointers.
 * @param {Object} pointers - The target pointers.
 * @returns {Object} The center point coordinate.
 */

function getPointersCenter(pointers) {
  var pageX = 0;
  var pageY = 0;
  var count = 0;
  forEach(pointers, function (_ref3) {
    var startX = _ref3.startX,
        startY = _ref3.startY;
    pageX += startX;
    pageY += startY;
    count += 1;
  });
  pageX /= count;
  pageY /= count;
  return {
    pageX: pageX,
    pageY: pageY
  };
}
/**
 * Get the max sizes in a rectangle under the given aspect ratio.
 * @param {Object} data - The original sizes.
 * @param {string} [type='contain'] - The adjust type.
 * @returns {Object} The result sizes.
 */

function getAdjustedSizes(_ref4) // or 'cover'
{
  var aspectRatio = _ref4.aspectRatio,
      height = _ref4.height,
      width = _ref4.width;
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
  var isValidWidth = isPositiveNumber(width);
  var isValidHeight = isPositiveNumber(height);

  if (isValidWidth && isValidHeight) {
    var adjustedWidth = height * aspectRatio;

    if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
      height = width / aspectRatio;
    } else {
      width = height * aspectRatio;
    }
  } else if (isValidWidth) {
    height = width / aspectRatio;
  } else if (isValidHeight) {
    width = height * aspectRatio;
  }

  return {
    width: width,
    height: height
  };
}
/**
 * Get the new sizes of a rectangle after rotated.
 * @param {Object} data - The original sizes.
 * @returns {Object} The result sizes.
 */

function getRotatedSizes(_ref5) {
  var width = _ref5.width,
      height = _ref5.height,
      degree = _ref5.degree;
  degree = Math.abs(degree) % 180;

  if (degree === 90) {
    return {
      width: height,
      height: width
    };
  }

  var arc = degree % 90 * Math.PI / 180;
  var sinArc = Math.sin(arc);
  var cosArc = Math.cos(arc);
  var newWidth = width * cosArc + height * sinArc;
  var newHeight = width * sinArc + height * cosArc;
  return degree > 90 ? {
    width: newHeight,
    height: newWidth
  } : {
    width: newWidth,
    height: newHeight
  };
}
/**
 * Get a canvas which drew the given image.
 * @param {HTMLImageElement} image - The image for drawing.
 * @param {Object} imageData - The image data.
 * @param {Object} canvasData - The canvas data.
 * @param {Object} options - The options.
 * @returns {HTMLCanvasElement} The result canvas.
 */

function getSourceCanvas(image, _ref6, _ref7, _ref8) {
  var imageAspectRatio = _ref6.aspectRatio,
      imageNaturalWidth = _ref6.naturalWidth,
      imageNaturalHeight = _ref6.naturalHeight,
      _ref6$rotate = _ref6.rotate,
      rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
      _ref6$scaleX = _ref6.scaleX,
      scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
      _ref6$scaleY = _ref6.scaleY,
      scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
  var aspectRatio = _ref7.aspectRatio,
      naturalWidth = _ref7.naturalWidth,
      naturalHeight = _ref7.naturalHeight;
  var _ref8$fillColor = _ref8.fillColor,
      fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
      _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
      imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
      _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
      imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
      _ref8$maxWidth = _ref8.maxWidth,
      maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
      _ref8$maxHeight = _ref8.maxHeight,
      maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
      _ref8$minWidth = _ref8.minWidth,
      minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
      _ref8$minHeight = _ref8.minHeight,
      minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  var maxSizes = getAdjustedSizes({
    aspectRatio: aspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var minSizes = getAdjustedSizes({
    aspectRatio: aspectRatio,
    width: minWidth,
    height: minHeight
  }, 'cover');
  var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
  var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
  // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

  var destMaxSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var destMinSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: minWidth,
    height: minHeight
  }, 'cover');
  var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
  var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
  var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
  canvas.width = normalizeDecimalNumber(width);
  canvas.height = normalizeDecimalNumber(height);
  context.fillStyle = fillColor;
  context.fillRect(0, 0, width, height);
  context.save();
  context.translate(width / 2, height / 2);
  context.rotate(rotate * Math.PI / 180);
  context.scale(scaleX, scaleY);
  context.imageSmoothingEnabled = imageSmoothingEnabled;
  context.imageSmoothingQuality = imageSmoothingQuality;
  context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
    return Math.floor(normalizeDecimalNumber(param));
  }))));
  context.restore();
  return canvas;
}
var fromCharCode = String.fromCharCode;
/**
 * Get string from char code in data view.
 * @param {DataView} dataView - The data view for read.
 * @param {number} start - The start index.
 * @param {number} length - The read length.
 * @returns {string} The read result.
 */

function getStringFromCharCode(dataView, start, length) {
  var str = '';
  length += start;

  for (var i = start; i < length; i += 1) {
    str += fromCharCode(dataView.getUint8(i));
  }

  return str;
}
var REGEXP_DATA_URL_HEAD = /^data:.*,/;
/**
 * Transform Data URL to array buffer.
 * @param {string} dataURL - The Data URL to transform.
 * @returns {ArrayBuffer} The result array buffer.
 */

function dataURLToArrayBuffer(dataURL) {
  var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
  var binary = atob(base64);
  var arrayBuffer = new ArrayBuffer(binary.length);
  var uint8 = new Uint8Array(arrayBuffer);
  forEach(uint8, function (value, i) {
    uint8[i] = binary.charCodeAt(i);
  });
  return arrayBuffer;
}
/**
 * Transform array buffer to Data URL.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
 * @param {string} mimeType - The mime type of the Data URL.
 * @returns {string} The result Data URL.
 */

function arrayBufferToDataURL(arrayBuffer, mimeType) {
  var chunks = []; // Chunk Typed Array for better performance (#435)

  var chunkSize = 8192;
  var uint8 = new Uint8Array(arrayBuffer);

  while (uint8.length > 0) {
    // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
    // eslint-disable-next-line prefer-spread
    chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
    uint8 = uint8.subarray(chunkSize);
  }

  return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
}
/**
 * Get orientation value from given array buffer.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
 * @returns {number} The read orientation value.
 */

function resetAndGetOrientation(arrayBuffer) {
  var dataView = new DataView(arrayBuffer);
  var orientation; // Ignores range error when the image does not have correct Exif information

  try {
    var littleEndian;
    var app1Start;
    var ifdStart; // Only handle JPEG image (start by 0xFFD8)

    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
      var length = dataView.byteLength;
      var offset = 2;

      while (offset + 1 < length) {
        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
          app1Start = offset;
          break;
        }

        offset += 1;
      }
    }

    if (app1Start) {
      var exifIDCode = app1Start + 4;
      var tiffOffset = app1Start + 10;

      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
        var endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 0x4949;

        if (littleEndian || endianness === 0x4D4D
        /* bigEndian */
        ) {
            if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
              var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

              if (firstIFDOffset >= 0x00000008) {
                ifdStart = tiffOffset + firstIFDOffset;
              }
            }
          }
      }
    }

    if (ifdStart) {
      var _length = dataView.getUint16(ifdStart, littleEndian);

      var _offset;

      var i;

      for (i = 0; i < _length; i += 1) {
        _offset = ifdStart + i * 12 + 2;

        if (dataView.getUint16(_offset, littleEndian) === 0x0112
        /* Orientation */
        ) {
            // 8 is the offset of the current tag's value
            _offset += 8; // Get the original orientation value

            orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

            dataView.setUint16(_offset, 1, littleEndian);
            break;
          }
      }
    }
  } catch (error) {
    orientation = 1;
  }

  return orientation;
}
/**
 * Parse Exif Orientation value.
 * @param {number} orientation - The orientation to parse.
 * @returns {Object} The parsed result.
 */

function parseOrientation(orientation) {
  var rotate = 0;
  var scaleX = 1;
  var scaleY = 1;

  switch (orientation) {
    // Flip horizontal
    case 2:
      scaleX = -1;
      break;
    // Rotate left 180

    case 3:
      rotate = -180;
      break;
    // Flip vertical

    case 4:
      scaleY = -1;
      break;
    // Flip vertical and rotate right 90

    case 5:
      rotate = 90;
      scaleY = -1;
      break;
    // Rotate right 90

    case 6:
      rotate = 90;
      break;
    // Flip horizontal and rotate right 90

    case 7:
      rotate = 90;
      scaleX = -1;
      break;
    // Rotate left 90

    case 8:
      rotate = -90;
      break;
  }

  return {
    rotate: rotate,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var render$1 = {
  render: function render() {
    this.initContainer();
    this.initCanvas();
    this.initCropBox();
    this.renderCanvas();

    if (this.cropped) {
      this.renderCropBox();
    }
  },
  initContainer: function initContainer() {
    var element = this.element,
        options = this.options,
        container = this.container,
        cropper = this.cropper;
    var minWidth = Number(options.minContainerWidth);
    var minHeight = Number(options.minContainerHeight);
    addClass$1(cropper, CLASS_HIDDEN);
    removeClass$1(element, CLASS_HIDDEN);
    var containerData = {
      width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
      height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
    };
    this.containerData = containerData;
    setStyle(cropper, {
      width: containerData.width,
      height: containerData.height
    });
    addClass$1(element, CLASS_HIDDEN);
    removeClass$1(cropper, CLASS_HIDDEN);
  },
  // Canvas (image wrapper)
  initCanvas: function initCanvas() {
    var containerData = this.containerData,
        imageData = this.imageData;
    var viewMode = this.options.viewMode;
    var rotated = Math.abs(imageData.rotate) % 180 === 90;
    var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
    var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
    var aspectRatio = naturalWidth / naturalHeight;
    var canvasWidth = containerData.width;
    var canvasHeight = containerData.height;

    if (containerData.height * aspectRatio > containerData.width) {
      if (viewMode === 3) {
        canvasWidth = containerData.height * aspectRatio;
      } else {
        canvasHeight = containerData.width / aspectRatio;
      }
    } else if (viewMode === 3) {
      canvasHeight = containerData.width / aspectRatio;
    } else {
      canvasWidth = containerData.height * aspectRatio;
    }

    var canvasData = {
      aspectRatio: aspectRatio,
      naturalWidth: naturalWidth,
      naturalHeight: naturalHeight,
      width: canvasWidth,
      height: canvasHeight
    };
    this.canvasData = canvasData;
    this.limited = viewMode === 1 || viewMode === 2;
    this.limitCanvas(true, true);
    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    canvasData.left = (containerData.width - canvasData.width) / 2;
    canvasData.top = (containerData.height - canvasData.height) / 2;
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    this.initialCanvasData = assign({}, canvasData);
  },
  limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var viewMode = options.viewMode;
    var aspectRatio = canvasData.aspectRatio;
    var cropped = this.cropped && cropBoxData;

    if (sizeLimited) {
      var minCanvasWidth = Number(options.minCanvasWidth) || 0;
      var minCanvasHeight = Number(options.minCanvasHeight) || 0;

      if (viewMode > 1) {
        minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
        minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

        if (viewMode === 3) {
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      } else if (viewMode > 0) {
        if (minCanvasWidth) {
          minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
        } else if (minCanvasHeight) {
          minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
        } else if (cropped) {
          minCanvasWidth = cropBoxData.width;
          minCanvasHeight = cropBoxData.height;

          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      }

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: minCanvasWidth,
        height: minCanvasHeight
      });

      minCanvasWidth = _getAdjustedSizes.width;
      minCanvasHeight = _getAdjustedSizes.height;
      canvasData.minWidth = minCanvasWidth;
      canvasData.minHeight = minCanvasHeight;
      canvasData.maxWidth = Infinity;
      canvasData.maxHeight = Infinity;
    }

    if (positionLimited) {
      if (viewMode > (cropped ? 0 : 1)) {
        var newCanvasLeft = containerData.width - canvasData.width;
        var newCanvasTop = containerData.height - canvasData.height;
        canvasData.minLeft = Math.min(0, newCanvasLeft);
        canvasData.minTop = Math.min(0, newCanvasTop);
        canvasData.maxLeft = Math.max(0, newCanvasLeft);
        canvasData.maxTop = Math.max(0, newCanvasTop);

        if (cropped && this.limited) {
          canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
          canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
          canvasData.maxLeft = cropBoxData.left;
          canvasData.maxTop = cropBoxData.top;

          if (viewMode === 2) {
            if (canvasData.width >= containerData.width) {
              canvasData.minLeft = Math.min(0, newCanvasLeft);
              canvasData.maxLeft = Math.max(0, newCanvasLeft);
            }

            if (canvasData.height >= containerData.height) {
              canvasData.minTop = Math.min(0, newCanvasTop);
              canvasData.maxTop = Math.max(0, newCanvasTop);
            }
          }
        }
      } else {
        canvasData.minLeft = -canvasData.width;
        canvasData.minTop = -canvasData.height;
        canvasData.maxLeft = containerData.width;
        canvasData.maxTop = containerData.height;
      }
    }
  },
  renderCanvas: function renderCanvas(changed, transformed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;

    if (transformed) {
      var _getRotatedSizes = getRotatedSizes({
        width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
        height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
        degree: imageData.rotate || 0
      }),
          naturalWidth = _getRotatedSizes.width,
          naturalHeight = _getRotatedSizes.height;

      var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
      var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
      canvasData.left -= (width - canvasData.width) / 2;
      canvasData.top -= (height - canvasData.height) / 2;
      canvasData.width = width;
      canvasData.height = height;
      canvasData.aspectRatio = naturalWidth / naturalHeight;
      canvasData.naturalWidth = naturalWidth;
      canvasData.naturalHeight = naturalHeight;
      this.limitCanvas(true, false);
    }

    if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
      canvasData.left = canvasData.oldLeft;
    }

    if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
      canvasData.top = canvasData.oldTop;
    }

    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    this.limitCanvas(false, true);
    canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
    canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    setStyle(this.canvas, assign({
      width: canvasData.width,
      height: canvasData.height
    }, getTransforms({
      translateX: canvasData.left,
      translateY: canvasData.top
    })));
    this.renderImage(changed);

    if (this.cropped && this.limited) {
      this.limitCropBox(true, true);
    }
  },
  renderImage: function renderImage(changed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;
    var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
    var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
    assign(imageData, {
      width: width,
      height: height,
      left: (canvasData.width - width) / 2,
      top: (canvasData.height - height) / 2
    });
    setStyle(this.image, assign({
      width: imageData.width,
      height: imageData.height
    }, getTransforms(assign({
      translateX: imageData.left,
      translateY: imageData.top
    }, imageData))));

    if (changed) {
      this.output();
    }
  },
  initCropBox: function initCropBox() {
    var options = this.options,
        canvasData = this.canvasData;
    var aspectRatio = options.aspectRatio || options.initialAspectRatio;
    var autoCropArea = Number(options.autoCropArea) || 0.8;
    var cropBoxData = {
      width: canvasData.width,
      height: canvasData.height
    };

    if (aspectRatio) {
      if (canvasData.height * aspectRatio > canvasData.width) {
        cropBoxData.height = cropBoxData.width / aspectRatio;
      } else {
        cropBoxData.width = cropBoxData.height * aspectRatio;
      }
    }

    this.cropBoxData = cropBoxData;
    this.limitCropBox(true, true); // Initialize auto crop area

    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

    cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
    cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
    cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
    cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;
    this.initialCropBoxData = assign({}, cropBoxData);
  },
  limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData,
        limited = this.limited;
    var aspectRatio = options.aspectRatio;

    if (sizeLimited) {
      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
      var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
      var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

      minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
      minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

      if (aspectRatio) {
        if (minCropBoxWidth && minCropBoxHeight) {
          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }
        } else if (minCropBoxWidth) {
          minCropBoxHeight = minCropBoxWidth / aspectRatio;
        } else if (minCropBoxHeight) {
          minCropBoxWidth = minCropBoxHeight * aspectRatio;
        }

        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
        } else {
          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
        }
      } // The minWidth/Height must be less than maxWidth/Height


      cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
      cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
      cropBoxData.maxWidth = maxCropBoxWidth;
      cropBoxData.maxHeight = maxCropBoxHeight;
    }

    if (positionLimited) {
      if (limited) {
        cropBoxData.minLeft = Math.max(0, canvasData.left);
        cropBoxData.minTop = Math.max(0, canvasData.top);
        cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
        cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
      } else {
        cropBoxData.minLeft = 0;
        cropBoxData.minTop = 0;
        cropBoxData.maxLeft = containerData.width - cropBoxData.width;
        cropBoxData.maxTop = containerData.height - cropBoxData.height;
      }
    }
  },
  renderCropBox: function renderCropBox() {
    var options = this.options,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData;

    if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
      cropBoxData.left = cropBoxData.oldLeft;
    }

    if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
      cropBoxData.top = cropBoxData.oldTop;
    }

    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
    this.limitCropBox(false, true);
    cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
    cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;

    if (options.movable && options.cropBoxMovable) {
      // Turn to move the canvas when the crop box is equal to the container
      setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
    }

    setStyle(this.cropBox, assign({
      width: cropBoxData.width,
      height: cropBoxData.height
    }, getTransforms({
      translateX: cropBoxData.left,
      translateY: cropBoxData.top
    })));

    if (this.cropped && this.limited) {
      this.limitCanvas(true, true);
    }

    if (!this.disabled) {
      this.output();
    }
  },
  output: function output() {
    this.preview();
    dispatchEvent(this.element, EVENT_CROP, this.getData());
  }
};

var preview = {
  initPreview: function initPreview() {
    var element = this.element,
        crossOrigin = this.crossOrigin;
    var preview = this.options.preview;
    var url = crossOrigin ? this.crossOriginUrl : this.url;
    var alt = element.alt || 'The image to preview';
    var image = document.createElement('img');

    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }

    image.src = url;
    image.alt = alt;
    this.viewBox.appendChild(image);
    this.viewBoxImage = image;

    if (!preview) {
      return;
    }

    var previews = preview;

    if (typeof preview === 'string') {
      previews = element.ownerDocument.querySelectorAll(preview);
    } else if (preview.querySelector) {
      previews = [preview];
    }

    this.previews = previews;
    forEach(previews, function (el) {
      var img = document.createElement('img'); // Save the original size for recover

      setData(el, DATA_PREVIEW, {
        width: el.offsetWidth,
        height: el.offsetHeight,
        html: el.innerHTML
      });

      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.src = url;
      img.alt = alt;
      /**
       * Override img element styles
       * Add `display:block` to avoid margin top issue
       * Add `height:auto` to override `height` attribute on IE8
       * (Occur only when margin-top <= -height)
       */

      img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
      el.innerHTML = '';
      el.appendChild(img);
    });
  },
  resetPreview: function resetPreview() {
    forEach(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);
      setStyle(element, {
        width: data.width,
        height: data.height
      });
      element.innerHTML = data.html;
      removeData(element, DATA_PREVIEW);
    });
  },
  preview: function preview() {
    var imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var cropBoxWidth = cropBoxData.width,
        cropBoxHeight = cropBoxData.height;
    var width = imageData.width,
        height = imageData.height;
    var left = cropBoxData.left - canvasData.left - imageData.left;
    var top = cropBoxData.top - canvasData.top - imageData.top;

    if (!this.cropped || this.disabled) {
      return;
    }

    setStyle(this.viewBoxImage, assign({
      width: width,
      height: height
    }, getTransforms(assign({
      translateX: -left,
      translateY: -top
    }, imageData))));
    forEach(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);
      var originalWidth = data.width;
      var originalHeight = data.height;
      var newWidth = originalWidth;
      var newHeight = originalHeight;
      var ratio = 1;

      if (cropBoxWidth) {
        ratio = originalWidth / cropBoxWidth;
        newHeight = cropBoxHeight * ratio;
      }

      if (cropBoxHeight && newHeight > originalHeight) {
        ratio = originalHeight / cropBoxHeight;
        newWidth = cropBoxWidth * ratio;
        newHeight = originalHeight;
      }

      setStyle(element, {
        width: newWidth,
        height: newHeight
      });
      setStyle(element.getElementsByTagName('img')[0], assign({
        width: width * ratio,
        height: height * ratio
      }, getTransforms(assign({
        translateX: -left * ratio,
        translateY: -top * ratio
      }, imageData))));
    });
  }
};

var events = {
  bind: function bind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;

    if (isFunction$1(options.cropstart)) {
      addListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction$1(options.cropmove)) {
      addListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction$1(options.cropend)) {
      addListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction$1(options.crop)) {
      addListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction$1(options.zoom)) {
      addListener(element, EVENT_ZOOM, options.zoom);
    }

    addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

    if (options.zoomable && options.zoomOnWheel) {
      addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
        passive: false,
        capture: true
      });
    }

    if (options.toggleDragModeOnDblclick) {
      addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
    }

    addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
    addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

    if (options.responsive) {
      addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
    }
  },
  unbind: function unbind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;

    if (isFunction$1(options.cropstart)) {
      removeListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction$1(options.cropmove)) {
      removeListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction$1(options.cropend)) {
      removeListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction$1(options.crop)) {
      removeListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction$1(options.zoom)) {
      removeListener(element, EVENT_ZOOM, options.zoom);
    }

    removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

    if (options.zoomable && options.zoomOnWheel) {
      removeListener(cropper, EVENT_WHEEL, this.onWheel, {
        passive: false,
        capture: true
      });
    }

    if (options.toggleDragModeOnDblclick) {
      removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
    }

    removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
    removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

    if (options.responsive) {
      removeListener(window, EVENT_RESIZE, this.onResize);
    }
  }
};

var handlers = {
  resize: function resize() {
    if (this.disabled) {
      return;
    }

    var options = this.options,
        container = this.container,
        containerData = this.containerData;
    var ratioX = container.offsetWidth / containerData.width;
    var ratioY = container.offsetHeight / containerData.height;
    var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY; // Resize when width changed or height changed

    if (ratio !== 1) {
      var canvasData;
      var cropBoxData;

      if (options.restore) {
        canvasData = this.getCanvasData();
        cropBoxData = this.getCropBoxData();
      }

      this.render();

      if (options.restore) {
        this.setCanvasData(forEach(canvasData, function (n, i) {
          canvasData[i] = n * ratio;
        }));
        this.setCropBoxData(forEach(cropBoxData, function (n, i) {
          cropBoxData[i] = n * ratio;
        }));
      }
    }
  },
  dblclick: function dblclick() {
    if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
      return;
    }

    this.setDragMode(hasClass$1(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
  },
  wheel: function wheel(event) {
    var _this = this;

    var ratio = Number(this.options.wheelZoomRatio) || 0.1;
    var delta = 1;

    if (this.disabled) {
      return;
    }

    event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

    if (this.wheeling) {
      return;
    }

    this.wheeling = true;
    setTimeout(function () {
      _this.wheeling = false;
    }, 50);

    if (event.deltaY) {
      delta = event.deltaY > 0 ? 1 : -1;
    } else if (event.wheelDelta) {
      delta = -event.wheelDelta / 120;
    } else if (event.detail) {
      delta = event.detail > 0 ? 1 : -1;
    }

    this.zoom(-delta * ratio, event);
  },
  cropStart: function cropStart(event) {
    var buttons = event.buttons,
        button = event.button;

    if (this.disabled // Handle mouse event and pointer event and ignore touch event
    || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
    isNumber$1(buttons) && buttons !== 1 || isNumber$1(button) && button !== 0 // Open context menu
    || event.ctrlKey)) {
      return;
    }

    var options = this.options,
        pointers = this.pointers;
    var action;

    if (event.changedTouches) {
      // Handle touch event
      forEach(event.changedTouches, function (touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      // Handle mouse event and pointer event
      pointers[event.pointerId || 0] = getPointer(event);
    }

    if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
      action = ACTION_ZOOM;
    } else {
      action = getData(event.target, DATA_ACTION);
    }

    if (!REGEXP_ACTIONS.test(action)) {
      return;
    }

    if (dispatchEvent(this.element, EVENT_CROP_START, {
      originalEvent: event,
      action: action
    }) === false) {
      return;
    } // This line is required for preventing page zooming in iOS browsers


    event.preventDefault();
    this.action = action;
    this.cropping = false;

    if (action === ACTION_CROP) {
      this.cropping = true;
      addClass$1(this.dragBox, CLASS_MODAL);
    }
  },
  cropMove: function cropMove(event) {
    var action = this.action;

    if (this.disabled || !action) {
      return;
    }

    var pointers = this.pointers;
    event.preventDefault();

    if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
      originalEvent: event,
      action: action
    }) === false) {
      return;
    }

    if (event.changedTouches) {
      forEach(event.changedTouches, function (touch) {
        // The first parameter should not be undefined (#432)
        assign(pointers[touch.identifier] || {}, getPointer(touch, true));
      });
    } else {
      assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
    }

    this.change(event);
  },
  cropEnd: function cropEnd(event) {
    if (this.disabled) {
      return;
    }

    var action = this.action,
        pointers = this.pointers;

    if (event.changedTouches) {
      forEach(event.changedTouches, function (touch) {
        delete pointers[touch.identifier];
      });
    } else {
      delete pointers[event.pointerId || 0];
    }

    if (!action) {
      return;
    }

    event.preventDefault();

    if (!Object.keys(pointers).length) {
      this.action = '';
    }

    if (this.cropping) {
      this.cropping = false;
      toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
    }

    dispatchEvent(this.element, EVENT_CROP_END, {
      originalEvent: event,
      action: action
    });
  }
};

var change = {
  change: function change(event) {
    var options = this.options,
        canvasData = this.canvasData,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData,
        pointers = this.pointers;
    var action = this.action;
    var aspectRatio = options.aspectRatio;
    var left = cropBoxData.left,
        top = cropBoxData.top,
        width = cropBoxData.width,
        height = cropBoxData.height;
    var right = left + width;
    var bottom = top + height;
    var minLeft = 0;
    var minTop = 0;
    var maxWidth = containerData.width;
    var maxHeight = containerData.height;
    var renderable = true;
    var offset; // Locking aspect ratio in "free mode" by holding shift key

    if (!aspectRatio && event.shiftKey) {
      aspectRatio = width && height ? width / height : 1;
    }

    if (this.limited) {
      minLeft = cropBoxData.minLeft;
      minTop = cropBoxData.minTop;
      maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
      maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
    }

    var pointer = pointers[Object.keys(pointers)[0]];
    var range = {
      x: pointer.endX - pointer.startX,
      y: pointer.endY - pointer.startY
    };

    var check = function check(side) {
      switch (side) {
        case ACTION_EAST:
          if (right + range.x > maxWidth) {
            range.x = maxWidth - right;
          }

          break;

        case ACTION_WEST:
          if (left + range.x < minLeft) {
            range.x = minLeft - left;
          }

          break;

        case ACTION_NORTH:
          if (top + range.y < minTop) {
            range.y = minTop - top;
          }

          break;

        case ACTION_SOUTH:
          if (bottom + range.y > maxHeight) {
            range.y = maxHeight - bottom;
          }

          break;
      }
    };

    switch (action) {
      // Move crop box
      case ACTION_ALL:
        left += range.x;
        top += range.y;
        break;
      // Resize crop box

      case ACTION_EAST:
        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_EAST);
        width += range.x;

        if (width < 0) {
          action = ACTION_WEST;
          width = -width;
          left -= width;
        }

        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }

        break;

      case ACTION_NORTH:
        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_NORTH);
        height -= range.y;
        top += range.y;

        if (height < 0) {
          action = ACTION_SOUTH;
          height = -height;
          top -= height;
        }

        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }

        break;

      case ACTION_WEST:
        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_WEST);
        width -= range.x;
        left += range.x;

        if (width < 0) {
          action = ACTION_EAST;
          width = -width;
          left -= width;
        }

        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }

        break;

      case ACTION_SOUTH:
        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_SOUTH);
        height += range.y;

        if (height < 0) {
          action = ACTION_NORTH;
          height = -height;
          top -= height;
        }

        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }

        break;

      case ACTION_NORTH_EAST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
        } else {
          check(ACTION_NORTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_NORTH_WEST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
          left += cropBoxData.width - width;
        } else {
          check(ACTION_NORTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_SOUTH_WEST:
        if (aspectRatio) {
          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_SOUTH_EAST:
        if (aspectRatio) {
          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          top -= height;
        }

        break;
      // Move canvas

      case ACTION_MOVE:
        this.move(range.x, range.y);
        renderable = false;
        break;
      // Zoom canvas

      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(pointers), event);
        renderable = false;
        break;
      // Create crop box

      case ACTION_CROP:
        if (!range.x || !range.y) {
          renderable = false;
          break;
        }

        offset = getOffset(this.cropper);
        left = pointer.startX - offset.left;
        top = pointer.startY - offset.top;
        width = cropBoxData.minWidth;
        height = cropBoxData.minHeight;

        if (range.x > 0) {
          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
        } else if (range.x < 0) {
          left -= width;
          action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
        }

        if (range.y < 0) {
          top -= height;
        } // Show the crop box if is hidden


        if (!this.cropped) {
          removeClass$1(this.cropBox, CLASS_HIDDEN);
          this.cropped = true;

          if (this.limited) {
            this.limitCropBox(true, true);
          }
        }

        break;
    }

    if (renderable) {
      cropBoxData.width = width;
      cropBoxData.height = height;
      cropBoxData.left = left;
      cropBoxData.top = top;
      this.action = action;
      this.renderCropBox();
    } // Override


    forEach(pointers, function (p) {
      p.startX = p.endX;
      p.startY = p.endY;
    });
  }
};

var methods = {
  // Show the crop box manually
  crop: function crop() {
    if (this.ready && !this.cropped && !this.disabled) {
      this.cropped = true;
      this.limitCropBox(true, true);

      if (this.options.modal) {
        addClass$1(this.dragBox, CLASS_MODAL);
      }

      removeClass$1(this.cropBox, CLASS_HIDDEN);
      this.setCropBoxData(this.initialCropBoxData);
    }

    return this;
  },
  // Reset the image and crop box to their initial states
  reset: function reset() {
    if (this.ready && !this.disabled) {
      this.imageData = assign({}, this.initialImageData);
      this.canvasData = assign({}, this.initialCanvasData);
      this.cropBoxData = assign({}, this.initialCropBoxData);
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    }

    return this;
  },
  // Clear the crop box
  clear: function clear() {
    if (this.cropped && !this.disabled) {
      assign(this.cropBoxData, {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      });
      this.cropped = false;
      this.renderCropBox();
      this.limitCanvas(true, true); // Render canvas after crop box rendered

      this.renderCanvas();
      removeClass$1(this.dragBox, CLASS_MODAL);
      addClass$1(this.cropBox, CLASS_HIDDEN);
    }

    return this;
  },

  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
   * @returns {Cropper} this
   */
  replace: function replace(url) {
    var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!this.disabled && url) {
      if (this.isImg) {
        this.element.src = url;
      }

      if (hasSameSize) {
        this.url = url;
        this.image.src = url;

        if (this.ready) {
          this.viewBoxImage.src = url;
          forEach(this.previews, function (element) {
            element.getElementsByTagName('img')[0].src = url;
          });
        }
      } else {
        if (this.isImg) {
          this.replaced = true;
        }

        this.options.data = null;
        this.uncreate();
        this.load(url);
      }
    }

    return this;
  },
  // Enable (unfreeze) the cropper
  enable: function enable() {
    if (this.ready && this.disabled) {
      this.disabled = false;
      removeClass$1(this.cropper, CLASS_DISABLED);
    }

    return this;
  },
  // Disable (freeze) the cropper
  disable: function disable() {
    if (this.ready && !this.disabled) {
      this.disabled = true;
      addClass$1(this.cropper, CLASS_DISABLED);
    }

    return this;
  },

  /**
   * Destroy the cropper and remove the instance from the image
   * @returns {Cropper} this
   */
  destroy: function destroy() {
    var element = this.element;

    if (!element[NAMESPACE]) {
      return this;
    }

    element[NAMESPACE] = undefined;

    if (this.isImg && this.replaced) {
      element.src = this.originalUrl;
    }

    this.uncreate();
    return this;
  },

  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
   * @returns {Cropper} this
   */
  move: function move(offsetX) {
    var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
    var _this$canvasData = this.canvasData,
        left = _this$canvasData.left,
        top = _this$canvasData.top;
    return this.moveTo(isUndefined$1(offsetX) ? offsetX : left + Number(offsetX), isUndefined$1(offsetY) ? offsetY : top + Number(offsetY));
  },

  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Cropper} this
   */
  moveTo: function moveTo(x) {
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    var canvasData = this.canvasData;
    var changed = false;
    x = Number(x);
    y = Number(y);

    if (this.ready && !this.disabled && this.options.movable) {
      if (isNumber$1(x)) {
        canvasData.left = x;
        changed = true;
      }

      if (isNumber$1(y)) {
        canvasData.top = y;
        changed = true;
      }

      if (changed) {
        this.renderCanvas(true);
      }
    }

    return this;
  },

  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoom: function zoom(ratio, _originalEvent) {
    var canvasData = this.canvasData;
    ratio = Number(ratio);

    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }

    return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
  },

  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Object} pivot - The zoom pivot point coordinate.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
    var options = this.options,
        canvasData = this.canvasData;
    var width = canvasData.width,
        height = canvasData.height,
        naturalWidth = canvasData.naturalWidth,
        naturalHeight = canvasData.naturalHeight;
    ratio = Number(ratio);

    if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;

      if (dispatchEvent(this.element, EVENT_ZOOM, {
        ratio: ratio,
        oldRatio: width / naturalWidth,
        originalEvent: _originalEvent
      }) === false) {
        return this;
      }

      if (_originalEvent) {
        var pointers = this.pointers;
        var offset = getOffset(this.cropper);
        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
          pageX: _originalEvent.pageX,
          pageY: _originalEvent.pageY
        }; // Zoom from the triggering point of the event

        canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
      } else if (isPlainObject(pivot) && isNumber$1(pivot.x) && isNumber$1(pivot.y)) {
        canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
      } else {
        // Zoom from the center of the canvas
        canvasData.left -= (newWidth - width) / 2;
        canvasData.top -= (newHeight - height) / 2;
      }

      canvasData.width = newWidth;
      canvasData.height = newHeight;
      this.renderCanvas(true);
    }

    return this;
  },

  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotate: function rotate(degree) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
  },

  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotateTo: function rotateTo(degree) {
    degree = Number(degree);

    if (isNumber$1(degree) && this.ready && !this.disabled && this.options.rotatable) {
      this.imageData.rotate = degree % 360;
      this.renderCanvas(true, true);
    }

    return this;
  },

  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Cropper} this
   */
  scaleX: function scaleX(_scaleX) {
    var scaleY = this.imageData.scaleY;
    return this.scale(_scaleX, isNumber$1(scaleY) ? scaleY : 1);
  },

  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scaleY: function scaleY(_scaleY) {
    var scaleX = this.imageData.scaleX;
    return this.scale(isNumber$1(scaleX) ? scaleX : 1, _scaleY);
  },

  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scale: function scale(scaleX) {
    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
    var imageData = this.imageData;
    var transformed = false;
    scaleX = Number(scaleX);
    scaleY = Number(scaleY);

    if (this.ready && !this.disabled && this.options.scalable) {
      if (isNumber$1(scaleX)) {
        imageData.scaleX = scaleX;
        transformed = true;
      }

      if (isNumber$1(scaleY)) {
        imageData.scaleY = scaleY;
        transformed = true;
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }
    }

    return this;
  },

  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function getData() {
    var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var data;

    if (this.ready && this.cropped) {
      data = {
        x: cropBoxData.left - canvasData.left,
        y: cropBoxData.top - canvasData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
      var ratio = imageData.width / imageData.naturalWidth;
      forEach(data, function (n, i) {
        data[i] = n / ratio;
      });

      if (rounded) {
        // In case rounding off leads to extra 1px in right or bottom border
        // we should round the top-left corner and the dimension (#343).
        var bottom = Math.round(data.y + data.height);
        var right = Math.round(data.x + data.width);
        data.x = Math.round(data.x);
        data.y = Math.round(data.y);
        data.width = right - data.x;
        data.height = bottom - data.y;
      }
    } else {
      data = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }

    if (options.rotatable) {
      data.rotate = imageData.rotate || 0;
    }

    if (options.scalable) {
      data.scaleX = imageData.scaleX || 1;
      data.scaleY = imageData.scaleY || 1;
    }

    return data;
  },

  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Cropper} this
   */
  setData: function setData(data) {
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData;
    var cropBoxData = {};

    if (this.ready && !this.disabled && isPlainObject(data)) {
      var transformed = false;

      if (options.rotatable) {
        if (isNumber$1(data.rotate) && data.rotate !== imageData.rotate) {
          imageData.rotate = data.rotate;
          transformed = true;
        }
      }

      if (options.scalable) {
        if (isNumber$1(data.scaleX) && data.scaleX !== imageData.scaleX) {
          imageData.scaleX = data.scaleX;
          transformed = true;
        }

        if (isNumber$1(data.scaleY) && data.scaleY !== imageData.scaleY) {
          imageData.scaleY = data.scaleY;
          transformed = true;
        }
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }

      var ratio = imageData.width / imageData.naturalWidth;

      if (isNumber$1(data.x)) {
        cropBoxData.left = data.x * ratio + canvasData.left;
      }

      if (isNumber$1(data.y)) {
        cropBoxData.top = data.y * ratio + canvasData.top;
      }

      if (isNumber$1(data.width)) {
        cropBoxData.width = data.width * ratio;
      }

      if (isNumber$1(data.height)) {
        cropBoxData.height = data.height * ratio;
      }

      this.setCropBoxData(cropBoxData);
    }

    return this;
  },

  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function getContainerData() {
    return this.ready ? assign({}, this.containerData) : {};
  },

  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function getImageData() {
    return this.sized ? assign({}, this.imageData) : {};
  },

  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function getCanvasData() {
    var canvasData = this.canvasData;
    var data = {};

    if (this.ready) {
      forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
        data[n] = canvasData[n];
      });
    }

    return data;
  },

  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Cropper} this
   */
  setCanvasData: function setCanvasData(data) {
    var canvasData = this.canvasData;
    var aspectRatio = canvasData.aspectRatio;

    if (this.ready && !this.disabled && isPlainObject(data)) {
      if (isNumber$1(data.left)) {
        canvasData.left = data.left;
      }

      if (isNumber$1(data.top)) {
        canvasData.top = data.top;
      }

      if (isNumber$1(data.width)) {
        canvasData.width = data.width;
        canvasData.height = data.width / aspectRatio;
      } else if (isNumber$1(data.height)) {
        canvasData.height = data.height;
        canvasData.width = data.height * aspectRatio;
      }

      this.renderCanvas(true);
    }

    return this;
  },

  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function getCropBoxData() {
    var cropBoxData = this.cropBoxData;
    var data;

    if (this.ready && this.cropped) {
      data = {
        left: cropBoxData.left,
        top: cropBoxData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
    }

    return data || {};
  },

  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Cropper} this
   */
  setCropBoxData: function setCropBoxData(data) {
    var cropBoxData = this.cropBoxData;
    var aspectRatio = this.options.aspectRatio;
    var widthChanged;
    var heightChanged;

    if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
      if (isNumber$1(data.left)) {
        cropBoxData.left = data.left;
      }

      if (isNumber$1(data.top)) {
        cropBoxData.top = data.top;
      }

      if (isNumber$1(data.width) && data.width !== cropBoxData.width) {
        widthChanged = true;
        cropBoxData.width = data.width;
      }

      if (isNumber$1(data.height) && data.height !== cropBoxData.height) {
        heightChanged = true;
        cropBoxData.height = data.height;
      }

      if (aspectRatio) {
        if (widthChanged) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else if (heightChanged) {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.renderCropBox();
    }

    return this;
  },

  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function getCroppedCanvas() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.ready || !window.HTMLCanvasElement) {
      return null;
    }

    var canvasData = this.canvasData;
    var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

    if (!this.cropped) {
      return source;
    }

    var _this$getData = this.getData(),
        initialX = _this$getData.x,
        initialY = _this$getData.y,
        initialWidth = _this$getData.width,
        initialHeight = _this$getData.height;

    var ratio = source.width / Math.floor(canvasData.naturalWidth);

    if (ratio !== 1) {
      initialX *= ratio;
      initialY *= ratio;
      initialWidth *= ratio;
      initialHeight *= ratio;
    }

    var aspectRatio = initialWidth / initialHeight;
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.maxWidth || Infinity,
      height: options.maxHeight || Infinity
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.minWidth || 0,
      height: options.minHeight || 0
    }, 'cover');

    var _getAdjustedSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.width || (ratio !== 1 ? source.width : initialWidth),
      height: options.height || (ratio !== 1 ? source.height : initialHeight)
    }),
        width = _getAdjustedSizes.width,
        height = _getAdjustedSizes.height;

    width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
    height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = options.fillColor || 'transparent';
    context.fillRect(0, 0, width, height);
    var _options$imageSmoothi = options.imageSmoothingEnabled,
        imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
        imageSmoothingQuality = options.imageSmoothingQuality;
    context.imageSmoothingEnabled = imageSmoothingEnabled;

    if (imageSmoothingQuality) {
      context.imageSmoothingQuality = imageSmoothingQuality;
    } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


    var sourceWidth = source.width;
    var sourceHeight = source.height; // Source canvas parameters

    var srcX = initialX;
    var srcY = initialY;
    var srcWidth;
    var srcHeight; // Destination canvas parameters

    var dstX;
    var dstY;
    var dstWidth;
    var dstHeight;

    if (srcX <= -initialWidth || srcX > sourceWidth) {
      srcX = 0;
      srcWidth = 0;
      dstX = 0;
      dstWidth = 0;
    } else if (srcX <= 0) {
      dstX = -srcX;
      srcX = 0;
      srcWidth = Math.min(sourceWidth, initialWidth + srcX);
      dstWidth = srcWidth;
    } else if (srcX <= sourceWidth) {
      dstX = 0;
      srcWidth = Math.min(initialWidth, sourceWidth - srcX);
      dstWidth = srcWidth;
    }

    if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
      srcY = 0;
      srcHeight = 0;
      dstY = 0;
      dstHeight = 0;
    } else if (srcY <= 0) {
      dstY = -srcY;
      srcY = 0;
      srcHeight = Math.min(sourceHeight, initialHeight + srcY);
      dstHeight = srcHeight;
    } else if (srcY <= sourceHeight) {
      dstY = 0;
      srcHeight = Math.min(initialHeight, sourceHeight - srcY);
      dstHeight = srcHeight;
    }

    var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

    if (dstWidth > 0 && dstHeight > 0) {
      var scale = width / initialWidth;
      params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
    } // All the numerical parameters should be integer for `drawImage`
    // https://github.com/fengyuanchen/cropper/issues/476


    context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    return canvas;
  },

  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Cropper} this
   */
  setAspectRatio: function setAspectRatio(aspectRatio) {
    var options = this.options;

    if (!this.disabled && !isUndefined$1(aspectRatio)) {
      // 0 -> NaN
      options.aspectRatio = Math.max(0, aspectRatio) || NaN;

      if (this.ready) {
        this.initCropBox();

        if (this.cropped) {
          this.renderCropBox();
        }
      }
    }

    return this;
  },

  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Cropper} this
   */
  setDragMode: function setDragMode(mode) {
    var options = this.options,
        dragBox = this.dragBox,
        face = this.face;

    if (this.ready && !this.disabled) {
      var croppable = mode === DRAG_MODE_CROP;
      var movable = options.movable && mode === DRAG_MODE_MOVE;
      mode = croppable || movable ? mode : DRAG_MODE_NONE;
      options.dragMode = mode;
      setData(dragBox, DATA_ACTION, mode);
      toggleClass(dragBox, CLASS_CROP, croppable);
      toggleClass(dragBox, CLASS_MOVE, movable);

      if (!options.cropBoxMovable) {
        // Sync drag mode to crop box when it is not movable
        setData(face, DATA_ACTION, mode);
        toggleClass(face, CLASS_CROP, croppable);
        toggleClass(face, CLASS_MOVE, movable);
      }
    }

    return this;
  }
};

var AnotherCropper = WINDOW.Cropper;

var Cropper = /*#__PURE__*/function () {
  /**
   * Create a new Cropper.
   * @param {Element} element - The target element for cropping.
   * @param {Object} [options={}] - The configuration options.
   */
  function Cropper(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Cropper);

    if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
      throw new Error('The first argument is required and must be an <img> or <canvas> element.');
    }

    this.element = element;
    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
    this.cropped = false;
    this.disabled = false;
    this.pointers = {};
    this.ready = false;
    this.reloading = false;
    this.replaced = false;
    this.sized = false;
    this.sizing = false;
    this.init();
  }

  _createClass(Cropper, [{
    key: "init",
    value: function init() {
      var element = this.element;
      var tagName = element.tagName.toLowerCase();
      var url;

      if (element[NAMESPACE]) {
        return;
      }

      element[NAMESPACE] = this;

      if (tagName === 'img') {
        this.isImg = true; // e.g.: "img/picture.jpg"

        url = element.getAttribute('src') || '';
        this.originalUrl = url; // Stop when it's a blank image

        if (!url) {
          return;
        } // e.g.: "https://example.com/img/picture.jpg"


        url = element.src;
      } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
        url = element.toDataURL();
      }

      this.load(url);
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this = this;

      if (!url) {
        return;
      }

      this.url = url;
      this.imageData = {};
      var element = this.element,
          options = this.options;

      if (!options.rotatable && !options.scalable) {
        options.checkOrientation = false;
      } // Only IE10+ supports Typed Arrays


      if (!options.checkOrientation || !window.ArrayBuffer) {
        this.clone();
        return;
      } // Detect the mime type of the image directly if it is a Data URL


      if (REGEXP_DATA_URL.test(url)) {
        // Read ArrayBuffer from Data URL of JPEG images directly for better performance
        if (REGEXP_DATA_URL_JPEG.test(url)) {
          this.read(dataURLToArrayBuffer(url));
        } else {
          // Only a JPEG image may contains Exif Orientation information,
          // the rest types of Data URLs are not necessary to check orientation at all.
          this.clone();
        }

        return;
      } // 1. Detect the mime type of the image by a XMLHttpRequest.
      // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


      var xhr = new XMLHttpRequest();
      var clone = this.clone.bind(this);
      this.reloading = true;
      this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
      // http, https, data, chrome, chrome-extension.
      // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
      // in some browsers as IE11 and Safari.

      xhr.onabort = clone;
      xhr.onerror = clone;
      xhr.ontimeout = clone;

      xhr.onprogress = function () {
        // Abort the request directly if it not a JPEG image for better performance
        if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
          xhr.abort();
        }
      };

      xhr.onload = function () {
        _this.read(xhr.response);
      };

      xhr.onloadend = function () {
        _this.reloading = false;
        _this.xhr = null;
      }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


      if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
        url = addTimestamp(url);
      } // The third parameter is required for avoiding side-effect (#682)


      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';
      xhr.withCredentials = element.crossOrigin === 'use-credentials';
      xhr.send();
    }
  }, {
    key: "read",
    value: function read(arrayBuffer) {
      var options = this.options,
          imageData = this.imageData; // Reset the orientation value to its default value 1
      // as some iOS browsers will render image with its orientation

      var orientation = resetAndGetOrientation(arrayBuffer);
      var rotate = 0;
      var scaleX = 1;
      var scaleY = 1;

      if (orientation > 1) {
        // Generate a new URL which has the default orientation value
        this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

        var _parseOrientation = parseOrientation(orientation);

        rotate = _parseOrientation.rotate;
        scaleX = _parseOrientation.scaleX;
        scaleY = _parseOrientation.scaleY;
      }

      if (options.rotatable) {
        imageData.rotate = rotate;
      }

      if (options.scalable) {
        imageData.scaleX = scaleX;
        imageData.scaleY = scaleY;
      }

      this.clone();
    }
  }, {
    key: "clone",
    value: function clone() {
      var element = this.element,
          url = this.url;
      var crossOrigin = element.crossOrigin;
      var crossOriginUrl = url;

      if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
        if (!crossOrigin) {
          crossOrigin = 'anonymous';
        } // Bust cache when there is not a "crossOrigin" property (#519)


        crossOriginUrl = addTimestamp(url);
      }

      this.crossOrigin = crossOrigin;
      this.crossOriginUrl = crossOriginUrl;
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = crossOriginUrl || url;
      image.alt = element.alt || 'The image to crop';
      this.image = image;
      image.onload = this.start.bind(this);
      image.onerror = this.stop.bind(this);
      addClass$1(image, CLASS_HIDE);
      element.parentNode.insertBefore(image, element.nextSibling);
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var image = this.image;
      image.onload = null;
      image.onerror = null;
      this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
      // such as Safari for iOS, Chrome for iOS, and in-app browsers.

      var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

      var done = function done(naturalWidth, naturalHeight) {
        assign(_this2.imageData, {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          aspectRatio: naturalWidth / naturalHeight
        });
        _this2.initialImageData = assign({}, _this2.imageData);
        _this2.sizing = false;
        _this2.sized = true;

        _this2.build();
      }; // Most modern browsers (excepts iOS WebKit)


      if (image.naturalWidth && !isIOSWebKit) {
        done(image.naturalWidth, image.naturalHeight);
        return;
      }

      var sizingImage = document.createElement('img');
      var body = document.body || document.documentElement;
      this.sizingImage = sizingImage;

      sizingImage.onload = function () {
        done(sizingImage.width, sizingImage.height);

        if (!isIOSWebKit) {
          body.removeChild(sizingImage);
        }
      };

      sizingImage.src = image.src; // iOS WebKit will convert the image automatically
      // with its orientation once append it into DOM (#279)

      if (!isIOSWebKit) {
        sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
        body.appendChild(sizingImage);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var image = this.image;
      image.onload = null;
      image.onerror = null;
      image.parentNode.removeChild(image);
      this.image = null;
    }
  }, {
    key: "build",
    value: function build() {
      if (!this.sized || this.ready) {
        return;
      }

      var element = this.element,
          options = this.options,
          image = this.image; // Create cropper elements

      var container = element.parentNode;
      var template = document.createElement('div');
      template.innerHTML = TEMPLATE;
      var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
      var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
      var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
      var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
      var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
      this.container = container;
      this.cropper = cropper;
      this.canvas = canvas;
      this.dragBox = dragBox;
      this.cropBox = cropBox;
      this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
      this.face = face;
      canvas.appendChild(image); // Hide the original image

      addClass$1(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

      container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

      if (!this.isImg) {
        removeClass$1(image, CLASS_HIDE);
      }

      this.initPreview();
      this.bind();
      options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
      addClass$1(cropBox, CLASS_HIDDEN);

      if (!options.guides) {
        addClass$1(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
      }

      if (!options.center) {
        addClass$1(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
      }

      if (options.background) {
        addClass$1(cropper, "".concat(NAMESPACE, "-bg"));
      }

      if (!options.highlight) {
        addClass$1(face, CLASS_INVISIBLE);
      }

      if (options.cropBoxMovable) {
        addClass$1(face, CLASS_MOVE);
        setData(face, DATA_ACTION, ACTION_ALL);
      }

      if (!options.cropBoxResizable) {
        addClass$1(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
        addClass$1(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
      }

      this.render();
      this.ready = true;
      this.setDragMode(options.dragMode);

      if (options.autoCrop) {
        this.crop();
      }

      this.setData(options.data);

      if (isFunction$1(options.ready)) {
        addListener(element, EVENT_READY, options.ready, {
          once: true
        });
      }

      dispatchEvent(element, EVENT_READY);
    }
  }, {
    key: "unbuild",
    value: function unbuild() {
      if (!this.ready) {
        return;
      }

      this.ready = false;
      this.unbind();
      this.resetPreview();
      this.cropper.parentNode.removeChild(this.cropper);
      removeClass$1(this.element, CLASS_HIDDEN);
    }
  }, {
    key: "uncreate",
    value: function uncreate() {
      if (this.ready) {
        this.unbuild();
        this.ready = false;
        this.cropped = false;
      } else if (this.sizing) {
        this.sizingImage.onload = null;
        this.sizing = false;
        this.sized = false;
      } else if (this.reloading) {
        this.xhr.onabort = null;
        this.xhr.abort();
      } else if (this.image) {
        this.stop();
      }
    }
    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */

  }], [{
    key: "noConflict",
    value: function noConflict() {
      window.Cropper = AnotherCropper;
      return Cropper;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */

  }, {
    key: "setDefaults",
    value: function setDefaults(options) {
      assign(DEFAULTS, isPlainObject(options) && options);
    }
  }]);

  return Cropper;
}();

assign(Cropper.prototype, render$1, preview, events, handlers, change, methods);

/*
Copyright (c) 2019 Daybrush
name: framework-utils
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/framework-utils.git
version: 1.1.0
*/
function prefixNames(prefix) {
  var classNames = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }

  return classNames.map(function (className) {
    return className.split(" ").map(function (name) {
      return name ? "" + prefix + name : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix, css) {
  return css.replace(/([^}{]*){/gm, function (_, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix + "$1") + "{";
  });
}
/* react */

function ref(target, name) {
  return function (e) {
    e && (target[name] = e);
  };
}
function refs(target, name, i) {
  return function (e) {
    e && (target[name][i] = e);
  };
}
/* Class Decorator */

function Properties(properties, action) {
  return function (component) {
    var prototype = component.prototype;
    properties.forEach(function (property) {
      action(prototype, property);
    });
  };
}
/* Property Decorator */

function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }

  return function (prototype, propertyName) {
    methods.forEach(function (name) {
      var methodName = duplicate[name] || name;

      if (methodName in prototype) {
        return;
      }

      prototype[methodName] = function () {
        var _a;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var result = (_a = this[propertyName])[name].apply(_a, args);

        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}

/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.0
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @param - This callback function returns the key of the item. <ko>     .</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff$1(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko          .
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko>    .</ko>
   * @param - This callback function returns the key of the item. <ko>     .</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko   .
   * @param - List to update <ko>   </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList` `list`   . </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff$1(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.7.1
*/
/**
* get string "function"
* @memberof Consts
* @example
import {FUNCTION} from "@daybrush/utils";

console.log(FUNCTION); // "function"
*/

var FUNCTION = "function";
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* get string "number"
* @memberof Consts
* @example
import {NUMBER} from "@daybrush/utils";

console.log(NUMBER); // "number"
*/

var NUMBER = "number";
/**
* get string "undefined"
* @memberof Consts
* @example
import {UNDEFINED} from "@daybrush/utils";

console.log(UNDEFINED); // "undefined"
*/

var UNDEFINED = "undefined";
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var IS_WINDOW = typeof window !== UNDEFINED;
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: "\"",
  close: "\""
}, {
  open: "'",
  close: "'"
}, {
  open: "\\\"",
  close: "\\\""
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM$1 = 0.0000001;
var DEFAULT_UNIT_PRESETS = {
  "cm": function (pos) {
    return pos * 96 / 2.54;
  },
  "mm": function (pos) {
    return pos * 96 / 254;
  },
  "in": function (pos) {
    return pos * 96;
  },
  "pt": function (pos) {
    return pos * 96 / 72;
  },
  "pc": function (pos) {
    return pos * 96 / 6;
  },
  "%": function (pos, size) {
    return pos * size / 100;
  },
  "vw": function (pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }

    return pos / 100 * size;
  },
  "vh": function (pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }

    return pos / 100 * size;
  },
  "vmax": function (pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  },
  "vmin": function (pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  }
};

/**
* @namespace
* @name Utils
*/

/**
 * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).
 * @memberof Utils
 * @param - The first number
 * @param - The second number
 * @param - The first number to base on the inner product
 * @param - The second number to base on the inner product
 * @return - Returns the inner product
import { dot } from "@daybrush/utils";

console.log(dot(0, 15, 2, 3)); // 6
console.log(dot(5, 15, 2, 3)); // 9
console.log(dot(5, 15, 1, 1)); // 10
 */

function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
/**
* Check the type that the value is undefined.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {boolean} true if the type is correct, false otherwise
* @example
import {isUndefined} from "@daybrush/utils";

console.log(isUndefined(undefined)); // true
console.log(isUndefined("")); // false
console.log(isUndefined(1)); // false
console.log(isUndefined(null)); // false
*/

function isUndefined(value) {
  return typeof value === UNDEFINED;
}
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
/**
* Check the type that the value is function.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isFunction} from "@daybrush/utils";

console.log(isFunction(function a() {})); // true
console.log(isFunction(() => {})); // true
console.log(isFunction("1234")); // false
console.log(isFunction(1)); // false
console.log(isFunction(null)); // false
*/

function isFunction(value) {
  return typeof value === FUNCTION;
}

function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}

function findOpen(openCharacter, texts, index, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);

  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);
  }

  return index;
}

function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }

  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}

function findClose(closeCharacter, texts, index, length, openCloseCharacters) {
  var _loop_1 = function (i) {
    var character = texts[i].trim();

    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {
      return {
        value: i
      };
    }

    var nextIndex = i; // re open

    var openCharacter = find$1(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);
    }

    if (nextIndex === -1) {
      return out_i_1 = i, "break";
    }

    i = nextIndex;
    out_i_1 = i;
  };

  var out_i_1;

  for (var i = index; i < length; ++i) {
    var state_1 = _loop_1(i);

    i = out_i_1;
    if (typeof state_1 === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return -1;
}

function splitText(text, splitOptions) {
  var _a = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions,
      _b = _a.separator,
      separator = _b === void 0 ? "," : _b,
      isSeparateFirst = _a.isSeparateFirst,
      isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,
      _c = _a.isSeparateOpenClose,
      isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,
      _d = _a.openCloseCharacters,
      openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;

  var openClosedText = openCloseCharacters.map(function (_a) {
    var open = _a.open,
        close = _a.close;

    if (open === close) {
      return open;
    }

    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text.split(regex).filter(Boolean);
  var length = texts.length;
  var values = [];
  var tempValues = [];

  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }

    return false;
  }

  var _loop_2 = function (i) {
    var character = texts[i].trim();
    var nextIndex = i;
    var openCharacter = find$1(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });
    var closeCharacter = find$1(openCloseCharacters, function (_a) {
      var close = _a.close;
      return close === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);

      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        values.push(texts.slice(i, nextIndex + 1).join(""));
        i = nextIndex;

        if (isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        return out_i_2 = i, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();

      if (isSeparateFirst) {
        return out_i_2 = i, "break";
      }

      return out_i_2 = i, "continue";
    }

    if (nextIndex === -1) {
      nextIndex = length - 1;
    }

    tempValues.push(texts.slice(i, nextIndex + 1).join(""));
    i = nextIndex;
    out_i_2 = i;
  };

  var out_i_2;

  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);

    i = out_i_2;
    if (state_2 === "break") break;
  }

  if (tempValues.length) {
    values.push(tempValues.join(""));
  }

  return values;
}
/**
* divide text by space.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {spliceSpace} from "@daybrush/utils";

console.log(splitSpace("a b c d e f g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitSpace("'a,b' c 'd,e' f g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitSpace(text) {
  // divide comma(space)
  return splitText(text, "");
}
/**
* divide text by comma.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {splitComma} from "@daybrush/utils";

console.log(splitComma("a,b,c,d,e,f,g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitComma("'a,b',c,'d,e',f,g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitComma(text) {
  // divide comma(,)
  // "[^"]*"|'[^']*'
  return splitText(text, ",");
}
/**
* divide text by bracket "(", ")".
* @memberof Utils
* @param {string} text - text to divide
* @return {object} divided texts
* @example
import {splitBracket} from "@daybrush/utils";

console.log(splitBracket("a(1, 2)"));
// {prefix: "a", value: "1, 2", suffix: ""}
console.log(splitBracket("a(1, 2)b"));
// {prefix: "a", value: "1, 2", suffix: "b"}
*/

function splitBracket(text) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);

  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
/**
* divide text by number and unit.
* @memberof Utils
* @param {string} text - text to divide
* @return {} divided texts
* @example
import {splitUnit} from "@daybrush/utils";

console.log(splitUnit("10px"));
// {prefix: "", value: 10, unit: "px"}
console.log(splitUnit("-10px"));
// {prefix: "", value: -10, unit: "px"}
console.log(splitUnit("a10%"));
// {prefix: "a", value: 10, unit: "%"}
*/

function splitUnit(text) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);

  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }

  var prefix = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix,
    unit: unit,
    value: parseFloat(value)
  };
}
/**
* transform strings to camel-case
* @memberof Utils
* @param {String} text - string
* @return {String} camel-case string
* @example
import {camelize} from "@daybrush/utils";

console.log(camelize("transform-origin")); // transformOrigin
console.log(camelize("abcd_efg")); // abcdEfg
console.log(camelize("abcd efg")); // abcdEfg
*/

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}
/**
* transform a camelized string into a lowercased string.
* @memberof Utils
* @param {string} text - a camel-cased string
* @param {string} [separator="-"] - a separator
* @return {string}  a lowercased string
* @example
import {decamelize} from "@daybrush/utils";

console.log(decamelize("transformOrigin")); // transform-origin
console.log(decamelize("abcdEfg", "_")); // abcd_efg
*/

function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }

  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now$1() {
  return Date.now ? Date.now() : new Date().getTime();
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the value of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `find` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function find$1(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* window.requestAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.
* @return {number} id
* @example
import {requestAnimationFrame} from "@daybrush/utils";

requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});
*/

var requestAnimationFrame$1 = /*#__PURE__*/function () {
  var firstTime = now$1();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function (callback) {
    var currTime = now$1();
    var id = window.setTimeout(function () {
      callback(currTime - firstTime);
    }, 1000 / 60);
    return id;
  };
}();
/**
* window.cancelAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {number} handle - the id obtained through requestAnimationFrame method
* @return {void}
* @example
import { requestAnimationFrame, cancelAnimationFrame } from "@daybrush/utils";

const id = requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});

cancelAnimationFrame(id);
*/

var cancelAnimationFrame = /*#__PURE__*/function () {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function (handle) {
    clearTimeout(handle);
  };
}();
/**
* @function
* @memberof Utils
*/

function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }

  var keys = [];

  for (var name in keys) {
    keys.push(name);
  }

  return keys;
}
/**
* convert unit size to px size
* @function
* @memberof Utils
*/

function convertUnitSize(pos, size) {
  var _a = splitUnit(pos),
      value = _a.value,
      unit = _a.unit;

  if (isObject(size)) {
    var sizeFunction = size[unit];

    if (sizeFunction) {
      if (isFunction(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }

  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }

  return value;
}
/**
* calculate between min, max
* @function
* @memberof Utils
*/

function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax, ratio) {
  if (ratio === void 0) {
    ratio = targetSize[0] / targetSize[1];
  }

  return [[throttle(compareSize[0], TINY_NUM$1), throttle(compareSize[0] / ratio, TINY_NUM$1)], [throttle(compareSize[1] * ratio, TINY_NUM$1), throttle(compareSize[1], TINY_NUM$1)]].filter(function (size) {
    return size.every(function (value, i) {
      var defaultSize = compareSize[i];
      var throttledSize = throttle(defaultSize, TINY_NUM$1);
      return isMax ? value <= defaultSize || value <= throttledSize : value >= defaultSize || value >= throttledSize;
    });
  })[0] || targetSize;
}
/**
* calculate bound size
* @function
* @memberof Utils
*/

function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function (value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }

  var width = size[0],
      height = size[1];
  var ratio = keepRatio === true ? width / height : keepRatio; // width : height = minWidth : minHeight;

  var _a = checkBoundSize(size, minSize, false, ratio),
      minWidth = _a[0],
      minHeight = _a[1];

  var _b = checkBoundSize(size, maxSize, true, ratio),
      maxWidth = _b[0],
      maxHeight = _b[1];

  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }

  return [width, height];
}
/**
* Add all the numbers.
* @function
* @memberof Utils
*/

function sum(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return total;
}
/**
* Average all numbers.
* @function
* @memberof Utils
*/

function average(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return length ? total / length : 0;
}
/**
* Get the angle of two points. (0 <= rad < 359)
* @function
* @memberof Utils
*/

function getRad$1(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
/**
* Get the average point of all points.
* @function
* @memberof Utils
*/

function getCenterPoint(points) {
  return [0, 1].map(function (i) {
    return average(points.map(function (pos) {
      return pos[i];
    }));
  });
}
/**
* Gets the direction of the shape.
* @function
* @memberof Utils
*/

function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad$1(center, points[0]);
  var pos2Rad = getRad$1(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
/**
* Get the distance between two points.
* @function
* @memberof Utils
*/

function getDist$2(a, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));
}
/**
* throttle number depending on the unit.
* @function
* @memberof Utils
*/

function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  var reverseUnit = 1 / unit;
  return Math.round(num / unit) / reverseUnit;
}
/**
* throttle number array depending on the unit.
* @function
* @memberof Utils
*/

function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
/**
* Checks if the specified class value exists in the element's class attribute.
* @memberof DOM
* @param element - target
* @param className - the class name to search
* @return {boolean} return false if the class is not found.
* @example
import {hasClass} from "@daybrush/utils";

console.log(hasClass(element, "start")); // true or false
*/

function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }

  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
/**
* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.
* @memberof DOM
* @param element - target
* @param className - the class name to add
* @example
import {addClass} from "@daybrush/utils";

addClass(element, "start");
*/

function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
/**
* Removes the specified class value.
* @memberof DOM
* @param element - target
* @param className - the class name to remove
* @example
import {removeClass} from "@daybrush/utils";

removeClass(element, "start");
*/

function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}

/*
Copyright (c) Daybrush
name: react-simple-compat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/react-simple-compat.git
version: 1.2.2
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$6 = function (d, b) {
  extendStatics$6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics$6(d, b);
};

function __extends$6(d, b) {
  extendStatics$6(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$7 = function () {
  __assign$7 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$7.apply(this, arguments);
};
function __rest$2(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays$4() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function isDiff(a, b) {
  if (a === b) {
    return false;
  }

  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }

  for (var i in b) {
    if (a[i] !== b[i]) {
      return true;
    }
  }

  return false;
}

function diffObject(a, b) {
  var keys1 = Object.keys(a);
  var keys2 = Object.keys(b);
  var result = diff$1(keys1, keys2, function (key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function (index) {
    var name = keys2[index];
    added[name] = b[name];
  });
  result.removed.forEach(function (index) {
    var name = keys1[index];
    removed[name] = a[name];
  });
  result.maintained.forEach(function (_a) {
    var index = _a[0];
    var name = keys1[index];
    var values = [a[name], b[name]];

    if (a[name] !== b[name]) {
      changed[name] = values;
    }
  });
  return {
    added: added,
    removed: removed,
    changed: changed
  };
}

function executeHooks(hooks) {
  hooks.forEach(function (hook) {
    hook();
  });
}

function fillKeys(keys) {
  var index = 0;
  return keys.map(function (key) {
    return key == null ? "$compat" + ++index : "" + key;
  });
}

function createProvider(el, key, index, container) {
  if (isString(el) || isNumber(el)) {
    return new TextProvider("text_" + el, key, index, container, null, {});
  }

  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index, container, el.ref, el.props);
}

function flat$1(arr) {
  var arr2 = [];
  arr.forEach(function (el) {
    arr2 = arr2.concat(isArray(el) ? flat$1(el) : el);
  });
  return arr2;
}

function getAttributes(props) {
  var className = props.className,
      otherProps = __rest$2(props, ["className"]);

  if (className != null) {
    otherProps.class = className;
  }

  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}

function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }

  for (var name in defaultProps) {
    if (isUndefined(props[name])) {
      props[name] = defaultProps[name];
    }
  }

  return props;
}

function createElement(type, props) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = props || {},
      key = _a.key,
      ref = _a.ref,
      otherProps = __rest$2(_a, ["key", "ref"]);

  return {
    type: type,
    key: key,
    ref: ref,
    props: __assign$7(__assign$7({}, otherProps), {
      children: flat$1(children).filter(function (child) {
        return child != null && child !== false;
      })
    })
  };
}

var Provider =
/*#__PURE__*/
function () {
  function Provider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    this.type = type;
    this.key = key;
    this.index = index;
    this.container = container;
    this.ref = ref;
    this.props = props;
    this._providers = [];
  }

  var __proto = Provider.prototype;

  __proto._should = function (nextProps, nextState) {
    return true;
  };

  __proto._update = function (hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !isString(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }

    this.original = nextElement;

    this._setState(nextState); // render


    var prevProps = this.props;

    if (!isString(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }

    this._render(hooks, this.base ? prevProps : {}, nextState);

    return true;
  };

  __proto._mounted = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._setState = function (nextstate) {
    return;
  };

  __proto._updated = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._destroy = function () {
    var ref = this.ref;
    ref && ref(null);
  };

  return Provider;
}();

function diffAttributes(attrs1, attrs2, el) {
  var _a = diffObject(attrs1, attrs2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in added) {
    el.setAttribute(name, added[name]);
  }

  for (var name in changed) {
    el.setAttribute(name, changed[name][1]);
  }

  for (var name in removed) {
    el.removeAttribute(name);
  }
}

function diffEvents(events1, events2, provier) {
  var _a = diffObject(events1, events2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in removed) {
    provier.removeEventListener(name);
  }

  for (var name in added) {
    provier.addEventListener(name, added[name]);
  }

  for (var name in changed) {
    provier.removeEventListener(name);
    provier.addEventListener(name, changed[name][1]);
  }

  for (var name in removed) {
    provier.removeEventListener(name);
  }
}

function diffStyle(style1, style2, el) {
  var style = el.style;

  var _a = diffObject(style1, style2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var beforeName in added) {
    var name = decamelize(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, added[beforeName]);
    } else {
      style[name] = added[beforeName];
    }
  }

  for (var beforeName in changed) {
    var name = decamelize(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, changed[beforeName][1]);
    } else {
      style[name] = changed[beforeName][1];
    }
  }

  for (var beforeName in removed) {
    var name = decamelize(beforeName, "-");

    if (style.removeProperty) {
      style.removeProperty(name);
    } else {
      style[name] = "";
    }
  }
}

function splitProps(props) {
  var attributes = {};
  var events = {};

  for (var name in props) {
    if (name.indexOf("on") === 0) {
      events[name.replace("on", "").toLowerCase()] = props[name];
    } else {
      attributes[name] = props[name];
    }
  }

  return {
    attributes: attributes,
    events: events
  };
}

var TextProvider =
/*#__PURE__*/
function (_super) {
  __extends$6(TextProvider, _super);

  function TextProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = TextProvider.prototype;

  __proto._render = function (hooks) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }

    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    this.base.parentNode.removeChild(this.base);
  };

  return TextProvider;
}(Provider);

var ElementProvider =
/*#__PURE__*/
function (_super) {
  __extends$6(ElementProvider, _super);

  function ElementProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.events = {};
    _this._isSVG = false;
    return _this;
  }

  var __proto = ElementProvider.prototype;

  __proto.addEventListener = function (name, callback) {
    var events = this.events;

    events[name] = function (e) {
      e.nativeEvent = e;
      callback(e);
    };

    this.base.addEventListener(name, events[name]);
  };

  __proto.removeEventListener = function (name) {
    var events = this.events;
    this.base.removeEventListener(name, events[name]);
    delete events[name];
  };

  __proto._should = function (nextProps) {
    return isDiff(this.props, nextProps);
  };

  __proto._render = function (hooks, prevProps) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      var isSVG = this._hasSVG();

      this._isSVG = isSVG;
      var element = this.props.portalContainer;

      if (!element) {
        var type = this.type;

        if (isSVG) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }

      this.base = element;
    }

    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base = this.base;

    var _a = splitProps(prevProps),
        prevAttributes = _a.attributes,
        prevEvents = _a.events;

    var _b = splitProps(this.props),
        nextAttributes = _b.attributes,
        nextEvents = _b.events;

    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    var events = this.events;
    var base = this.base;

    for (var name in events) {
      base.removeEventListener(name, events[name]);
    }

    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    this.events = {};

    if (!this.props.portalContainer) {
      base.parentNode.removeChild(base);
    }
  };

  __proto._hasSVG = function () {
    if (this._isSVG || this.type === "svg") {
      return true;
    }

    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };

  return ElementProvider;
}(Provider);

function findContainerNode(provider) {
  if (!provider) {
    return null;
  }

  var base = provider.base;

  if (base instanceof Node) {
    return base;
  }

  return findContainerNode(provider.container);
}

function findDOMNode(comp) {
  if (!comp) {
    return null;
  }

  if (comp instanceof Node) {
    return comp;
  }

  var providers = comp.$_provider._providers;

  if (!providers.length) {
    return null;
  }

  return findDOMNode(providers[0].base);
}

var FunctionProvider =
/*#__PURE__*/
function (_super) {
  __extends$6(FunctionProvider, _super);

  function FunctionProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = FunctionProvider.prototype;

  __proto._render = function (hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });
  };

  return FunctionProvider;
}(Provider);

var ContainerProvider =
/*#__PURE__*/
function (_super) {
  __extends$6(ContainerProvider, _super);

  function ContainerProvider(base) {
    var _this = _super.call(this, "container", "container", 0, null) || this;

    _this.base = base;
    return _this;
  }

  var __proto = ContainerProvider.prototype;

  __proto._render = function () {
    return true;
  };

  __proto._unmount = function () {
    return;
  };

  return ContainerProvider;
}(Provider);

var ComponentProvider =
/*#__PURE__*/
function (_super) {
  __extends$6(ComponentProvider, _super);

  function ComponentProvider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    return _super.call(this, type, key, index, container, ref, fillProps(props, type.defaultProps)) || this;
  }

  var __proto = ComponentProvider.prototype;

  __proto._should = function (nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };

  __proto._render = function (hooks, prevProps, nextState) {
    var _this = this;

    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;

    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }

    var base = this.base;
    var prevState = base.state;
    var template = base.render();

    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }

    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();

        base.componentDidMount();
      } else {
        _this._updated();

        base.componentDidUpdate(prevProps, prevState);
      }
    });
  };

  __proto._setState = function (nextState) {
    var base = this.base;

    if (!base || !nextState) {
      return;
    }

    base.state = nextState;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };

  return ComponentProvider;
}(Provider);

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    if (props === void 0) {
      props = {};
    }

    this.props = props;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }

  var __proto = Component.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return true;
  };

  __proto.render = function () {
    return null;
  };

  __proto.setState = function (state, callback, isForceUpdate) {
    var _this = this;

    if (!this.$_timer) {
      this.$_state = {};
    }

    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign$7(__assign$7({}, this.$_state), state);

    if (!isForceUpdate) {
      this.$_timer = setTimeout(function () {
        _this.$_timer = 0;

        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }

    return;
  };

  __proto.forceUpdate = function (callback) {
    this.setState({}, callback, true);
  };

  __proto.componentDidMount = function () {};

  __proto.componentDidUpdate = function (prevProps, prevState) {};

  __proto.componentWillUnmount = function () {};

  __proto.$_setState = function (callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign$7(__assign$7({}, this.state), this.$_state), isForceUpdate);

    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }

      executeHooks(hooks);
    }
  };

  return Component;
}();

var PureComponent =
/*#__PURE__*/
function (_super) {
  __extends$6(PureComponent, _super);

  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = PureComponent.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };

  return PureComponent;
}(Component);

var _Portal =
/*#__PURE__*/
function (_super) {
  __extends$6(_Portal, _super);

  function _Portal() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = _Portal.prototype;

  __proto.componentDidMount = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentDidUpdate = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentWillUnmount = function () {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };

  return _Portal;
}(PureComponent);

function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}

function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length = childProviders.length;

  for (var i = childProvider.index + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].base);

    if (el) {
      return el;
    }
  }

  return null;
}

function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function (p) {
    return isString(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function (p) {
    return p.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = diff$1(keys1, keys2, function (key) {
    return key;
  });
  result.removed.forEach(function (index) {
    providers.splice(index, 1)[0]._unmount();
  });
  result.ordered.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);

    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function (index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function (_a) {
    _a[0];
        var to = _a[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = isString(el) ? "text_" + el : el.type;

    if (type !== childProvider.type) {
      childProvider._unmount();

      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }

    childProvider.index = to;
    return false;
  });
  return __spreadArrays$4(result.added, changed.map(function (_a) {
    _a[0];
        var to = _a[1];
    return to;
  }));
}

function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function (childProvider, i) {
    return childProvider._update(updatedHooks, children[i], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);

  if (containerNode) {
    result.reverse().forEach(function (index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.base);

      if (!el) {
        return;
      }

      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }

  return updated.length > 0;
}

function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }

  var isProvider = !!provider;

  if (!provider) {
    provider = new ContainerProvider(container);
  }

  updateProvider(provider, element ? [element] : []);

  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }

  return provider;
}

function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;

  if (element && !provider) {
    container.innerHTML = "";
  }

  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement(_Portal, {
    element: el,
    container: container
  });
}
var version = "simple-1.1.0";

/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.4.2
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgentString(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function isWebView(userAgent) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;
}
function getLegacyAgent(userAgent) {
  var nextAgent = getUserAgentString(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion; // Early whale bugs

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  var platfomResult = find(OS_PRESETS, function (preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";

  if (osData) {
    os.version = osData.platformVersion;
  }

  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser.name = browserBrandByFullVersionList.brand || browser.name;
    browser.version = browserBrandByFullVersionList.version || browser.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser.name = browserBrand.brand || browser.name;
    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko       .
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>  </ko>
 * @return - agent Info <ko>   </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent$1(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent);
  }
}

/*
Copyright (c) 2020 Daybrush
name: @scena/matrix
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/matrix
version: 1.1.1
*/

function add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    matrix[x] += matrix[fromX] * k;
    inverseMatrix[x] += inverseMatrix[fromX] * k;
  }
}

function swap(matrix, inverseMatrix, startIndex, fromIndex, n) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    var v = matrix[x];
    var iv = inverseMatrix[x];
    matrix[x] = matrix[fromX];
    matrix[fromX] = v;
    inverseMatrix[x] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}

function divide(matrix, inverseMatrix, startIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    matrix[x] /= k;
    inverseMatrix[x] /= k;
  }
}
/**
 *
 * @namespace Matrix
 */

/**
 * @memberof Matrix
 */


function ignoreDimension(matrix, m, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();

  for (var i = 0; i < n; ++i) {
    newMatrix[i * n + m - 1] = 0;
    newMatrix[(m - 1) * n + i] = 0;
  }

  newMatrix[(m - 1) * (n + 1)] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function invert(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();
  var inverseMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n; ++i) {
    // diagonal
    var identityIndex = n * i + i;

    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {
      // newMatrix[identityIndex] = 0;
      for (var j = i + 1; j < n; ++j) {
        if (newMatrix[n * i + j]) {
          swap(newMatrix, inverseMatrix, i, j, n);
          break;
        }
      }
    }

    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {
      // no inverse matrix
      return [];
    }

    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);

    for (var j = 0; j < n; ++j) {
      var targetStartIndex = j;
      var targetIndex = j + i * n;
      var target = newMatrix[targetIndex];

      if (!throttle(target, TINY_NUM$1) || i === j) {
        continue;
      }

      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);
    }
  }

  return inverseMatrix;
}
/**
 * @memberof Matrix
 */

function transpose(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = [];

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < n; ++j) {
      newMatrix[j * n + i] = matrix[n * i + j];
    }
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function getOrigin(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var originMatrix = [];
  var w = matrix[n * n - 1];

  for (var i = 0; i < n - 1; ++i) {
    originMatrix[i] = matrix[n * (n - 1) + i] / w;
  }

  originMatrix[n - 1] = 0;
  return originMatrix;
}
/**
 * @memberof Matrix
 */

function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n - 1; ++i) {
    newMatrix[n * (n - 1) + i] = pos[i] || 0;
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertPositionMatrix(matrix, n) {
  var newMatrix = matrix.slice();

  for (var i = matrix.length; i < n - 1; ++i) {
    newMatrix[i] = 0;
  }

  newMatrix[n - 1] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertDimension(matrix, n, m) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  } // n < m


  if (n === m) {
    return matrix;
  }

  var newMatrix = createIdentityMatrix(m);
  var length = Math.min(n, m);

  for (var i = 0; i < length - 1; ++i) {
    for (var j = 0; j < length - 1; ++j) {
      newMatrix[i * m + j] = matrix[i * n + j];
    }

    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];
    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];
  }

  newMatrix[m * m - 1] = matrix[n * n - 1];
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function multiplies(n) {
  var matrixes = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }

  var m = createIdentityMatrix(n);
  matrixes.forEach(function (matrix) {
    m = multiply(m, matrix, n);
  });
  return m;
}
/**
 * @memberof Matrix
 */

function multiply(matrix, matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = []; // 1 y: n
  // 1 x: m
  // 2 x: m
  // 2 y: k
  // n * m X m * k

  var m = matrix.length / n;
  var k = matrix2.length / m;

  if (!m) {
    return matrix2;
  } else if (!k) {
    return matrix;
  }

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < k; ++j) {
      newMatrix[j * n + i] = 0;

      for (var l = 0; l < m; ++l) {
        // m1 x: m(l), y: n(i)
        // m2 x: k(j):  y: m(l)
        // nw x: n(i), y: k(j)
        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];
      }
    }
  } // n * k


  return newMatrix;
}
/**
 * @memberof Matrix
 */

function plus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] + pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function minus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] - pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function convertCSStoMatrix(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 6;
  }

  if (is2d) {
    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function convertMatrixtoCSS(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 9;
  }

  if (is2d) {
    return [a[0], a[1], a[3], a[4], a[6], a[7]];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function calculate(matrix, matrix2, n) {
  if (n === void 0) {
    n = matrix2.length;
  }

  var result = multiply(matrix, matrix2, n);
  var k = result[n - 1];
  return result.map(function (v) {
    return v / k;
  });
}
/**
 * @memberof Matrix
 */

function rotateX3d(matrix, rad) {
  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateY3d(matrix, rad) {
  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateZ3d(matrix, rad) {
  return multiply(matrix, createRotateMatrix(rad, 4));
}
/**
 * @memberof Matrix
 */

function scale3d(matrix, _a) {
  var _b = _a[0],
      sx = _b === void 0 ? 1 : _b,
      _c = _a[1],
      sy = _c === void 0 ? 1 : _c,
      _d = _a[2],
      sz = _d === void 0 ? 1 : _d;
  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
/**
 * @memberof Matrix
 */

function translate3d(matrix, _a) {
  var _b = _a[0],
      tx = _b === void 0 ? 0 : _b,
      _c = _a[1],
      ty = _c === void 0 ? 0 : _c,
      _d = _a[2],
      tz = _d === void 0 ? 0 : _d;
  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
/**
 * @memberof Matrix
 */

function matrix3d(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
/**
 * @memberof Matrix
 */

function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m = createIdentityMatrix(n); // cos -sin
  // sin cos

  m[0] = cos;
  m[1] = sin;
  m[n] = -sin;
  m[n + 1] = cos;
  return m;
}
/**
 * @memberof Matrix
 */

function createIdentityMatrix(n) {
  var length = n * n;
  var matrix = [];

  for (var i = 0; i < length; ++i) {
    matrix[i] = i % (n + 1) ? 0 : 1;
  }

  return matrix;
}
/**
 * @memberof Matrix
 */

function createScaleMatrix(scale, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(scale.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[(n + 1) * i] = scale[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createOriginMatrix(origin, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(origin.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[n * (n - 1) + i] = origin[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0],
      y0 = pos0[1];
  var x1 = pos1[0],
      y1 = pos1[1];
  var x2 = pos2[0],
      y2 = pos2[1];
  var x3 = pos3[0],
      y3 = pos3[1];
  var u0 = nextPos0[0],
      v0 = nextPos0[1];
  var u1 = nextPos1[0],
      v1 = nextPos1[1];
  var u2 = nextPos2[0],
      v2 = nextPos2[1];
  var u3 = nextPos3[0],
      v3 = nextPos3[1];
  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix, 8);

  if (!inverseMatrix.length) {
    return [];
  }

  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h[8] = 1;
  return convertDimension(transpose(h), 3, 4);
}

/*
Copyright (c) 2019 Daybrush
name: css-to-mat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-to-mat.git
version: 1.0.3
*/

function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(transform) {
  return toMat(parse(transform));
}
function calculateMatrixDist(matrix, pos) {
  var res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w = res[3] || 1;
  return [res[0] / w, res[1] / w, res[2] / w];
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function (info) {
    var matrixFunction = info.matrixFunction,
        functionValue = info.functionValue;

    if (!matrixFunction) {
      return;
    }

    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse(transform) {
  var transforms = isArray(transform) ? transform : splitSpace(transform);
  return transforms.map(function (t) {
    var _a = splitBracket(t),
        name = _a.prefix,
        value = _a.value;

    var matrixFunction = null;
    var functionName = name;
    var functionValue = "";

    if (name === "translate" || name === "translateX" || name === "translate3d") {
      var _b = splitComma(value).map(function (v) {
        return parseFloat(v);
      }),
          posX = _b[0],
          _c = _b[1],
          posY = _c === void 0 ? 0 : _c,
          _d = _b[2],
          posZ = _d === void 0 ? 0 : _d;

      matrixFunction = translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name === "translateY") {
      var posY = parseFloat(value);
      matrixFunction = translate3d;
      functionValue = [0, posY, 0];
    } else if (name === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = translate3d;
      functionValue = [0, 0, posZ];
    } else if (name === "scale" || name === "scale3d") {
      var _e = splitComma(value).map(function (v) {
        return parseFloat(v);
      }),
          sx = _e[0],
          _f = _e[1],
          sy = _f === void 0 ? sx : _f,
          _g = _e[2],
          sz = _g === void 0 ? 1 : _g;

      matrixFunction = scale3d;
      functionValue = [sx, sy, sz];
    } else if (name === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [sx, 1, 1];
    } else if (name === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, sy, 1];
    } else if (name === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, 1, sz];
    } else if (name === "rotate" || name === "rotateZ" || name === "rotateX" || name === "rotateY") {
      var _h = splitUnit(value),
          unit = _h.unit,
          unitValue = _h.value;

      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;

      if (name === "rotate" || name === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = rotateZ3d;
      } else if (name === "rotateX") {
        matrixFunction = rotateX3d;
      } else if (name === "rotateY") {
        matrixFunction = rotateY3d;
      }

      functionValue = rad;
    } else if (name === "matrix3d") {
      matrixFunction = matrix3d;
      functionValue = splitComma(value).map(function (v) {
        return parseFloat(v);
      });
    } else if (name === "matrix") {
      var m = splitComma(value).map(function (v) {
        return parseFloat(v);
      });
      matrixFunction = matrix3d;
      functionValue = [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
    } else {
      functionName = "";
    }

    return {
      name: name,
      functionName: functionName,
      value: value,
      matrixFunction: matrixFunction,
      functionValue: functionValue
    };
  });
}

/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/children-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-children-differ
version: 1.0.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$5 = function (d, b) {
  extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics$5(d, b);
};

function __extends$5(d, b) {
  extendStatics$5(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var findKeyCallback = typeof Map === "function" ? undefined : function () {
  var childrenCount = 0;
  return function (el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();

/**
 * A module that checks diff when child are added, removed, or changed .
 * @ko           .
 * @memberof eg
 * @extends eg.ListDiffer
 */

var ChildrenDiffer =
/*#__PURE__*/
function (_super) {
  __extends$5(ChildrenDiffer, _super);
  /**
   * @param - Initializing Children <ko>    </ko>
   */


  function ChildrenDiffer(list) {
    if (list === void 0) {
      list = [];
    }

    return _super.call(this, list, findKeyCallback) || this;
  }

  return ChildrenDiffer;
}(ListDiffer);

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
/**
 *
 * @memberof eg.ChildrenDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/children-differ";
 * // script => eg.ChildrenDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list) {
  return diff$1(prevList, list, findKeyCallback);
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

var ChildrenDiffer$1 = ChildrenDiffer;

/*
Copyright (c) 2020 Daybrush
name: overlap-area
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/overlap-area.git
version: 1.1.0
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$3() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function tinyThrottle(num) {
  return throttle(num, TINY_NUM$1);
}
function isSameConstants(linearConstants1, linearConstants2) {
  return linearConstants1.every(function (v, i) {
    return tinyThrottle(v - linearConstants2[i]) === 0;
  });
}
function isSamePoint(point1, point2) {
  return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);
}

/**
 * @namespace OverlapArea
 */

/**
 * Gets the size of a shape (polygon) made of points.
 * @memberof OverlapArea
 */

function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }

  return Math.abs(sum(points.map(function (point, i) {
    var nextPoint = points[i + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
/**
 * Get points that fit the rect,
 * @memberof OverlapArea
 */

function fitPoints(points, rect) {
  var width = rect.width,
      height = rect.height,
      left = rect.left,
      top = rect.top;

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function (point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
/**
 * Get the minimum and maximum points of the points.
 * @memberof OverlapArea
 */

function getMinMaxs(points) {
  var xs = points.map(function (point) {
    return point[0];
  });
  var ys = points.map(function (point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
/**
 * Whether the point is in shape
 * @param - point pos
 * @param - shape points
 * @param - whether to check except line
 * @memberof OverlapArea
 */

function isInside(pos, points, excludeLine) {
  var x = pos[0],
      y = pos[1];

  var _a = getMinMaxs(points),
      minX = _a.minX,
      maxX = _a.maxX;

  var xLine = [[minX, y], [maxX, y]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var lines = convertLines(points);
  var intersectionPosInfos = [];
  lines.forEach(function (line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var standardPoint = line[0];

    if (isSameConstants(xLinearConstants, linearConstants)) {
      intersectionPosInfos.push({
        pos: pos,
        line: line,
        type: "line"
      });
    } else {
      var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
      xPoints.forEach(function (point) {
        if (line.some(function (linePoint) {
          return isSamePoint(linePoint, point);
        })) {
          intersectionPosInfos.push({
            pos: point,
            line: line,
            type: "point"
          });
        } else if (tinyThrottle(standardPoint[1] - y) !== 0) {
          intersectionPosInfos.push({
            pos: point,
            line: line,
            type: "intersection"
          });
        }
      });
    }
  });

  if (!excludeLine) {
    // on line
    if (find$1(intersectionPosInfos, function (p) {
      return p[0] === x;
    })) {
      return true;
    }
  }

  var intersectionCount = 0;
  var xMap = {};
  intersectionPosInfos.forEach(function (_a) {
    var pos = _a.pos,
        type = _a.type,
        line = _a.line;

    if (pos[0] > x) {
      return;
    }

    if (type === "intersection") {
      ++intersectionCount;
    } else if (type === "line") {
      return;
    } else if (type === "point") {
      var point = find$1(line, function (linePoint) {
        return linePoint[1] !== y;
      });
      var prevValue = xMap[pos[0]];
      var nextValue = point[1] > y ? 1 : -1;

      if (!prevValue) {
        xMap[pos[0]] = nextValue;
      } else if (prevValue !== nextValue) {
        ++intersectionCount;
      }
    }
  });
  return intersectionCount % 2 === 1;
}
/**
 * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)
 * @return [a, b, c]
 * @memberof OverlapArea
 */

function getLinearConstants(point1, point2) {
  var x1 = point1[0],
      y1 = point1[1];
  var x2 = point2[0],
      y2 = point2[1]; // ax + by + c = 0
  // [a, b, c]

  var dx = x2 - x1;
  var dy = y2 - y1;

  if (Math.abs(dx) < TINY_NUM$1) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM$1) {
    dy = 0;
  } // b > 0
  // ax + by + c = 0


  var a = 0;
  var b = 0;
  var c = 0;

  if (!dx) {
    if (dy) {
      // -x + 1 = 0
      a = -1;
      c = x1;
    }
  } else if (!dy) {
    // y - 1 = 0
    b = 1;
    c = -y1;
  } else {
    // y = -a(x - x1) + y1
    // ax + y + a * x1 - y1 = 0
    a = -dy / dx;
    b = 1;
    c = -a * x1 - y1;
  }

  return [a, b, c];
}
/**
 * Get intersection points with linear functions.
 * @memberof OverlapArea
 */

function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0],
      b1 = linearConstants1[1],
      c1 = linearConstants1[2];
  var a2 = linearConstants2[0],
      b2 = linearConstants2[1],
      c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;
  var results = [];

  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    // b1 * y + c1 = 0
    // b2 * y + c2 = 0
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;

    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    // a1 * x + c1 = 0
    // a2 * x + c2 = 0
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;

    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    // b1 * y + c1 = 0
    // y = - c1 / b1;
    // a2 * x + b2 * y + c2 = 0
    var y = -c1 / b1;
    var x = -(b2 * y + c2) / a2;
    results = [[x, y]];
  } else if (a2 === 0) {
    // b2 * y + c2 = 0
    // y = - c2 / b2;
    // a1 * x + b1 * y + c1 = 0
    var y = -c2 / b2;
    var x = -(b1 * y + c1) / a1;
    results = [[x, y]];
  } else if (b1 === 0) {
    // a1 * x + c1 = 0
    // x = - c1 / a1;
    // a2 * x + b2 * y + c2 = 0
    var x = -c1 / a1;
    var y = -(a2 * x + c2) / b2;
    results = [[x, y]];
  } else if (b2 === 0) {
    // a2 * x + c2 = 0
    // x = - c2 / a2;
    // a1 * x + b1 * y + c1 = 0
    var x = -c2 / a2;
    var y = -(a1 * x + c1) / b1;
    results = [[x, y]];
  } else {
    // a1 * x + b1 * y + c1 = 0
    // a2 * x + b2 * y + c2 = 0
    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0
    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0
    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)
    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y = -(a1 * x + c1) / b1;
    results = [[x, y]];
  }

  return results.map(function (result) {
    return [result[0], result[1]];
  });
}
/**
 * Get the points on the lines (between two points).
 * @memberof OverlapArea
 */

function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function (line) {
    return [0, 1].map(function (order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });
  var results = [];

  if (points.length === 2) {
    var _a = points[0],
        x = _a[0],
        y = _a[1];

    if (!tinyThrottle(x - points[1][0])) {
      /// Math.max(minY1, minY2)
      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][0];
      })); /// Math.min(maxY1, miax2)

      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][1];
      }));

      if (tinyThrottle(top - bottom) > 0) {
        return [];
      }

      results = [[x, top], [x, bottom]];
    } else if (!tinyThrottle(y - points[1][1])) {
      /// Math.max(minY1, minY2)
      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][0];
      })); /// Math.min(maxY1, miax2)

      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][1];
      }));

      if (tinyThrottle(left - right) > 0) {
        return [];
      }

      results = [[left, y], [right, y]];
    }
  }

  if (!results.length) {
    results = points.filter(function (point) {
      var pointX = point[0],
          pointY = point[1];
      return minMaxs.every(function (minMax) {
        return 0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX) && 0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY);
      });
    });
  }

  return results.map(function (result) {
    return [tinyThrottle(result[0]), tinyThrottle(result[1])];
  });
}
/**
* Convert two points into lines.
* @function
* @memberof OverlapArea
*/

function convertLines(points) {
  return __spreadArrays$3(points.slice(1), [points[0]]).map(function (point, i) {
    return [points[i], point];
  });
}

function getOverlapPointInfos(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();

  if (getShapeDirection(targetPoints1) === -1) {
    targetPoints1.reverse();
  }

  if (getShapeDirection(targetPoints2) === -1) {
    targetPoints2.reverse();
  }

  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantsList1 = lines1.map(function (line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantsList2 = lines2.map(function (line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantsList1.forEach(function (linearConstants1, i) {
    var line1 = lines1[i];
    var linePointInfos = [];
    linearConstantsList2.forEach(function (linearConstants2, j) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);
      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {
        return {
          index1: i,
          index2: j,
          pos: pos,
          type: "intersection"
        };
      }));
    });
    linePointInfos.sort(function (a, b) {
      return getDist$2(line1[0], a.pos) - getDist$2(line1[0], b.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);

    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i,
        index2: -1,
        pos: line1[1],
        type: "inside"
      });
    }
  });
  lines2.forEach(function (line2, i) {
    if (!isInside(line2[1], targetPoints1)) {
      return;
    }

    var isNext = false;
    var index = findIndex(overlapInfos, function (_a) {
      var index2 = _a.index2;

      if (index2 === i) {
        isNext = true;
        return false;
      }

      if (isNext) {
        return true;
      }

      return false;
    });

    if (index === -1) {
      isNext = false;
      index = findIndex(overlapInfos, function (_a) {
        var index1 = _a.index1,
            index2 = _a.index2;

        if (index1 === -1 && index2 + 1 === i) {
          isNext = true;
          return false;
        }

        if (isNext) {
          return true;
        }

        return false;
      });
    }

    if (index === -1) {
      overlapInfos.push({
        index1: -1,
        index2: i,
        pos: line2[1],
        type: "inside"
      });
    } else {
      overlapInfos.splice(index, 0, {
        index1: -1,
        index2: i,
        pos: line2[1],
        type: "inside"
      });
    }
  });
  var pointMap = {};
  return overlapInfos.filter(function (_a) {
    var pos = _a.pos;
    var key = pos[0] + "x" + pos[1];

    if (pointMap[key]) {
      return false;
    }

    pointMap[key] = true;
    return true;
  });
}
/**
* Get the points of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/


function getOverlapPoints(points1, points2) {
  var infos = getOverlapPointInfos(points1, points2);
  return infos.map(function (_a) {
    var pos = _a.pos;
    return pos;
  });
}
/**
* Gets the size of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$6 = function () {
  __assign$6 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$6.apply(this, arguments);
};
function __spreadArrays$2() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter$3 =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays$2(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$6({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

var EventEmitter$4 = EventEmitter$3;

/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.6.0
*/
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now() {
  return Date.now ? Date.now() : new Date().getTime();
}

/*
Copyright (c) 2019 Daybrush
name: @scena/dragscroll
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/dragscroll.git
version: 1.1.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$4 = function (d, b) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics$4(d, b);
};

function __extends$4(d, b) {
  extendStatics$4(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$5 = function () {
  __assign$5 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$5.apply(this, arguments);
};

function getDefaultScrollPosition$1(e) {
  var container = e.container;

  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }

  return [container.scrollLeft, container.scrollTop];
}

var DragScroll =
/*#__PURE__*/
function (_super) {
  __extends$4(DragScroll, _super);

  function DragScroll() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    return _this;
  }

  var __proto = DragScroll.prototype;

  __proto.dragStart = function (e, options) {
    var container = options.container;
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;

    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }

    this._startPos = [e.clientX, e.clientY];
    this._startRect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
  };

  __proto.drag = function (e, options) {
    var clientX = e.clientX,
        clientY = e.clientY;
    var _a = options.threshold,
        threshold = _a === void 0 ? 0 : _a;

    var _b = this,
        _startRect = _b._startRect,
        _startPos = _b._startPos;

    var direction = [0, 0];

    if (_startRect.top > clientY - threshold) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction[1] = 1;
      }
    }

    if (_startRect.left > clientX - threshold) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction[0] = 1;
      }
    }

    clearTimeout(this._timer);

    if (!direction[0] && !direction[1]) {
      return false;
    }

    return this._continueDrag(__assign$5(__assign$5({}, options), {
      direction: direction,
      inputEvent: e,
      isDrag: true
    }));
  };

  __proto.checkScroll = function (options) {
    var _this = this;

    if (this._isWait) {
      return false;
    }

    var _a = options.prevScrollPos,
        prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,
        direction = options.direction,
        _b = options.throttleTime,
        throttleTime = _b === void 0 ? 0 : _b,
        inputEvent = options.inputEvent,
        isDrag = options.isDrag;

    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);

    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;

    if (!offsetX && !offsetY) {
      return false;
    }

    this.trigger("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent: inputEvent
    });

    if (throttleTime && isDrag) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, throttleTime);
    }

    return true;
  };

  __proto.dragEnd = function () {
    clearTimeout(this._timer);
  };

  __proto._getScrollPosition = function (direction, options) {
    var container = options.container,
        _a = options.getScrollPosition,
        getScrollPosition = _a === void 0 ? getDefaultScrollPosition$1 : _a;
    return getScrollPosition({
      container: container,
      direction: direction
    });
  };

  __proto._continueDrag = function (options) {
    var _this = this;

    var container = options.container,
        direction = options.direction,
        throttleTime = options.throttleTime,
        useScroll = options.useScroll,
        isDrag = options.isDrag,
        inputEvent = options.inputEvent;

    if (isDrag && this._isWait) {
      return;
    }

    var nowTime = now();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);

    if (distTime > 0) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }

    this._prevTime = nowTime;

    var prevScrollPos = this._getScrollPosition(direction, options);

    this._prevScrollPos = prevScrollPos;

    if (isDrag) {
      this._isWait = true;
    }

    this.trigger("scroll", {
      container: container,
      direction: direction,
      inputEvent: inputEvent
    });
    this._isWait = false;
    return useScroll || this.checkScroll(__assign$5(__assign$5({}, options), {
      prevScrollPos: prevScrollPos,
      direction: direction,
      inputEvent: inputEvent
    }));
  };

  return DragScroll;
}(EventEmitter$4);

var DragScroll$1 = DragScroll;

/*
Copyright (c) 2019 Daybrush
name: gesto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesto.git
version: 1.9.0
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$3 = function (d, b) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics$3(d, b);
};

function __extends$3(d, b) {
  extendStatics$3(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$4 = function () {
  __assign$4 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$4.apply(this, arguments);
};

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (!e) {
    return [];
  }

  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;

  var _a = getAverageClient(clients, length),
      clientX = _a.clientX,
      clientY = _a.clientY,
      originalClientX = _a.originalClientX,
      originalClientY = _a.originalClientY;

  var _b = getAverageClient(prevClients, length),
      prevX = _b.clientX,
      prevY = _b.clientY;

  var _c = getAverageClient(startClients, length),
      startX = _c.clientX,
      startY = _c.clientY;

  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX: deltaX,
    deltaY: deltaY,
    distX: distX,
    distY: distY
  };
}
function getDist$1(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];

  for (var i = 0; i < length; ++i) {
    clients.push(getClient(touches[i]));
  }

  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }

  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };

  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }

  if (!length) {
    return sumClient;
  }

  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}

var ClientStore =
/*#__PURE__*/
function () {
  function ClientStore(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }

  var __proto = ClientStore.prototype;

  __proto.getAngle = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients);
  };

  __proto.getRotation = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients) - getRotatiion(this.startClients);
  };

  __proto.getPosition = function (clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX,
        deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };

  __proto.getPositions = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var prevClients = this.prevClients;
    return this.startClients.map(function (startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };

  __proto.getMovement = function (clients) {
    var movement = this.movement;

    if (!clients) {
      return movement;
    }

    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };

  __proto.getDistance = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist$1(clients);
  };

  __proto.getScale = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist$1(clients) / getDist$1(this.startClients);
  };

  __proto.move = function (deltaX, deltaY) {
    this.startClients.forEach(function (client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };

  return ClientStore;
}();

var INPUT_TAGNAMES = ["textarea", "input"];
/**
 * You can set up drag, pinch events in any browser.
 */

var Gesto =
/*#__PURE__*/
function (_super) {
  __extends$3(Gesto, _super);
  /**
   *
   */


  function Gesto(targets, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;

    _this.onDragStart = function (e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }

      if (!_this.flag && e.cancelable === false) {
        return;
      }

      var _a = _this.options,
          container = _a.container,
          pinchOutside = _a.pinchOutside,
          preventWheelClick = _a.preventWheelClick,
          preventRightClick = _a.preventRightClick,
          preventDefault = _a.preventDefault,
          checkInput = _a.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;

      if (preventWheelClick && (e.which === 2 || e.button === 1) || preventRightClick && (e.which === 3 || e.button === 2)) {
        _this.initDrag();

        return false;
      }

      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;

        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            // force false or already focused.
            return false;
          } // no focus


          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;

          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }

        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};
        _this.doubleFlag = now$1() - _this.prevTime < 200;

        var result = _this.emit("dragStart", __assign$4(__assign$4({
          datas: _this.datas,
          inputEvent: e,
          isTrusted: isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition()), {
          preventDefault: function () {
            e.preventDefault();
          },
          preventDrag: function () {
            _this._dragFlag = false;
          }
        }));

        if (result === false) {
          _this.initDrag();
        }

        _this.flag && preventDefault && e.preventDefault();
      }

      if (!_this.flag) {
        return false;
      }

      var timer = 0;

      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function () {
          addEvent(container, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }

      if (!isDragStart && isTouch && pinchOutside) {
        removeEvent(container, "touchstart", _this.onDragStart);
      }

      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);

        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }

        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };

    _this.onDrag = function (e, isScroll) {
      if (!_this.flag) {
        return;
      }

      var clients = getEventClients(e);

      var result = _this.moveClients(clients, e, false);

      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign$4(__assign$4({}, result), {
            isScroll: !!isScroll,
            inputEvent: e
          }));

          if (dragResult === false) {
            _this.stop();

            return;
          }
        }

        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }

      _this.getCurrentStore().getPosition(clients, true);
    };

    _this.onDragEnd = function (e) {
      if (!_this.flag) {
        return;
      }

      var _a = _this.options,
          pinchOutside = _a.pinchOutside,
          container = _a.container;

      if (_this.isTouch && pinchOutside) {
        removeEvent(container, "touchstart", _this.onDragStart);
      }

      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }

      var clients = (e === null || e === void 0 ? void 0 : e.touches) ? getEventClients(e) : [];
      var clientsLength = clients.length;

      if (clientsLength === 0 || !_this.options.keepDragging) {
        _this.flag = false;
      } else {
        _this._addStore(new ClientStore(clients));
      }

      var position = _this._getPosition();

      var currentTime = now$1();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;

      if (!_this.flag) {
        _this.emit("dragEnd", __assign$4({
          datas: _this.datas,
          isDouble: isDouble,
          isDrag: _this.isDrag,
          isClick: !_this.isDrag,
          inputEvent: e
        }, position));

        _this.clientStores = [];
      }
    };

    _this.onBlur = function () {
      _this.onDragEnd();
    };

    var elements = [].concat(targets);
    _this.options = __assign$4({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventWheelClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      keepDragging: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a = _this.options,
        container = _a.container,
        events = _a.events,
        checkWindowBlur = _a.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;

    if (_this.isMouse) {
      elements.forEach(function (el) {
        addEvent(el, "mousedown", _this.onDragStart);
      });
      addEvent(container, "mousemove", _this.onDrag);
      addEvent(container, "mouseup", _this.onDragEnd);
      addEvent(container, "contextmenu", _this.onDragEnd);
    }

    if (checkWindowBlur) {
      addEvent(window, "blur", _this.onBlur);
    }

    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function (el) {
        addEvent(el, "touchstart", _this.onDragStart, passive_1);
      });
      addEvent(container, "touchmove", _this.onDrag, passive_1);
      addEvent(container, "touchend", _this.onDragEnd, passive_1);
      addEvent(container, "touchcancel", _this.onDragEnd, passive_1);
    }

    return _this;
  }
  /**
   * Stop Gesto's drag events.
   */


  var __proto = Gesto.prototype;

  __proto.stop = function () {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  /**
   * The total moved distance
   */


  __proto.getMovement = function (clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  /**
   * Whether to drag
   */


  __proto.isDragging = function () {
    return this.isDrag;
  };
  /**
   * Whether to start drag
   */


  __proto.isFlag = function () {
    return this.flag;
  };
  /**
   * Whether to start pinch
   */


  __proto.isPinchFlag = function () {
    return this.pinchFlag;
  };
  /**
  * Whether to start double click
  */


  __proto.isDoubleFlag = function () {
    return this.doubleFlag;
  };
  /**
   * Whether to pinch
   */


  __proto.isPinching = function () {
    return this.isPinch;
  };
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */


  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }

    if (!this.flag) {
      return;
    }

    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  /**
   * Create a virtual drag event.
   */


  __proto.move = function (_a, inputEvent) {
    var deltaX = _a[0],
        deltaY = _a[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function (_a) {
      var clientX = _a.clientX,
          clientY = _a.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  /**
   * The dragStart event is triggered by an external event.
   */


  __proto.triggerDragStart = function (e) {
    this.onDragStart(e, false);
  };
  /**
   * Set the event data while dragging.
   */


  __proto.setEventDatas = function (datas) {
    var currentDatas = this.datas;

    for (var name in datas) {
      currentDatas[name] = datas[name];
    }

    return this;
  };
  /**
   * Get the current event state while dragging.
   */


  __proto.getCurrentEvent = function (inputEvent) {
    return __assign$4(__assign$4({
      datas: this.datas
    }, this._getPosition()), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };
  /**
   * Get & Set the event data while dragging.
   */


  __proto.getEventDatas = function () {
    return this.datas;
  };
  /**
   * Unset Gesto
   */


  __proto.unset = function () {
    var _this = this;

    var targets = this.targets;
    var container = this.options.container;
    this.off();
    removeEvent(window, "blur", this.onBlur);

    if (this.isMouse) {
      targets.forEach(function (target) {
        removeEvent(target, "mousedown", _this.onDragStart);
      });
      removeEvent(container, "mousemove", this.onDrag);
      removeEvent(container, "mouseup", this.onDragEnd);
      removeEvent(container, "contextmenu", this.onDragEnd);
    }

    if (this.isTouch) {
      targets.forEach(function (target) {
        removeEvent(target, "touchstart", _this.onDragStart);
      });
      removeEvent(container, "touchstart", this.onDragStart);
      removeEvent(container, "touchmove", this.onDrag);
      removeEvent(container, "touchend", this.onDragEnd);
      removeEvent(container, "touchcancel", this.onDragEnd);
    }
  };

  __proto.onPinchStart = function (e) {
    var pinchThreshold = this.options.pinchThreshold;

    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }

    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;

    this._addStore(store);

    var result = this.emit("pinchStart", __assign$4(__assign$4({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition()), {
      inputEvent: e
    }));

    if (result === false) {
      this.pinchFlag = false;
    }
  };

  __proto.onPinch = function (e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }

    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign$4(__assign$4({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients)), {
      inputEvent: e
    }));
  };

  __proto.onPinchEnd = function (e) {
    if (!this.pinchFlag) {
      return;
    }

    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign$4(__assign$4({
      datas: this.datas,
      isPinch: isPinch,
      touches: store.getPositions()
    }, store.getPosition()), {
      inputEvent: e
    }));
  };

  __proto.initDrag = function () {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };

  __proto.getCurrentStore = function () {
    return this.clientStores[0];
  };

  __proto.moveClients = function (clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);

    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }

    return __assign$4(__assign$4({
      datas: this.datas
    }, position), {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };

  __proto._addStore = function (store) {
    this.clientStores.splice(0, 0, store);
  };

  __proto._getPosition = function (clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);

    var _a = this.clientStores.slice(1).reduce(function (prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position),
        distX = _a.distX,
        distY = _a.distY;

    return __assign$4(__assign$4({}, position), {
      distX: distX,
      distY: distY
    });
  };

  return Gesto;
}(EventEmitter$4);

var Gesto$1 = Gesto;

/*
Copyright (c) 2019 Daybrush
name: css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.0
*/

function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

function getHash(str) {
  return stringHash(str).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();

    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }

  return;
}
function replaceStyle(className, css, options) {
  if (options.original) {
    return css;
  }

  return css.replace(/([^};{\s}][^};{]*|^\s*){/mg, function (_, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? splitComma(trimmedSelector) : [""]).map(function (subSelector) {
      var trimmedSubSelector = subSelector.trim();

      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "" + trimmedSubSelector.replace(/\:host/g, "." + className);
      } else if (trimmedSubSelector) {
        return "." + className + " " + trimmedSubSelector;
      } else {
        return "." + className;
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css, options, shadowRoot) {
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);

  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }

  style.innerHTML = replaceStyle(className, css, options);
  (shadowRoot || document.head || document.body).appendChild(style);
  return style;
}

/**
 * Create an styled object that can be defined and inserted into the css.
 * @param - css styles
 */

function styled$1(css) {
  var injectClassName = "rCS" + getHash(css);
  var injectCount = 0;
  var injectElement;
  return {
    className: injectClassName,
    inject: function (el, options) {
      if (options === void 0) {
        options = {};
      }

      var shadowRoot = getShadowRoot(el);
      var firstMount = injectCount === 0;
      var styleElement;

      if (shadowRoot || firstMount) {
        styleElement = injectStyle(injectClassName, css, options, shadowRoot);
      }

      if (firstMount) {
        injectElement = styleElement;
      }

      if (!shadowRoot) {
        ++injectCount;
      }

      return {
        destroy: function () {
          if (shadowRoot) {
            el.removeChild(styleElement);
            styleElement = null;
          } else {
            if (injectCount > 0) {
              --injectCount;
            }

            if (injectCount === 0 && injectElement) {
              injectElement.parentNode.removeChild(injectElement);
              injectElement = null;
            }
          }
        }
      };
    }
  };
}

/*
Copyright (c) Daybrush
name: react-compat-css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.8
*/

/*
Copyright (c) 2019 Daybrush
name: react-css-styled
license: MIT
author: Daybrush
repository: https://github.com/daybrush/css-styled/tree/master/packages/react-css-styled
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$2 = function (d, b) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics$2(d, b);
};

function __extends$2(d, b) {
  extendStatics$2(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function () {
  __assign$3 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$3.apply(this, arguments);
};
function __rest$1(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

var StyledElement =
/*#__PURE__*/
function (_super) {
  __extends$2(StyledElement, _super);

  function StyledElement() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }

  var __proto = StyledElement.prototype;

  __proto.render = function () {
    var _a = this.props,
        _b = _a.className,
        className = _b === void 0 ? "" : _b;
        _a.cspNonce;
        var portalContainer = _a.portalContainer,
        attributes = __rest$1(_a, ["className", "cspNonce", "portalContainer"]);

    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};

    if ((version ).indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer: portalContainer
      };
    }

    return createElement(Tag, __assign$3({
      "ref": ref(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };

  __proto.componentDidMount = function () {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };

  __proto.componentWillUnmount = function () {
    this.injectResult.destroy();
    this.injectResult = null;
  };

  __proto.getElement = function () {
    return this.element;
  };

  return StyledElement;
}(Component);

function styled(tag, css) {
  var injector = styled$1(css);
  return (
    /*#__PURE__*/
    function (_super) {
      __extends$2(Styled, _super);

      function Styled() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.injector = injector;
        _this.tag = tag;
        return _this;
      }

      return Styled;
    }(StyledElement)
  );
}

/*
Copyright (c) 2019 Daybrush
name: react-compat-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-compat-moveable
version: 0.18.0
*/

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1$1 = function () {
  __assign$1$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1$1.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter$2 =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays$1(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$1$1({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

var EventEmitter$1$1 = EventEmitter$2;

/*
Copyright (c) 2019 Daybrush
name: react-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable
version: 0.33.0
*/
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */

var extendStatics$1 = function (d, b) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics$1(d, b);
};

function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$2 = function () {
  __assign$2 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$2.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function makeAble(name, able) {
  var _a;

  return __assign$2({
    events: {},
    props: (_a = {}, _a[name] = Boolean, _a),
    name: name
  }, able);
}

function getSVGCursor(scale, degree) {
  return "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"".concat(32 * scale, "px\" height=\"").concat(32 * scale, "px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(").concat(degree, "deg);transform-origin: 16px 16px\"></path></svg>");
}

function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree); // const x2 = getSVGCursor(2, degree);

  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";

  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  } // tslint:disable-next-line: max-line-length


  return "cursor:".concat(defaultCursor, ";cursor: url('").concat(x1, "') 16 16, ").concat(defaultCursor, ";");
}

var agent = agent$1();
var IS_WEBKIT = agent.browser.webkit;

var IS_WEBKIT605 = IS_WEBKIT && function () {
  var navi = typeof window === "undefined" ? {
    userAgent: ""
  } : window.navigator;
  var res = /applewebkit\/([^\s]+)/g.exec(navi.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();

var PREFIX = "moveable-";
var MOVEABLE_CSS = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n".concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {
  return "\n.direction[data-rotation=\"".concat(degree, "\"] {\n\t").concat(getCursorCSS(degree), "\n}\n");
}).join("\n"), "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n").concat(IS_WEBKIT605 ? ":global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}" : "", "\n");
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 0.0001;
var TINY_NUM = 0.0000001;
var MIN_SCALE = 0.000000001;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"];

function setCustomDrag(e, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign$2(__assign$2({}, isConvert ? convertDragDist(state, result) : result), {
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e.originalDatas
  });
}

var CustomGesto = /*#__PURE__*/function () {
  function CustomGesto() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }

  var __proto = CustomGesto.prototype;

  __proto.dragStart = function (client, e) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e.originalDatas;
    this.datas = originalDatas;

    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }

    return __assign$2(__assign$2({}, this.move(client, e.inputEvent)), {
      type: "dragstart"
    });
  };

  __proto.drag = function (client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };

  __proto.move = function (delta, inputEvent) {
    var clientX;
    var clientY;

    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];

      if (delta[0] || delta[1]) {
        this.isDrag = true;
      }
    }

    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX: clientX,
      clientY: clientY,
      inputEvent: inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };

  return CustomGesto;
}();

function fillChildEvents(moveable, name, e) {
  var datas = e.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function (_, i) {
    childDatas[i] = childDatas[i] || {};
    childDatas[i][name] = childDatas[i][name] || {};
    return __assign$2(__assign$2({}, e), {
      datas: childDatas[i][name],
      originalDatas: childDatas[i]
    });
  });
}

function triggerChildGesto(moveable, able, type, delta, e, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e.isPinch;
  var datas = e.datas;
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var state = childMoveable.state;
    var childEvent = ev;

    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!state.gesto) {
        state.gesto = datas.childGestos[i];
      }

      if (!state.gesto) {
        return;
      }

      childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert);
    }

    var result = able[type](childMoveable, __assign$2(__assign$2({}, childEvent), {
      parentFlag: true
    }));

    if (isEnd) {
      state.gesto = null;
    }

    return result;
  });

  if (isStart) {
    datas.childGestos = moveables.map(function (child) {
      return child.state.gesto;
    });
  }

  return childs;
}

function triggerChildAbles(moveable, able, type, e, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function (_, ev) {
      return ev;
    };
  }

  var isEnd = !!type.match(/End$/g);
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign$2(__assign$2({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i);

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });
  return childs;
}

function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }

  var _a = moveable.state,
      renderPoses = _a.renderPoses,
      rotationRad = _a.rotation,
      direction = _a.direction;
  var _b = moveable.props,
      _c = _b.renderDirections,
      directions = _c === void 0 ? defaultDirections : _c,
      zoom = _b.zoom;
  var directionMap = {};

  if (!directions) {
    return [];
  }

  var sign = direction > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = rotationRad / Math.PI * 180;
  renderDirections.forEach(function (dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function (dir) {
    var indexes = DIRECTION_INDEXES[dir];

    if (!indexes || !directionMap[dir]) {
      return null;
    }

    var directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-".concat(dir),
      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function (index) {
        return renderPoses[index];
      }), false))
    });
  });
}

function renderLine(React, direction, pos1, pos2, zoom, key) {
  var classNames = [];

  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }

  var rad = getRad$1(pos1, pos2);
  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line".concat(key),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", direction], classNames, false)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}

function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}

function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}
/**
 * @namespace Rotatable
 * @memberof Moveable
 * @description Rotatable indicates whether the target can be rotated.
 */


function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = getRad$1(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.defaultDeg = datas.prevDeg;
  datas.prevSnapDeg = 0;
  datas.loop = 0;
}

function getAbsoluteDist(deg, direction, datas) {
  var defaultDeg = datas.defaultDeg,
      prevDeg = datas.prevDeg;
  var normalizedPrevDeg = prevDeg % 360;
  var loop = Math.floor(prevDeg / 360);

  if (normalizedPrevDeg < 0) {
    normalizedPrevDeg += 360;
  }

  if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {
    // 360 => 0
    ++loop;
  } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {
    // 0 => 360
    --loop;
  }

  var dist = direction * (loop * 360 + deg - defaultDeg);
  datas.prevDeg = defaultDeg + dist;
  return dist;
}

function getAbsoluteDistByClient(clientX, clientY, direction, datas) {
  return getAbsoluteDist(getRad$1(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, datas);
}

function getRotateInfo(moveable, moveableRect, datas, dist, startValue, isSnap) {
  var _a = moveable.props.throttleRotate,
      throttleRotate = _a === void 0 ? 0 : _a;
  var nextDist = dist;
  var prevSnapDeg = datas.prevSnapDeg;

  if (isSnap) {
    nextDist = checkSnapRotate(moveable, moveableRect, datas.origin, nextDist);
  }

  var snapRotation = throttle(startValue + nextDist, throttleRotate);
  var snapDeg = snapRotation - startValue;
  datas.prevSnapDeg = snapDeg;
  return [snapDeg - prevSnapDeg, nextDist, snapRotation];
}

function getRotationPositions(rotationPosition, _a, direction) {
  var pos1 = _a[0],
      pos2 = _a[1],
      pos3 = _a[2],
      pos4 = _a[3];

  if (rotationPosition === "none") {
    return;
  }

  var _b = (rotationPosition || "top").split("-"),
      dir1 = _b[0],
      dir2 = _b[1];

  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {
  //     dir1 = getReversePositionX(dir1);
  //     dir2 = getReversePositionX(dir2);
  // }
  // if (scale[1] < 0) {
  //     dir1 = getReversePositionY(dir1);
  //     dir2 = getReversePositionY(dir2);
  // }

  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }

  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction);

  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }

  return [pos, rad];
}

function dragControlCondition(moveable, e) {
  if (e.isRequest) {
    return e.requestAble === "rotatable";
  }

  var target = e.inputEvent.target;

  if (hasClass(target, prefix("rotation-control"))) {
    return true;
  }

  var rotationTarget = moveable.props.rotationTarget;

  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function (element) {
      if (!element) {
        return false;
      }

      return target === element || target.contains(element);
    });
  }

  return false;
}

var Rotatable$1 = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onBeforeRotate: "beforeRotate",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onBeforeRotateGroup: "beforeRotateGroup",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function (moveable, React) {
    var _a = moveable.props,
        rotatable = _a.rotatable,
        rotationPosition = _a.rotationPosition,
        zoom = _a.zoom,
        renderDirections = _a.renderDirections;
    var _b = moveable.state,
        renderPoses = _b.renderPoses,
        direction = _b.direction;

    if (!rotatable) {
      return null;
    }

    var positions = getRotationPositions(rotationPosition, renderPoses, direction);
    var jsxs = [];

    if (positions) {
      var pos = positions[0],
          rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rad, "rad)")
        }
      }, React.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(zoom, ")")
        }
      }), React.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(zoom, ")")
        }
      })));
    }

    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }

    return jsxs;
  },
  dragControlCondition: dragControlCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var _a = moveable.state,
        target = _a.target,
        left = _a.left,
        top = _a.top,
        origin = _a.origin,
        beforeOrigin = _a.beforeOrigin,
        direction = _a.direction,
        beforeDirection = _a.beforeDirection,
        targetTransform = _a.targetTransform,
        moveableClientRect = _a.moveableClientRect;

    if (!isRequest && !target) {
      return false;
    }

    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));

    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        defaultDeg: externalRotate,
        prevSnapDeg: 0
      };
      datas.afterInfo = __assign$2(__assign$2({}, datas.beforeInfo), {
        origin: rect.origin
      });
      datas.absoluteInfo = __assign$2(__assign$2({}, datas.beforeInfo), {
        origin: rect.origin,
        startValue: externalRotate
      });
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      datas.absoluteInfo = {
        origin: rect.origin,
        startValue: rect.rotation
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
      setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);
    }

    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e, "rotate");
    var params = fillParams(moveable, e, __assign$2(__assign$2({
      set: function (rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable$1.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a, _b, _c;

    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        groupDelta = e.groupDelta;
    var beforeDirection = datas.beforeDirection,
        beforeInfo = datas.beforeInfo,
        afterInfo = datas.afterInfo,
        absoluteInfo = datas.absoluteInfo,
        isRotate = datas.isRotate,
        startValue = datas.startValue,
        rect = datas.rect;

    if (!isRotate) {
      return;
    }

    resolveTransformEvent(e, "rotate");
    var targetDirection = getTransformDirection(e);
    var direction = beforeDirection * targetDirection;
    var parentMoveable = moveable.props.parentMoveable;
    var beforeDelta = 0;
    var beforeDist;
    var beforeRotation;
    var delta = 0;
    var dist;
    var rotation;
    var absoluteDelta = 0;
    var absoluteDist;
    var absoluteRotation;
    var startRotation = 180 / Math.PI * startValue;
    var absoluteStartRotation = absoluteInfo.startValue;
    var isSnap = false;

    if (!parentFlag && "parentDist" in e) {
      var parentDist = e.parentDist;
      beforeDist = parentDist;
      dist = parentDist;
      absoluteDist = parentDist;
    } else if (isPinch || parentFlag) {
      beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);
      dist = getAbsoluteDist(parentRotate, direction, afterInfo);
      absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);
    } else {
      beforeDist = getAbsoluteDistByClient(clientX, clientY, beforeDirection, beforeInfo);
      dist = getAbsoluteDistByClient(clientX, clientY, direction, afterInfo);
      absoluteDist = getAbsoluteDistByClient(clientX, clientY, direction, absoluteInfo);
      isSnap = true;
    }

    beforeRotation = startRotation + beforeDist;
    rotation = startRotation + dist;
    absoluteRotation = absoluteStartRotation + absoluteDist;
    triggerEvent(moveable, "onBeforeRotate", fillParams(moveable, e, {
      beforeRotation: beforeRotation,
      rotation: rotation,
      absoluteRotation: absoluteRotation,
      setRotation: function (nextRotation) {
        dist = nextRotation - startRotation;
        beforeDist = dist;
        absoluteDist = dist;
      }
    }, true));
    _a = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap), beforeDelta = _a[0], beforeDist = _a[1], beforeRotation = _a[2];
    _b = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap), delta = _b[0], dist = _b[1], rotation = _b[2];
    _c = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotation = _c[2];

    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }

    var nextTransform = convertTransformFormat(datas, "rotate(".concat(rotation, "deg)"), "rotate(".concat(dist, "deg)"));
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = minus(plus(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    datas.requestValue = null;
    var params = fillParams(moveable, e, __assign$2({
      delta: delta,
      dist: dist,
      rotate: rotation,
      rotation: rotation,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeRotate: beforeRotation,
      beforeRotation: beforeRotation,
      absoluteDist: absoluteDist,
      absoluteDelta: absoluteDelta,
      absoluteRotate: absoluteRotation,
      absoluteRotation: absoluteRotation,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    e.datas.requestValue;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    datas.isRotate = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onRotateEnd", params);
    return params;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var _a = moveable.state,
        parentLeft = _a.left,
        parentTop = _a.top,
        parentBeforeOrigin = _a.beforeOrigin;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    params.set(datas.beforeDirection * moveable.rotation);
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      var _a = child.state,
          left = _a.left,
          top = _a.top,
          beforeOrigin = _a.beforeOrigin;
      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign$2(__assign$2({}, ev), {
        parentRotate: 0
      });
    });

    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    catchEvent(moveable, "onBeforeRotate", function (parentEvent) {
      triggerEvent(moveable, "onBeforeRotateGroup", fillParams(moveable, e, __assign$2(__assign$2({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var direction = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = ev.datas.groupClient,
          prevX = _a[0],
          prevY = _a[1];

      var _b = rotate([prevX, prevY], rad * direction),
          clientX = _b[0],
          clientY = _b[1];

      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign$2(__assign$2({}, ev), {
        parentRotate: parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction * params.beforeRotation;

    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events: events,
      set: function (rotation) {
        moveable.rotation = rotation;
      },
      setGroupRotation: function (rotation) {
        moveable.rotation = rotation;
      }
    }, params);

    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaRotate" in e) {
          distRotate += e.deltaRotate;
        } else if ("rotate" in e) {
          distRotate = e.rotate - startRotation;
        }

        return {
          datas: datas,
          parentDist: distRotate
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be rotated. (default: false)
 * @name Moveable.Rotatable#rotatable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.rotatable = true;
 */

/**
 * You can specify the position of the rotation. (default: "top")
 * @name Moveable.Rotatable#rotationPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   rotationPosition: "top",
 * });
 *
 * moveable.rotationPosition = "bottom"
 */

/**
 * throttle of angle(degree) when rotate.
 * @name Moveable.Rotatable#throttleRotate
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleRotate = 1;
 */

/**
 * When the rotate starts, the rotateStart event is called.
 * @memberof Moveable.Rotatable
 * @event rotateStart
 * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
* When rotating, the rotate event is called.
* @memberof Moveable.Rotatable
* @event rotate
* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { rotatable: true });
* moveable.on("rotate", ({ target, transform, dist }) => {
*     target.style.transform = transform;
* });
*/

/**
 * When the rotate finishes, the rotateEnd event is called.
 * @memberof Moveable.Rotatable
 * @event rotateEnd
 * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
 * When the group rotate starts, the `rotateGroupStart` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupStart
 * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupStart", ({ targets }) => {
 *     console.log("onRotateGroupStart", targets);
 * });
 */

/**
* When the group rotate, the `rotateGroup` event is called.
* @memberof Moveable.Rotatable
* @event rotateGroup
* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     rotatable: true
* });
* moveable.on("rotateGroup", ({ targets, events }) => {
*     console.log("onRotateGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group rotate.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const deg = ev.beforeDist;
*     });
* });
*/

/**
 * When the group rotate finishes, the `rotateGroupEnd` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupEnd
 * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onRotateGroupEnd", targets, isDrag);
 * });
 */

var VERTICAL_NAMES = ["left", "right", "center"];
var HORIZONTAL_NAMES = ["top", "bottom", "middle"];
var VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
};
var HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};

function hasGuidelines(moveable, ableName) {
  var _a = moveable.props,
      snappable = _a.snappable,
      bounds = _a.bounds,
      innerBounds = _a.innerBounds,
      verticalGuidelines = _a.verticalGuidelines,
      horizontalGuidelines = _a.horizontalGuidelines,
      snapGridWidth = _a.snapGridWidth,
      snapGridHeight = _a.snapGridHeight,
      _b = moveable.state,
      guidelines = _b.guidelines,
      enableSnap = _b.enableSnap;

  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }

  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }

  return false;
}

function getSnapDirections(snapDirections) {
  if (snapDirections === false) {
    return {};
  } else if (snapDirections === true || !snapDirections) {
    return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
  }

  return snapDirections;
}

function mapSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapDirections = getSnapDirections(snapDirections);
  var nextSnapPoses = {};

  for (var name in nextSnapDirections) {
    if (name in snapPoses && nextSnapDirections[name]) {
      nextSnapPoses[name] = snapPoses[name];
    }
  }

  return nextSnapPoses;
}

function splitSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);
  var horizontalNames = HORIZONTAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  var verticalNames = VERTICAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  return {
    horizontal: horizontalNames.map(function (name) {
      return nextSnapPoses[name];
    }),
    vertical: verticalNames.map(function (name) {
      return nextSnapPoses[name];
    })
  };
}

function getGapGuidelines(moveable, targetRect, snapThreshold) {
  var elementRects = moveable.state.elementRects;
  var gapGuidelines = [];
  [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function (_a) {
    var type = _a[0],
        mainNames = _a[1],
        sideNames = _a[2];
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetCenter = targetRect[mainNames.center];
    var targetStart2 = targetRect[sideNames.start];
    var targetEnd2 = targetRect[sideNames.end]; // element : moveable

    function getDist(elementRect) {
      var rect = elementRect.rect;

      if (rect[mainNames.end] < targetStart + snapThreshold) {
        return targetStart - rect[mainNames.end];
      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {
        return rect[mainNames.start] - targetEnd;
      } else {
        return -1;
      }
    }

    var nextElementRects = elementRects.filter(function (elementRect) {
      var rect = elementRect.rect;

      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {
        return false;
      }

      return getDist(elementRect) > 0;
    }).sort(function (a, b) {
      return getDist(a) - getDist(b);
    });
    var groups = [];
    nextElementRects.forEach(function (snapRect1) {
      nextElementRects.forEach(function (snapRect2) {
        if (snapRect1 === snapRect2) {
          return;
        }

        var rect1 = snapRect1.rect;
        var rect2 = snapRect2.rect;
        var rect1Start = rect1[sideNames.start];
        var rect1End = rect1[sideNames.end];
        var rect2Start = rect2[sideNames.start];
        var rect2End = rect2[sideNames.end];

        if (rect1Start > rect2End || rect2Start > rect1End) {
          return;
        }

        groups.push([snapRect1, snapRect2]);
      });
    });
    groups.forEach(function (_a) {
      var snapRect1 = _a[0],
          snapRect2 = _a[1];
      var rect1 = snapRect1.rect;
      var rect2 = snapRect2.rect;
      var rect1Start = rect1[mainNames.start];
      var rect1End = rect1[mainNames.end];
      var rect2Start = rect2[mainNames.start];
      var rect2End = rect2[mainNames.end];
      var gap = 0;
      var pos = 0;
      var isStart = false;
      var isCenter = false;
      var isEnd = false;

      if (rect1End <= targetStart && targetEnd <= rect2Start) {
        // (l)element1(r) : (l)target(r) : (l)element2(r)
        isCenter = true;
        gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;
        pos = rect1End + gap + (targetEnd - targetStart) / 2;

        if (Math.abs(pos - targetCenter) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {
        // (l)element1(r) : (l)element2(r) : (l)target
        isStart = true;
        gap = rect2Start - rect1End;
        pos = rect2End + gap;

        if (Math.abs(pos - targetStart) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {
        // target(r) : (l)element1(r) : (l)element2(r)
        isEnd = true;
        gap = rect2Start - rect1End;
        pos = rect1Start - gap;

        if (Math.abs(pos - targetEnd) > snapThreshold) {
          return;
        }
      } else {
        return;
      }

      if (!gap) {
        return;
      }

      gapGuidelines.push({
        type: type,
        pos: type === "vertical" ? [pos, 0] : [0, pos],
        element: snapRect2.element,
        size: 0,
        className: snapRect2.className,
        isStart: isStart,
        isCenter: isCenter,
        isEnd: isEnd,
        gap: gap,
        hide: true,
        gapRects: [snapRect1, snapRect2]
      });
    });
  });
  return gapGuidelines;
}

function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }

  var guidelines = [];
  var snapOffsetLeft = snapOffset.left,
      snapOffsetTop = snapOffset.top,
      snapOffsetBottom = snapOffset.bottom,
      snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, throttle(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "vertical",
      pos: [throttle(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}

function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}

function getSnapElementRects(moveable, values) {
  if (!values.length) {
    return [];
  }

  var state = moveable.state;
  var containerClientRect = state.containerClientRect,
      _a = state.targetClientRect,
      clientTop = _a.top,
      clientLeft = _a.left,
      rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;

  var _b = calculateContainerPos(rootMatrix, containerClientRect, n),
      containerLeft = _b[0],
      containerTop = _b[1];

  var poses = getAbsolutePosesByState(state);

  var _c = getMinMaxs(poses),
      targetLeft = _c.minX,
      targetTop = _c.minY;

  var _d = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {
    return roundSign(pos);
  }),
      distLeft = _d[0],
      distTop = _d[1];

  return values.map(function (value) {
    var rect = value.element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;

    var _a = calculateInversePosition(rootMatrix, [left, top], n),
        elementLeft = _a[0],
        elementTop = _a[1];

    var _b = calculateInversePosition(rootMatrix, [right, bottom], n),
        elementRight = _b[0],
        elementBottom = _b[1];

    return __assign$2(__assign$2({}, value), {
      rect: {
        left: elementLeft + distLeft,
        right: elementRight + distLeft,
        top: elementTop + distTop,
        bottom: elementBottom + distTop,
        center: (elementLeft + elementRight) / 2 + distLeft,
        middle: (elementTop + elementBottom) / 2 + distTop
      }
    });
  });
}

function getElementGuidelines(moveable) {
  var state = moveable.state;
  var _a = moveable.props.elementGuidelines,
      elementGuidelines = _a === void 0 ? [] : _a;

  if (!elementGuidelines.length) {
    state.elementRects = [];
    return [];
  }

  var prevValues = (state.elementRects || []).filter(function (snapRect) {
    return !snapRect.refresh;
  });
  var nextElementGuidelines = elementGuidelines.map(function (el) {
    if (isObject(el) && "element" in el) {
      return el;
    }

    return {
      element: getRefTarget(el, true)
    };
  }).filter(function (value) {
    return value.element;
  });

  var _b = diff(prevValues.map(function (v) {
    return v.element;
  }), nextElementGuidelines.map(function (v) {
    return v.element;
  })),
      maintained = _b.maintained,
      added = _b.added;

  var nextValues = [];
  maintained.forEach(function (_a) {
    var prevIndex = _a[0],
        nextIndex = _a[1];
    nextValues[nextIndex] = prevValues[prevIndex];
  });
  getSnapElementRects(moveable, added.map(function (index) {
    return nextElementGuidelines[index];
  })).map(function (rect, i) {
    nextValues[added[i]] = rect;
  });
  state.elementRects = nextValues;
  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);
  var nextGuidelines = [];
  nextValues.forEach(function (snapRect) {
    var element = snapRect.element,
        _a = snapRect.top,
        topValue = _a === void 0 ? elementSnapDirections.top : _a,
        _b = snapRect.left,
        leftValue = _b === void 0 ? elementSnapDirections.left : _b,
        _c = snapRect.right,
        rightValue = _c === void 0 ? elementSnapDirections.right : _c,
        _d = snapRect.bottom,
        bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d,
        _e = snapRect.center,
        centerValue = _e === void 0 ? elementSnapDirections.center : _e,
        _f = snapRect.middle,
        middleValue = _f === void 0 ? elementSnapDirections.middle : _f,
        className = snapRect.className,
        rect = snapRect.rect;

    var _g = splitSnapDirectionPoses({
      top: topValue,
      right: rightValue,
      left: leftValue,
      bottom: bottomValue,
      center: centerValue,
      middle: middleValue
    }, rect),
        horizontal = _g.horizontal,
        vertical = _g.vertical;

    var rectTop = rect.top;
    var rectLeft = rect.left;
    var width = rect.right - rectLeft;
    var height = rect.bottom - rectTop;
    var sizes = [width, height];
    vertical.forEach(function (pos) {
      nextGuidelines.push({
        type: "vertical",
        element: element,
        pos: [throttle(pos, 0.1), rectTop],
        size: height,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
    horizontal.forEach(function (pos) {
      nextGuidelines.push({
        type: "horizontal",
        element: element,
        pos: [rectLeft, throttle(pos, 0.1)],
        size: width,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
  });
  return nextGuidelines;
}

function getTotalGuidelines(moveable) {
  var _a = moveable.state,
      snapOffset = _a.snapOffset,
      _b = _a.containerClientRect,
      overflow = _b.overflow,
      containerHeight = _b.scrollHeight,
      containerWidth = _b.scrollWidth,
      containerClientHeight = _b.clientHeight,
      containerClientWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop;
  var _c = moveable.props,
      _d = _c.snapGap,
      snapGap = _d === void 0 ? true : _d,
      verticalGuidelines = _c.verticalGuidelines,
      horizontalGuidelines = _c.horizontalGuidelines,
      _e = _c.snapThreshold,
      snapThreshold = _e === void 0 ? 5 : _e,
      _f = _c.snapGridWidth,
      snapGridWidth = _f === void 0 ? 0 : _f,
      _g = _c.snapGridHeight,
      snapGridHeight = _g === void 0 ? 0 : _g;
  var elementGuidelines = getElementGuidelines(moveable);

  var totalGuidelines = __spreadArray([], elementGuidelines, true);

  if (snapGap) {
    var _h = getRect(getAbsolutePosesByState(moveable.state)),
        top = _h.top,
        left = _h.left,
        bottom = _h.bottom,
        right = _h.right;

    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    }, snapThreshold));
  }

  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}

function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  var guidelines = [];

  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, throttle(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }

  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [throttle(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }

  return guidelines;
}

function solveLineConstants(_a) {
  var point1 = _a[0],
      point2 = _a[1];
  var dx = point2[0] - point1[0];
  var dy = point2[1] - point1[1];

  if (Math.abs(dx) < TINY_NUM$1) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM$1) {
    dy = 0;
  } // b > 0
  // ax + by + c = 0


  var a = 0;
  var b = 0;
  var c = 0;

  if (!dx) {
    // -x + 1 = 0
    a = -1;
    c = point1[0];
  } else if (!dy) {
    // y - 1 = 0
    b = 1;
    c = -point1[1];
  } else {
    // y = -a(x - x1) + y1
    // ax + y + a * x1 - y1 = 0
    a = -dy / dx;
    b = 1;
    c = a * point1[0] - point1[1];
  }

  return [a, b, c].map(function (v) {
    return throttle(v, TINY_NUM$1);
  });
}

function checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {
  var props = moveable.props;
  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);
}

function checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, snapThreshold)
  };
}

function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0],
      endY = endPos[1];
  var startX = startPos[0],
      startY = startPos[1];

  var _a = minus(endPos, startPos),
      dx = _a[0],
      dy = _a[1];

  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }

  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),
      verticalSnapInfo = _b.vertical,
      horizontalSnapInfo = _b.horizontal;

  verticalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;

  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),
      isVerticalSnap = _c.isSnap,
      verticalGuideline = _c.guideline;

  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),
      isHorizontalSnap = _d.isSnap,
      horizontalGuideline = _d.guideline;

  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;

  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isSnap = false;

    if (isVerticalSnap) {
      x = verticalPos;
      y = a * x + b;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y = horizontalPos;
      x = (y - b) / a;
      isSnap = true;
    }

    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkSnaps(moveable, rect, customSnapThreshold) {
  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);
  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);
}

function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;

  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }

  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap: isSnap,
    offset: offset,
    dist: dist,
    pos: posInfo.pos,
    guideline: guideline
  };
}

function checkSnap(guidelines, targetType, targetPoses, snapThreshold) {
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }

  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function (targetPos, index) {
    var guidelineInfos = guidelines.map(function (guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset: offset,
        dist: Math.abs(offset),
        guideline: guideline
      };
    }).filter(function (_a) {
      var guideline = _a.guideline,
          dist = _a.dist;
      var type = guideline.type;

      if (type !== targetType || dist > snapThreshold) {
        return false;
      }

      return true;
    }).sort(function (a, b) {
      return a.dist - b.dist;
    });
    return {
      pos: targetPos,
      index: index,
      guidelineInfos: guidelineInfos
    };
  }).filter(function (snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function (a, b) {
    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap: isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}

function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];

  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {
      return getPosByDirection(poses, direction);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];

    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);

      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }

  return checkMoveableSnapPoses(moveable, nextPoses.map(function (pos) {
    return pos[0];
  }), nextPoses.map(function (pos) {
    return pos[1];
  }), 1);
}

function checkSnapBoundPriority(a, b) {
  var aDist = Math.abs(a.offset);
  var bDist = Math.abs(b.offset);

  if (a.isBound && b.isBound) {
    return bDist - aDist;
  } else if (a.isBound) {
    return -1;
  } else if (b.isBound) {
    return 1;
  } else if (a.isSnap && b.isSnap) {
    return bDist - aDist;
  } else if (a.isSnap) {
    return -1;
  } else if (b.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }

  return aDist - bDist;
}

function getNearOffsetInfo(offsets, index) {
  return offsets.slice().sort(function (a, b) {
    var aSign = a.sign[index];
    var bSign = b.sign[index];
    var aOffset = a.offset[index];
    var bOffset = b.offset[index]; // -1 The positions of a and b do not change.
    // 1 The positions of a and b are reversed.

    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }

    return checkSnapBoundPriority({
      isBound: a.isBound,
      isSnap: a.isSnap,
      offset: aOffset
    }, {
      isBound: b.isBound,
      isSnap: b.isSnap,
      offset: bOffset
    });
  })[0];
}

function getCheckSnapDirections(direction, fixedDirection, keepRatio) {
  var directions = []; // const fixedDirection = [-direction[0], -direction[1]];

  if (keepRatio) {
    if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {
      directions.push([fixedDirection, [-1, -1]], [fixedDirection, [-1, 1]], [fixedDirection, [1, -1]], [fixedDirection, [1, 1]]);
    } else {
      directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);
    }

    directions.push([fixedDirection, direction]);
  } else {
    if (direction[0] && direction[1] || !direction[0] && !direction[1]) {
      var endDirection_1 = direction[0] ? direction : [1, 1];
      [1, -1].forEach(function (signX) {
        [1, -1].forEach(function (signY) {
          var nextDirection = [signX * endDirection_1[0], signY * endDirection_1[1]];

          if (fixedDirection[0] === nextDirection[0] && fixedDirection[1] === nextDirection[1]) {
            return;
          }

          directions.push([fixedDirection, nextDirection]);
        });
      });
    } else if (direction[0]) {
      var signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];
      signs.forEach(function (sign) {
        directions.push([[fixedDirection[0], -1], [sign * direction[0], -1]], [[fixedDirection[0], 0], [sign * direction[0], 0]], [[fixedDirection[0], 1], [sign * direction[0], 1]]);
      });
    } else if (direction[1]) {
      var signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];
      signs.forEach(function (sign) {
        directions.push([[-1, fixedDirection[1]], [-1, sign * direction[1]]], [[0, fixedDirection[1]], [0, sign * direction[1]]], [[1, fixedDirection[1]], [1, sign * direction[1]]]);
      });
    }
  }

  return directions;
}

function isStartLine(dot, line) {
  // l    o     => true
  // o    l    => false
  var cx = average([line[0][0], line[1][0]]);
  var cy = average([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot[0],
    horizontal: cy <= dot[1]
  };
}

function hitTestLine(dot, _a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var test1;
  var test2;

  if (!dx) {
    test1 = pos1[0];
    test2 = dot[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot[1];
  } else {
    var a = dy / dx; // y = a * (x - pos1) + pos1

    test1 = a * (dot[0] - pos1[0]) + pos1[1];
    test2 = dot[1];
  }

  return test1 - test2;
}

function isSameStartLine(dots, line, centerSign, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }

  return dots.every(function (dot) {
    var value = hitTestLine(dot, line);
    var sign = value <= 0;
    return sign === centerSign || Math.abs(value) <= error;
  });
}

function checkInnerBoundDot(pos, start, end, isStart, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {
    // false 402 565 602 => 37 ([0, 37])
    // true 400 524.9712603540036 600 => 124 ([124, 0])
    // true 400 410 600 => 10 ([10, 0])
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }

  return {
    isBound: false,
    offset: 0
  };
}

function checkInnerBound(moveable, _a) {
  var line = _a.line,
      centerSign = _a.centerSign,
      verticalSign = _a.verticalSign,
      horizontalSign = _a.horizontalSign,
      lineConstants = _a.lineConstants;
  var bounds = moveable.props.innerBounds;

  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];

  if (isSameStartLine([[left, top], [left + width, top], [left, top + height], [left + width, top + height]], line, centerSign)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  } // test vertical


  var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);
  var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign); // test horizontal

  var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);
  var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;

  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }

  return {
    isAllBound: isAllBound,
    isVerticalBound: isVerticalBound,
    isHorizontalBound: isHorizontalBound,
    isBound: isBound,
    offset: offset
  };
}

function checkLineBoundCollision(line, _a, boundLine, isStart, threshold, isRender) {
  var a = _a[0],
      b = _a[1];
  var dot1 = line[0]; // const dot2 = line[1];

  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1]; // const dy1 = getTinyDist(dot2[1] - dot1[1]);
  // const dx1 = getTinyDist(dot2[0] - dot1[0]);

  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);
  var hasDx = b;
  var hasDy = a;
  var slope = -a / b; // lineConstants
  // ax + by + c = 0
  // dx2 or dy2 is zero

  if (!dx2) {
    // vertical
    // by + c = 0
    if (isRender && !hasDy) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (hasDx) {
      // ax + by + c = 0
      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];
      var y = slope * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]

      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);
    } else {
      // ax + c = 0
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    // horizontal
    if (isRender && !hasDx) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (hasDy) {
      // y = a * (x - x1) + y1
      // x = (y - y1) / a + x1
      // const a = dy1 / dx1;
      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];
      var x = (boundDot1[1] - dot1[1]) / slope + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]

      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  }

  return {
    isBound: false,
    offset: 0
  };
}

function getInnerBoundInfo(moveable, lineInfos, datas) {
  return lineInfos.map(function (info) {
    var _a = checkInnerBound(moveable, info),
        isBound = _a.isBound,
        offset = _a.offset,
        isVerticalBound = _a.isVerticalBound,
        isHorizontalBound = _a.isHorizontalBound;

    var multiple = info.multiple;
    var sizeOffset = getDragDist({
      datas: datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isBound,
      isVerticalBound: isVerticalBound,
      isHorizontalBound: isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}

function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a;

  var lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(function (info) {
    return __assign$2(__assign$2({}, info), {
      multiple: info.multiple.map(function (dir) {
        return Math.abs(dir) * 2;
      })
    });
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;

  if (isVerticalBound || isHorizontalBound) {
    _a = getInverseDragDist({
      datas: datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a[0], horizontalOffset = _a[1];
  }

  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}

function getCheckSnapLineDirections(direction, keepRatio) {
  var lineDirections = [];
  var x = direction[0];
  var y = direction[1];

  if (x && y) {
    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);
  } else if (x) {
    // vertcal
    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);

    if (keepRatio) {
      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);
    }
  } else if (y) {
    // horizontal
    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);

    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);
    }
  } else {
    // [0, 0] to all direction
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }

  return lineDirections;
}

function getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio) {
  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  var virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);
  var center = getPosByDirection(virtualPoses, [0, 0]);
  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {
    var multiple = _a[0],
        dir1 = _a[1],
        dir2 = _a[2];
    var virtualLine = [getPosByDirection(virtualPoses, dir1), getPosByDirection(virtualPoses, dir2)];
    var lineConstants = solveLineConstants(virtualLine);

    var _b = isStartLine(center, virtualLine),
        verticalSign = _b.vertical,
        horizontalSign = _b.horizontal;

    var centerSign = hitTestLine(center, virtualLine) <= 0;
    return {
      multiple: multiple,
      centerSign: centerSign,
      verticalSign: verticalSign,
      horizontalSign: horizontalSign,
      lineConstants: lineConstants,
      line: [getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)]
    };
  });
}

function isBoundRotate$1(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line) {
    var centerSign = hitTestLine(center, line) <= 0;
    return !isSameStartLine(boundDots, line, centerSign);
  });
}

function getDistPointLine(_a) {
  // x = 0, y = 0
  // d = (ax + by + c) / root(a2 + b2)
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return Math.abs(pos1[0]);
  }

  if (!dy) {
    return Math.abs(pos1[1]);
  } // y - y1 = a(x - x1)
  // 0 = ax -y + -a * x1 + y1


  var a = dy / dx;
  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));
}

function solveReverseLine(_a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return [pos1[0], 0];
  }

  if (!dy) {
    return [0, pos1[1]];
  }

  var a = dy / dx; // y - y1 = a (x  - x1)
  // y = ax - a * x1 + y1

  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x
  // x = -b / (a + 1 / a)
  // y = b / (1 + 1 / a^2)

  return [-b / (a + 1 / a), b / (a * a + 1)];
}

function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;

  if (!bounds) {
    return [];
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);

  if (!isBoundRotate$1(nextPoses, dots, center, 0)) {
    return [];
  }

  var result = [];
  var dotInfos = dots.map(function (dot) {
    return [getDistSize(dot), getRad$1([0, 0], dot)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {
    var lineRad = getRad$1([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function (_a) {
      var dotDist = _a[0];
      return dotDist && lineDist <= dotDist;
    }).map(function (_a) {
      var dotDist = _a[0],
          dotRad = _a[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function (prev, cur) {
      prev.push.apply(prev, cur);
      return prev;
    }, []).filter(function (nextRad) {
      return !isBoundRotate$1(prevPoses, dots, center, nextRad);
    }).map(function (nextRad) {
      return throttle(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}

function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;

  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }

  var _a = moveable.getRect(),
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;

  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left,
      top = innerBounds.top,
      width = innerBounds.width,
      height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lineInfos.forEach(function (lineInfo) {
    var line = lineInfo.line,
        lineConstants = lineInfo.lineConstants;

    var _a = isStartLine(center, line),
        isHorizontalStart = _a.horizontal,
        isVerticalStart = _a.vertical; // test vertical


    var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true); // test horizontal

    var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);

    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }

    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }

    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }

    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}

function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a = bounds || {},
      _b = _a.position,
      position = _b === void 0 ? "client" : _b,
      _c = _a.left,
      left = _c === void 0 ? -Infinity : _c,
      _d = _a.top,
      top = _d === void 0 ? -Infinity : _d,
      _e = _a.right,
      right = _e === void 0 ? Infinity : _e,
      _f = _a.bottom,
      bottom = _f === void 0 ? Infinity : _f;

  var nextBounds = {
    position: position,
    left: left,
    top: top,
    right: right,
    bottom: bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}

function getBounds(moveable, externalBounds) {
  var _a = moveable.state,
      _b = _a.containerClientRect,
      containerHeight = _b.clientHeight,
      containerWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop,
      _c = _a.snapOffset,
      snapOffsetLeft = _c.left,
      snapOffsetTop = _c.top,
      snapOffsetRight = _c.right,
      snapOffsetBottom = _c.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position = bounds.position || "client";
  var isCSS = position === "css";
  var _d = bounds.left,
      left = _d === void 0 ? -Infinity : _d,
      _e = bounds.top,
      top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right,
      right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f,
      _g = bounds.bottom,
      bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;

  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }

  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}

function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var endX = endPos[0],
      endY = endPos[1];

  var _b = minus(endPos, startPos),
      dx = _b[0],
      dy = _b[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isBound = false;

    if (isRight && right <= endX) {
      y = a * right + b;
      x = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y = a * left + b;
      x = left;
      isBound = true;
    }

    if (isBound) {
      if (y < top || y > bottom) {
        isBound = false;
      }
    }

    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y = bottom;
        x = (y - b) / a;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y = top;
        x = (y - b) / a;
        isBound = true;
      }
    }

    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkBounds(bounds, poses, isVertical) {
  // 0   [100 - 200]  300
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"]; // 450

  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];

  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }

  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }

  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }

  return boundInfos.sort(function (a, b) {
    return Math.abs(b.offset) - Math.abs(a.offset);
  });
}

function isBoundRotate(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function (pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}

function boundRotate(vec, boundPos, index) {
  var r = getDistSize(vec);
  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function (a, b) {
    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);
  }).map(function (pos) {
    return getRad$1([0, 0], index ? [pos, boundPos] : [boundPos, pos]);
  });
}

function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }

  var rad = rotation * Math.PI / 180;

  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };

  if (!isBoundRotate(nextPoses, boundRect, 0)) {
    return [];
  }

  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a) {
    var boundPos = _a[0],
        index = _a[1];
    nextPoses.forEach(function (nextPos) {
      var relativeRad1 = getRad$1([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function (nextRad) {
        return !isBoundRotate(prevPoses, boundRect, nextRad);
      }).map(function (nextRad) {
        return throttle(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}

function renderGuideline(info, React) {
  var _a;

  var direction = info.direction,
      classNames = info.classNames,
      size = info.size,
      pos = info.pos,
      zoom = info.zoom,
      key = info.key;
  var isHorizontal = direction === "horizontal";
  var scaleType = isHorizontal ? "Y" : "X"; // const scaleType2 = isHorizontal ? "Y" : "X";

  return React.createElement("div", {
    key: key,
    className: classNames.join(" "),
    style: (_a = {}, _a[isHorizontal ? "width" : "height"] = "".concat(size), _a.transform = "translate(".concat(pos[0], ", ").concat(pos[1], ") translate").concat(scaleType, "(-50%) scale").concat(scaleType, "(").concat(zoom, ")"), _a)
  });
}

function renderInnerGuideline(info, React) {
  return renderGuideline(__assign$2(__assign$2({}, info), {
    classNames: __spreadArray([prefix("line", "guideline", info.direction)], info.classNames, true).filter(function (className) {
      return className;
    }),
    size: info.size || "".concat(info.sizeValue, "px"),
    pos: info.pos || info.posValue.map(function (v) {
      return "".concat(throttle(v, 0.1), "px");
    })
  }), React);
}

function renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function (_a, i) {
    var type = _a.type,
        pos = _a.pos;
    var renderPos = [0, 0];
    renderPos[index] = minPos;
    renderPos[index ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: "".concat(direction, "TargetGuideline").concat(i),
      classNames: [prefix("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom,
      direction: direction
    }, React);
  });
}

function renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {
  var _a = moveable.props,
      zoom = _a.zoom,
      isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;
  var mainNames = type === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[mainNames.start];
  var targetEnd = targetRect[mainNames.end];
  return guidelines.filter(function (_a) {
    var hide = _a.hide,
        elementRect = _a.elementRect;

    if (hide) {
      return false;
    }

    if (isDisplayInnerSnapDigit && elementRect) {
      // inner
      var rect = elementRect.rect;

      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {
        return false;
      }
    }

    return true;
  }).map(function (guideline, i) {
    var pos = guideline.pos,
        size = guideline.size,
        element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: "".concat(type, "-default-guideline-").concat(i),
      classNames: element ? [prefix("bold")] : [],
      direction: type,
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom
    }, React);
  });
}

function renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {
  var _a;

  var _b = moveable.props,
      _c = _b.snapDigit,
      snapDigit = _c === void 0 ? 0 : _c,
      _d = _b.isDisplaySnapDigit,
      isDisplaySnapDigit = _d === void 0 ? true : _d,
      _e = _b.snapDistFormat,
      snapDistFormat = _e === void 0 ? function (v, type) {
    // Type can be used render different values.
    if (type === 'vertical') {
      return v;
    }

    return v;
  } : _e,
      zoom = _b.zoom;
  var scaleType = type === "horizontal" ? "X" : "Y";
  var sizeName = type === "vertical" ? "height" : "width";
  var absGap = Math.abs(gap);
  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
  return React.createElement("div", {
    key: "".concat(type, "-").concat(lineType, "-guideline-").concat(index),
    className: prefix("guideline-group", type),
    style: (_a = {
      left: "".concat(renderPos[0], "px"),
      top: "".concat(renderPos[1], "px")
    }, _a[sizeName] = "".concat(absGap, "px"), _a)
  }, renderInnerGuideline({
    direction: type,
    classNames: [prefix(lineType), className],
    size: "100%",
    posValue: [0, 0],
    sizeValue: absGap,
    zoom: zoom
  }, React), React.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(scaleType, "(-50%) scale(").concat(zoom, ")")
    }
  }, snapSize > 0 ? snapDistFormat(snapSize, type) : ""));
}

function groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {
  var index = type === "vertical" ? 0 : 1;
  var otherIndex = type === "vertical" ? 1 : 0;
  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[names.start];
  var targetEnd = targetRect[names.end];
  return groupBy(guidelines, function (guideline) {
    return guideline.pos[index];
  }).map(function (nextGuidelines) {
    var start = [];
    var end = [];
    var inner = [];
    nextGuidelines.forEach(function (guideline) {
      var _a, _b;

      var element = guideline.element;
      var rect = guideline.elementRect.rect;

      if (rect[names.end] < targetStart) {
        start.push(guideline);
      } else if (targetEnd < rect[names.start]) {
        end.push(guideline);
      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {
        var pos = guideline.pos;
        var elementRect1 = {
          element: element,
          rect: __assign$2(__assign$2({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a))
        };
        var elementRect2 = {
          element: element,
          rect: __assign$2(__assign$2({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b))
        };
        var nextPos1 = [0, 0];
        var nextPos2 = [0, 0];
        nextPos1[index] = pos[index];
        nextPos1[otherIndex] = pos[otherIndex];
        nextPos2[index] = pos[index];
        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;
        start.push({
          type: type,
          pos: nextPos1,
          size: 0,
          elementRect: elementRect1
        });
        end.push({
          type: type,
          pos: nextPos2,
          size: 0,
          elementRect: elementRect2
        }); // inner.push(guideline);
      }
    });
    start.sort(function (a, b) {
      return b.pos[otherIndex] - a.pos[otherIndex];
    });
    end.sort(function (a, b) {
      return a.pos[otherIndex] - b.pos[otherIndex];
    });
    return {
      total: nextGuidelines,
      start: start,
      end: end,
      inner: inner
    };
  });
}

function renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var rendered = [];
  ["vertical", "horizontal"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 1 : 0;
    var otherIndex = index ? 0 : 1;
    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    groups.forEach(function (_a) {
      var total = _a.total,
          start = _a.start,
          end = _a.end,
          inner = _a.inner;
      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];
      var prevRect = targetRect;
      start.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = prevRect[mainNames.start] - nextRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      prevRect = targetRect;
      end.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = nextRect[mainNames.start] - prevRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      inner.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size1 = targetStart - nextRect[mainNames.start];
        var size2 = nextRect[mainNames.end] - targetEnd;
        var renderPos1 = [0, 0];
        var renderPos2 = [0, 0];
        renderPos1[index] = targetPos[index] - size1;
        renderPos1[otherIndex] = sidePos;
        renderPos2[index] = targetPos[index] + targetEnd - targetStart;
        renderPos2[otherIndex] = sidePos;
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size1, renderPos1, guideline.className, React));
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size2, renderPos2, guideline.className, React));
      });
    });
  });
  return rendered;
}

function renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var rendered = [];
  ["horizontal", "vertical"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 0 : 1;
    var otherIndex = index ? 0 : 1;
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetSideStart = targetRect[sideNames.start];
    var targetSideEnd = targetRect[sideNames.end];
    nextGuidelines.forEach(function (_a) {
      var gap = _a.gap,
          gapRects = _a.gapRects,
          className = _a.className;
      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.start];
      }), false));
      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.end];
      }), false));
      var sideCenterPos = (sideStartPos + sideEndPos) / 2;

      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {
        return;
      }

      gapRects.forEach(function (_a) {
        var rect = _a.rect;
        var renderPos = [targetPos[0], targetPos[1]];

        if (rect[mainNames.end] < targetStart) {
          renderPos[index] += rect[mainNames.end] - targetStart;
        } else if (targetEnd < rect[mainNames.start]) {
          renderPos[index] += rect[mainNames.start] - targetStart - gap;
        } else {
          return;
        }

        renderPos[otherIndex] += sideCenterPos - targetSideStart;
        rendered.push(renderDigitLine(moveable, index ? "vertical" : "horizontal", "gap", rendered.length, gap, renderPos, className, React));
      });
    });
  });
  return rendered;
}

function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < TINY_NUM$1) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM$1) {
    dy = 0;
  }

  if (!dx) {
    // y = 0 * x + b
    // only horizontal
    if (!isVertical) {
      return [0, snapOffset];
    }

    return [0, 0];
  }

  if (!dy) {
    // only vertical
    if (isVertical) {
      return [snapOffset, 0];
    }

    return [0, 0];
  } // y = ax + b


  var a = dy / dx;
  var b = pos1[1] - a * pos1[0];

  if (isVertical) {
    // y = a * x + b
    var y = a * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    // x = (y - b) / a
    var x = (pos2[1] + snapOffset - b) / a;
    return [x - pos2[0], snapOffset];
  }
}

function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);

  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }

  var size = getDist$2(pos1, pos2);
  var dist1 = getDist$2(sizeOffset, pos1);
  var dist2 = getDist$2(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;

  var _a = getDragDist({
    datas: datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }),
      widthOffset = _a[0],
      heightOffset = _a[1];

  return {
    offset: [widthOffset, heightOffset],
    isOutside: isOutside
  };
}

function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }

  return 0;
}

function checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {
  var distX = _a[0],
      distY = _a[1];
  var isVerticalBound = _b[0],
      isHorizontalBound = _b[1];
  var isVerticalSnap = _c[0],
      isHorizontalSnap = _c[1];
  var verticalOffset = _d[0],
      horizontalOffset = _d[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;

  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];

    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }

    if (adjustPoses.length) {
      adjustPoses.sort(function (a, b) {
        return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));
      });
      var adjustPos = adjustPoses[0];

      if (adjustPos[0] && Math.abs(distX) > TINY_NUM$1) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM$1) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }

      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > TINY_NUM$1 && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > TINY_NUM$1 && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }

  return [offsetX, offsetY];
}

function checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }

  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);

  var _a = getRect(poses),
      left = _a.left,
      right = _a.right,
      top = _a.top,
      bottom = _a.bottom;

  var boundPoses = {
    horizontal: poses.map(function (pos) {
      return pos[1];
    }),
    vertical: poses.map(function (pos) {
      return pos[0];
    })
  };
  var snapDirections = getSnapDirections(moveable.props.snapDirections);
  var snapPoses = splitSnapDirectionPoses(snapDirections, {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  });

  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses),
      verticalSnapBoundInfo = _b.vertical,
      horizontalSnapBoundInfo = _b.horizontal;

  var _c = getInnerBoundDragInfo(moveable, poses, datas),
      verticalInnerBoundInfo = _c.vertical,
      horizontalInnerBoundInfo = _c.horizontal;

  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);

  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),
      offsetX = _d[0],
      offsetY = _d[1];

  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}

function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }

  var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {
  var _a = checkBoundPoses(bounds, posesX, posesY),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical; // options.isRequest ? {
  //     horizontal: { isSnap: false, index: -1 } as SnapInfo,
  //     vertical: { isSnap: false, index: -1 } as SnapInfo,
  // } :


  var _b = checkSnapPoses(guideines, posesX, posesY, snapThreshold),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = getRad$1(startPos, endPos) / Math.PI * 180;
  var _a = snapBoundInfo.vertical,
      isVerticalBound = _a.isBound,
      isVerticalSnap = _a.isSnap,
      verticalDist = _a.dist,
      _b = snapBoundInfo.horizontal,
      isHorizontalBound = _b.isBound,
      isHorizontalSnap = _b.isSnap,
      horizontalDist = _b.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;

  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }

  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }

  return "";
}

function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function (_a) {
    var startDirection = _a[0],
        endDirection = _a[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {
      vertical: [otherEndPos[0]],
      horizontal: [otherEndPos[1]]
    });
    var _b = snapBoundInfo.horizontal,
        // dist: otherHorizontalDist,
    otherHorizontalOffset = _b.offset,
        isOtherHorizontalBound = _b.isBound,
        isOtherHorizontalSnap = _b.isSnap,
        _c = snapBoundInfo.vertical,
        // dist: otherVerticalDist,
    otherVerticalOffset = _c.offset,
        isOtherVerticalBound = _c.isBound,
        isOtherVerticalSnap = _c.isSnap;
    var multiple = minus(endDirection, startDirection);

    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }

    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);

    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }

    var isVertical = snapLine === "vertical";
    var sizeOffset = [0, 0];

    if (!keepRatio && Math.abs(endDirection[0]) === 1 && Math.abs(endDirection[1]) === 1 && startDirection[0] !== endDirection[0] && startDirection[1] !== endDirection[1]) {
      sizeOffset = getDragDist({
        datas: datas,
        distX: -otherVerticalOffset,
        distY: -otherHorizontalOffset
      });
    } else {
      sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset;
    }

    sizeOffset = sizeOffset.map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}

function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }

  return 0;
}

function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a = checkBoundKeepRatio(moveable, startPos, endPos),
      horizontalBoundInfo = _a.horizontal,
      verticalBoundInfo = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}

function checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {
  var fixedDirection = [-direction[0], -direction[1]];
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;

  if (bounds) {
    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];
    var _b = bounds.left,
        left_1 = _b === void 0 ? -Infinity : _b,
        _c = bounds.top,
        top_1 = _c === void 0 ? -Infinity : _c,
        _d = bounds.right,
        right_1 = _d === void 0 ? Infinity : _d,
        _e = bounds.bottom,
        bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function (otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg = getRad$1(fixedPosition, otherPos) * 360 / Math.PI;

      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }

        var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),
            _b = _a.offset,
            heightOffset = _b[1],
            isHeightOutside = _a.isOutside;

        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }

      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }

        var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas),
            widthOffset = _c.offset[0],
            isWidthOutside = _c.isOutside;

        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }

  return {
    maxWidth: maxWidth,
    maxHeight: maxHeight
  };
}

function snapStart(moveable) {
  var state = moveable.state;

  if (state.guidelines && state.guidelines.length) {
    return;
  }

  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };

  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);

    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = throttle(offset1[0], 0.1);
      snapOffset.top = throttle(offset1[1], 0.1);
      snapOffset.right = throttle(offset2[0], 0.1);
      snapOffset.bottom = throttle(offset2[1], 0.1);
    }
  }

  state.snapOffset = snapOffset;
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}

function getNextFixedPoses(matrix, width, height, fixedDirection, fixedPos, is3d) {
  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);
  var nextFixedPos = getPosByDirection(nextPoses, fixedDirection);
  return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));
}

function getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {
  var fixedDirection = datas.fixedDirection;
  var directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);
  var innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);

  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas), true), getInnerBoundInfo(moveable, innerBoundLineInfos, datas), true);

  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}

function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction);

  var _a = checkMoveableSnapBounds(moveable, isRequest, {
    vertical: [snapPos[0]],
    horizontal: [snapPos[1]]
  }),
      horizontalOffset = _a.horizontal.offset,
      verticalOffset = _a.vertical.offset;

  if (verticalOffset || horizontalOffset) {
    var _b = getDragDist({
      datas: datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }),
        nextWidthOffset = _b[0],
        nextHeightOffset = _b[1];

    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }

  return [0, 0];
}

function checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;

  for (var i = 0; i < 2; ++i) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);

    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),
        widthOffsetInfo = _a.width,
        heightOffsetInfo = _a.height;

    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;

    if (i === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }

      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }

    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }

    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;

      if (isGetWidthOffset) {
        // width : height = ? : heightOffset
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        // width : height = widthOffset : ?
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  if (direction[0] && direction[1]) {
    var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas),
        maxWidth = _b.maxWidth,
        maxHeight = _b.maxHeight;

    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) {
      return pos.map(function (p) {
        return throttle(p, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),
        nextWidthOffset = _c[0],
        nextHeightOffset = _c[1];

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  return [widthOffset, heightOffset];
}

function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }

  var pos1 = rect.pos1,
      pos2 = rect.pos2,
      pos3 = rect.pos3,
      pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {
    return minus(pos, origin);
  });
  var nextPoses = prevPoses.map(function (pos) {
    return rotate(pos, rad);
  });

  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation), true), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation), true);

  result.sort(function (a, b) {
    return Math.abs(a - rotation) - Math.abs(b - rotation);
  });

  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}

function checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }

  var fixedDirection = datas.fixedDirection;
  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  return checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedDirection, fixedPosition, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
}

function checkSnapScale(moveable, scale, direction, isRequest, datas) {
  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }

  var startOffsetWidth = datas.startOffsetWidth,
      startOffsetHeight = datas.startOffsetHeight,
      fixedPosition = datas.fixedPosition,
      fixedDirection = datas.fixedDirection,
      is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight])), startOffsetWidth, startOffsetHeight, fixedDirection, fixedPosition, is3d);
  }, startOffsetWidth, startOffsetHeight, direction, fixedPosition, isRequest, datas);
  return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];
}

function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}

function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function (posInfo) {
    posInfo.guidelineInfos.forEach(function (_a) {
      var guideline = _a.guideline;

      if (guidelines.indexOf(guideline) > -1) {
        return;
      }

      guidelines.push(guideline);
    });
  });
  return guidelines;
}

function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses),
      verticalBoundInfos = _a.vertical,
      horizontalBoundInfos = _a.horizontal;

  verticalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });

  var _b = checkInnerBoundPoses(moveable),
      verticalInnerBoundPoses = _b.vertical,
      horizontalInnerBoundPoses = _b.horizontal;

  verticalInnerBoundPoses.forEach(function (innerPos) {
    if (findIndex(verticalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function (innerPos) {
    if (findIndex(horizontalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
/**
 * @namespace Moveable.Snappable
 * @description Whether or not target can be snapped to the guideline. (default: false)
 * @sort 2
 */


var Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function (moveable, React) {
    var state = moveable.state;
    var targetTop = state.top,
        targetLeft = state.left,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        snapRenderInfo = state.snapRenderInfo;

    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }

    state.guidelines = getTotalGuidelines(moveable);
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];

    var _a = getRect(poses),
        width = _a.width,
        height = _a.height,
        top = _a.top,
        left = _a.left,
        bottom = _a.bottom,
        right = _a.right;

    var targetRect = {
      left: left,
      right: right,
      top: top,
      bottom: bottom,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    };
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};

    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }

      if (snapRenderInfo.snap) {
        var rect = getRect(poses);

        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, rect, 1));
      }

      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, externalRect, 1));
      }

      snapInfos.forEach(function (snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos,
            horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }

    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);

    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }

    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines, true), horizontalGuidelines, true);

    var elementGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.element && !guideline.gapRects;
    });
    var gapGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.gapRects;
    });
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function (_a) {
        var element = _a.element;
        return !element;
      }),
      elements: elementGuidelines,
      gaps: gapGuidelines
    }, true);
    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React), true), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React), true), renderGuidelines(moveable, "horizontal", horizontalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderGuidelines(moveable, "vertical", verticalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React), true), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React), true);
  },
  dragStart: function (moveable, e) {
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function (moveable) {
    var state = moveable.state;
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function (moveable) {
    this.unset(moveable);
  },
  dragEnd: function (moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function (moveable, e) {
    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {
      return true;
    }

    if (!e.isRequest && e.inputEvent) {
      return hasClass(e.inputEvent.target, prefix("snap-control"));
    }
  },
  dragControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function (moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function (moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function (moveable) {
    this.unset(moveable);
  },
  unset: function (moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapRenderInfo = null;
    state.elementRects = [];
  }
};
/**
 * Whether or not target can be snapped to the guideline. (default: false)
 * @name Moveable.Snappable#snappable
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snappable = true;
 */

/**
 *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)
 * @name Moveable.Snappable#snapContainer
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.querySelector(".container"));
 *
 * moveable.snapContainer = document.body;
 */

/**
 * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#snapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapDirections: true,
 * });
 * // snap center
 * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#elementSnapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   elementSnapDirections: true,
 * });
 * // snap center
 * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * When you drag, make the gap snap in the element guidelines. (default: true)
 * @name Moveable.Snappable#snapGap
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapElement: true,
 *   snapGap: true,
 * });
 *
 * moveable.snapGap = false;
 */

/**
 * Distance value that can snap to guidelines. (default: 5)
 * @name Moveable.Snappable#snapThreshold
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapThreshold = 5;
 */

/**
 * Add guidelines in the horizontal direction. (default: [])
 * @name Moveable.Snappable#horizontalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.horizontalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines in the vertical direction. (default: [])
 * @name Moveable.Snappable#verticalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.verticalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines for the element. (default: [])
 * @name Moveable.Snappable#elementGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.elementGuidelines = [
 *   document.querySelector(".element"),
 * ];
 */

/**
 * You can set up boundaries.
 * @name Moveable.Snappable#bounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};
 */

/**
 * You can set up inner boundaries.
 * @name Moveable.Snappable#innerBounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};
 */

/**
 * snap distance digits (default: 0)
 * @name Moveable.Snappable#snapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapDigit = 0
 */

/**
 * If width size is greater than 0, you can vertical snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridWidth
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridWidth = 5;
 */

/**
 * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridHeight
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridHeight = 5;
 */

/**
 * Whether to show snap distance (default: true)
 * @name Moveable.Snappable#isDisplaySnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplaySnapDigit = true;
 */

/**
 * Whether to show element inner snap distance (default: false)
 * @name Moveable.Snappable#isDisplayInnerSnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplayInnerSnapDigit = true;
 */

/**
 * You can set the text format of the distance shown in the guidelines. (default: self)
 * @name Moveable.Snappable#snapDistFormat
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  snappable: true,
 *  snapDistFormat: (v, type) => v,
 * });
 * moveable.snapDistFormat = (v, type) => `${v}px`;
 */

/**
 * When you drag or dragControl, the `snap` event is called.
 * @memberof Moveable.Snappable
 * @event snap
 * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     snappable: true
 * });
 * moveable.on("snap", e => {
 *     console.log("onSnap", e);
 * });
 */

/**
 * @namespace Draggable
 * @memberof Moveable
 * @description Draggable refers to the ability to drag and move targets.
 */

var Draggable$1 = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        throttleDragRotate = _a.throttleDragRotate,
        zoom = _a.zoom;
    var _b = moveable.state,
        dragInfo = _b.dragInfo,
        beforeOrigin = _b.beforeOrigin;

    if (!throttleDragRotate || !dragInfo) {
      return [];
    }

    var dist = dragInfo.dist;

    if (!dist[0] && !dist[1]) {
      return [];
    }

    var width = getDistSize(dist);
    var rad = getRad$1(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat(width, "px"),
        transform: "translate(".concat(beforeOrigin[0], "px, ").concat(beforeOrigin[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")")
      }
    })];
  },
  dragStart: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentGesto = e.parentGesto;
    var state = moveable.state;
    var target = state.target,
        gesto = state.gesto;

    if (gesto) {
      return false;
    }

    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle$1(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    datas.deltaOffset = [0, 0];
    var params = fillParams(moveable, e, __assign$2({
      set: function (translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);

    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }

    return datas.isDrag ? params : false;
  },
  drag: function (moveable, e) {
    if (!e) {
      return;
    }

    resolveTransformEvent(e, "translate");
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest,
        deltaOffset = e.deltaOffset;
    var distX = e.distX,
        distY = e.distY;
    var isDrag = datas.isDrag,
        prevDist = datas.prevDist,
        prevBeforeDist = datas.prevBeforeDist,
        startValue = datas.startValue;

    if (!isDrag) {
      return;
    }

    if (deltaOffset) {
      distX += deltaOffset[0];
      distY += deltaOffset[1];
    }

    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;

    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props.startDragRotate || 0;
      var deg = throttle(startDragRotate + getRad$1([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));
      var r = getDistSize([rx, ry]);
      dragRotateRad = deg * Math.PI / 180;
      distX = r * Math.cos(dragRotateRad);
      distY = r * Math.sin(dragRotateRad);
    }

    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest || deltaOffset, datas),
          verticalInfo = _a[0],
          horizontalInfo = _a[1];

      var isVerticalSnap = verticalInfo.isSnap,
          isVerticalBound = verticalInfo.isBound,
          verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap,
          isHorizontalBound = horizontalInfo.isBound,
          horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }

    var beforeTranslate = plus(getBeforeDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);
    var translate = plus(getTransformDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);

    if (!throttleDragRotate && !isSnap) {
      throttleArray(translate, throttleDrag);
      throttleArray(beforeTranslate, throttleDrag);
    }

    var beforeDist = minus(beforeTranslate, startValue);
    var dist = minus(translate, startValue);
    var delta = minus(dist, prevDist);
    var beforeDelta = minus(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    datas.passDelta = delta; //distX - (datas.passDistX || 0);
    // datas.passDeltaY = distY - (datas.passDistY || 0);

    datas.passDist = dist; //distX;
    // datas.passDistY = distY;

    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(".concat(translate[0], "px, ").concat(translate[1], "px)"), "translate(".concat(dist[0], "px, ").concat(dist[1], "px)"));
    fillOriginalTransform(e, nextTransform);
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;

    if (!parentEvent && !parentMoveable && delta.every(function (num) {
      return !num;
    }) && beforeDelta.some(function (num) {
      return !num;
    })) {
      return;
    }

    var _b = moveable.state,
        width = _b.width,
        height = _b.height;
    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist: dist,
      delta: delta,
      translate: translate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeTranslate: beforeTranslate,
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      width: width,
      height: height,
      isPinch: isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragAfter: function (moveable, e) {
    var datas = e.datas;
    var deltaOffset = datas.deltaOffset;

    if (deltaOffset[0] || deltaOffset[1]) {
      datas.deltaOffset = [0, 0];
      return this.drag(moveable, __assign$2(__assign$2({}, e), {
        deltaOffset: deltaOffset
      }));
    }

    return false;
  },
  dragEnd: function (moveable, e) {
    var parentEvent = e.parentEvent,
        datas = e.datas;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;

    if (!datas.isDrag) {
      return;
    }

    datas.isDrag = false;
    var param = fillEndParams(moveable, e, {});
    !parentEvent && triggerEvent(moveable, "onDragEnd", param);
    return param;
  },
  dragGroupStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY;
    var params = this.dragStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e, false);

    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    var params = this.drag(moveable, e);
    var passDelta = e.datas.passDelta;
    var events = triggerChildGesto(moveable, this, "drag", passDelta, e, false);

    if (!params) {
      return;
    }

    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    this.dragEnd(moveable, e);
    var events = triggerChildGesto(moveable, this, "dragEnd", [0, 0], e, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    }));
    return isDrag;
  },

  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("x" in e) {
          distX = e.x - rect.left;
        } else if ("deltaX" in e) {
          distX += e.deltaX;
        }

        if ("y" in e) {
          distY = e.y - rect.top;
        } else if ("deltaY" in e) {
          distY += e.deltaY;
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  },
  unset: function (moveable) {
    moveable.state.dragInfo = null;
  }
};
/**
 * Whether or not target can be dragged. (default: false)
 * @name Moveable.Draggable#draggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.draggable = true;
 */

/**
 * throttle of x, y when drag.
 * @name Moveable.Draggable#throttleDrag
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleDrag = 1;
 */

/**
* throttle of angle of x, y when drag.
* @name Moveable.Draggable#throttleDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* moveable.throttleDragRotate = 45;
*/

/**
* start angle of throttleDragRotate of x, y when drag.
* @name Moveable.Draggable#startDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* // 45, 135, 225, 315
* moveable.throttleDragRotate = 90;
* moveable.startDragRotate = 45;
*/

/**
 * When the drag starts, the dragStart event is called.
 * @memberof Moveable.Draggable
 * @event dragStart
 * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When dragging, the drag event is called.
 * @memberof Moveable.Draggable
 * @event drag
 * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("drag", ({ target, transform }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the drag finishes, the dragEnd event is called.
 * @memberof Moveable.Draggable
 * @event dragEnd
 * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group drag starts, the `dragGroupStart` event is called.
* @memberof Moveable.Draggable
* @event dragGroupStart
* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroupStart", ({ targets }) => {
*     console.log("onDragGroupStart", targets);
* });
*/

/**
* When the group drag, the `dragGroup` event is called.
* @memberof Moveable.Draggable
* @event dragGroup
* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroup", ({ targets, events }) => {
*     console.log("onDragGroup", targets);
*     events.forEach(ev => {
*          // drag event
*          console.log("onDrag left, top", ev.left, ev.top);
*          // ev.target!.style.left = `${ev.left}px`;
*          // ev.target!.style.top = `${ev.top}px`;
*          console.log("onDrag translate", ev.dist);
*          ev.target!.style.transform = ev.transform;)
*     });
* });
*/

/**
 * When the group drag finishes, the `dragGroupEnd` event is called.
 * @memberof Moveable.Draggable
 * @event dragGroupEnd
 * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     draggable: true
 * });
 * moveable.on("dragGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onDragGroupEnd", targets, isDrag);
 * });
 */

function calculatePointerDist(moveable, e) {
  var clientX = e.clientX,
      clientY = e.clientY,
      datas = e.datas;
  var _a = moveable.state,
      moveableClientRect = _a.moveableClientRect,
      rootMatrix = _a.rootMatrix,
      is3d = _a.is3d,
      pos1 = _a.pos1;
  var left = moveableClientRect.left,
      top = moveableClientRect.top;
  var n = is3d ? 4 : 3;

  var _b = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),
      posX = _b[0],
      posY = _b[1];

  var _c = getDragDist({
    datas: datas,
    distX: posX,
    distY: posY
  }),
      distX = _c[0],
      distY = _c[1];

  return [distX, distY];
}

function setDragStart(moveable, _a) {
  var datas = _a.datas;
  var _b = moveable.state,
      allMatrix = _b.allMatrix,
      beforeMatrix = _b.beforeMatrix,
      is3d = _b.is3d,
      left = _b.left,
      top = _b.top,
      origin = _b.origin,
      offsetMatrix = _b.offsetMatrix,
      targetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = invert(allMatrix, n);
  datas.inverseBeforeMatrix = invert(beforeMatrix, n);
  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);
  datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);
}

function getTransformDirection(e) {
  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}

function resolveTransformEvent(event, functionName) {
  var datas = event.datas,
      originalDatas = event.originalDatas.beforeRenderable;
  var index = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = 0;

  if (index === -1) {
    nextIndex = nextTransforms.length;
    datas.transformIndex = nextIndex;
  } else {
    nextIndex = index + nextTransformAppendedIndexes.filter(function (i) {
      return i < index;
    }).length;
  }

  var result = convertTransformInfo(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;

  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes, true), [nextIndex], false);
  }
}

function convertTransformFormat(datas, value, dist) {
  return "".concat(datas.beforeFunctionTexts.join(" "), " ").concat(datas.isAppendTransform ? dist : value, " ").concat(datas.afterFunctionTexts.join(" "));
}

function getTransformDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;

  var _b = getBeforeDragDist({
    datas: datas,
    distX: distX,
    distY: distY
  }),
      bx = _b[0],
      by = _b[1]; // B * [tx, ty] * A = [bx, by] * targetMatrix;
  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];


  var res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));
  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);
}

function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform,
      beforeTransform2 = datas.beforeTransform2,
      afterTransform2 = datas.afterTransform2,
      targetAllTransform = datas.targetAllTransform; // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)
  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1
  // nextTargetMatrix = (targetMatrix * targetAllTransform)

  var nextTargetMatrix = isAfter ? multiply(targetAllTransform, targetMatrix, 4) : multiply(targetMatrix, targetAllTransform, 4); // res1 = B-1 * nextTargetMatrix

  var res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4); // res3 = res2 * A-1

  var afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}

function getBeforeDragDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY; // TT = BT

  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3; // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])
  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]

  return minus(calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}

function getDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      inverseMatrix = datas.inverseMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}

function getInverseDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var beforeMatrix = datas.beforeMatrix,
      matrix = datas.matrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}

function calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }

  if (prevHeight === void 0) {
    prevHeight = height;
  }

  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }

  if (!transformOrigin) {
    return prevOrigin;
  }

  return transformOrigin.map(function (pos, i) {
    var _a = splitUnit(pos),
        value = _a.value,
        unit = _a.unit;

    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;

    if (pos === "%" || isNaN(value)) {
      // no value but %
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }

    return size * value / 100;
  });
}

function getPosIndexesByDirection(direction) {
  var indexes = [];

  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }

    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }

  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }

    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }

  return indexes;
}

function getPosesByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  return getPosIndexesByDirection(direction).map(function (index) {
    return poses[index];
  });
}

function getPosByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  var nextPoses = getPosesByDirection(poses, direction);
  return [average(nextPoses.map(function (pos) {
    return pos[0];
  })), average(nextPoses.map(function (pos) {
    return pos[1];
  }))];
}

function getDist(startPos, matrix, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}

function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}

function getNextTransformMatrix(state, datas, transform) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d;
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = parseMat([transform]);
  return getNextMatrix(offsetMatrix, convertDimension(multiply(multiply(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);
}

function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d,
      targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);
}

function fillTransformStartEvent(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return {
    setTransform: function (transform, index) {
      if (index === void 0) {
        index = -1;
      }

      originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);
      setTransformIndex(e, index);
    },
    setTransformIndex: function (index) {
      setTransformIndex(e, index);
    }
  };
}

function setDefaultTransformIndex(e, property) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e, findIndex(startTransforms, function (func) {
    return func.indexOf("".concat(property, "(")) === 0;
  }));
}

function setTransformIndex(e, index) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var datas = e.datas;
  datas.transformIndex = index;

  if (index === -1) {
    return;
  }

  var transform = originalDatas.startTransforms[index];

  if (!transform) {
    return;
  }

  var info = parse([transform]);
  datas.startValue = info[0].functionValue;
}

function fillOriginalTransform(e, transform) {
  var originalDatas = e.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = splitSpace(transform);
}

function getNextTransformText(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return originalDatas.nextTransforms.join(" ");
}

function fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {
  fillOriginalTransform(e, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable$1.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))
  };
}

function getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left,
      top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = minus(fixedPosition, nextFixedPosition);
  return minus(dist, [groupLeft, groupTop]);
}

function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  var dist = getTranslateDist(moveable, "scale(".concat(scaleDist.join(", "), ")"), fixedDirection, fixedPosition, datas);
  return dist;
}

function getOriginDirection(moveable) {
  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      transformOrigin = _a.transformOrigin;
  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];
}

function getDirectionOffset(moveable, direction, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      is3d = _a.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}

function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(".concat(rotateDist, "deg)"), fixedDirection, fixedPosition, datas);
}

function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a = moveable.state,
      prevOrigin = _a.transformOrigin,
      targetMatrix = _a.targetMatrix,
      offsetMatrix = _a.offsetMatrix,
      is3d = _a.is3d,
      prevWidth = _a.width,
      prevHeight = _a.height,
      left = _a.left,
      top = _a.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return minus(dist, [groupLeft, groupTop]);
}

function getAbsolutePosition(moveable, direction) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);
}

function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}

function prefix() {
  var classNames = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }

  return prefixNames.apply(void 0, __spreadArray([PREFIX], classNames, false));
}

function defaultSync(fn) {
  fn();
}

function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }

  if (isObject(transform)) {
    return transform;
  }

  return parseMat(transform);
}

function getAbsoluteMatrix(matrix, n, origin) {
  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function (a) {
    return -a;
  }), n));
}

function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }

  return 1;
}

function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle$1(el, ":before"));
  return relativeOrigin.map(function (o, i) {
    var _a = splitUnit(o),
        value = _a.value,
        unit = _a.unit;

    return value * measureSVGSize(el, unit, i === 0);
  });
}

function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}

function getElementTransform(target, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getComputedStyle$1(target);
  }

  var computedTransform = computedStyle.transform;

  if (computedTransform && computedTransform !== "none") {
    return computedStyle.transform;
  }

  if ("transform" in target) {
    var list = target.transform;
    var baseVal = list.baseVal;

    if (!baseVal) {
      return "";
    }

    var length = baseVal.length;

    if (!length) {
      return "";
    }

    var matrixes = [];

    var _loop_1 = function (i) {
      var matrix = baseVal[i].matrix;
      matrixes.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function (chr) {
        return matrix[chr];
      }).join(", "), ")"));
    };

    for (var i = 0; i < length; ++i) {
      _loop_1(i);
    }

    return matrixes.join(" ");
  }

  return "";
}

function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position = "relative";

  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }

    var style = getComputedStyle$1(target);
    var tagName = target.tagName.toLowerCase();
    var transform = getElementTransform(target, style);
    position = style.position;

    if (tagName === "svg" || position !== "static" || transform && transform !== "none") {
      break;
    }

    target = target.parentElement;
    position = "relative";
  }

  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}

function getOffsetPosInfo(el, style) {
  var _a;

  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop; // svg

  var isSVG = isUndefined(offsetLeft);
  var hasOffset = !isSVG;
  var origin;
  var targetOrigin; // inner svg element

  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];
  } else {
    origin = getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }

  return {
    tagName: tagName,
    isSVG: isSVG,
    hasOffset: hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin: origin,
    targetOrigin: targetOrigin
  };
}

function getBodyOffset(el, isSVG, style) {
  if (style === void 0) {
    style = getComputedStyle$1(el);
  }

  var bodyStyle = getComputedStyle$1(document.body);
  var bodyPosition = bodyStyle.position;

  if (!isSVG && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }

  var marginLeft = parseInt(bodyStyle.marginLeft, 10);
  var marginTop = parseInt(bodyStyle.marginTop, 10);

  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop = 0;
    }

    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft = 0;
    }
  }

  return [marginLeft, marginTop];
}

function convert3DMatrixes(matrixes) {
  matrixes.forEach(function (info) {
    var matrix = info.matrix;

    if (matrix) {
      info.matrix = convertDimension(matrix, 3, 4);
    }
  });
}

function getBodyScrollPos() {
  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];
}

function getPositionFixedInfo(el) {
  var fixedContainer = el.parentElement;
  var hasTransform = false;

  while (fixedContainer) {
    var transform = getComputedStyle$1(fixedContainer).transform;

    if (transform && transform !== "none") {
      hasTransform = true;
      break;
    }

    if (fixedContainer === document.body) {
      break;
    }

    fixedContainer = fixedContainer.parentElement;
  }

  return {
    fixedContainer: fixedContainer || document.body,
    hasTransform: hasTransform
  };
}

function getMatrixStackInfo(target, container, checkContainer) {
  var el = target;
  var matrixes = [];
  var requestEnd = !checkContainer && target === container || target === document.body;
  var isEnd = requestEnd;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetTransformOrigin;
  var targetMatrix;
  var hasFixed = false;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;

  while (el && !isEnd) {
    isEnd = requestEnd;
    var style = getComputedStyle$1(el);
    var position = style.position;
    var transform = getElementTransform(el, style);
    var matrix = convertCSStoMatrix(getTransformMatrix(transform));
    var isFixed = position === "fixed";
    var fixedInfo = {
      hasTransform: false,
      fixedContainer: null
    };

    if (isFixed) {
      hasFixed = true;
      fixedInfo = getPositionFixedInfo(el);
      offsetContainer = fixedInfo.fixedContainer;
    } // convert 3 to 4


    var length = matrix.length;

    if (!is3d && length === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);

      if (targetMatrix) {
        targetMatrix = convertDimension(targetMatrix, 3, 4);
      }
    }

    if (is3d && length === 9) {
      matrix = convertDimension(matrix, 3, 4);
    }

    var _a = getOffsetPosInfo(el, style),
        tagName = _a.tagName,
        hasOffset = _a.hasOffset,
        isSVG = _a.isSVG,
        origin = _a.origin,
        targetOrigin = _a.targetOrigin,
        offsetPos = _a.offset;

    var offsetLeft = offsetPos[0],
        offsetTop = offsetPos[1];

    if (tagName === "svg" && targetMatrix) {
      // scale matrix for svg's SVGElements.
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createIdentityMatrix(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }

    var offsetParent = void 0;
    var isOffsetEnd = false;
    var isStatic = false;

    if (isFixed) {
      offsetParent = fixedInfo.fixedContainer;
      isOffsetEnd = true;
    } else {
      var offsetInfo = getOffsetInfo(el, container);
      offsetParent = offsetInfo.offsetParent;
      isOffsetEnd = offsetInfo.isEnd;
      isStatic = offsetInfo.isStatic;
    }

    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === "relative" || position === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      requestEnd = requestEnd || isOffsetEnd;
    }

    var parentClientLeft = 0;
    var parentClientTop = 0;
    var fixedClientLeft = 0;
    var fixedClientTop = 0;

    if (isFixed) {
      if (hasOffset && fixedInfo.hasTransform) {
        // border
        fixedClientLeft = offsetParent.clientLeft;
        fixedClientTop = offsetParent.clientTop;
      }
    } else {
      if (hasOffset && offsetContainer !== offsetParent) {
        // border
        parentClientLeft = offsetParent.clientLeft;
        parentClientTop = offsetParent.clientTop;
      }

      if (hasOffset && offsetParent === document.body) {
        var margin = getBodyOffset(el, false, style);
        offsetLeft += margin[0];
        offsetTop += margin[1];
      }
    }

    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix, n, origin)
    });

    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createOriginMatrix([offsetLeft - el.scrollLeft + parentClientLeft - fixedClientLeft, offsetTop - el.scrollTop + parentClientTop - fixedClientTop], n)
      });
    } else {
      // svg
      matrixes.push({
        type: "offset",
        target: el,
        origin: origin
      });
    }

    if (!targetMatrix) {
      targetMatrix = matrix;
    }

    if (!transformOrigin) {
      transformOrigin = origin;
    }

    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }

    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      requestEnd = isOffsetEnd;
    }

    if (!checkContainer || el === document.body) {
      isEnd = requestEnd;
    }
  }

  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(n);
  }

  if (!transformOrigin) {
    transformOrigin = [0, 0];
  }

  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }

  return {
    offsetContainer: offsetContainer,
    matrixes: matrixes,
    targetMatrix: targetMatrix,
    transformOrigin: transformOrigin,
    targetOrigin: targetTransformOrigin,
    is3d: is3d,
    hasFixed: hasFixed
  };
}

function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};

  if (target) {
    var _a = getSize(target),
        offsetWidth = _a.offsetWidth,
        offsetHeight = _a.offsetHeight;

    width = offsetWidth;
    height = offsetHeight;
  }

  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign$2(__assign$2({}, result), position);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }

  var n = isAbsolute3d ? 4 : 3;
  return __assign$2({
    width: width,
    height: height,
    rotation: rotation,
    rootMatrix: createIdentityMatrix(n),
    beforeMatrix: createIdentityMatrix(n),
    offsetMatrix: createIdentityMatrix(n),
    allMatrix: createIdentityMatrix(n),
    targetMatrix: createIdentityMatrix(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: false
  }, allResult);
}

function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var _b = getMatrixStackInfo(target, container),
      matrixes = _b.matrixes,
      is3d = _b.is3d,
      prevTargetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin,
      targetOrigin = _b.targetOrigin,
      offsetContainer = _b.offsetContainer,
      hasFixed = _b.hasFixed; // prevMatrix


  var _c = getMatrixStackInfo(offsetContainer, rootContainer, true),
      rootMatrixes = _c.matrixes,
      isRoot3d = _c.is3d; // prevRootMatrix
  // if (rootContainer === document.body) {
  //     console.log(offsetContainer, rootContainer, rootMatrixes);
  // }


  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix; // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);
  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);
  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);

  var allMatrix = createIdentityMatrix(n);
  var rootMatrix = createIdentityMatrix(n);
  var beforeMatrix = createIdentityMatrix(n);
  var offsetMatrix = createIdentityMatrix(n);
  var length = matrixes.length;
  rootMatrixes.reverse();
  matrixes.reverse();

  if (!is3d && isNext3d) {
    targetMatrix = convertDimension(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }

  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)
  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container
  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)
  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)


  rootMatrixes.forEach(function (info) {
    rootMatrix = multiply(rootMatrix, info.matrix, n);
  });
  var originalRootContainer = rootContainer || document.body;
  var endContainer = ((_a = rootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function (matrix, info) {
    return multiply(matrix, info.matrix, n);
  }, createIdentityMatrix(n));
  matrixes.forEach(function (info, i) {
    if (length - 2 === i) {
      // length - 3
      beforeMatrix = allMatrix.slice();
    }

    if (length - 1 === i) {
      // length - 2
      offsetMatrix = allMatrix.slice();
    } // calculate for SVGElement


    if (!info.matrix) {
      var nextInfo = matrixes[i + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, multiply(rootMatrixBeforeOffset, allMatrix, n));
      info.matrix = createOriginMatrix(offset, n);
    }

    allMatrix = multiply(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;

  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);
  }

  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = ignoreDimension(rootMatrix, n, n);
  return {
    hasFixed: hasFixed,
    rootMatrix: rootMatrix,
    beforeMatrix: beforeMatrix,
    offsetMatrix: offsetMatrix,
    allMatrix: allMatrix,
    targetMatrix: targetMatrix,
    targetTransform: targetTransform,
    transformOrigin: transformOrigin,
    targetOrigin: targetOrigin,
    is3d: isNext3d
  };
}

function makeMatrixCSS(matrix, is3d) {
  if (is3d === void 0) {
    is3d = matrix.length > 9;
  }

  return "".concat(is3d ? "matrix3d" : "matrix", "(").concat(convertMatrixtoCSS(matrix, !is3d).join(","), ")");
}

function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;

  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: clientWidth,
      clientHeight: clientHeight
    };
  }

  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight
  };
}

function getSVGMatrix(el, n) {
  var _a = getSVGViewBox(el),
      viewBoxWidth = _a.width,
      viewBoxHeight = _a.height,
      clientWidth = _a.clientWidth,
      clientHeight = _a.clientHeight;

  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio

  var align = preserveAspectRatio.align; // 1 : meet 2: slice

  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];

  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }

  var scaleMatrix = createScaleMatrix(scale, n);
  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);
}

function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox || el.tagName.toLowerCase() === "g") {
    return [0, 0, 0, 0];
  }

  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}

function calculatePosition(matrix, pos, n) {
  return calculate(matrix, convertPositionMatrix(pos, n), n);
}

function calculatePoses(matrix, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {
    return calculatePosition(matrix, pos, n);
  });
}

function getRect(poses) {
  var posesX = poses.map(function (pos) {
    return pos[0];
  });
  var posesY = poses.map(function (pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: rectWidth,
    height: rectHeight
  };
}

function calculateRect(matrix, width, height, n) {
  var poses = calculatePoses(matrix, width, height, n);
  return getRect(poses);
}

function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a;

  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;

  var _b = getSize(target),
      width = _b.offsetWidth,
      height = _b.offsetHeight;

  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];

  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }

  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = multiplies(n, beforeMatrix, targetMatrix);

  var _c = calculateRect(mat, width, height, n),
      prevLeft = _c.left,
      prevTop = _c.top,
      prevWidth = _c.width,
      prevHeight = _c.height;

  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;

  while (++count < 10) {
    var inverseBeforeMatrix = invert(beforeMatrix, n);
    _a = minus(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];
    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), targetMatrix);

    var _d = calculateRect(mat2, width, height, n),
        nextLeft = _d.left,
        nextTop = _d.top;

    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;

    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }

    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }

  return offset.map(function (p) {
    return Math.round(p);
  });
}

function calculateMoveablePosition(matrix, origin, width, height) {
  var is3d = matrix.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix, width, height, n);
  var _a = poses[0],
      x1 = _a[0],
      y1 = _a[1],
      _b = poses[1],
      x2 = _b[0],
      y2 = _b[1],
      _c = poses[2],
      x3 = _c[0],
      y3 = _c[1],
      _d = poses[3],
      x4 = _d[0],
      y4 = _d[1];

  var _e = calculatePosition(matrix, origin, n),
      originX = _e[0],
      originY = _e[1];

  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction = getShapeDirection(poses);
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction: direction
  };
}

function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}

function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}

function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }

  if (rad === void 0) {
    rad = getRad$1(pos1, pos2);
  }

  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(".concat(pos1[0], "px, ").concat(pos1[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")"),
    width: "".concat(width, "px")
  };
}

function getControlTransform(rotation, zoom) {
  var poses = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }

  var length = poses.length;
  var x = poses.reduce(function (prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function (prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translateZ(0px) translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "rad) scale(").concat(zoom, ")")
  };
}

function getCSSSize(target) {
  var style = getComputedStyle$1(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}

function getSize(target, style) {
  if (style === void 0) {
    style = getComputedStyle$1(target);
  }

  var hasOffset = !isUndefined(target.offsetWidth);

  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    var offsetWidth = bbox.width;
    var offsetHeight = bbox.height;
    return {
      svg: true,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      clientWidth: offsetWidth,
      clientHeight: offsetHeight,
      cssWidth: offsetWidth,
      cssHeight: offsetHeight
    };
  } else {
    var boxSizing = style.boxSizing === "border-box";
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    var cssWidth = parseFloat(style.width);
    var cssHeight = parseFloat(style.height);
    var offsetWidth = cssWidth;
    var offsetHeight = cssHeight;
    var clientWidth = cssWidth;
    var clientHeight = cssHeight;
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorder = borderLeft + borderRight;
    var verticalBorder = borderTop + borderBottom;
    var horizontalOffset = horizontalPadding + horizontalBorder;
    var verticalOffset = verticalPadding + verticalBorder;

    if (boxSizing) {
      cssWidth = offsetWidth - horizontalOffset;
      cssHeight = offsetHeight - verticalOffset;
    } else {
      offsetWidth = cssWidth + horizontalOffset;
      offsetHeight = cssHeight + verticalOffset;
    }

    clientWidth = cssWidth + horizontalPadding;
    clientHeight = cssHeight + verticalPadding;
    return {
      svg: false,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      clientWidth: clientWidth,
      clientHeight: clientHeight,
      cssWidth: cssWidth,
      cssHeight: cssHeight
    };
  }
}

function getRotationRad(poses, direction) {
  return getRad$1(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}

function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);

  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, plus(result.transformOrigin, getOrigin(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = plus(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);

    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }

  return __assign$2({
    targetClientRect: targetClientRect,
    containerClientRect: containerClientRect,
    moveableClientRect: moveableClientRect,
    beforeDirection: beforeDirection,
    beforeOrigin: beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target: target
  }, result);
}

function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}

function getClientRect(el, isExtends) {
  var _a;

  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;

  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    var scrollPos = getBodyScrollPos();
    _a = [-scrollPos[0], -scrollPos[1]], left = _a[0], top = _a[1];
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }

  var rect = {
    left: left,
    right: left + width,
    top: top,
    bottom: top + height,
    width: width,
    height: height
  };

  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle$1(el).overflow !== "visible";
  }

  return rect;
}

function getDirection(target) {
  if (!target) {
    return;
  }

  var direciton = target.getAttribute("data-direction");

  if (!direciton) {
    return;
  }

  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}

function getAbsolutePoses(poses, dist) {
  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];
}

function getAbsolutePosesByState(_a) {
  var left = _a.left,
      top = _a.top,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}

function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}

function unset(self, name) {
  var _a;

  (_a = self[name]) === null || _a === void 0 ? void 0 : _a.unset();
  self[name] = null;
}

function fillParams(moveable, e, params, isBeforeEvent) {
  var datas = e.datas;

  if (!datas.datas) {
    datas.datas = {};
  }

  var nextParams = __assign$2(__assign$2({}, params), {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    moveable: moveable,
    datas: datas.datas
  });

  if (!datas.isStartEvent) {
    datas.isStartEvent = true;
  } else if (!isBeforeEvent) {
    datas.lastEvent = nextParams;
  }

  return nextParams;
}

function fillEndParams(moveable, e, params) {
  var datas = e.datas;
  var isDrag = "isDrag" in params ? params.isDrag : e.isDrag;

  if (!datas.datas) {
    datas.datas = {};
  }

  return __assign$2(__assign$2({
    isDrag: isDrag
  }, params), {
    moveable: moveable,
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e.isDouble,
    datas: datas.datas
  });
}

function catchEvent(moveable, name, callback) {
  moveable._emitter.on(name, callback);
}

function triggerEvent(moveable, name, params, isManager) {
  return moveable.triggerEvent(name, params, isManager);
}

function getComputedStyle$1(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}

function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function (able) {
    var name = able.name;

    if (enabledAbles[name] || !methods.some(function (method) {
      return able[method];
    })) {
      return false;
    }

    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }

      ableGroups[able.ableGroup] = true;
    }

    enabledAbles[name] = true;
    return true;
  });
}

function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}

function selectValue() {
  var values = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }

  var length = values.length - 1;

  for (var i = 0; i < length; ++i) {
    var value = values[i];

    if (!isUndefined(value)) {
      return value;
    }
  }

  return values[length];
}

function groupBy(arr, func) {
  var groups = [];
  var groupKeys = [];
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];

    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}

function groupByMap(arr, func) {
  var groups = [];
  var groupKeys = {};
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var group = groupKeys[groupKey];

    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}

function flat(arr) {
  return arr.reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
}

function maxOffset() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  args.sort(function (a, b) {
    return Math.abs(b) - Math.abs(a);
  });
  return args[0];
}

function calculateInversePosition(matrix, pos, n) {
  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);
}

function convertDragDist(state, e) {
  var _a;

  var is3d = state.is3d,
      rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];
  return e;
}

function calculatePadding(matrix, pos, transformOrigin, origin, n) {
  return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);
}

function convertCSSSize(value, size, isRelative) {
  return isRelative ? "".concat(value / size * 100, "%") : "".concat(value, "px");
}

function getTinyDist(v) {
  return Math.abs(v) <= TINY_NUM ? 0 : v;
}

function directionCondition(moveable, e) {
  if (e.isRequest) {
    if (e.requestAble === "resizable" || e.requestAble === "scalable") {
      return e.parentDirection;
    } else {
      return false;
    }
  }

  return hasClass(e.inputEvent.target, prefix("direction"));
}

function invertObject(obj) {
  var nextObj = {};

  for (var name in obj) {
    nextObj[obj[name]] = name;
  }

  return nextObj;
}

function convertTransformInfo(transforms, index) {
  var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);
  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);
  var targetFunctionText = transforms[index] || "";
  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);
  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);
  var beforeFunctions = parse(beforeFunctionTexts);
  var beforeFunctions2 = parse(beforeFunctionTexts2);
  var targetFunctions = parse([targetFunctionText]);
  var afterFunctions = parse(afterFunctionTexts);
  var afterFunctions2 = parse(afterFunctionTexts2);
  var beforeFunctionMatrix = toMat(beforeFunctions);
  var beforeFunctionMatrix2 = toMat(beforeFunctions2);
  var afterFunctionMatrix = toMat(afterFunctions);
  var afterFunctionMatrix2 = toMat(afterFunctions2);
  var allFunctionMatrix = multiply(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms: transforms,
    beforeFunctionMatrix: beforeFunctionMatrix,
    beforeFunctionMatrix2: beforeFunctionMatrix2,
    targetFunctionMatrix: toMat(targetFunctions),
    afterFunctionMatrix: afterFunctionMatrix,
    afterFunctionMatrix2: afterFunctionMatrix2,
    allFunctionMatrix: allFunctionMatrix,
    beforeFunctions: beforeFunctions,
    beforeFunctions2: beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions: afterFunctions,
    afterFunctions2: afterFunctions2,
    beforeFunctionTexts: beforeFunctionTexts,
    beforeFunctionTexts2: beforeFunctionTexts2,
    targetFunctionText: targetFunctionText,
    afterFunctionTexts: afterFunctionTexts,
    afterFunctionTexts2: afterFunctionTexts2
  };
}

function isArrayFormat(arr) {
  if (!arr || !isObject(arr)) {
    return false;
  }

  if (arr instanceof Element) {
    return false;
  }

  return isArray(arr) || "length" in arr;
}

function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }

  if (isString(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }

    return target;
  }

  if (isFunction(target)) {
    return target();
  }

  if ("current" in target) {
    return target.current;
  }

  return target;
}

function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }

  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function (prev, target) {
    if (isString(target) && isSelector) {
      return __spreadArray(__spreadArray([], prev, true), [].slice.call(document.querySelectorAll(target)), true);
    }

    prev.push(getRefTarget(target, isSelector));
    return prev;
  }, []);
}

function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function (target) {
    if (!target) {
      return;
    }

    if (isString(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }

      return;
    }

    elementTargets.push(target);
  });
  return elementTargets;
}

function getAbsoluteRotation(pos1, pos2, direction) {
  var deg = getRad$1(pos1, pos2) / Math.PI * 180;
  deg = direction >= 0 ? deg : 180 - deg;
  deg = deg >= 0 ? deg : 360 + deg;
  return deg;
}

function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = invert(rootMatrix, n);

  if (!is3d) {
    inverseMatrix = convertDimension(inverseMatrix, 3, 4);
  }

  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return calculateMatrixDist(inverseMatrix, dist);
}

function getSizeDistByDist(startSize, dist, ratio, direction, keepRatio) {
  var startOffsetWidth = startSize[0],
      startOffsetHeight = startSize[1];
  var distWidth = 0;
  var distHeight = 0;

  if (keepRatio && startOffsetWidth && startOffsetHeight) {
    var rad = getRad$1([0, 0], dist);
    var standardRad = getRad$1([0, 0], direction);
    var size = getDistSize(dist);
    var signSize = Math.cos(rad - standardRad) * size;

    if (!direction[0]) {
      // top, bottom
      distHeight = signSize;
      distWidth = distHeight * ratio;
    } else if (!direction[1]) {
      // left, right
      distWidth = signSize;
      distHeight = distWidth / ratio;
    } else {
      // two-way
      var startWidthSize = direction[0] * 2 * startOffsetWidth;
      var startHeightSize = direction[1] * 2 * startOffsetHeight;
      var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
      var ratioRad = getRad$1([0, 0], [ratio, 1]);
      distWidth = Math.cos(ratioRad) * distSize;
      distHeight = Math.sin(ratioRad) * distSize;
    }
  } else {
    distWidth = direction[0] * dist[0];
    distHeight = direction[1] * dist[1];
  }

  return [distWidth, distHeight];
}

function getOffsetSizeDist(sizeDirection, keepRatio, datas, e) {
  var _a;

  var ratio = datas.ratio,
      startOffsetWidth = datas.startOffsetWidth,
      startOffsetHeight = datas.startOffsetHeight;
  var distWidth = 0;
  var distHeight = 0;
  var distX = e.distX,
      distY = e.distY,
      parentDistance = e.parentDistance,
      parentDist = e.parentDist,
      parentScale = e.parentScale,
      isPinch = e.isPinch;
  var startFixedDirection = datas.fixedDirection;

  if (parentDist) {
    distWidth = parentDist[0];
    distHeight = parentDist[1];

    if (keepRatio) {
      if (!distWidth) {
        distWidth = distHeight * ratio;
      } else if (!distHeight) {
        distHeight = distWidth / ratio;
      }
    }
  } else if (parentScale) {
    distWidth = (parentScale[0] - 1) * startOffsetWidth;
    distHeight = (parentScale[1] - 1) * startOffsetHeight;
  } else if (isPinch) {
    if (parentDistance) {
      distWidth = parentDistance;
      distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
    }
  } else {
    var dist_1 = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    });
    dist_1 = [0, 1].map(function (index) {
      var directionRatio = Math.abs(sizeDirection[index] - startFixedDirection[index]);

      if (directionRatio !== 0) {
        directionRatio = 2 / directionRatio;
      }

      return dist_1[index] * directionRatio;
    });
    _a = getSizeDistByDist([startOffsetWidth, startOffsetHeight], dist_1, ratio, sizeDirection, keepRatio), distWidth = _a[0], distHeight = _a[1];
  }

  return {
    // direction,
    // sizeDirection,
    distWidth: distWidth,
    distHeight: distHeight
  };
}
/**
 * @namespace Moveable.Pinchable
 * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 */


var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function () {
    return true;
  },
  pinchStart: function (moveable, e) {
    var datas = e.datas,
        targets = e.targets,
        angle = e.angle,
        originalDatas = e.originalDatas;
    var _a = moveable.props,
        pinchable = _a.pinchable,
        ables = _a.ables;

    if (!pinchable) {
      return false;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "", "Start");
    var controlEventName = "drag".concat(targets ? "Group" : "", "ControlStart");
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function (able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;

    if (!isPinch) {
      return false;
    }

    pinchAbles.forEach(function (able) {
      originalDatas[able.name] = originalDatas[able.name] || {};

      if (!able[controlEventName]) {
        return;
      }

      var ableEvent = __assign$2(__assign$2({}, e), {
        datas: originalDatas[able.name],
        parentRotate: angle,
        isPinch: true
      });

      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function (moveable, e) {
    var datas = e.datas,
        pinchScale = e.scale,
        distance = e.distance,
        originalDatas = e.originalDatas,
        inputEvent = e.inputEvent,
        targets = e.targets,
        angle = e.angle;

    if (!datas.isPinch) {
      return;
    }

    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag".concat(targets ? "Group" : "", "Control");
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign$2(__assign$2({}, e), {
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        parentDistance: parentDistance,
        parentRotate: angle,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        targets = e.targets,
        originalDatas = e.originalDatas;

    if (!datas.isPinch) {
      return;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "", "End");
    var params = fillEndParams(moveable, e, {
      isDrag: isPinch
    });

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag".concat(targets ? "Group" : "", "ControlEnd");
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign$2(__assign$2({}, e), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function (moveable, e) {
    return this.pinchStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function (moveable, e) {
    return this.pinch(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function (moveable, e) {
    return this.pinchEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  }
});
/**
 * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 * @name Moveable.Pinchable#pinchable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.pinchable = true;
 */

/**
 * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart
 * @memberof Moveable.Pinchable
 * @event pinchStart
 * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When pinching, the pinch event is called with part of scale, rotate, resize
 * @memberof Moveable.Pinchable
 * @event pinch
 * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinch", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotate", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scale", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the pinch finishes, the pinchEnd event is called.
 * @memberof Moveable.Pinchable
 * @event pinchEnd
 * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleEnd", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the group pinch starts, the `pinchGroupStart` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupStart
 * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupStart", ({ targets }) => {
 *     console.log("onPinchGroupStart", targets);
 * });
 */

/**
 * When the group pinch, the `pinchGroup` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroup
 * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroup", ({ targets, events }) => {
 *     console.log("onPinchGroup", targets);
 * });
 */

/**
 * When the group pinch finishes, the `pinchGroupEnd` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupEnd
 * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onPinchGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Resizable
 * @memberof Moveable
 * @description Resizable indicates whether the target's width and height can be increased or decreased.
 */

var Resizable$1 = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean,
    resizeFormat: Function
  },
  events: {
    onResizeStart: "resizeStart",
    onBeforeResize: "beforeResize",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onBeforeResizeGroup: "beforeResizeGroup",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        edge = _a.edge;

    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var _a;

    var inputEvent = e.inputEvent,
        isPinch = e.isPinch,
        isGroup = e.isGroup,
        parentDirection = e.parentDirection,
        datas = e.datas;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height;

    if (!direction || !target) {
      return false;
    }

    !isPinch && setDragStart(moveable, e);
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];

    if (!isGroup) {
      var style = getComputedStyle$1(target);
      var position = style.position,
          minWidth = style.minWidth,
          minHeight = style.minHeight,
          maxWidth = style.maxWidth,
          maxHeight = style.maxHeight;
      var isParentElement = position === "static" || position === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;

      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;

        if (isParentElement) {
          var containerStyle = getComputedStyle$1(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }

      datas.minSize = plus([convertUnitSize(minWidth, containerWidth) || 0, convertUnitSize(minHeight, containerHeight) || 0], padding);
      datas.maxSize = plus([convertUnitSize(maxWidth, containerWidth) || Infinity, convertUnitSize(maxHeight, containerHeight) || Infinity], padding);
    }

    var transformOrigin = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin && isString(transformOrigin) ? transformOrigin.split(" ") : transformOrigin;
    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    datas.startPositions = getAbsolutePosesByState(moveable.state);

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);
    }

    function setMin(minSize) {
      datas.minSize = [convertUnitSize("".concat(minSize[0]), 0) || 0, convertUnitSize("".concat(minSize[1]), 0) || 0];
    }

    function setMax(maxSize) {
      var nextMaxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];

      if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {
        nextMaxSize[0] = convertUnitSize("".concat(nextMaxSize[0]), 0) || Infinity;
      }

      if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {
        nextMaxSize[1] = convertUnitSize("".concat(nextMaxSize[1]), 0) || Infinity;
      }

      datas.maxSize = nextMaxSize;
    }

    setRatio(width / height);
    setFixedDirection([-direction[0], -direction[1]]);
    datas.setFixedDirection = setFixedDirection;
    datas.setMin = setMin;
    datas.setMax = setMax;
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (_a) {
        var startWidth = _a[0],
            startHeight = _a[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: setMin,
      setMax: setMax,
      setRatio: setRatio,
      setFixedDirection: setFixedDirection,
      setOrigin: function (origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable$1.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);

    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isResize ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        parentKeepRatio = e.parentKeepRatio,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var isResize = datas.isResize,
        transformOrigin = datas.transformOrigin,
        startWidth = datas.startWidth,
        startHeight = datas.startHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight,
        minSize = datas.minSize,
        maxSize = datas.maxSize,
        ratio = datas.ratio,
        isWidth = datas.isWidth,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight;

    if (!isResize) {
      return;
    }

    var props = moveable.props;
    var resizeFormat = props.resizeFormat,
        _b = props.throttleResize,
        throttleResize = _b === void 0 ? 1 : _b,
        parentMoveable = props.parentMoveable;
    var direction = datas.direction;
    var sizeDirection = direction;
    var distWidth = 0;
    var distHeight = 0;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;

    function getNextBoundingSize() {
      var nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);
      distWidth = nextSize.distWidth;
      distHeight = nextSize.distHeight;
      var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
      var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;

      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight
        if (isWidth) {
          nextHeight = nextWidth / ratio;
        } else {
          nextWidth = nextHeight * ratio;
        }
      }

      return [nextWidth, nextHeight];
    }

    var _c = getNextBoundingSize(),
        boundingWidth = _c[0],
        boundingHeight = _c[1];

    datas.setFixedDirection(datas.fixedDirection);
    triggerEvent(moveable, "onBeforeResize", fillParams(moveable, e, {
      setFixedDirection: function (nextFixedDirection) {
        var _a;

        datas.setFixedDirection(nextFixedDirection);
        _a = getNextBoundingSize(), boundingWidth = _a[0], boundingHeight = _a[1];
        return [boundingWidth, boundingHeight];
      },
      boundingWidth: boundingWidth,
      boundingHeight: boundingHeight,
      setSize: function (size) {
        boundingWidth = size[0], boundingHeight = size[1];
      }
    }, true));
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapResize(moveable, boundingWidth, boundingHeight, direction, fixedPosition, isRequest, datas);
    }

    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }

    function computeSize() {
      var _a;

      if (resizeFormat) {
        _a = resizeFormat([boundingWidth, boundingHeight]), boundingWidth = _a[0], boundingHeight = _a[1];
      }

      boundingWidth = throttle(boundingWidth, throttleResize);
      boundingHeight = throttle(boundingHeight, throttleResize);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        // pre-compute before maintaining the ratio
        computeSize();
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        boundingWidth += snapDist[0];
        boundingHeight = boundingWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        boundingHeight += snapDist[1];
        boundingWidth = boundingHeight * ratio;
      }
    } else {
      boundingWidth += snapDist[0];
      boundingHeight += snapDist[1];
      boundingWidth = Math.max(0, boundingWidth);
      boundingHeight = Math.max(0, boundingHeight);
    }

    _a = calculateBoundSize([boundingWidth, boundingHeight], minSize, maxSize, keepRatio ? ratio : false), boundingWidth = _a[0], boundingHeight = _a[1];
    computeSize();
    distWidth = boundingWidth - startOffsetWidth;
    distHeight = boundingHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, boundingWidth, boundingHeight, datas.fixedDirection, fixedPosition, transformOrigin);

    if (!parentMoveable && delta.every(function (num) {
      return !num;
    }) && inverseDelta.every(function (num) {
      return !num;
    })) {
      return;
    }

    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: Math.round(boundingWidth),
      offsetHeight: Math.round(boundingHeight),
      boundingWidth: boundingWidth,
      boundingHeight: boundingHeight,
      direction: direction,
      dist: [distWidth, distHeight],
      delta: delta,
      isPinch: !!isPinch,
      drag: Draggable$1.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;

    if (!isResize) {
      return;
    }

    var _a = moveable.state,
        width = _a.width,
        height = _a.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;

    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }

    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }

    if (isErrorWidth || isErrorHeight) {
      return this.dragControl(moveable, e);
    }
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    datas.isResize = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return params;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, __assign$2(__assign$2({}, e), {
      isGroup: true
    }));

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);
      var pos = getPosByDirection(startPositions, fixedDirection);

      var _a = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    var parentStartOffsetWidth = datas.startOffsetWidth,
        parentStartOffsetHeight = datas.startOffsetHeight;

    function updateGroupMin() {
      var originalMinSize = datas.minSize;
      originalEvents.forEach(function (ev) {
        var _a = ev.datas,
            childMinSize = _a.minSize,
            childStartOffsetWidth = _a.startOffsetWidth,
            childStartOffsetHeight = _a.startOffsetHeight;
        var parentMinWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);
        var parentMinHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);
        originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);
        originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);
      });
    }

    function updateGroupMax() {
      var originalMaxSize = datas.maxSize;
      originalEvents.forEach(function (ev) {
        var _a = ev.datas,
            childMaxSize = _a.maxSize,
            childStartOffsetWidth = _a.startOffsetWidth,
            childStartOffsetHeight = _a.startOffsetHeight;
        var parentMaxWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);
        var parentMaxHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);
        originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);
        originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);
      });
    }

    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });
    updateGroupMin();
    updateGroupMax();

    var setFixedDirection = function (fixedDirection) {
      params.setFixedDirection(fixedDirection);
      events.forEach(function (ev, i) {
        ev.setFixedDirection(fixedDirection);
        setDist(ev.moveable, originalEvents[i]);
      });
    };

    datas.setFixedDirection = setFixedDirection;

    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events: events.map(function (ev) {
        return __assign$2(__assign$2({}, ev), {
          setMin: function (minSize) {
            ev.setMin(minSize);
            updateGroupMin();
          },
          setMax: function (maxSize) {
            ev.setMax(maxSize);
            updateGroupMax();
          }
        });
      }),
      setFixedDirection: setFixedDirection,
      setMin: function (minSize) {
        params.setMin(minSize);
        updateGroupMin();
      },
      setMax: function (maxSize) {
        params.setMax(maxSize);
        updateGroupMax();
      }
    });

    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    catchEvent(moveable, "onBeforeResize", function (parentEvent) {
      triggerEvent(moveable, "onBeforeResizeGroup", fillParams(moveable, e, __assign$2(__assign$2({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var boundingWidth = params.boundingWidth,
        boundingHeight = params.boundingHeight,
        dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [boundingWidth / (boundingWidth - dist[0]), boundingHeight / (boundingHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign$2(__assign$2({}, ev), {
        parentDist: null,
        parentScale: parentScale,
        dragClient: plus(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });

    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Resizable#request
   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        if ("offsetWidth" in e) {
          distWidth = e.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e) {
          distWidth += e.deltaWidth;
        }

        if ("offsetHeight" in e) {
          distHeight = e.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e) {
          distHeight += e.deltaHeight;
        }

        return {
          datas: datas,
          parentDist: [distWidth, distHeight],
          parentKeepRatio: e.keepRatio
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be resized.
 * @name Moveable.Resizable#resizable
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     resizable: false,
 * });
 *
 * moveable.resizable = true;
 */

/**
 * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.
 * @name Moveable.Resizable#throttleResize
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   throttleResize: 1,
 * });
 *
 * moveable.throttleResize = 0;
 */

/**
 * When resize or scale, keeps a ratio of the width, height.
 * @name Moveable.Resizable#keepRatio
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * Set directions to show the control box.
 * @name Moveable.Resizable#renderDirections
 * @default ["n", "nw", "ne", "s", "se", "sw", "e", "w"]
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * Function to convert size for resize
 * @name Moveable.Resizable#resizeFormat
 * @default oneself
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   resizeFormat: v => v,
 * });
 *
 * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];
 */

/**
 * When the resize starts, the resizeStart event is called.
 * @memberof Moveable.Resizable
 * @event resizeStart
 * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.
 * @memberof Moveable.Resizable
 * @event beforeResize
 * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("beforeResize", ({ setFixedDirection }) => {
 *     if (shiftKey) {
 *        setFixedDirection([0, 0]);
 *     }
 * });
 * moveable.on("resize", ({ target, width, height, drag }) => {
 *     target.style.width = `${width}px`;
 *     target.style.height = `${height}px`;
 *     target.style.transform = drag.transform;
 * });
 */

/**
 * When resizing, the resize event is called.
 * @memberof Moveable.Resizable
 * @event resize
 * @param {Moveable.Resizable.OnResize} - Parameters for the resize event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resize", ({ target, width, height }) => {
 *     target.style.width = `${e.width}px`;
 *     target.style.height = `${e.height}px`;
 * });
 */

/**
 * When the resize finishes, the resizeEnd event is called.
 * @memberof Moveable.Resizable
 * @event resizeEnd
 * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group resize starts, the `resizeGroupStart` event is called.
* @memberof Moveable.Resizable
* @event resizeGroupStart
* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroupStart", ({ targets }) => {
*     console.log("onResizeGroupStart", targets);
* });
*/

/**
* When the group resize, the `resizeGroup` event is called.
* @memberof Moveable.Resizable
* @event resizeGroup
* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroup", ({ targets, events }) => {
*     console.log("onResizeGroup", targets);
*     events.forEach(ev => {
*         const offset = [
*             direction[0] < 0 ? -ev.delta[0] : 0,
*             direction[1] < 0 ? -ev.delta[1] : 0,
*         ];
*         // ev.drag is a drag event that occurs when the group resize.
*         const left = offset[0] + ev.drag.beforeDist[0];
*         const top = offset[1] + ev.drag.beforeDist[1];
*         const width = ev.width;
*         const top = ev.top;
*     });
* });
*/

/**
 * When the group resize finishes, the `resizeGroupEnd` event is called.
 * @memberof Moveable.Resizable
 * @event resizeGroupEnd
 * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     resizable: true
 * });
 * moveable.on("resizeGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onResizeGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Scalable
 * @memberof Moveable
 * @description Scalable indicates whether the target's x and y can be scale of transform.
 */

var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onBeforeScale: "beforeScale",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onBeforeScaleGroup: "beforeScaleGroup",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        edge = _a.edge;

    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        parentDirection = e.parentDirection;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a = moveable.state,
        width = _a.width,
        height = _a.height,
        targetTransform = _a.targetTransform,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos4 = _a.pos4;

    if (!direction || !target) {
      return false;
    }

    if (!isPinch) {
      setDragStart(moveable, e);
    }

    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.startValue = [1, 1];
    var scaleWidth = getDist$2(pos1, pos2);
    var scaleHeight = getDist$2(pos2, pos4);
    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e, "scale");
    datas.isWidth = isWidth;

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    datas.startPositions = getAbsolutePosesByState(moveable.state);

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);
    }

    datas.setFixedDirection = setFixedDirection;
    setRatio(getDist$2(pos1, pos2) / getDist$2(pos2, pos4));
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, __assign$2(__assign$2({
      direction: direction,
      set: function (scale) {
        datas.startValue = scale;
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable$1.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);

    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isScale ? params : false;
  },
  dragControl: function (moveable, e) {
    resolveTransformEvent(e, "scale");
    var datas = e.datas,
        parentKeepRatio = e.parentKeepRatio,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        dragClient = e.dragClient,
        isRequest = e.isRequest;
    var prevDist = datas.prevDist,
        direction = datas.direction,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        isScale = datas.isScale,
        startValue = datas.startValue,
        isWidth = datas.isWidth,
        ratio = datas.ratio;

    if (!isScale) {
      return false;
    }

    var props = moveable.props;
    var throttleScale = props.throttleScale,
        parentMoveable = props.parentMoveable;
    var sizeDirection = direction;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;
    var state = moveable.state;

    function getNextScale() {
      var _a = getOffsetSizeDist(sizeDirection, keepRatio, datas, e),
          distWidth = _a.distWidth,
          distHeight = _a.distHeight;

      var scaleX = (startOffsetWidth + distWidth) / startOffsetWidth;
      var scaleY = (startOffsetHeight + distHeight) / startOffsetHeight;
      scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
      scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];

      if (scaleX === 0) {
        scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
      }

      if (scaleY === 0) {
        scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
      }

      return [scaleX, scaleY];
    }

    var scale = getNextScale();

    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;

      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction: direction,
          request: e.isRequest
        };
      }
    }

    triggerEvent(moveable, "onBeforeScale", fillParams(moveable, e, {
      scale: scale,
      setFixedDirection: function (nextFixedDirection) {
        datas.setFixedDirection(nextFixedDirection);
        scale = getNextScale();
        return scale;
      },
      setScale: function (nextScale) {
        scale = nextScale;
      }
    }, true));
    var dist = [scale[0] / startValue[0], scale[1] / startValue[1]];
    var fixedPosition = dragClient;
    var snapDist = [0, 0];

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / startOffsetHeight / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / startOffsetWidth / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];

      if (!snapDist[0]) {
        dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];
      }

      if (!snapDist[1]) {
        dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }

    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);
    var inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;

    if (scale[0] === prevDist[0] && scale[1] === prevDist[1] && inverseDelta.every(function (num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }

    var nextTransform = convertTransformFormat(datas, "scale(".concat(scale.join(", "), ")"), "scale(".concat(dist.join(", "), ")"));
    var params = fillParams(moveable, e, __assign$2({
      offsetWidth: startOffsetWidth,
      offsetHeight: startOffsetHeight,
      direction: direction,
      scale: scale,
      dist: dist,
      delta: delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isScale) {
      return false;
    }

    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);
      var pos = getPosByDirection(startPositions, fixedDirection);

      var _a = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    datas.moveableScale = moveable.scale;
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var setFixedDirection = function (fixedDirection) {
      params.setFixedDirection(fixedDirection);
      events.forEach(function (ev, i) {
        ev.setFixedDirection(fixedDirection);
        setDist(ev.moveable, originalEvents[i]);
      });
    };

    datas.setFixedDirection = setFixedDirection;

    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: setFixedDirection
    });

    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    catchEvent(moveable, "onBeforeScale", function (parentEvent) {
      triggerEvent(moveable, "onBeforeScaleGroup", fillParams(moveable, e, __assign$2(__assign$2({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist,
        scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign$2(__assign$2({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: plus(fixedPosition, [clientX, clientY])
      });
    });

    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Scalable#request
   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function () {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        distWidth += e.deltaWidth;
        distHeight += e.deltaHeight;
        return {
          datas: datas,
          parentDist: [distWidth, distHeight],
          parentKeepRatio: e.keepRatio
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can scaled.
 *
 * @name Moveable.Scalable#scalable
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.scalable = true;
 */

/**
 * throttle of scaleX, scaleY when scale.
 * @name Moveable.Scalable#throttleScale
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleScale = 0.1;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Scalable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Scalable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * When the scale starts, the scaleStart event is called.
 * @memberof Moveable.Scalable
 * @event scaleStart
 * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.
 * @memberof Moveable.Scalable
 * @event beforeScale
 * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("beforeScale", ({ setFixedDirection }) => {
 *     if (shiftKey) {
 *        setFixedDirection([0, 0]);
 *     }
 * });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When scaling, the `scale` event is called.
 * @memberof Moveable.Scalable
 * @event scale
 * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the scale finishes, the `scaleEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleEnd
 * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group scale starts, the `scaleGroupStart` event is called.
* @memberof Moveable.Scalable
* @event scaleGroupStart
* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroupStart", ({ targets }) => {
*     console.log("onScaleGroupStart", targets);
* });
*/

/**
* When the group scale, the `scaleGroup` event is called.
* @memberof Moveable.Scalable
* @event scaleGroup
* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroup", ({ targets, events }) => {
*     console.log("onScaleGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group scale.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const scaleX = ev.scale[0];
*         const scaleY = ev.scale[1];
*     });
* });
*/

/**
 * When the group scale finishes, the `scaleGroupEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleGroupEnd
 * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     scalable: true
 * });
 * moveable.on("scaleGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onScaleGroupEnd", targets, isDrag);
 * });
 */

function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function (pos, i) {
    return dot(pos, pos2[i], 1, 2);
  });
}

function getTriangleRad(pos1, pos2, pos3) {
  // pos1 Rad
  var rad1 = getRad$1(pos1, pos2);
  var rad2 = getRad$1(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}

function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;

  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }

  return true;
}
/**
 * @namespace Moveable.Warpable
 * @description Warpable indicates whether the target can be warped(distorted, bented).
 */


var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        warpable = _a.warpable,
        zoom = _a.zoom;

    if (resizable || scalable || !warpable) {
      return [];
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArray([React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React), true);
  },
  dragControlCondition: function (moveable, e) {
    if (e.isRequest) {
      return false;
    }

    return hasClass(e.inputEvent.target, prefix("direction"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);

    if (!direction || !target) {
      return false;
    }

    var state = moveable.state;
    var transformOrigin = state.transformOrigin,
        is3d = state.is3d,
        targetTransform = state.targetTransform,
        targetMatrix = state.targetMatrix,
        width = state.width,
        height = state.height,
        left = state.left,
        top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);
    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {
      return minus(p, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function (_a) {
      var x = _a[0],
          y = _a[1];
      return calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startValue = createIdentityMatrix(4);
    datas.prevMatrix = createIdentityMatrix(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "matrix3d");
    state.snapRenderInfo = {
      request: e.isRequest,
      direction: direction
    };
    var params = fillParams(moveable, e, __assign$2({
      set: function (matrix) {
        datas.startValue = matrix;
      }
    }, fillTransformStartEvent(e)));
    var result = triggerEvent(moveable, "onWarpStart", params);

    if (result !== false) {
      datas.isWarp = true;
    }

    return datas.isWarp;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix,
        prevMatrix = datas.prevMatrix,
        isWarp = datas.isWarp,
        startValue = datas.startValue,
        poses = datas.poses,
        posIndexes = datas.posIndexes,
        absolutePoses = datas.absolutePoses;

    if (!isWarp) {
      return false;
    }

    resolveTransformEvent(e, "matrix3d");

    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function (index) {
        return absolutePoses[index];
      });

      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }

      var _a = checkMoveableSnapBounds(moveable, isRequest, {
        horizontal: selectedPoses.map(function (pos) {
          return pos[1] + distY;
        }),
        vertical: selectedPoses.map(function (pos) {
          return pos[0] + distX;
        })
      }),
          horizontalSnapInfo = _a.horizontal,
          verticalSnapInfo = _a.vertical;

      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }

    var dist = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function (index) {
      nextPoses[index] = plus(nextPoses[index], dist);
    });

    if (!NEARBY_POS.every(function (nearByPoses) {
      return isValidPos(nearByPoses.map(function (i) {
        return poses[i];
      }), nearByPoses.map(function (i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }

    var h = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);

    if (!h.length) {
      return false;
    } // B * A * M


    var afterMatrix = multiply(targetInverseMatrix, h, 4); // B * M * A

    var matrix = getTransfromMatrix(datas, afterMatrix, true);
    var delta = multiply(invert(prevMatrix, 4), matrix, 4);
    datas.prevMatrix = matrix;
    var totalMatrix = multiply(startValue, matrix, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(".concat(totalMatrix.join(", "), ")"), "matrix3d(".concat(matrix.join(", "), ")"));
    fillOriginalTransform(e, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta: delta,
      matrix: totalMatrix,
      dist: matrix,
      multiply: multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isWarp) {
      return false;
    }

    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  }
};
/**
 * Whether or not target can be warped. (default: false)
 * @name Moveable.Warpable#warpable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.warpable = true;
 */

/**
* Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
* @name Moveable.Warpable#renderDirections
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     warpable: true,
*     renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
* });
*
* moveable.renderDirections = ["nw", "ne", "sw", "se"];
*/

/**
* When the warp starts, the warpStart event is called.
* @memberof Moveable.Warpable
* @event warpStart
* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { warpable: true });
* moveable.on("warpStart", ({ target }) => {
*     console.log(target);
* });
*/

/**
 * When warping, the warp event is called.
 * @memberof Moveable.Warpable
 * @event warp
 * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event
 * @example
 * import Moveable from "moveable";
 * let matrix = [
 *  1, 0, 0, 0,
 *  0, 1, 0, 0,
 *  0, 0, 1, 0,
 *  0, 0, 0, 1,
 * ];
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warp", ({ target, transform, delta, multiply }) => {
 *    // target.style.transform = transform;
 *    matrix = multiply(matrix, delta);
 *    target.style.transform = `matrix3d(${matrix.join(",")})`;
 * });
 */

/**
 * When the warp finishes, the warpEnd event is called.
 * @memberof Moveable.Warpable
 * @event warpEnd
 * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warpEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

var AREA_PIECES = /*#__PURE__*/prefix("area-pieces");
var AREA_PIECE = /*#__PURE__*/prefix("area-piece");
var AVOID = /*#__PURE__*/prefix("avoid");

function restoreStyle(moveable) {
  var el = moveable.areaElement;

  if (!el) {
    return;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  removeClass(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: ".concat(width, "px; height: ").concat(height, "px");
}

function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}

var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        target = _a.target,
        dragArea = _a.dragArea,
        groupable = _a.groupable,
        passDragArea = _a.passDragArea;
    var _b = moveable.state,
        width = _b.width,
        height = _b.height,
        renderPoses = _b.renderPoses;
    var className = passDragArea ? prefix("area", "pass") : prefix("area");

    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: ref(moveable, "areaElement"),
        className: className
      }), renderPieces(React)];
    }

    if (!target || !dragArea) {
      return [];
    }

    var h = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform = h.length ? makeMatrixCSS(h, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: ref(moveable, "areaElement"),
      className: className,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        transformOrigin: "0 0",
        transform: transform
      }
    }), renderPieces(React)];
  },
  dragStart: function (moveable, _a) {
    var datas = _a.datas,
        clientX = _a.clientX,
        clientY = _a.clientY,
        inputEvent = _a.inputEvent;

    if (!inputEvent) {
      return false;
    }

    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect,
        renderPoses = state.renderPoses,
        rootMatrix = state.rootMatrix,
        is3d = state.is3d;
    var left = moveableClientRect.left,
        top = moveableClientRect.top;

    var _b = getRect(renderPoses),
        relativeLeft = _b.left,
        relativeTop = _b.top,
        width = _b.width,
        height = _b.height;

    var n = is3d ? 4 : 3;

    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),
        posX = _c[0],
        posY = _c[1];

    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width: width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height: height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width: width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height: height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function (rect, i) {
      children[i].style.cssText = "left: ".concat(rect.left, "px;top: ").concat(rect.top, "px; width: ").concat(rect.width, "px; height: ").concat(rect.height, "px;");
    });
    addClass(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function (moveable, _a) {
    var datas = _a.datas,
        inputEvent = _a.inputEvent;
    this.enableNativeEvent(moveable);

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function (moveable, e) {
    this.enableNativeEvent(moveable);
    var inputEvent = e.inputEvent,
        datas = e.datas;

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  unset: function (moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function (moveable) {
    var state = moveable.state;

    if (state.disableNativeEvent) {
      requestAnimationFrame$1(function () {
        state.disableNativeEvent = false;
      });
    }
  }
};
/**
 * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)
 * @name Moveable#dragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

/**
 * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)
 * @name Moveable#passDragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

var Origin = makeAble("origin", {
  render: function (moveable, React) {
    var zoom = moveable.props.zoom;
    var _a = moveable.state,
        beforeOrigin = _a.beforeOrigin,
        rotation = _a.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
/**
 * Whether or not the origin controlbox will be visible or not (default: true)
 * @name Moveable#origin
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.origin = true;
 */

function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
/**
 * @namespace Moveable.Scrollable
 * @description Whether or not target can be scrolled to the scroll container (default: false)
 */


var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.scrollContainer,
        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;
    var dragScroll = new DragScroll$1();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e.datas.dragScroll = dragScroll;
    var gestoName = e.isControl ? "controlGesto" : "targetGesto";
    var targets = e.targets;
    dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;
      var params = fillParams(moveable, e, {
        scrollContainer: container,
        direction: direction
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";

      if (targets) {
        params.targets = targets;
      }

      triggerEvent(moveable, eventName, params);
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);
    });
    dragScroll.dragStart(e, {
      container: scrollContainerElement
    });
  },
  checkScroll: function (moveable, e) {
    var dragScroll = e.datas.dragScroll;

    if (!dragScroll) {
      return;
    }

    var _a = moveable.props,
        _b = _a.scrollContainer,
        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,
        _c = _a.scrollThreshold,
        scrollThreshold = _c === void 0 ? 0 : _c,
        _d = _a.getScrollPosition,
        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;
    dragScroll.drag(e, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function (ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function (moveable, e) {
    return this.checkScroll(moveable, e);
  },
  dragEnd: function (moveable, e) {
    e.datas.dragScroll.dragEnd();
    e.datas.dragScroll = null;
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      isControl: true
    }));
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function (moveable, e) {
    return this.drag(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  }
};
/**
 * Whether or not target can be scrolled to the scroll container (default: false)
 * @name Moveable.Scrollable#scrollable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 * moveable.scrollable = true;
 */

/**
 * The container to which scroll is applied (default: container)
 * @name Moveable.Scrollable#scrollContainer
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Expand the range of the scroll check area. (default: 0)
 * @name Moveable.Scrollable#scrollThreshold
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Sets a function to get the scroll position. (default: Function)
 * @name Moveable.Scrollable#getScrollPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.
 * @memberof Moveable.Scrollable
 * @event scroll
 * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.
 * @memberof Moveable.Scrollable
 * @event scrollGroup
 * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object,
    flushSync: Function
  },
  events: {}
};
var Padding = makeAble("padding", {
  render: function (moveable, React) {
    var props = moveable.props;

    if (props.dragArea) {
      return [];
    }

    var padding = props.padding || {};
    var _a = padding.left,
        left = _a === void 0 ? 0 : _a,
        _b = padding.top,
        top = _b === void 0 ? 0 : _b,
        _c = padding.right,
        right = _c === void 0 ? 0 : _c,
        _d = padding.bottom,
        bottom = _d === void 0 ? 0 : _d;
    var _e = moveable.state,
        renderPoses = _e.renderPoses,
        pos1 = _e.pos1,
        pos2 = _e.pos2,
        pos3 = _e.pos3,
        pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];

    if (left > 0) {
      paddingDirections.push([0, 2]);
    }

    if (top > 0) {
      paddingDirections.push([0, 1]);
    }

    if (right > 0) {
      paddingDirections.push([1, 3]);
    }

    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }

    return paddingDirections.map(function (_a, i) {
      var dir1 = _a[0],
          dir2 = _a[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);

      if (!h.length) {
        return undefined;
      }

      return React.createElement("div", {
        key: "padding".concat(i),
        className: prefix("padding"),
        style: {
          transform: makeMatrixCSS(h, true)
        }
      });
    });
  }
});
/**
 * Add padding around the target to increase the drag area.
 * @name Moveable#padding
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  target: document.querySelector(".target"),
 *  padding: { left: 0, top: 0, right: 0, bottom: 0 },
 * });
 * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },
 * moveable.updateRect();
 */

var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];

function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}

var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];

function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  if (right === void 0) {
    right = width;
  }

  if (bottom === void 0) {
    bottom = height;
  }

  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function (pos, i) {
    var _a = controlPoses[i],
        horizontal = _a.horizontal,
        vertical = _a.vertical;

    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }

    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws: raws
  };
}

function getRadiusRange(controlPoses) {
  // [start, length]
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length = controlPoses.length;

  for (var i = 0; i < length; ++i) {
    var clipPose = controlPoses[i];

    if (!clipPose.sub) {
      continue;
    }

    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i;
      }

      horizontalRange[1] = i - horizontalRange[0] + 1;
      verticalRange[0] = i + 1;
    }

    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i;
      }

      verticalRange[1] = i - verticalRange[0] + 1;
    }
  }

  return {
    horizontalRange: horizontalRange,
    verticalRange: verticalRange
  };
}

function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a, _b, _c, _d;

  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0],
      nwValue = _e === void 0 ? "0px" : _e,
      _f = horizontalValues[1],
      neValue = _f === void 0 ? nwValue : _f,
      _g = horizontalValues[2],
      seValue = _g === void 0 ? nwValue : _g,
      _h = horizontalValues[3],
      swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0],
      wnValue = _j === void 0 ? nwValue : _j,
      _k = verticalValues[1],
      enValue = _k === void 0 ? wnValue : _k,
      _l = verticalValues[2],
      esValue = _l === void 0 ? wnValue : _l,
      _m = verticalValues[3],
      wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {
    return convertUnitSize(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {
    return convertUnitSize(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];
  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];
  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];
  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i],
      direction: direction
    };
  }), true), nextVerticalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i],
      direction: direction
    };
  }), true);
}

function removeRadiusPos(controlPoses, poses, index, startIndex, length) {
  if (length === void 0) {
    length = poses.length;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  var radiuslIndex = index - startIndex;
  var deleteCount = 0;

  if (radiuslIndex === 0) {
    deleteCount = length;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }

  controlPoses.splice(index, deleteCount);
  poses.splice(index, deleteCount);
}

function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;

    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {
      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;
      var x = 0;

      if (horizontalIndex === i) {
        x = distX;
      } else if (i === 0) {
        x = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {
        x = right - (poses[startIndex][0] - left);
      }

      controlPoses.splice(startIndex + i, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
        vertical: 0,
        pos: [x, y]
      });
      poses.splice(startIndex + i, 0, [x, y]);

      if (i === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;

    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: pos
      });
      poses.push(pos);
    }

    var startVerticalIndex = verticalRange[0];

    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {
      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;
      var y = 0;

      if (verticalIndex === i) {
        y = distY;
      } else if (i === 0) {
        y = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {
        y = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {
        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }

      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i],
        pos: [x, y]
      });
      poses.push([x, y]);

      if (i === 0) {
        break;
      }
    }
  }
}

function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function (pos) {
      return pos.raw;
    });
  }

  var horizontals = controlPoses.map(function (pos, i) {
    return pos.horizontal ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function (pos, i) {
    return pos.vertical ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  return {
    horizontals: horizontals,
    verticals: verticals
  };
}

var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; // 1 2 5 6 0 3 4 7
// 0 1 2 3 4 5 6 7

function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";

  if (clipType === "polygon") {
    return poses.map(function (pos) {
      return "".concat(convertCSSSize(pos[0], width, clipRelative), " ").concat(convertCSSSize(pos[1], height, clipRelative));
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];

    if (isRect) {
      return [top, right, bottom, left].map(function (pos) {
        return "".concat(pos, "px");
      });
    }

    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {
      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);
    });

    if (poses.length > 8) {
      var _c = minus(poses[4], poses[0]),
          subWidth = _c[0],
          subHeight = _c[1];

      clipStyles.push.apply(clipStyles, __spreadArray(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles, false));
    }

    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}

function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function (_a) {
    var dirx = _a[0],
        diry = _a[1],
        dir = _a[2];
    var x = xs[dirx + 1];
    var y = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x, y]
    };
  });
}

function getControlSize(controlPoses) {
  var xRange = [Infinity, -Infinity];
  var yRange = [Infinity, -Infinity];
  controlPoses.forEach(function (_a) {
    var pos = _a.pos;
    xRange[0] = Math.min(xRange[0], pos[0]);
    xRange[1] = Math.max(xRange[1], pos[0]);
    yRange[0] = Math.min(yRange[0], pos[1]);
    yRange[1] = Math.max(yRange[1], pos[1]);
  });
  return [Math.abs(xRange[1] - xRange[0]), Math.abs(yRange[1] - yRange[0])];
}

function moveControlPos(controlPoses, index, dist, isRect, keepRatio) {
  var _a = controlPoses[index],
      direction = _a.direction,
      sub = _a.sub;
  var dists = controlPoses.map(function () {
    return [0, 0];
  });
  var directions = direction ? direction.split("") : [];

  if (isRect && index < 8) {
    var verticalDirections = directions.filter(function (dir) {
      return dir === "w" || dir === "e";
    });
    var horizontalDirections = directions.filter(function (dir) {
      return dir === "n" || dir === "s";
    });
    var verticalDirection_1 = verticalDirections[0];
    var horizontalDirection_1 = horizontalDirections[0];
    dists[index] = dist;

    var _b = getControlSize(controlPoses),
        width = _b[0],
        height = _b[1];

    var ratio = width && height ? width / height : 0;

    if (ratio && keepRatio) {
      // 0 1 2
      // 7   3
      // 6 5 4
      var fixedIndex = (index + 4) % 8;
      var fixedPosition = controlPoses[fixedIndex].pos;
      var sizeDirection = [0, 0];

      if (direction.indexOf("w") > -1) {
        sizeDirection[0] = -1;
      } else if (direction.indexOf("e") > -1) {
        sizeDirection[0] = 1;
      }

      if (direction.indexOf("n") > -1) {
        sizeDirection[1] = -1;
      } else if (direction.indexOf("s") > -1) {
        sizeDirection[1] = 1;
      }

      var nextDist = getSizeDistByDist([width, height], dist, ratio, sizeDirection, true);
      var nextWidth = width + nextDist[0];
      var nextHeight = height + nextDist[1];
      var top = fixedPosition[1];
      var bottom = fixedPosition[1];
      var left = fixedPosition[0];
      var right = fixedPosition[0];

      if (sizeDirection[0] === -1) {
        left = right - nextWidth;
      } else if (sizeDirection[0] === 1) {
        right = left + nextWidth;
      } else {
        left = left - nextWidth / 2;
        right = right + nextWidth / 2;
      }

      if (sizeDirection[1] === -1) {
        top = bottom - nextHeight;
      } else if (sizeDirection[1] === 1) {
        bottom = top + nextHeight;
      } else {
        top = bottom - nextHeight / 2;
        bottom = top + nextHeight;
      }

      var nextControlPoses_1 = getRectPoses(top, right, bottom, left);
      controlPoses.forEach(function (controlPose, i) {
        dists[i][0] = nextControlPoses_1[i].pos[0] - controlPose.pos[0];
        dists[i][1] = nextControlPoses_1[i].pos[1] - controlPose.pos[1];
      });
    } else {
      controlPoses.forEach(function (controlPose, i) {
        var controlDir = controlPose.direction;

        if (!controlDir) {
          return;
        }

        if (controlDir.indexOf(verticalDirection_1) > -1) {
          dists[i][0] = dist[0];
        }

        if (controlDir.indexOf(horizontalDirection_1) > -1) {
          dists[i][1] = dist[1];
        }
      });

      if (verticalDirection_1) {
        dists[1][0] = dist[0] / 2;
        dists[5][0] = dist[0] / 2;
      }

      if (horizontalDirection_1) {
        dists[3][1] = dist[1] / 2;
        dists[7][1] = dist[1] / 2;
      }
    }
  } else if (direction && !sub) {
    directions.forEach(function (dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function (controlPose, i) {
        var dirDir = controlPose.direction,
            dirHorizontal = controlPose.horizontal,
            dirVertical = controlPose.vertical;

        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }

        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index] = dist;
  }

  return dists;
}

function getClipPath(target, width, height, defaultClip, customClip) {
  var _a, _b, _c, _d, _e, _f, _g;

  var clipText = customClip;

  if (!clipText) {
    var style = getComputedStyle$1(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }

  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;

    if (!clipText) {
      return;
    }
  }

  var _h = splitBracket(clipText),
      _j = _h.prefix,
      clipPrefix = _j === void 0 ? clipText : _j,
      _k = _h.value,
      value = _k === void 0 ? "" : _k;

  var isCircle = clipPrefix === "circle";
  var splitter = " ";

  if (clipPrefix === "polygon") {
    var values = splitComma(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function (pos) {
      var _a = pos.split(" "),
          xPos = _a[0],
          yPos = _a[1];

      return {
        vertical: 1,
        horizontal: 1,
        pos: [convertUnitSize(xPos, width), convertUnitSize(yPos, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText: clipText,
      poses: poses,
      splitter: splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = splitSpace(value);

    if (isCircle) {
      var radius = "";
      _a = values[0], radius = _a === void 0 ? "50%" : _a, _b = values[2], xPos = _b === void 0 ? "50%" : _b, _c = values[3], yPos = _c === void 0 ? "50%" : _c;
      radiusX_1 = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d = values[0], xRadius = _d === void 0 ? "50%" : _d, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = convertUnitSize(xRadius, width);
      radiusY_1 = convertUnitSize(yRadius, height);
    }

    var centerPos_1 = [convertUnitSize(xPos, width), convertUnitSize(yPos, height)];

    var poses = __spreadArray([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }), true);

    return {
      type: clipPrefix,
      clipText: clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses: poses,
      splitter: splitter
    };
  } else if (clipPrefix === "inset") {
    var values = splitSpace(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);

    var _l = values.slice(0, rectLength),
        topValue = _l[0],
        _m = _l[1],
        rightValue = _m === void 0 ? topValue : _m,
        _o = _l[2],
        bottomValue = _o === void 0 ? topValue : _o,
        _p = _l[3],
        leftValue = _p === void 0 ? rightValue : _p;

    var _q = [topValue, bottomValue].map(function (pos) {
      return convertUnitSize(pos, height);
    }),
        top = _q[0],
        bottom = _q[1];

    var _r = [leftValue, rightValue].map(function (pos) {
      return convertUnitSize(pos, width);
    }),
        left = _r[0],
        right = _r[1];

    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);

    var poses = __spreadArray(__spreadArray([], getRectPoses(top, nextRight, nextBottom, left), true), radiusPoses, true);

    return {
      type: "inset",
      clipText: clipText,
      poses: poses,
      top: top,
      left: left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter: splitter
    };
  } else if (clipPrefix === "rect") {
    // top right bottom left
    var values = splitComma(value || "0px, ".concat(width, "px, ").concat(height, "px, 0px"));
    splitter = ",";

    var _s = values.map(function (pos) {
      var posValue = splitUnit(pos).value;
      return posValue;
    }),
        top = _s[0],
        right = _s[1],
        bottom = _s[2],
        left = _s[3];

    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText: clipText,
      poses: poses,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      values: values,
      splitter: splitter
    };
  }

  return;
}

function addClipPath(moveable, e) {
  var _a = calculatePointerDist(moveable, e),
      distX = _a[0],
      distY = _a[1];

  var _b = e.datas,
      clipPath = _b.clipPath,
      clipIndex = _b.clipIndex;
  var _c = clipPath,
      clipType = _c.type,
      clipPoses = _c.poses,
      splitter = _c.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });

  if (clipType === "polygon") {
    poses.splice(clipIndex, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);
    var length = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "added",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: "".concat(clipType, "(").concat(clipStyles.join(splitter), ")"),
    distX: 0,
    distY: 0
  }));
}

function removeClipPath(moveable, e) {
  var _a = e.datas,
      clipPath = _a.clipPath,
      clipIndex = _a.clipIndex;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses,
      splitter = _b.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });
  var length = poses.length;

  if (clipType === "polygon") {
    clipPoses.splice(clipIndex, 1);
    poses.splice(clipIndex, 1);
  } else if (clipType === "inset") {
    if (clipIndex < 8) {
      return;
    }

    removeRadiusPos(clipPoses, poses, clipIndex, 8, length);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "removed",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: "".concat(clipType, "(").concat(clipStyles.join(splitter), ")"),
    distX: 0,
    distY: 0
  }));
}
/**
 * @namespace Moveable.Clippable
 * @description Whether to clip the target.
 */


var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    keepRatio: Boolean,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function (moveable, React) {
    var _a = moveable.props,
        customClipPath = _a.customClipPath,
        defaultClipPath = _a.defaultClipPath,
        clipArea = _a.clipArea,
        zoom = _a.zoom;
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height,
        allMatrix = _b.allMatrix,
        is3d = _b.is3d,
        left = _b.left,
        top = _b.top,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4,
        clipPathState = _b.clipPathState,
        snapBoundInfos = _b.snapBoundInfos,
        rotationRad = _b.rotation;

    if (!target) {
      return [];
    }

    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);

    if (!clipPath) {
      return [];
    }

    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function (pos) {
      // return [x, y];
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";

    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function (to, i) {
        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];
        var rad = getRad$1(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine".concat(i),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": i,
          style: {
            width: "".concat(dist, "px"),
            transform: "translate(".concat(from[0], "px, ").concat(from[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")")
          }
        });
      });
    }

    controls = poses.map(function (pos, i) {
      return React.createElement("div", {
        key: "clipControl".concat(i),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": i,
        style: {
          transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rotationRad, "rad) scale(").concat(zoom, ")")
        }
      });
    });

    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {
        return React.createElement("div", {
          key: "clipRadiusControl".concat(i),
          className: prefix("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i,
          style: {
            transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rotationRad, "rad) scale(").concat(zoom, ")")
          }
        });
      }));
    }

    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left,
          clipTop = clipPath.top,
          radiusX = clipPath.radiusX,
          radiusY = clipPath.radiusY;

      var _c = minus(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)),
          distLeft = _c[0],
          distTop = _c[1];

      var ellipseClipPath = "none";

      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];

        for (var i = 0; i <= piece; ++i) {
          var rad = Math.PI * 2 / piece * i;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }

        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(".concat(areaPoses.map(function (pos) {
          return "".concat(pos[0], "px ").concat(pos[1], "px");
        }).join(", "), ")");
      }

      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(radiusX * 2, "px"),
          height: "".concat(radiusY * 2, "px"),
          clipPath: ellipseClipPath,
          transform: "translate(".concat(-left + distLeft, "px, ").concat(-top + distTop, "px) ").concat(makeMatrixCSS(allMatrix))
        }
      }));
    }

    if (clipArea) {
      var _d = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses, true)),
          allWidth = _d.width,
          allHeight = _d.height,
          allLeft_1 = _d.left,
          allTop_1 = _d.top;

      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(allWidth, "px"),
            height: "".concat(allHeight, "px"),
            transform: "translate(".concat(allLeft_1, "px, ").concat(allTop_1, "px)"),
            clipPath: "polygon(".concat(areaPoses.map(function (pos) {
              return "".concat(pos[0] - allLeft_1, "px ").concat(pos[1] - allTop_1, "px");
            }).join(", "), ")")
          }
        }));
      }
    }

    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function (directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";

        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip".concat(directionType, "snap").concat(i), "guideline");
          }));
        }

        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip".concat(directionType, "bounds").concat(i), "guideline", "bounds", "bold");
          }));
        }
      });
    }

    return __spreadArray(__spreadArray([], controls, true), lines, true);
  },
  dragControlCondition: function (moveable, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.dragWithClip,
        dragWithClip = _a === void 0 ? true : _a;

    if (dragWithClip) {
      return false;
    }

    return this.dragControlStart(moveable, e);
  },
  drag: function (moveable, e) {
    return this.dragControl(moveable, __assign$2(__assign$2({}, e), {
      isDragTarget: true
    }));
  },
  dragEnd: function (moveable, e) {
    return this.dragControlEnd(moveable, e);
  },
  dragControlStart: function (moveable, e) {
    var state = moveable.state;
    var _a = moveable.props,
        defaultClipPath = _a.defaultClipPath,
        customClipPath = _a.customClipPath;
    var target = state.target,
        width = state.width,
        height = state.height;
    var inputTarget = e.inputEvent ? e.inputEvent.target : null;
    var className = inputTarget && inputTarget.getAttribute("class") || "";
    var datas = e.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);

    if (!clipPath) {
      return false;
    }

    var clipText = clipPath.clipText,
        type = clipPath.type,
        poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function (pos) {
        return pos.pos;
      })
    }));

    if (result === false) {
      datas.isClipStart = false;
      return false;
    }

    datas.isControl = className && className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e);
    return true;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        originalDatas = e.originalDatas,
        isDragTarget = e.isDragTarget;

    if (!datas.isClipStart) {
      return false;
    }

    var _b = datas,
        isControl = _b.isControl,
        isLine = _b.isLine,
        isArea = _b.isArea,
        clipIndex = _b.clipIndex,
        clipPath = _b.clipPath;

    if (!clipPath) {
      return false;
    }

    var keepRatio = moveable.props.keepRatio;
    var distX = 0;
    var distY = 0;
    var originalDraggable = originalDatas.draggable;
    var originalDist = getDragDist(e);

    if (isDragTarget && originalDraggable) {
      _a = originalDraggable.prevBeforeDist, distX = _a[0], distY = _a[1];
    } else {
      distX = originalDist[0], distY = originalDist[1];
    }

    var firstDist = [distX, distY];
    var props = moveable.props;
    var state = moveable.state;
    var width = state.width,
        height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type,
        clipPoses = clipPath.poses,
        splitter = clipPath.splitter;
    var poses = clipPoses.map(function (pos) {
      return pos.pos;
    });

    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }

    var isAll = !isControl || clipPoses[clipIndex].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function () {
      return [0, 0];
    });

    if (isControl && !isAll) {
      var _c = clipPoses[clipIndex],
          horizontal = _c.horizontal,
          vertical = _c.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);
    } else if (isAll) {
      dists = poses.map(function () {
        return [distX, distY];
      });
    }

    var nextPoses = poses.map(function (pos, i) {
      return plus(pos, dists[i]);
    });

    var guidePoses = __spreadArray([], nextPoses, true);

    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";

    if (isCircle || isEllipse) {
      var guideRect = getRect(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx; // right

      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      } // bottom


      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]); // left

      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }

    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) {
      return convertUnitSize("".concat(v), height);
    }), (props.clipVerticalGuidelines || []).map(function (v) {
      return convertUnitSize("".concat(v), width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function (_, i) {
        return dists[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function (_, i) {
        return dists[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    }

    var boundDelta = [0, 0];

    var _d = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 5),
        horizontalSnapInfo = _d.horizontal,
        verticalSnapInfo = _d.vertical;

    var snapOffsetY = horizontalSnapInfo.offset;
    var snapOffsetX = verticalSnapInfo.offset;

    if (horizontalSnapInfo.isBound) {
      boundDelta[1] += snapOffsetY;
    }

    if (verticalSnapInfo.isBound) {
      boundDelta[0] += snapOffsetX;
    }

    if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
      var guideRect = getRect(nextPoses);
      var cy = guideRect.bottom - guideRect.top;
      var cx = isEllipse ? guideRect.right - guideRect.left : cy;
      var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
      var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
      cx -= distSnapX;
      cy -= distSnapY;

      if (isCircle) {
        cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
        cx = cy;
      }

      var center = guidePoses[0];
      guidePoses[1][1] = center[1] - cy;
      guidePoses[2][0] = center[0] + cx;
      guidePoses[3][1] = center[1] + cy;
      guidePoses[4][0] = center[0] - cx;
    } else if (isRect && keepRatio && isControl) {
      var _e = getControlSize(clipPoses),
          width_1 = _e[0],
          height_1 = _e[1];

      var ratio = width_1 && height_1 ? width_1 / height_1 : 0;
      var clipPose = clipPoses[clipIndex];
      var direction = clipPose.direction || "";
      var top = guidePoses[1][1];
      var bottom = guidePoses[5][1];
      var left = guidePoses[7][0];
      var right = guidePoses[3][0];

      if (snapOffsetY <= snapOffsetX) {
        snapOffsetY = snapOffsetX / ratio;
      } else {
        snapOffsetX = snapOffsetY * ratio;
      }

      if (direction.indexOf("w") > -1) {
        left -= snapOffsetX;
      } else if (direction.indexOf("e") > -1) {
        right -= snapOffsetX;
      } else {
        left += snapOffsetX / 2;
        right -= snapOffsetX / 2;
      }

      if (direction.indexOf("n") > -1) {
        top -= snapOffsetY;
      } else if (direction.indexOf("s") > -1) {
        bottom -= snapOffsetY;
      } else {
        top += snapOffsetY / 2;
        bottom -= snapOffsetY / 2;
      }

      var nextControlPoses_2 = getRectPoses(top, right, bottom, left);
      guidePoses.forEach(function (pos, i) {
        var _a;

        _a = nextControlPoses_2[i].pos, pos[0] = _a[0], pos[1] = _a[1];
      });
    } else {
      guidePoses.forEach(function (pos, j) {
        var dist = dists[j];

        if (dist[0]) {
          pos[0] -= snapOffsetX;
        }

        if (dist[1]) {
          pos[1] -= snapOffsetY;
        }
      });
    }

    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = "".concat(clipType, "(").concat(nextClipStyles.join(splitter), ")");
    state.clipPathState = clipStyle;

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function (pos) {
        return pos[1];
      });
    }

    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 1);

    if (originalDraggable) {
      var is3d = state.is3d,
          allMatrix = state.allMatrix;
      var n = is3d ? 4 : 3;
      var dragDist = boundDelta;

      if (isDragTarget) {
        dragDist = [firstDist[0] + boundDelta[0] - originalDist[0], firstDist[1] + boundDelta[1] - originalDist[1]];
      }

      originalDraggable.deltaOffset = multiply(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);
    }

    triggerEvent(moveable, "onClip", fillParams(moveable, e, {
      clipEventType: "changed",
      clipType: clipType,
      poses: nextPoses,
      clipStyle: clipStyle,
      clipStyles: nextClipStyles,
      distX: distX,
      distY: distY
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    this.unset(moveable);
    var isDrag = e.isDrag,
        datas = e.datas,
        isDouble = e.isDouble;
    var isLine = datas.isLine,
        isClipStart = datas.isClipStart,
        isControl = datas.isControl;

    if (!isClipStart) {
      return false;
    }

    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e, {}));

    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e);
      } else if (isLine) {
        // add
        addClipPath(moveable, e);
      }
    }

    return isDouble || isDrag;
  },
  unset: function (moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
/**
 * Whether to clip the target. (default: false)
 * @name Moveable.Clippable#clippable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#defaultClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (`rect` not possible) (default: false)
 * @name Moveable.Clippable#clipRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#customClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When dragging the target, the clip also moves. (default: true)
 * @name Moveable.Clippable#dragWithClip
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can drag the clip by setting clipArea. (default: false)
 * @name Moveable.Clippable#clipArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
* Whether the clip is bound to the target. (default: false)
* @name Moveable.Clippable#clipTargetBounds
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipTargetBounds: true,
* });
* moveable.on("clipStart", e => {
*     console.log(e);
* }).on("clip", e => {
*     if (e.clipType === "rect") {
*         e.target.style.clip = e.clipStyle;
*     } else {
*         e.target.style.clipPath = e.clipStyle;
*     }
* }).on("clipEnd", e => {
*     console.log(e);
* });
*/

/**
* Add clip guidelines in the vertical direction. (default: [])
* @name Moveable.Clippable#clipVerticalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* Add clip guidelines in the horizontal direction. (default: [])
* @name Moveable.Clippable#clipHorizontalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* istance value that can snap to clip guidelines. (default: 5)
* @name Moveable.Clippable#clipSnapThreshold
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
 * When drag start the clip area or controls, the `clipStart` event is called.
 * @memberof Moveable.Clippable
 * @event clipStart
 * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag the clip area or controls, the `clip` event is called.
 * @memberof Moveable.Clippable
 * @event clip
 * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the clip area or controls, the `clipEnd` event is called.
 * @memberof Moveable.Clippable
 * @event clipEnd
 * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * @namespace OriginDraggable
 * @memberof Moveable
 * @description Whether to drag origin (default: false)
 */

var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function (_, e) {
    if (e.isRequest) {
      return e.requestAble === "originDraggable";
    }

    return hasClass(e.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas;
    setDragStart(moveable, e);
    var params = fillParams(moveable, e, {
      dragStart: Draggable$1.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;

    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }

    return params;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        isRequest = e.isRequest;

    if (!datas.isDragOrigin) {
      return false;
    }

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var state = moveable.state;
    var width = state.width,
        height = state.height,
        offsetMatrix = state.offsetMatrix,
        targetMatrix = state.targetMatrix,
        is3d = state.is3d;
    var _b = moveable.props.originRelative,
        originRelative = _b === void 0 ? true : _b;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];

    if (isRequest) {
      var distOrigin = e.distOrigin;

      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }

    var origin = plus(datas.startOrigin, dist);
    var targetOrigin = plus(datas.startTargetOrigin, dist);
    var delta = minus(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e, {
      width: width,
      height: height,
      origin: origin,
      dist: dist,
      delta: delta,
      transformOrigin: transformOrigin,
      drag: Draggable$1.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDragOrigin) {
      return false;
    }

    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e, {}));
    return true;
  },
  dragGroupControlCondition: function (moveable, e) {
    return this.dragControlCondition(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    return true;
  },
  dragGroupControl: function (moveable, e) {
    var params = this.dragControl(moveable, e);

    if (!params) {
      return false;
    }

    moveable.transformOrigin = params.transformOrigin;
    return true;
  },

  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaOrigin" in e) {
          distOrigin[0] += e.deltaOrigin[0];
          distOrigin[1] += e.deltaOrigin[1];
        } else if ("origin" in e) {
          distOrigin[0] = e.origin[0] - transformOrigin[0];
          distOrigin[1] = e.origin[1] - transformOrigin[1];
        } else {
          if ("x" in e) {
            distX = e.x - rect.left;
          } else if ("deltaX" in e) {
            distX += e.deltaX;
          }

          if ("y" in e) {
            distY = e.y - rect.top;
          } else if ("deltaY" in e) {
            distY += e.deltaY;
          }
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY,
          distOrigin: distOrigin
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether to drag origin (default: false)
 * @name Moveable.OriginDraggable#originDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 * });
 * let translate = [0, 0];
 * moveable.on("dragOriginStart", e => {
 *     e.dragStart && e.dragStart.set(translate);
 * }).on("dragOrigin", e => {
 *     translate = e.drag.beforeTranslate;
 *     e.target.style.cssText
 *         = `transform-origin: ${e.transformOrigin};`
 *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
 * }).on("dragOriginEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (default: true)
 * @name Moveable.OriginDraggable#originRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 *     originRelative: false,
 * });
 * moveable.originRelative = true;
 */

/**
* When drag start the origin, the `dragOriginStart` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginStart
* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag the origin, the `dragOrigin` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOrigin
* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag end the origin, the `dragOriginEnd` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginEnd
* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a = splitRadiusPoses(controlPoses),
      horizontals = _a.horizontals,
      verticals = _a.verticals;

  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length; // lineIndex
  // 0 top
  // 1 right
  // 2 left
  // 3 bottom
  // 0 top - left
  // 1 top - right
  // 2 bottom - right
  // 3 bottom - left
  // 0 left - top
  // 1 right - top
  // 2 right - bottom
  // 3 left - bottom

  var horizontalIndex = -1;
  var verticalIndex = -1;

  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }

  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }

  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}

function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var borderRadius;
  var values = [];

  if (!state) {
    var style = getComputedStyle$1(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }

  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = splitSpace(borderRadius);
  }

  return getRadiusValues(values, width, height, 0, 0, minCounts);
}

function triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width,
      height = state.height;

  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),
      raws = _a.raws,
      styles = _a.styles;

  var _b = splitRadiusPoses(controlPoses, raws),
      horizontals = _b.horizontals,
      verticals = _b.verticals;

  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e, {
    horizontals: horizontals,
    verticals: verticals,
    borderRadius: borderRadius,
    width: width,
    height: height,
    delta: delta,
    dist: dist
  }));
}
/**
 * @namespace Moveable.Roundable
 * @description Whether to show and drag or double click border-radius
 */


var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function (moveable, React) {
    var _a = moveable.state,
        target = _a.target,
        width = _a.width,
        height = _a.height,
        allMatrix = _a.allMatrix,
        is3d = _a.is3d,
        left = _a.left,
        top = _a.top,
        borderRadiusState = _a.borderRadiusState;
    var _b = moveable.props,
        _c = _b.minRoundControls,
        minRoundControls = _c === void 0 ? [0, 0] : _c,
        _d = _b.maxRoundControls,
        maxRoundControls = _d === void 0 ? [4, 4] : _d,
        zoom = _b.zoom;

    if (!target) {
      return null;
    }

    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);

    if (!radiusValues) {
      return null;
    }

    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function (v, i) {
      horizontalCount += Math.abs(v.horizontal);
      verticalCount += Math.abs(v.vertical);
      var pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);
      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl".concat(i),
        className: prefix("control", "border-radius"),
        "data-radius-index": i,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(zoom, ")")
        }
      });
    });
  },
  dragControlCondition: function (moveable, e) {
    if (!e.inputEvent || e.isRequest) {
      return false;
    }

    var className = e.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function (moveable, e) {
    var inputEvent = e.inputEvent,
        datas = e.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;

    if (!isControl && !isLine) {
      return false;
    }

    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e, {}));

    if (result === false) {
      return false;
    }

    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e);
    var _a = moveable.props,
        roundRelative = _a.roundRelative,
        _b = _a.minRoundControls,
        minRoundControls = _b === void 0 ? [0, 0] : _b;
    var state = moveable.state;
    var target = state.target,
        width = state.width,
        height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }

    var index = datas.controlIndex;
    var controlPoses = datas.controlPoses;

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var dist = [distX, distY];
    var delta = minus(dist, datas.prevDist);
    var _b = moveable.props.maxRoundControls,
        maxRoundControls = _b === void 0 ? [4, 4] : _b;
    var _c = moveable.state,
        width = _c.width,
        height = _c.height;
    var selectedControlPose = controlPoses[index];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal; // 0: [0, 1, 2, 3] maxCount === 1
    // 0: [0, 2] maxCount === 2
    // 1: [1, 3] maxCount === 2
    // 0: [0] maxCount === 3
    // 1: [1, 3] maxCount === 3

    var dists = controlPoses.map(function (pose) {
      var horizontal = pose.horizontal,
          vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];

      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }

      return [0, 0];
    });
    dists[index] = dist;
    var nextPoses = controlPoses.map(function (pos, i) {
      return plus(pos.pos, dists[i]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e.datas,
        isDouble = e.isDouble;

    if (!datas.isRound) {
      return false;
    }

    var width = state.width,
        height = state.height;
    var isControl = datas.isControl,
        controlIndex = datas.controlIndex,
        isLine = datas.isLine,
        lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function (pos) {
      return pos.pos;
    });
    var length = poses.length;
    var _a = moveable.props.roundClickable,
        roundClickable = _a === void 0 ? true : _a;

    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b = calculatePointerDist(moveable, e),
            distX = _b[0],
            distY = _b[1];

        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }

      if (length !== controlPoses.length) {
        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);
      }
    }

    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function (moveable) {
    moveable.state.borderRadiusState = "";
  }
};
/**
 * Whether to show and drag or double click border-radius, (default: false)
 * @name Moveable.Roundable#roundable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px
 * @name Moveable.Roundable#roundRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])
 * @name Moveable.Roundable#minRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     minRoundControls: [0, 0],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])
 * @name Moveable.Roundable#maxRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     maxRoundControls: [4, 4],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)
 * @name Moveable.Roundable#roundClickable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     roundClickable: true,
 * });
 * moveable.roundClickable = false;
 */

/**
 * When drag start the clip area or controls, the `roundStart` event is called.
 * @memberof Moveable.Roundable
 * @event roundStart
 * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag or double click the border area or controls, the `round` event is called.
 * @memberof Moveable.Roundable
 * @event round
 * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the border area or controls, the `roundEnd` event is called.
 * @memberof Moveable.Roundable
 * @event roundEnd
 * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

function isIdentityMatrix(matrix, is3d) {
  var value = is3d ? "matrix3d(".concat(createIdentityMatrix(4)) : "matrix(".concat(createIdentityMatrix(3), ")");
  return matrix === value || matrix === "matrix(1,0,0,1,0,0)";
}

var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function (moveable, e) {
    var _a = moveable.state,
        is3d = _a.is3d,
        target = _a.target,
        targetMatrix = _a.targetMatrix;
    var transform = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(".concat(targetMatrix.join(","), ")") : "matrix(".concat(convertMatrixtoCSS(targetMatrix, true), ")");
    var startTransform = !transform || transform === "none" ? cssMatrix : transform;
    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);
  },
  resetTransform: function (e) {
    e.datas.nextTransforms = e.datas.startTransforms;
    e.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function (moveable, e) {
    return fillParams(moveable, e, {
      setTransform: function (transform) {
        e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function (moveable, e) {
    this.setTransform(moveable, e);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e));
  },
  drag: function (moveable, e) {
    this.resetTransform(e);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function (moveable, e) {
    var _this = this;

    this.dragStart(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.setTransform(childMoveable, childEvent);

      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      setTransform: function () {},
      events: params
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    this.drag(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.resetTransform(childEvent);

      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  }
};
var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function (moveable, e) {
    triggerEvent(moveable, "onRender", this.fillDragParams(moveable, e));
  },
  dragAfter: function (moveable, e) {
    if (e.resultCount) {
      return this.drag(moveable, e);
    }
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onRenderEnd", this.fillDragEndParams(moveable, e));
  },
  dragGroupStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      transform: getNextTransformText(e),
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragEndParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlAfter: function (moveable, e) {
    return this.dragAfter(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      transform: getNextTransformText(e)
    });
  },
  fillDragEndParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    });
  }
};

function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e.isRequest;

  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {
    return false;
  } // "drag" "Control" "After"


  var eventName = "".concat(eventOperation).concat(eventAffix).concat(eventType);
  var conditionName = "".concat(eventOperation).concat(eventAffix, "Condition");
  var isEnd = eventType === "End";
  var isAfter = eventType === "After";
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());

  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }

  if (eventType === "" && !isRequest) {
    convertDragDist(moveable.state, e);
  } // const isGroup = eventAffix.indexOf("Group") > -1;


  var ables = __spreadArray([], moveable[ableType], true);

  if (isRequest) {
    var requestAble_1 = e.requestAble;

    if (!ables.some(function (able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function (able) {
        return able.name === requestAble_1;
      }));
    }
  }

  if (!ables.length) {
    return false;
  }

  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables, true), [Renderable], false).filter(function (able) {
    return able[eventName];
  });

  var datas = e.datas;

  if (isFirstStart) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  var inputEvent = e.inputEvent;
  var inputTarget;

  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;
  }

  var resultCount = 0;
  var results = eventAbles.filter(function (able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});

    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);
    }

    if (nextDatas.isEventStart) {
      var result = able[eventName](moveable, __assign$2(__assign$2({}, e), {
        resultCount: resultCount,
        datas: nextDatas,
        originalDatas: datas,
        inputTarget: inputTarget
      }));

      moveable._emitter.off();

      if (isStart && result === false) {
        nextDatas.isEventStart = false;
      }

      resultCount += result ? 1 : 0;
      return result;
    }

    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = false; // end ables

  if (isStart && eventAbles.length && !isUpdate) {
    isForceEnd = eventAbles.filter(function (able) {
      var ableName = able.name;
      var nextDatas = datas[ableName];

      if (nextDatas.isEventStart) {
        if (able.dragRelation === "strong") {
          // cancel drag
          nextDatas.isEventStart = false;
          return false;
        } // start drag


        return true;
      } // cancel event


      return false;
    }).length === 0;
  }

  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;

    if (moveable.moveables) {
      moveable.moveables.forEach(function (childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }

  if (isFirstStart && isForceEnd) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  if (isStart && !isRequest && isUpdate) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
  }

  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }

  if (!isStart && isUpdate && !requestInstant || isEnd) {
    var flushSync = moveable.props.flushSync || defaultSync;
    flushSync(function () {
      moveable.updateRect(isEnd ? eventType : "", true, false);
      moveable.forceUpdate();
    });
  }

  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }

  return true;
}

function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);

  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }

  var startFunc = function (e) {
    var eventTarget = e.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || hasClass(eventTarget, "moveable-area") || hasClass(eventTarget, "moveable-padding");
  };

  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}

function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }

  var _a = moveable.props,
      pinchOutside = _a.pinchOutside,
      pinchThreshold = _a.pinchThreshold;
  var options = {
    preventDefault: false,
    preventRightClick: true,
    preventWheelClick: true,
    container: window,
    pinchThreshold: pinchThreshold,
    pinchOutside: pinchOutside
  };
  var gesto = new Gesto$1(target, options);
  ["drag", "pinch"].forEach(function (eventOperation) {
    ["Start", "", "End"].forEach(function (eventType) {
      gesto.on("".concat(eventOperation).concat(eventType), function (e) {
        var eventName = e.eventType;

        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {
          e.stop();
          return;
        }

        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);

        if (!result) {
          e.stop();
        }
      });
    });
  });
  return gesto;
}

var EventManager = /*#__PURE__*/function () {
  function EventManager(target, moveable, eventName) {
    var _this = this;

    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];

    this._onEvent = function (e) {
      var eventName = _this.eventName;
      var moveable = _this.moveable;

      if (moveable.state.disableNativeEvent) {
        return;
      }

      _this.ables.forEach(function (able) {
        able[eventName](moveable, {
          inputEvent: e
        });
      });
    };

    target.addEventListener(eventName.toLowerCase(), this._onEvent);
  }

  var __proto = EventManager.prototype;

  __proto.setAbles = function (ables) {
    this.ables = ables;
  };

  __proto.destroy = function () {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent);
    this.target = null;
    this.moveable = null;
  };

  return EventManager;
}();

var MoveableManager$1 = /*#__PURE__*/function (_super) {
  __extends$1(MoveableManager, _super);

  function MoveableManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = __assign$2({
      container: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this._emitter = new EventEmitter$1$1();
    _this._prevTarget = null;
    _this._prevDragArea = false;
    _this._observer = null;
    _this._observerId = 0;

    _this.onPreventClick = function (e) {
      e.stopPropagation();
      e.preventDefault();
      removeEvent(window, "click", _this.onPreventClick, true);
    };

    _this.checkUpdateRect = function () {
      if (_this.isDragging()) {
        return;
      }

      var parentMoveable = _this.props.parentMoveable;

      if (parentMoveable) {
        parentMoveable.checkUpdateRect();
        return;
      }

      cancelAnimationFrame(_this._observerId);
      _this._observerId = requestAnimationFrame$1(function () {
        if (_this.isDragging()) {
          return;
        }

        _this.updateRect();
      });
    };

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.render = function () {
    var props = this.props;
    var state = this.state;
    var parentPosition = props.parentPosition,
        className = props.className,
        propsTarget = props.target,
        zoom = props.zoom,
        cspNonce = props.cspNonce,
        translateZ = props.translateZ,
        ControlBoxElement = props.cssStyled,
        portalContainer = props.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();

    var _a = parentPosition || {
      left: 0,
      top: 0
    },
        parentLeft = _a.left,
        parentTop = _a.top;

    var left = state.left,
        top = state.top,
        stateTarget = state.target,
        direction = state.direction,
        hasFixed = state.hasFixed;
    var groupTargets = props.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    this.getEnabledAbles().forEach(function (able) {
      ableAttributes["data-able-".concat(able.name.toLowerCase())] = true;
    });
    return createElement(ControlBoxElement, __assign$2({
      cspNonce: cspNonce,
      ref: ref(this, "controlBox"),
      className: "".concat(prefix("control-box", direction === -1 ? "reverse" : "", isDragging ? "dragging" : ""), " ").concat(className)
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer: portalContainer,
      style: {
        "position": hasFixed ? "fixed" : "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(".concat(left - parentLeft, "px, ").concat(top - parentTop, "px, ").concat(translateZ, ")"),
        "--zoom": zoom,
        "--zoompx": "".concat(zoom, "px")
      }
    }), this.renderAbles(), this._renderLines());
  };

  __proto.componentDidMount = function () {
    this.isUnmounted = false;
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable,
        container = props.container,
        wrapperMoveable = props.wrapperMoveable;

    this._updateTargets();

    this._updateNativeEvents();

    this._updateEvents();

    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }

    this.updateCheckInput();

    this._updateObserver(this.props);
  };

  __proto.componentDidUpdate = function (prevProps) {
    this._updateNativeEvents();

    this._updateEvents();

    this._updateTargets();

    this.updateCheckInput();

    this._updateObserver(prevProps);
  };

  __proto.componentWillUnmount = function () {
    this.isUnmounted = true;

    this._emitter.off();

    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events = this.events;

    for (var name in events) {
      var manager = events[name];
      manager && manager.destroy();
    }
  };

  __proto.getContainer = function () {
    var _a = this.props,
        parentMoveable = _a.parentMoveable,
        wrapperMoveable = _a.wrapperMoveable,
        container = _a.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */


  __proto.isMoveableElement = function (target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */


  __proto.dragStart = function (e) {
    var targetGesto = this.targetGesto;

    if (targetGesto && !targetGesto.isFlag()) {
      targetGesto.triggerDragStart(e);
    }

    return this;
  };
  /**
   * Hit test an element or rect on a moveable target.
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */


  __proto.hitTest = function (el) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return 0;
    }

    var rect;

    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign$2({
        width: 0,
        height: 0
      }, el);
    }

    var rectLeft = rect.left,
        rectTop = rect.top,
        rectWidth = rect.width,
        rectHeight = rect.height;
    var points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);
    var size = getOverlapSize(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = getAreaSize(points);

    if (!size || !totalSize) {
      return 0;
    }

    return Math.min(100, size / totalSize * 100);
  };
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */


  __proto.isInside = function (clientX, clientY) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return false;
    }

    return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));
  };
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */


  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    var props = this.props;
    var parentMoveable = props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */


  __proto.isDragging = function () {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * @method Moveable#updateTarget
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */


  __proto.updateTarget = function (type) {
    this.updateRect(type, true);
  };
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */


  __proto.getRect = function () {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0],
        pos2 = poses[1],
        pos3 = poses[2],
        pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width,
        offsetHeight = state.height;
    var width = rect.width,
        height = rect.height,
        left = rect.left,
        top = rect.top;
    var statePos = [state.left, state.top];
    var origin = plus(statePos, state.origin);
    var beforeOrigin = plus(statePos, state.beforeOrigin);
    var transformOrigin = state.transformOrigin;
    return {
      width: width,
      height: height,
      left: left,
      top: top,
      pos1: pos1,
      pos2: pos2,
      pos3: pos3,
      pos4: pos4,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      beforeOrigin: beforeOrigin,
      origin: origin,
      transformOrigin: transformOrigin,
      rotation: this.getRotation()
    };
  };
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */


  __proto.getManager = function () {
    return this;
  };

  __proto.getRotation = function () {
    var _a = this.state,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        direction = _a.direction;
    return getAbsoluteRotation(pos1, pos2, direction);
  };
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */


  __proto.request = function (ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }

    var _a = this.props,
        ables = _a.ables,
        groupable = _a.groupable;
    var requsetAble = ables.filter(function (able) {
      return able.name === ableName;
    })[0];

    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function () {
          return this;
        },
        requestEnd: function () {
          return this;
        }
      };
    }

    var self = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = "".concat(groupable ? "Group" : "").concat(ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function (ableParam) {
        triggerAble(self, ableType, "drag", eventAffix, "", __assign$2(__assign$2({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function () {
        triggerAble(self, ableType, "drag", eventAffix, "End", __assign$2(__assign$2({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self, ableType, "drag", eventAffix, "Start", __assign$2(__assign$2({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */


  __proto.destroy = function () {
    this.componentWillUnmount();
  };

  __proto.updateRenderPoses = function () {
    var state = this.state;
    var props = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin,
        transformOrigin = state.transformOrigin,
        allMatrix = state.allMatrix,
        is3d = state.is3d,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        stateLeft = state.left,
        stateTop = state.top;

    var _a = props.padding || {},
        _b = _a.left,
        left = _b === void 0 ? 0 : _b,
        _c = _a.top,
        top = _c === void 0 ? 0 : _c,
        _d = _a.bottom,
        bottom = _d === void 0 ? 0 : _d,
        _e = _a.right,
        right = _e === void 0 ? 0 : _e;

    var n = is3d ? 4 : 3;
    var absoluteOrigin = props.groupable ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];
  };

  __proto.checkUpdate = function () {
    var _a = this.props,
        target = _a.target,
        container = _a.container,
        parentMoveable = _a.parentMoveable;
    var _b = this.state,
        stateTarget = _b.target,
        stateContainer = _b.container;

    if (!stateTarget && !target) {
      return;
    }

    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);

    if (!isChanged) {
      return;
    }

    var moveableContainer = container || this.controlBox;

    if (moveableContainer) {
      this.unsetAbles();
    }

    this.updateState({
      target: target,
      container: container
    });

    if (!parentMoveable && moveableContainer) {
      this.updateRect("End", false, false);
    }
  };

  __proto.triggerEvent = function (name, e) {
    this._emitter.trigger(name, e);

    var callback = this.props[name];
    return callback && callback(e);
  };

  __proto.useCSS = function (tag, css) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css;

    if (!customStyleMap[key]) {
      customStyleMap[key] = styled(tag, css);
    }

    return customStyleMap[key];
  };

  __proto.unsetAbles = function () {
    var _this = this;

    this.targetAbles.forEach(function (able) {
      if (able.unset) {
        able.unset(_this);
      }
    });
  };

  __proto.updateAbles = function (ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }

    if (eventAffix === void 0) {
      eventAffix = "";
    }

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function (able) {
      return able && (able.always && props[able.name] !== false || props[able.name]);
    });
    var dragStart = "drag".concat(eventAffix, "Start");
    var pinchStart = "pinch".concat(eventAffix, "Start");
    var dragControlStart = "drag".concat(eventAffix, "ControlStart");
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };

  __proto.updateState = function (nextState, isSetState) {
    if (isSetState) {
      if (this.isUnmounted) {
        return;
      }

      this.setState(nextState);
    } else {
      var state = this.state;

      for (var name in nextState) {
        state[name] = nextState[name];
      }
    }
  };

  __proto.getEnabledAbles = function () {
    var props = this.props;
    var ables = props.ables;
    return ables.filter(function (able) {
      return able && props[able.name];
    });
  };

  __proto.renderAbles = function () {
    var _this = this;

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var Renderer = {
      createElement: createElement
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function (_a) {
      var render = _a.render;
      return render(_this, Renderer) || [];
    })).filter(function (el) {
      return el;
    }), function (_a) {
      var key = _a.key;
      return key;
    }).map(function (group) {
      return group[0];
    });
  };

  __proto.updateCheckInput = function () {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };

  __proto._updateObserver = function (prevProps) {
    var _a;

    var props = this.props;
    var target = props.target;

    if (!window.ResizeObserver || !target || !props.useResizeObserver) {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
      return;
    }

    if (prevProps.target === target && this._observer) {
      return;
    }

    var observer = new ResizeObserver(this.checkUpdateRect);
    observer.observe(target, {
      box: "border-box"
    });
    this._observer = observer;
    return;
  };

  __proto._updateEvents = function () {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props = this.props;
    var target = props.dragTarget || props.target;

    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);

    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }

    if (!hasControlAble) {
      unset(this, "controlGesto");
    }

    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }

    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
  };

  __proto._updateTargets = function () {
    var props = this.props;
    this._prevTarget = props.dragTarget || props.target;
    this._prevDragArea = props.dragArea;
  };

  __proto._renderLines = function () {
    var props = this.props;
    var edge = props.edge,
        zoom = props.zoom,
        hideDefaultLines = props.hideDefaultLines;

    if (hideDefaultLines) {
      return [];
    }

    var renderPoses = this.state.renderPoses;
    var Renderer = {
      createElement: createElement
    };
    return [renderLine(Renderer, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3)];
  };

  __proto._isTargetChanged = function (useDragArea) {
    var props = this.props;
    var target = props.dragTarget || props.target;
    var prevTarget = this._prevTarget;
    var prevDragArea = this._prevDragArea;
    var dragArea = props.dragArea; // check target without dragArea

    var isTargetChanged = !dragArea && prevTarget !== target;
    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;
    return isTargetChanged || isDragAreaChanged;
  };

  __proto._updateNativeEvents = function () {
    var _this = this;

    var props = this.props;
    var target = props.dragArea ? this.areaElement : this.state.target;
    var events = this.events;
    var eventKeys = getKeys(events);

    if (this._isTargetChanged()) {
      for (var eventName in events) {
        var manager = events[eventName];
        manager && manager.destroy();
        events[eventName] = null;
      }
    }

    if (!target) {
      return;
    }

    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function (eventName) {
      var ables = filterAbles(enabledAbles, [eventName]);
      var hasAbles = ables.length > 0;
      var manager = events[eventName];

      if (!hasAbles) {
        if (manager) {
          manager.destroy();
          events[eventName] = null;
        }

        return;
      }

      if (!manager) {
        manager = new EventManager(target, _this, eventName);
        events[eventName] = manager;
      }

      manager.setAbles(ables);
    });
  };

  MoveableManager.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: false,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    hideDefaultLines: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    flushSync: defaultSync
  };
  return MoveableManager;
}(PureComponent);
/**
 * The target to indicate Moveable Control Box.
 * @name Moveable#target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 */

/**
 * Zooms in the elements of a moveable.
 * @name Moveable#zoom
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.zoom = 2;
 */

/**
 * Whether the target size is detected and updated whenever it changes.
 * @name Moveable#zoom
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.useResizeObserver = true;
 */

/**
 * Resize, Scale Events at edges
 * @name Moveable#edge
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.edge = true;
 */

/**
 * You can specify the className of the moveable controlbox.
 * @name Moveable#className
 * @default ""
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   className: "",
 * });
 *
 * moveable.className = "moveable1";
 */

/**
 * The target(s) to drag Moveable target(s)
 * @name Moveable#dragTarget
 * @default target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 * moveable.dragTarget = document.querySelector(".dragTarget");
 */

/**
 * `renderStart` event occurs at the first start of all events.
 * @memberof Moveable
 * @event renderStart
 * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderStart", ({ target }) => {
 *     console.log("onRenderStart", target);
 * });
 */

/**
 * `render` event occurs before the target is drawn on the screen.
 * @memberof Moveable
 * @event render
 * @param {Moveable.OnRender} - Parameters for the `render` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("render", ({ target }) => {
 *     console.log("onRender", target);
 * });
 */

/**
 * `renderEnd` event occurs at the end of all events.
 * @memberof Moveable
 * @event renderEnd
 * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderEnd", ({ target }) => {
 *     console.log("onRenderEnd", target);
 * });
 */

/**
 * `renderGroupStart` event occurs at the first start of all events in group.
 * @memberof Moveable
 * @event renderGroupStart
 * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupStart", ({ targets }) => {
 *     console.log("onRenderGroupStart", targets);
 * });
 */

/**
 * `renderGroup` event occurs before the target is drawn on the screen in group.
 * @memberof Moveable
 * @event renderGroup
 * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroup", ({ targets }) => {
 *     console.log("onRenderGroup", targets);
 * });
 */

/**
 * `renderGroupEnd` event occurs at the end of all events in group.
 * @memberof Moveable
 * @event renderGroupEnd
 * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupEnd", ({ targets }) => {
 *     console.log("onRenderGroupEnd", targets);
 * });
 */


var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function (moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a = moveable.state,
        left = _a.left,
        top = _a.top;
    var position = {
      left: left,
      top: top
    };
    var props = moveable.props;
    return targets.map(function (target, i) {
      return React.createElement(MoveableManager$1, {
        key: "moveable" + i,
        ref: refs(moveable, "moveables", i),
        target: target,
        origin: false,
        cssStyled: props.cssStyled,
        customStyledMap: props.customStyledMap,
        useResizeObserver: props.useResizeObserver,
        parentMoveable: moveable,
        parentPosition: position
      });
    });
  }
};
var Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean,
    preventClickDefault: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    if (!e.isRequest) {
      addEvent(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function (moveable, e) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    var isMoveableElement = moveable.isMoveableElement(inputTarget);
    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);

    if (!moveable.props.preventClickDefault && !e.isDrag || containsElement) {
      this.unset(moveable);
    }

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement // External event duplicate target or dragAreaElement
    ) {
      return;
    }

    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      isDouble: e.isDouble,
      inputTarget: inputTarget,
      isTarget: target === inputTarget,
      containsTarget: containsTarget
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.endEvent(moveable);
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement
    || e.datas.inputTarget === inputTarget) {
      return;
    }

    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;

    if (targetIndex === -1) {
      targetIndex = findIndex(targets, function (parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }

    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      isDouble: e.isDouble,
      targets: targets,
      inputTarget: inputTarget,
      targetIndex: targetIndex,
      isTarget: isTarget,
      containsTarget: containsTarget
    }));
  },
  dragControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  endEvent: function (moveable) {
    var _this = this;

    requestAnimationFrame$1(function () {
      _this.unset(moveable);
    });
  },
  unset: function (moveable) {
    removeEvent(window, "click", moveable.onPreventClick, true);
  }
});
/**
 * When you click on the element, the `click` event is called.
 * @memberof Moveable
 * @event click
 * @param {Moveable.OnClick} - Parameters for the `click` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("click", ({ hasTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", target, hasTarget, containsTarget, targetIndex);
 * });
 */

/**
 * When you click on the element inside the group, the `clickGroup` event is called.
 * @memberof Moveable
 * @event clickGroup
 * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("clickGroup", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", inputTarget, isTarget, containsTarget, targetIndex);
 * });
 */

function getDraggableEvent(e) {
  var datas = e.originalDatas.draggable;

  if (!datas) {
    e.originalDatas.draggable = {};
    datas = e.originalDatas.draggable;
  }

  return __assign$2(__assign$2({}, e), {
    datas: datas
  });
}

var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return hasClass(target, prefix("direction")) && hasClass(target, prefix("line"));
  },
  dragControlStart: function (moveable, e) {
    return Draggable$1.dragStart(moveable, getDraggableEvent(e));
  },
  dragControl: function (moveable, e) {
    return Draggable$1.drag(moveable, getDraggableEvent(e));
  },
  dragControlEnd: function (moveable, e) {
    return Draggable$1.dragEnd(moveable, getDraggableEvent(e));
  },
  dragGroupControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return hasClass(target, prefix("direction")) && hasClass(target, prefix("line"));
  },
  dragGroupControlStart: function (moveable, e) {
    return Draggable$1.dragGroupStart(moveable, getDraggableEvent(e));
  },
  dragGroupControl: function (moveable, e) {
    return Draggable$1.dragGroup(moveable, getDraggableEvent(e));
  },
  dragGroupControlEnd: function (moveable, e) {
    return Draggable$1.dragGroupEnd(moveable, getDraggableEvent(e));
  },
  unset: function (moveable) {
    return Draggable$1.unset(moveable);
  }
});
/**
 * Whether to move by dragging the edge line (default: false)
 * @name Moveable.Draggable#edgeDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  draggable: true,
 *  edgeDraggable: false,
 * });
 *
 * moveable.edgeDraggable = true;
 */

var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};
var MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable$1, edgeDraggable, Rotatable$1, Resizable$1, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign$2(__assign$2({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign$2(__assign$2({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);

function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }

  var moveablePoses = moveables.map(function (_a) {
    var state = _a.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = throttle(rotation, TINY_NUM);

  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function (poses) {
      poses.forEach(function (pos) {
        // ax + b = y
        // b = y - ax
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function (b1) {
      // a1x + b1 = a2x + b2
      b2MinMax_1.forEach(function (b2) {
        // (a1 - a2)x = b2 - b1
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function (_a) {
      var pos1 = _a[0],
          pos2 = _a[1],
          pos3 = _a[2],
          pos4 = _a[3];
      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;

    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }

  return [minX, minY, groupWidth, groupHeight];
}
/**
 * @namespace Moveable.Group
 * @description You can make targets moveable.
 */


var MoveableGroup = /*#__PURE__*/function (_super) {
  __extends$1(MoveableGroup, _super);

  function MoveableGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.differ = new ChildrenDiffer$1();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }

  var __proto = MoveableGroup.prototype;

  __proto.checkUpdate = function () {
    this.updateAbles();
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    if (!this.controlBox) {
      return;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;

    if (!isTarget || type !== "" && props.updateGroup) {
      // reset rotataion
      this.rotation = props.defaultGroupRotate;
      this.transformOrigin = props.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }

    var rotation = this.rotation;
    var scale = this.scale;

    var _a = getGroupRect(this.moveables, rotation),
        left = _a[0],
        top = _a[1],
        width = _a[2],
        height = _a[3]; // tslint:disable-next-line: max-line-length


    var transform = "rotate(".concat(rotation, "deg) scale(").concat(scale[0] >= 0 ? 1 : -1, ", ").concat(scale[1] >= 0 ? 1 : -1, ")");
    target.style.cssText += "left:0px;top:0px; transform-origin: ".concat(this.transformOrigin, "; width:").concat(width, "px; height:").concat(height, "px;") + "transform:".concat(transform);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];

    var _b = getAbsolutePosesByState(info),
        pos1 = _b[0],
        pos2 = _b[1],
        pos3 = _b[2],
        pos4 = _b[3]; // info.left + info.pos(1 ~ 4)


    var minPos = getMinMaxs([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = minus(pos1, delta);
    info.pos2 = minus(pos2, delta);
    info.pos3 = minus(pos3, delta);
    info.pos4 = minus(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = minus(plus(pos, info.origin), delta);
    info.beforeOrigin = minus(plus(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin); // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);

    var clientRect = info.targetClientRect;
    var direction = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(".concat(-delta[0], "px, ").concat(-delta[1], "px) ").concat(transform);
    this.updateState(__assign$2(__assign$2({}, info), {
      direction: direction,
      beforeDirection: direction
    }), isSetState);
  };

  __proto.getRect = function () {
    return __assign$2(__assign$2({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.triggerEvent = function (name, e, isManager) {
    if (isManager || name.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name, e);
    } else {
      this._emitter.trigger(name, e);
    }
  };

  __proto.updateAbles = function () {
    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, true), [Groupable], false), "Group");
  };

  __proto._updateTargets = function () {
    _super.prototype._updateTargets.call(this);

    this._prevTarget = this.props.dragTarget || this.areaElement;
  };

  __proto._updateEvents = function () {
    var state = this.state;
    var props = this.props;
    var prevTarget = this._prevTarget;
    var nextTarget = props.dragTarget || this.areaElement;

    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }

    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
    }

    if (state.target) {
      if (!this.targetGesto) {
        this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      }

      if (!this.controlGesto) {
        this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
      }
    }

    var isContainerChanged = !equals(state.container, props.container);

    if (isContainerChanged) {
      state.container = props.container;
    }

    var _a = this.differ.update(props.targets),
        added = _a.added,
        changed = _a.changed,
        removed = _a.removed;

    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };

  __proto._updateObserver = function () {};

  MoveableGroup.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup;
}(MoveableManager$1);
/**
 * @namespace Moveable.IndividualGroup
 * @description Create targets individually, not as a group.Create targets individually, not as a group.
 */


var MoveableIndividualGroup = /*#__PURE__*/function (_super) {
  __extends$1(MoveableIndividualGroup, _super);

  function MoveableIndividualGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.moveables = [];
    return _this;
  }

  var __proto = MoveableIndividualGroup.prototype;

  __proto.render = function () {
    var _this = this;

    var _a = this.props,
        cspNonce = _a.cspNonce,
        ControlBoxElement = _a.cssStyled,
        targets = _a.targets;
    return createElement(ControlBoxElement, {
      cspNonce: cspNonce,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, targets.map(function (target, i) {
      return createElement(MoveableManager$1, __assign$2({
        key: "moveable" + i,
        ref: refs(_this, "moveables", i)
      }, _this.props, {
        target: target,
        wrapperMoveable: _this
      }));
    }));
  };

  __proto.componentDidUpdate = function () {};

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };

  __proto.getRect = function () {
    return __assign$2(__assign$2({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.request = function () {
    return {
      request: function () {
        return this;
      },
      requestEnd: function () {
        return this;
      }
    };
  };

  __proto.dragStart = function () {
    return this;
  };

  __proto.hitTest = function () {
    return 0;
  };

  __proto.isInside = function () {
    return false;
  };

  __proto.isDragging = function () {
    return false;
  };

  __proto.updateRenderPoses = function () {};

  __proto.checkUpdate = function () {};

  __proto.triggerEvent = function () {};

  __proto.updateAbles = function () {};

  __proto._updateEvents = function () {};

  __proto._updateObserver = function () {};

  return MoveableIndividualGroup;
}(MoveableManager$1);

var InitialMoveable = /*#__PURE__*/function (_super) {
  __extends$1(InitialMoveable, _super);

  function InitialMoveable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }

  var __proto = InitialMoveable.prototype;

  InitialMoveable.makeStyled = function () {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function (_a) {
      var css = _a.css;

      if (!css) {
        return;
      }

      css.forEach(function (text) {
        cssMap[text] = true;
      });
    });
    var style = getKeys(cssMap).join("\n");
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + style));
  };

  InitialMoveable.getTotalAbles = function () {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, true);
  };

  __proto.render = function () {
    var moveableContructor = this.constructor;

    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }

    var _a = this.props,
        userAbles = _a.ables,
        userProps = _a.props,
        props = __rest(_a, ["ables", "props"]);

    var refTargets = this._updateRefs(true);

    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();

    var ables = __spreadArray(__spreadArray([], totalAbles, true), userAbles || [], true);

    var nextProps = __assign$2(__assign$2(__assign$2({}, props), userProps || {}), {
      ables: ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });

    if (isGroup) {
      if (props.individualGroupable) {
        return createElement(MoveableIndividualGroup, __assign$2({
          key: "individual-group",
          ref: ref(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }

      return createElement(MoveableGroup, __assign$2({
        key: "group",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return createElement(MoveableManager$1, __assign$2({
        key: "single",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };

  __proto.componentDidMount = function () {
    this._updateRefs();
  };

  __proto.componentDidUpdate = function () {
    this._updateRefs();
  };

  __proto.componentWillUnmount = function () {
    this.selectorMap = {};
    this.refTargets = [];
  };

  __proto.getManager = function () {
    return this.moveable;
  };

  __proto._updateRefs = function (isRender) {
    var prevRefTargets = this.refTargets;
    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);
    var isBrowser = typeof document !== "undefined";
    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function (target, i) {
      var nextTarget = nextRefTargets[i];

      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }

      return false;
    });
    var selectorMap = this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function (target) {
      if (isString(target)) {
        var selectorTarget = selectorMap[target];

        if (selectorTarget) {
          nextSelectorMap[target] = selectorMap[target];
        } else if (isBrowser) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        }
      }
    });
    this.refTargets = nextRefTargets;
    this.selectorMap = nextSelectorMap;

    if (!isRender && isUpdate) {
      this.forceUpdate();
    }

    return nextRefTargets;
  };

  InitialMoveable.defaultAbles = [];
  InitialMoveable.customStyledMap = {};
  InitialMoveable.defaultStyled = null;

  __decorate$1([withMethods(MOVEABLE_METHODS)], InitialMoveable.prototype, "moveable", void 0);

  return InitialMoveable;
}(PureComponent);

var Moveable$1 = /*#__PURE__*/function (_super) {
  __extends$1(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Moveable.defaultAbles = MOVEABLE_ABLES;
  return Moveable;
}(InitialMoveable);

var Moveable$2 = Moveable$1;

/*
Copyright (c) 2019 Daybrush
name: moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/moveable
version: 0.30.0
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var InnerMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InnerMoveable, _super);

  function InnerMoveable(props) {
    var _this = _super.call(this, props) || this;

    _this.state = {};
    _this.state = _this.props;
    return _this;
  }

  var __proto = InnerMoveable.prototype;

  __proto.render = function () {
    return createPortal(createElement(Moveable$2, __assign$1({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  };

  return InnerMoveable;
}(Component);

var PROPERTIES = MOVEABLE_PROPS;
var METHODS = MOVEABLE_METHODS;
var EVENTS = MOVEABLE_EVENTS;

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

var EventEmitter$1 = EventEmitter;

/**
 * Moveable is Draggable! Resizable! Scalable! Rotatable!
 * @sort 1
 * @alias Moveable
 * @extends EventEmitter
 */

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);
  /**
   *
   */


  function MoveableManager(parentElement, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.tempElement = document.createElement("div");

    var nextOptions = __assign$1({}, options);

    var events = {};
    EVENTS.forEach(function (name) {
      events[camelize("on ".concat(name))] = function (e) {
        return _this.trigger(name, e);
      };
    });
    render(createElement(InnerMoveable, __assign$1({
      ref: ref(_this, "innerMoveable"),
      parentElement: parentElement
    }, nextOptions, events)), _this.tempElement);
    var target = nextOptions.target;

    if (isArray(target) && target.length > 1) {
      _this.updateRect();
    }

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.setState = function (state, callback) {
    this.innerMoveable.setState(state, callback);
  };

  __proto.forceUpdate = function (callback) {
    this.innerMoveable.forceUpdate(callback);
  };

  __proto.dragStart = function (e) {
    var innerMoveable = this.innerMoveable;

    if (innerMoveable.$_timer) {
      this.forceUpdate();
    }

    this.getMoveable().dragStart(e);
  };

  __proto.destroy = function () {
    render(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };

  __proto.getMoveable = function () {
    return this.innerMoveable.moveable;
  };

  MoveableManager = __decorate([Properties(METHODS, function (prototype, property) {
    if (prototype[property]) {
      return;
    }

    prototype[property] = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var self = this.getMoveable();

      if (!self || !self[property]) {
        return;
      }

      return self[property].apply(self, args);
    };
  }), Properties(PROPERTIES, function (prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function () {
        return this.getMoveable().props[property];
      },
      set: function (value) {
        var _a;

        this.setState((_a = {}, _a[property] = value, _a));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager);
  return MoveableManager;
}(EventEmitter$1);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Moveable;
}(MoveableManager);

var loadImage = {exports: {}};

/*
 * JavaScript Load Image
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function ($) {

  var urlAPI = $.URL || $.webkitURL;

  /**
   * Creates an object URL for a given File object.
   *
   * @param {Blob} blob Blob object
   * @returns {string|boolean} Returns object URL if API exists, else false.
   */
  function createObjectURL(blob) {
    return urlAPI ? urlAPI.createObjectURL(blob) : false
  }

  /**
   * Revokes a given object URL.
   *
   * @param {string} url Blob object URL
   * @returns {undefined|boolean} Returns undefined if API exists, else false.
   */
  function revokeObjectURL(url) {
    return urlAPI ? urlAPI.revokeObjectURL(url) : false
  }

  /**
   * Helper function to revoke an object URL
   *
   * @param {string} url Blob Object URL
   * @param {object} [options] Options object
   */
  function revokeHelper(url, options) {
    if (url && url.slice(0, 5) === 'blob:' && !(options && options.noRevoke)) {
      revokeObjectURL(url);
    }
  }

  /**
   * Loads a given File object via FileReader interface.
   *
   * @param {Blob} file Blob object
   * @param {Function} onload Load event callback
   * @param {Function} [onerror] Error/Abort event callback
   * @param {string} [method=readAsDataURL] FileReader method
   * @returns {FileReader|boolean} Returns FileReader if API exists, else false.
   */
  function readFile(file, onload, onerror, method) {
    if (!$.FileReader) return false
    var reader = new FileReader();
    reader.onload = function () {
      onload.call(reader, this.result);
    };
    if (onerror) {
      reader.onabort = reader.onerror = function () {
        onerror.call(reader, this.error);
      };
    }
    var readerMethod = reader[method || 'readAsDataURL'];
    if (readerMethod) {
      readerMethod.call(reader, file);
      return reader
    }
  }

  /**
   * Cross-frame instanceof check.
   *
   * @param {string} type Instance type
   * @param {object} obj Object instance
   * @returns {boolean} Returns true if the object is of the given instance.
   */
  function isInstanceOf(type, obj) {
    // Cross-frame instanceof check
    return Object.prototype.toString.call(obj) === '[object ' + type + ']'
  }

  /**
   * @typedef { HTMLImageElement|HTMLCanvasElement } Result
   */

  /**
   * Loads an image for a given File object.
   *
   * @param {Blob|string} file Blob object or image URL
   * @param {Function|object} [callback] Image load event callback or options
   * @param {object} [options] Options object
   * @returns {HTMLImageElement|FileReader|Promise<Result>} Object
   */
  function loadImage(file, callback, options) {
    /**
     * Promise executor
     *
     * @param {Function} resolve Resolution function
     * @param {Function} reject Rejection function
     * @returns {HTMLImageElement|FileReader} Object
     */
    function executor(resolve, reject) {
      var img = document.createElement('img');
      var url;
      /**
       * Callback for the fetchBlob call.
       *
       * @param {HTMLImageElement|HTMLCanvasElement} img Error object
       * @param {object} data Data object
       * @returns {undefined} Undefined
       */
      function resolveWrapper(img, data) {
        if (resolve === reject) {
          // Not using Promises
          if (resolve) resolve(img, data);
          return
        } else if (img instanceof Error) {
          reject(img);
          return
        }
        data = data || {}; // eslint-disable-line no-param-reassign
        data.image = img;
        resolve(data);
      }
      /**
       * Callback for the fetchBlob call.
       *
       * @param {Blob} blob Blob object
       * @param {Error} err Error object
       */
      function fetchBlobCallback(blob, err) {
        if (err && $.console) console.log(err); // eslint-disable-line no-console
        if (blob && isInstanceOf('Blob', blob)) {
          file = blob; // eslint-disable-line no-param-reassign
          url = createObjectURL(file);
        } else {
          url = file;
          if (options && options.crossOrigin) {
            img.crossOrigin = options.crossOrigin;
          }
        }
        img.src = url;
      }
      img.onerror = function (event) {
        revokeHelper(url, options);
        if (reject) reject.call(img, event);
      };
      img.onload = function () {
        revokeHelper(url, options);
        var data = {
          originalWidth: img.naturalWidth || img.width,
          originalHeight: img.naturalHeight || img.height
        };
        try {
          loadImage.transform(img, options, resolveWrapper, file, data);
        } catch (error) {
          if (reject) reject(error);
        }
      };
      if (typeof file === 'string') {
        if (loadImage.requiresMetaData(options)) {
          loadImage.fetchBlob(file, fetchBlobCallback, options);
        } else {
          fetchBlobCallback();
        }
        return img
      } else if (isInstanceOf('Blob', file) || isInstanceOf('File', file)) {
        url = createObjectURL(file);
        if (url) {
          img.src = url;
          return img
        }
        return readFile(
          file,
          function (url) {
            img.src = url;
          },
          reject
        )
      }
    }
    if ($.Promise && typeof callback !== 'function') {
      options = callback; // eslint-disable-line no-param-reassign
      return new Promise(executor)
    }
    return executor(callback, callback)
  }

  // Determines if metadata should be loaded automatically.
  // Requires the load image meta extension to load metadata.
  loadImage.requiresMetaData = function (options) {
    return options && options.meta
  };

  // If the callback given to this function returns a blob, it is used as image
  // source instead of the original url and overrides the file argument used in
  // the onload and onerror event callbacks:
  loadImage.fetchBlob = function (url, callback) {
    callback();
  };

  loadImage.transform = function (img, options, callback, file, data) {
    callback(img, data);
  };

  loadImage.global = $;
  loadImage.readFile = readFile;
  loadImage.isInstanceOf = isInstanceOf;
  loadImage.createObjectURL = createObjectURL;
  loadImage.revokeObjectURL = revokeObjectURL;

  if (module.exports) {
    module.exports = loadImage;
  } else {
    $.loadImage = loadImage;
  }
})((typeof window !== 'undefined' && window) || commonjsGlobal);
}(loadImage));

var loadImageScale = {exports: {}};

/*
 * JavaScript Load Image Scaling
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var originalTransform = loadImage.transform;

  loadImage.createCanvas = function (width, height, offscreen) {
    if (offscreen && loadImage.global.OffscreenCanvas) {
      return new OffscreenCanvas(width, height)
    }
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas
  };

  loadImage.transform = function (img, options, callback, file, data) {
    originalTransform.call(
      loadImage,
      loadImage.scale(img, options, data),
      options,
      callback,
      file,
      data
    );
  };

  // Transform image coordinates, allows to override e.g.
  // the canvas orientation based on the orientation option,
  // gets canvas, options and data passed as arguments:
  loadImage.transformCoordinates = function () {};

  // Returns transformed options, allows to override e.g.
  // maxWidth, maxHeight and crop options based on the aspectRatio.
  // gets img, options, data passed as arguments:
  loadImage.getTransformedOptions = function (img, options) {
    var aspectRatio = options.aspectRatio;
    var newOptions;
    var i;
    var width;
    var height;
    if (!aspectRatio) {
      return options
    }
    newOptions = {};
    for (i in options) {
      if (Object.prototype.hasOwnProperty.call(options, i)) {
        newOptions[i] = options[i];
      }
    }
    newOptions.crop = true;
    width = img.naturalWidth || img.width;
    height = img.naturalHeight || img.height;
    if (width / height > aspectRatio) {
      newOptions.maxWidth = height * aspectRatio;
      newOptions.maxHeight = height;
    } else {
      newOptions.maxWidth = width;
      newOptions.maxHeight = width / aspectRatio;
    }
    return newOptions
  };

  // Canvas render method, allows to implement a different rendering algorithm:
  loadImage.drawImage = function (
    img,
    canvas,
    sourceX,
    sourceY,
    sourceWidth,
    sourceHeight,
    destWidth,
    destHeight,
    options
  ) {
    var ctx = canvas.getContext('2d');
    if (options.imageSmoothingEnabled === false) {
      ctx.msImageSmoothingEnabled = false;
      ctx.imageSmoothingEnabled = false;
    } else if (options.imageSmoothingQuality) {
      ctx.imageSmoothingQuality = options.imageSmoothingQuality;
    }
    ctx.drawImage(
      img,
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      0,
      0,
      destWidth,
      destHeight
    );
    return ctx
  };

  // Determines if the target image should be a canvas element:
  loadImage.requiresCanvas = function (options) {
    return options.canvas || options.crop || !!options.aspectRatio
  };

  // Scales and/or crops the given image (img or canvas HTML element)
  // using the given options:
  loadImage.scale = function (img, options, data) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    // eslint-disable-next-line no-param-reassign
    data = data || {};
    var useCanvas =
      img.getContext ||
      (loadImage.requiresCanvas(options) &&
        !!loadImage.global.HTMLCanvasElement);
    var width = img.naturalWidth || img.width;
    var height = img.naturalHeight || img.height;
    var destWidth = width;
    var destHeight = height;
    var maxWidth;
    var maxHeight;
    var minWidth;
    var minHeight;
    var sourceWidth;
    var sourceHeight;
    var sourceX;
    var sourceY;
    var pixelRatio;
    var downsamplingRatio;
    var tmp;
    var canvas;
    /**
     * Scales up image dimensions
     */
    function scaleUp() {
      var scale = Math.max(
        (minWidth || destWidth) / destWidth,
        (minHeight || destHeight) / destHeight
      );
      if (scale > 1) {
        destWidth *= scale;
        destHeight *= scale;
      }
    }
    /**
     * Scales down image dimensions
     */
    function scaleDown() {
      var scale = Math.min(
        (maxWidth || destWidth) / destWidth,
        (maxHeight || destHeight) / destHeight
      );
      if (scale < 1) {
        destWidth *= scale;
        destHeight *= scale;
      }
    }
    if (useCanvas) {
      // eslint-disable-next-line no-param-reassign
      options = loadImage.getTransformedOptions(img, options, data);
      sourceX = options.left || 0;
      sourceY = options.top || 0;
      if (options.sourceWidth) {
        sourceWidth = options.sourceWidth;
        if (options.right !== undefined && options.left === undefined) {
          sourceX = width - sourceWidth - options.right;
        }
      } else {
        sourceWidth = width - sourceX - (options.right || 0);
      }
      if (options.sourceHeight) {
        sourceHeight = options.sourceHeight;
        if (options.bottom !== undefined && options.top === undefined) {
          sourceY = height - sourceHeight - options.bottom;
        }
      } else {
        sourceHeight = height - sourceY - (options.bottom || 0);
      }
      destWidth = sourceWidth;
      destHeight = sourceHeight;
    }
    maxWidth = options.maxWidth;
    maxHeight = options.maxHeight;
    minWidth = options.minWidth;
    minHeight = options.minHeight;
    if (useCanvas && maxWidth && maxHeight && options.crop) {
      destWidth = maxWidth;
      destHeight = maxHeight;
      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
      if (tmp < 0) {
        sourceHeight = (maxHeight * sourceWidth) / maxWidth;
        if (options.top === undefined && options.bottom === undefined) {
          sourceY = (height - sourceHeight) / 2;
        }
      } else if (tmp > 0) {
        sourceWidth = (maxWidth * sourceHeight) / maxHeight;
        if (options.left === undefined && options.right === undefined) {
          sourceX = (width - sourceWidth) / 2;
        }
      }
    } else {
      if (options.contain || options.cover) {
        minWidth = maxWidth = maxWidth || minWidth;
        minHeight = maxHeight = maxHeight || minHeight;
      }
      if (options.cover) {
        scaleDown();
        scaleUp();
      } else {
        scaleUp();
        scaleDown();
      }
    }
    if (useCanvas) {
      pixelRatio = options.pixelRatio;
      if (
        pixelRatio > 1 &&
        // Check if the image has not yet had the device pixel ratio applied:
        !(
          img.style.width &&
          Math.floor(parseFloat(img.style.width, 10)) ===
            Math.floor(width / pixelRatio)
        )
      ) {
        destWidth *= pixelRatio;
        destHeight *= pixelRatio;
      }
      // Check if workaround for Chromium orientation crop bug is required:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074354
      if (
        loadImage.orientationCropBug &&
        !img.getContext &&
        (sourceX || sourceY || sourceWidth !== width || sourceHeight !== height)
      ) {
        // Write the complete source image to an intermediate canvas first:
        tmp = img;
        // eslint-disable-next-line no-param-reassign
        img = loadImage.createCanvas(width, height, true);
        loadImage.drawImage(
          tmp,
          img,
          0,
          0,
          width,
          height,
          width,
          height,
          options
        );
      }
      downsamplingRatio = options.downsamplingRatio;
      if (
        downsamplingRatio > 0 &&
        downsamplingRatio < 1 &&
        destWidth < sourceWidth &&
        destHeight < sourceHeight
      ) {
        while (sourceWidth * downsamplingRatio > destWidth) {
          canvas = loadImage.createCanvas(
            sourceWidth * downsamplingRatio,
            sourceHeight * downsamplingRatio,
            true
          );
          loadImage.drawImage(
            img,
            canvas,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            canvas.width,
            canvas.height,
            options
          );
          sourceX = 0;
          sourceY = 0;
          sourceWidth = canvas.width;
          sourceHeight = canvas.height;
          // eslint-disable-next-line no-param-reassign
          img = canvas;
        }
      }
      canvas = loadImage.createCanvas(destWidth, destHeight);
      loadImage.transformCoordinates(canvas, options, data);
      if (pixelRatio > 1) {
        canvas.style.width = canvas.width / pixelRatio + 'px';
      }
      loadImage
        .drawImage(
          img,
          canvas,
          sourceX,
          sourceY,
          sourceWidth,
          sourceHeight,
          destWidth,
          destHeight,
          options
        )
        .setTransform(1, 0, 0, 1, 0, 0); // reset to the identity matrix
      return canvas
    }
    img.width = destWidth;
    img.height = destHeight;
    return img
  };
});
}(loadImageScale));

var loadImageMeta = {exports: {}};

/*
 * JavaScript Load Image Meta
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Image metadata handling implementation
 * based on the help and contribution of
 * Achim Sthr.
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var global = loadImage.global;
  var originalTransform = loadImage.transform;

  var blobSlice =
    global.Blob &&
    (Blob.prototype.slice ||
      Blob.prototype.webkitSlice ||
      Blob.prototype.mozSlice);

  var bufferSlice =
    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||
    function (begin, end) {
      // Polyfill for IE10, which does not support ArrayBuffer.slice
      // eslint-disable-next-line no-param-reassign
      end = end || this.byteLength - begin;
      var arr1 = new Uint8Array(this, begin, end);
      var arr2 = new Uint8Array(end);
      arr2.set(arr1);
      return arr2.buffer
    };

  var metaDataParsers = {
    jpeg: {
      0xffe1: [], // APP1 marker
      0xffed: [] // APP13 marker
    }
  };

  /**
   * Parses image metadata and calls the callback with an object argument
   * with the following property:
   * - imageHead: The complete image head as ArrayBuffer
   * The options argument accepts an object and supports the following
   * properties:
   * - maxMetaDataSize: Defines the maximum number of bytes to parse.
   * - disableImageHead: Disables creating the imageHead property.
   *
   * @param {Blob} file Blob object
   * @param {Function} [callback] Callback function
   * @param {object} [options] Parsing options
   * @param {object} [data] Result data object
   * @returns {Promise<object>|undefined} Returns Promise if no callback given.
   */
  function parseMetaData(file, callback, options, data) {
    var that = this;
    /**
     * Promise executor
     *
     * @param {Function} resolve Resolution function
     * @param {Function} reject Rejection function
     * @returns {undefined} Undefined
     */
    function executor(resolve, reject) {
      if (
        !(
          global.DataView &&
          blobSlice &&
          file &&
          file.size >= 12 &&
          file.type === 'image/jpeg'
        )
      ) {
        // Nothing to parse
        return resolve(data)
      }
      // 256 KiB should contain all EXIF/ICC/IPTC segments:
      var maxMetaDataSize = options.maxMetaDataSize || 262144;
      if (
        !loadImage.readFile(
          blobSlice.call(file, 0, maxMetaDataSize),
          function (buffer) {
            // Note on endianness:
            // Since the marker and length bytes in JPEG files are always
            // stored in big endian order, we can leave the endian parameter
            // of the DataView methods undefined, defaulting to big endian.
            var dataView = new DataView(buffer);
            // Check for the JPEG marker (0xffd8):
            if (dataView.getUint16(0) !== 0xffd8) {
              return reject(
                new Error('Invalid JPEG file: Missing JPEG marker.')
              )
            }
            var offset = 2;
            var maxOffset = dataView.byteLength - 4;
            var headLength = offset;
            var markerBytes;
            var markerLength;
            var parsers;
            var i;
            while (offset < maxOffset) {
              markerBytes = dataView.getUint16(offset);
              // Search for APPn (0xffeN) and COM (0xfffe) markers,
              // which contain application-specific metadata like
              // Exif, ICC and IPTC data and text comments:
              if (
                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                markerBytes === 0xfffe
              ) {
                // The marker bytes (2) are always followed by
                // the length bytes (2), indicating the length of the
                // marker segment, which includes the length bytes,
                // but not the marker bytes, so we add 2:
                markerLength = dataView.getUint16(offset + 2) + 2;
                if (offset + markerLength > dataView.byteLength) {
                  // eslint-disable-next-line no-console
                  console.log('Invalid JPEG metadata: Invalid segment size.');
                  break
                }
                parsers = metaDataParsers.jpeg[markerBytes];
                if (parsers && !options.disableMetaDataParsers) {
                  for (i = 0; i < parsers.length; i += 1) {
                    parsers[i].call(
                      that,
                      dataView,
                      offset,
                      markerLength,
                      data,
                      options
                    );
                  }
                }
                offset += markerLength;
                headLength = offset;
              } else {
                // Not an APPn or COM marker, probably safe to
                // assume that this is the end of the metadata
                break
              }
            }
            // Meta length must be longer than JPEG marker (2)
            // plus APPn marker (2), followed by length bytes (2):
            if (!options.disableImageHead && headLength > 6) {
              data.imageHead = bufferSlice.call(buffer, 0, headLength);
            }
            resolve(data);
          },
          reject,
          'readAsArrayBuffer'
        )
      ) {
        // No support for the FileReader interface, nothing to parse
        resolve(data);
      }
    }
    options = options || {}; // eslint-disable-line no-param-reassign
    if (global.Promise && typeof callback !== 'function') {
      options = callback || {}; // eslint-disable-line no-param-reassign
      data = options; // eslint-disable-line no-param-reassign
      return new Promise(executor)
    }
    data = data || {}; // eslint-disable-line no-param-reassign
    return executor(callback, callback)
  }

  /**
   * Replaces the head of a JPEG Blob
   *
   * @param {Blob} blob Blob object
   * @param {ArrayBuffer} oldHead Old JPEG head
   * @param {ArrayBuffer} newHead New JPEG head
   * @returns {Blob} Combined Blob
   */
  function replaceJPEGHead(blob, oldHead, newHead) {
    if (!blob || !oldHead || !newHead) return null
    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {
      type: 'image/jpeg'
    })
  }

  /**
   * Replaces the image head of a JPEG blob with the given one.
   * Returns a Promise or calls the callback with the new Blob.
   *
   * @param {Blob} blob Blob object
   * @param {ArrayBuffer} head New JPEG head
   * @param {Function} [callback] Callback function
   * @returns {Promise<Blob|null>|undefined} Combined Blob
   */
  function replaceHead(blob, head, callback) {
    var options = { maxMetaDataSize: 1024, disableMetaDataParsers: true };
    if (!callback && global.Promise) {
      return parseMetaData(blob, options).then(function (data) {
        return replaceJPEGHead(blob, data.imageHead, head)
      })
    }
    parseMetaData(
      blob,
      function (data) {
        callback(replaceJPEGHead(blob, data.imageHead, head));
      },
      options
    );
  }

  loadImage.transform = function (img, options, callback, file, data) {
    if (loadImage.requiresMetaData(options)) {
      data = data || {}; // eslint-disable-line no-param-reassign
      parseMetaData(
        file,
        function (result) {
          if (result !== data) {
            // eslint-disable-next-line no-console
            if (global.console) console.log(result);
            result = data; // eslint-disable-line no-param-reassign
          }
          originalTransform.call(
            loadImage,
            img,
            options,
            callback,
            file,
            result
          );
        },
        options,
        data
      );
    } else {
      originalTransform.apply(loadImage, arguments);
    }
  };

  loadImage.blobSlice = blobSlice;
  loadImage.bufferSlice = bufferSlice;
  loadImage.replaceHead = replaceHead;
  loadImage.parseMetaData = parseMetaData;
  loadImage.metaDataParsers = metaDataParsers;
});
}(loadImageMeta));

var loadImageFetch = {exports: {}};

/*
 * JavaScript Load Image Fetch
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2017, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var global = loadImage.global;

  if (
    global.fetch &&
    global.Request &&
    global.Response &&
    global.Response.prototype.blob
  ) {
    loadImage.fetchBlob = function (url, callback, options) {
      /**
       * Fetch response handler.
       *
       * @param {Response} response Fetch response
       * @returns {Blob} Fetched Blob.
       */
      function responseHandler(response) {
        return response.blob()
      }
      if (global.Promise && typeof callback !== 'function') {
        return fetch(new Request(url, callback)).then(responseHandler)
      }
      fetch(new Request(url, options))
        .then(responseHandler)
        .then(callback)
        [
          // Avoid parsing error in IE<9, where catch is a reserved word.
          // eslint-disable-next-line dot-notation
          'catch'
        ](function (err) {
          callback(null, err);
        });
    };
  } else if (
    global.XMLHttpRequest &&
    // https://xhr.spec.whatwg.org/#the-responsetype-attribute
    new XMLHttpRequest().responseType === ''
  ) {
    loadImage.fetchBlob = function (url, callback, options) {
      /**
       * Promise executor
       *
       * @param {Function} resolve Resolution function
       * @param {Function} reject Rejection function
       */
      function executor(resolve, reject) {
        options = options || {}; // eslint-disable-line no-param-reassign
        var req = new XMLHttpRequest();
        req.open(options.method || 'GET', url);
        if (options.headers) {
          Object.keys(options.headers).forEach(function (key) {
            req.setRequestHeader(key, options.headers[key]);
          });
        }
        req.withCredentials = options.credentials === 'include';
        req.responseType = 'blob';
        req.onload = function () {
          resolve(req.response);
        };
        req.onerror =
          req.onabort =
          req.ontimeout =
            function (err) {
              if (resolve === reject) {
                // Not using Promises
                reject(null, err);
              } else {
                reject(err);
              }
            };
        req.send(options.body);
      }
      if (global.Promise && typeof callback !== 'function') {
        options = callback; // eslint-disable-line no-param-reassign
        return new Promise(executor)
      }
      return executor(callback, callback)
    };
  }
});
}(loadImageFetch));

var loadImageExif = {exports: {}};

/*
 * JavaScript Load Image Exif Parser
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports, loadImageMeta.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  /**
   * Exif tag map
   *
   * @name ExifMap
   * @class
   * @param {number|string} tagCode IFD tag code
   */
  function ExifMap(tagCode) {
    if (tagCode) {
      Object.defineProperty(this, 'map', {
        value: this.ifds[tagCode].map
      });
      Object.defineProperty(this, 'tags', {
        value: (this.tags && this.tags[tagCode]) || {}
      });
    }
  }

  ExifMap.prototype.map = {
    Orientation: 0x0112,
    Thumbnail: 'ifd1',
    Blob: 0x0201, // Alias for JPEGInterchangeFormat
    Exif: 0x8769,
    GPSInfo: 0x8825,
    Interoperability: 0xa005
  };

  ExifMap.prototype.ifds = {
    ifd1: { name: 'Thumbnail', map: ExifMap.prototype.map },
    0x8769: { name: 'Exif', map: {} },
    0x8825: { name: 'GPSInfo', map: {} },
    0xa005: { name: 'Interoperability', map: {} }
  };

  /**
   * Retrieves exif tag value
   *
   * @param {number|string} id Exif tag code or name
   * @returns {object} Exif tag value
   */
  ExifMap.prototype.get = function (id) {
    return this[id] || this[this.map[id]]
  };

  /**
   * Returns the Exif Thumbnail data as Blob.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} offset Thumbnail data offset
   * @param {number} length Thumbnail data length
   * @returns {undefined|Blob} Returns the Thumbnail Blob or undefined
   */
  function getExifThumbnail(dataView, offset, length) {
    if (!length) return
    if (offset + length > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid thumbnail data.');
      return
    }
    return new Blob(
      [loadImage.bufferSlice.call(dataView.buffer, offset, offset + length)],
      {
        type: 'image/jpeg'
      }
    )
  }

  var ExifTagTypes = {
    // byte, 8-bit unsigned int:
    1: {
      getValue: function (dataView, dataOffset) {
        return dataView.getUint8(dataOffset)
      },
      size: 1
    },
    // ascii, 8-bit byte:
    2: {
      getValue: function (dataView, dataOffset) {
        return String.fromCharCode(dataView.getUint8(dataOffset))
      },
      size: 1,
      ascii: true
    },
    // short, 16 bit int:
    3: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint16(dataOffset, littleEndian)
      },
      size: 2
    },
    // long, 32 bit int:
    4: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint32(dataOffset, littleEndian)
      },
      size: 4
    },
    // rational = two long values, first is numerator, second is denominator:
    5: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return (
          dataView.getUint32(dataOffset, littleEndian) /
          dataView.getUint32(dataOffset + 4, littleEndian)
        )
      },
      size: 8
    },
    // slong, 32 bit signed int:
    9: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getInt32(dataOffset, littleEndian)
      },
      size: 4
    },
    // srational, two slongs, first is numerator, second is denominator:
    10: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return (
          dataView.getInt32(dataOffset, littleEndian) /
          dataView.getInt32(dataOffset + 4, littleEndian)
        )
      },
      size: 8
    }
  };
  // undefined, 8-bit byte, value depending on field:
  ExifTagTypes[7] = ExifTagTypes[1];

  /**
   * Returns Exif tag value.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} tiffOffset TIFF offset
   * @param {number} offset Tag offset
   * @param {number} type Tag type
   * @param {number} length Tag length
   * @param {boolean} littleEndian Little endian encoding
   * @returns {object} Tag value
   */
  function getExifValue(
    dataView,
    tiffOffset,
    offset,
    type,
    length,
    littleEndian
  ) {
    var tagType = ExifTagTypes[type];
    var tagSize;
    var dataOffset;
    var values;
    var i;
    var str;
    var c;
    if (!tagType) {
      console.log('Invalid Exif data: Invalid tag type.');
      return
    }
    tagSize = tagType.size * length;
    // Determine if the value is contained in the dataOffset bytes,
    // or if the value at the dataOffset is a pointer to the actual data:
    dataOffset =
      tagSize > 4
        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)
        : offset + 8;
    if (dataOffset + tagSize > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid data offset.');
      return
    }
    if (length === 1) {
      return tagType.getValue(dataView, dataOffset, littleEndian)
    }
    values = [];
    for (i = 0; i < length; i += 1) {
      values[i] = tagType.getValue(
        dataView,
        dataOffset + i * tagType.size,
        littleEndian
      );
    }
    if (tagType.ascii) {
      str = '';
      // Concatenate the chars:
      for (i = 0; i < values.length; i += 1) {
        c = values[i];
        // Ignore the terminating NULL byte(s):
        if (c === '\u0000') {
          break
        }
        str += c;
      }
      return str
    }
    return values
  }

  /**
   * Determines if the given tag should be included.
   *
   * @param {object} includeTags Map of tags to include
   * @param {object} excludeTags Map of tags to exclude
   * @param {number|string} tagCode Tag code to check
   * @returns {boolean} True if the tag should be included
   */
  function shouldIncludeTag(includeTags, excludeTags, tagCode) {
    return (
      (!includeTags || includeTags[tagCode]) &&
      (!excludeTags || excludeTags[tagCode] !== true)
    )
  }

  /**
   * Parses Exif tags.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} tiffOffset TIFF offset
   * @param {number} dirOffset Directory offset
   * @param {boolean} littleEndian Little endian encoding
   * @param {ExifMap} tags Map to store parsed exif tags
   * @param {ExifMap} tagOffsets Map to store parsed exif tag offsets
   * @param {object} includeTags Map of tags to include
   * @param {object} excludeTags Map of tags to exclude
   * @returns {number} Next directory offset
   */
  function parseExifTags(
    dataView,
    tiffOffset,
    dirOffset,
    littleEndian,
    tags,
    tagOffsets,
    includeTags,
    excludeTags
  ) {
    var tagsNumber, dirEndOffset, i, tagOffset, tagNumber, tagValue;
    if (dirOffset + 6 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory offset.');
      return
    }
    tagsNumber = dataView.getUint16(dirOffset, littleEndian);
    dirEndOffset = dirOffset + 2 + 12 * tagsNumber;
    if (dirEndOffset + 4 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory size.');
      return
    }
    for (i = 0; i < tagsNumber; i += 1) {
      tagOffset = dirOffset + 2 + 12 * i;
      tagNumber = dataView.getUint16(tagOffset, littleEndian);
      if (!shouldIncludeTag(includeTags, excludeTags, tagNumber)) continue
      tagValue = getExifValue(
        dataView,
        tiffOffset,
        tagOffset,
        dataView.getUint16(tagOffset + 2, littleEndian), // tag type
        dataView.getUint32(tagOffset + 4, littleEndian), // tag length
        littleEndian
      );
      tags[tagNumber] = tagValue;
      if (tagOffsets) {
        tagOffsets[tagNumber] = tagOffset;
      }
    }
    // Return the offset to the next directory:
    return dataView.getUint32(dirEndOffset, littleEndian)
  }

  /**
   * Parses tags in a given IFD (Image File Directory).
   *
   * @param {object} data Data object to store exif tags and offsets
   * @param {number|string} tagCode IFD tag code
   * @param {DataView} dataView Data view interface
   * @param {number} tiffOffset TIFF offset
   * @param {boolean} littleEndian Little endian encoding
   * @param {object} includeTags Map of tags to include
   * @param {object} excludeTags Map of tags to exclude
   */
  function parseExifIFD(
    data,
    tagCode,
    dataView,
    tiffOffset,
    littleEndian,
    includeTags,
    excludeTags
  ) {
    var dirOffset = data.exif[tagCode];
    if (dirOffset) {
      data.exif[tagCode] = new ExifMap(tagCode);
      if (data.exifOffsets) {
        data.exifOffsets[tagCode] = new ExifMap(tagCode);
      }
      parseExifTags(
        dataView,
        tiffOffset,
        tiffOffset + dirOffset,
        littleEndian,
        data.exif[tagCode],
        data.exifOffsets && data.exifOffsets[tagCode],
        includeTags && includeTags[tagCode],
        excludeTags && excludeTags[tagCode]
      );
    }
  }

  loadImage.parseExifData = function (dataView, offset, length, data, options) {
    if (options.disableExif) {
      return
    }
    var includeTags = options.includeExifTags;
    var excludeTags = options.excludeExifTags || {
      0x8769: {
        // ExifIFDPointer
        0x927c: true // MakerNote
      }
    };
    var tiffOffset = offset + 10;
    var littleEndian;
    var dirOffset;
    var thumbnailIFD;
    // Check for the ASCII code for "Exif" (0x45786966):
    if (dataView.getUint32(offset + 4) !== 0x45786966) {
      // No Exif data, might be XMP data instead
      return
    }
    if (tiffOffset + 8 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid segment size.');
      return
    }
    // Check for the two null bytes:
    if (dataView.getUint16(offset + 8) !== 0x0000) {
      console.log('Invalid Exif data: Missing byte alignment offset.');
      return
    }
    // Check the byte alignment:
    switch (dataView.getUint16(tiffOffset)) {
      case 0x4949:
        littleEndian = true;
        break
      case 0x4d4d:
        littleEndian = false;
        break
      default:
        console.log('Invalid Exif data: Invalid byte alignment marker.');
        return
    }
    // Check for the TIFF tag marker (0x002A):
    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {
      console.log('Invalid Exif data: Missing TIFF marker.');
      return
    }
    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
    // Create the exif object to store the tags:
    data.exif = new ExifMap();
    if (!options.disableExifOffsets) {
      data.exifOffsets = new ExifMap();
      data.exifTiffOffset = tiffOffset;
      data.exifLittleEndian = littleEndian;
    }
    // Parse the tags of the main image directory (IFD0) and retrieve the
    // offset to the next directory (IFD1), usually the thumbnail directory:
    dirOffset = parseExifTags(
      dataView,
      tiffOffset,
      tiffOffset + dirOffset,
      littleEndian,
      data.exif,
      data.exifOffsets,
      includeTags,
      excludeTags
    );
    if (dirOffset && shouldIncludeTag(includeTags, excludeTags, 'ifd1')) {
      data.exif.ifd1 = dirOffset;
      if (data.exifOffsets) {
        data.exifOffsets.ifd1 = tiffOffset + dirOffset;
      }
    }
    Object.keys(data.exif.ifds).forEach(function (tagCode) {
      parseExifIFD(
        data,
        tagCode,
        dataView,
        tiffOffset,
        littleEndian,
        includeTags,
        excludeTags
      );
    });
    thumbnailIFD = data.exif.ifd1;
    // Check for JPEG Thumbnail offset and data length:
    if (thumbnailIFD && thumbnailIFD[0x0201]) {
      thumbnailIFD[0x0201] = getExifThumbnail(
        dataView,
        tiffOffset + thumbnailIFD[0x0201],
        thumbnailIFD[0x0202] // Thumbnail data length
      );
    }
  };

  // Registers the Exif parser for the APP1 JPEG metadata segment:
  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData);

  loadImage.exifWriters = {
    // Orientation writer:
    0x0112: function (buffer, data, value) {
      var orientationOffset = data.exifOffsets[0x0112];
      if (!orientationOffset) return buffer
      var view = new DataView(buffer, orientationOffset + 8, 2);
      view.setUint16(0, value, data.exifLittleEndian);
      return buffer
    }
  };

  loadImage.writeExifData = function (buffer, data, id, value) {
    return loadImage.exifWriters[data.exif.map[id]](buffer, data, value)
  };

  loadImage.ExifMap = ExifMap;

  // Adds the following properties to the parseMetaData callback data:
  // - exif: The parsed Exif tags
  // - exifOffsets: The parsed Exif tag offsets
  // - exifTiffOffset: TIFF header offset (used for offset pointers)
  // - exifLittleEndian: little endian order if true, big endian if false

  // Adds the following options to the parseMetaData method:
  // - disableExif: Disables Exif parsing when true.
  // - disableExifOffsets: Disables storing Exif tag offsets when true.
  // - includeExifTags: A map of Exif tags to include for parsing.
  // - excludeExifTags: A map of Exif tags to exclude from parsing.
});
}(loadImageExif));

var loadImageExifMap = {exports: {}};

/*
 * JavaScript Load Image Exif Map
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Exif tags mapping based on
 * https://github.com/jseidelin/exif-js
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports, loadImageExif.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var ExifMapProto = loadImage.ExifMap.prototype;

  ExifMapProto.tags = {
    // =================
    // TIFF tags (IFD0):
    // =================
    0x0100: 'ImageWidth',
    0x0101: 'ImageHeight',
    0x0102: 'BitsPerSample',
    0x0103: 'Compression',
    0x0106: 'PhotometricInterpretation',
    0x0112: 'Orientation',
    0x0115: 'SamplesPerPixel',
    0x011c: 'PlanarConfiguration',
    0x0212: 'YCbCrSubSampling',
    0x0213: 'YCbCrPositioning',
    0x011a: 'XResolution',
    0x011b: 'YResolution',
    0x0128: 'ResolutionUnit',
    0x0111: 'StripOffsets',
    0x0116: 'RowsPerStrip',
    0x0117: 'StripByteCounts',
    0x0201: 'JPEGInterchangeFormat',
    0x0202: 'JPEGInterchangeFormatLength',
    0x012d: 'TransferFunction',
    0x013e: 'WhitePoint',
    0x013f: 'PrimaryChromaticities',
    0x0211: 'YCbCrCoefficients',
    0x0214: 'ReferenceBlackWhite',
    0x0132: 'DateTime',
    0x010e: 'ImageDescription',
    0x010f: 'Make',
    0x0110: 'Model',
    0x0131: 'Software',
    0x013b: 'Artist',
    0x8298: 'Copyright',
    0x8769: {
      // ExifIFDPointer
      0x9000: 'ExifVersion', // EXIF version
      0xa000: 'FlashpixVersion', // Flashpix format version
      0xa001: 'ColorSpace', // Color space information tag
      0xa002: 'PixelXDimension', // Valid width of meaningful image
      0xa003: 'PixelYDimension', // Valid height of meaningful image
      0xa500: 'Gamma',
      0x9101: 'ComponentsConfiguration', // Information about channels
      0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel
      0x927c: 'MakerNote', // Any desired information written by the manufacturer
      0x9286: 'UserComment', // Comments by user
      0xa004: 'RelatedSoundFile', // Name of related sound file
      0x9003: 'DateTimeOriginal', // Date and time when the original image was generated
      0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally
      0x9010: 'OffsetTime', // Time zone when the image file was last changed
      0x9011: 'OffsetTimeOriginal', // Time zone when the image was stored digitally
      0x9012: 'OffsetTimeDigitized', // Time zone when the image was stored digitally
      0x9290: 'SubSecTime', // Fractions of seconds for DateTime
      0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal
      0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized
      0x829a: 'ExposureTime', // Exposure time (in seconds)
      0x829d: 'FNumber',
      0x8822: 'ExposureProgram', // Exposure program
      0x8824: 'SpectralSensitivity', // Spectral sensitivity
      0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2
      0x8828: 'OECF', // Optoelectric conversion factor
      0x8830: 'SensitivityType',
      0x8831: 'StandardOutputSensitivity',
      0x8832: 'RecommendedExposureIndex',
      0x8833: 'ISOSpeed',
      0x8834: 'ISOSpeedLatitudeyyy',
      0x8835: 'ISOSpeedLatitudezzz',
      0x9201: 'ShutterSpeedValue', // Shutter speed
      0x9202: 'ApertureValue', // Lens aperture
      0x9203: 'BrightnessValue', // Value of brightness
      0x9204: 'ExposureBias', // Exposure bias
      0x9205: 'MaxApertureValue', // Smallest F number of lens
      0x9206: 'SubjectDistance', // Distance to subject in meters
      0x9207: 'MeteringMode', // Metering mode
      0x9208: 'LightSource', // Kind of light source
      0x9209: 'Flash', // Flash status
      0x9214: 'SubjectArea', // Location and area of main subject
      0x920a: 'FocalLength', // Focal length of the lens in mm
      0xa20b: 'FlashEnergy', // Strobe energy in BCPS
      0xa20c: 'SpatialFrequencyResponse',
      0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit
      0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit
      0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution
      0xa214: 'SubjectLocation', // Location of subject in image
      0xa215: 'ExposureIndex', // Exposure index selected on camera
      0xa217: 'SensingMethod', // Image sensor type
      0xa300: 'FileSource', // Image source (3 == DSC)
      0xa301: 'SceneType', // Scene type (1 == directly photographed)
      0xa302: 'CFAPattern', // Color filter array geometric pattern
      0xa401: 'CustomRendered', // Special processing
      0xa402: 'ExposureMode', // Exposure mode
      0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual
      0xa404: 'DigitalZoomRatio', // Digital zoom ratio
      0xa405: 'FocalLengthIn35mmFilm',
      0xa406: 'SceneCaptureType', // Type of scene
      0xa407: 'GainControl', // Degree of overall image gain adjustment
      0xa408: 'Contrast', // Direction of contrast processing applied by camera
      0xa409: 'Saturation', // Direction of saturation processing applied by camera
      0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera
      0xa40b: 'DeviceSettingDescription',
      0xa40c: 'SubjectDistanceRange', // Distance to subject
      0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image
      0xa430: 'CameraOwnerName',
      0xa431: 'BodySerialNumber',
      0xa432: 'LensSpecification',
      0xa433: 'LensMake',
      0xa434: 'LensModel',
      0xa435: 'LensSerialNumber'
    },
    0x8825: {
      // GPSInfoIFDPointer
      0x0000: 'GPSVersionID',
      0x0001: 'GPSLatitudeRef',
      0x0002: 'GPSLatitude',
      0x0003: 'GPSLongitudeRef',
      0x0004: 'GPSLongitude',
      0x0005: 'GPSAltitudeRef',
      0x0006: 'GPSAltitude',
      0x0007: 'GPSTimeStamp',
      0x0008: 'GPSSatellites',
      0x0009: 'GPSStatus',
      0x000a: 'GPSMeasureMode',
      0x000b: 'GPSDOP',
      0x000c: 'GPSSpeedRef',
      0x000d: 'GPSSpeed',
      0x000e: 'GPSTrackRef',
      0x000f: 'GPSTrack',
      0x0010: 'GPSImgDirectionRef',
      0x0011: 'GPSImgDirection',
      0x0012: 'GPSMapDatum',
      0x0013: 'GPSDestLatitudeRef',
      0x0014: 'GPSDestLatitude',
      0x0015: 'GPSDestLongitudeRef',
      0x0016: 'GPSDestLongitude',
      0x0017: 'GPSDestBearingRef',
      0x0018: 'GPSDestBearing',
      0x0019: 'GPSDestDistanceRef',
      0x001a: 'GPSDestDistance',
      0x001b: 'GPSProcessingMethod',
      0x001c: 'GPSAreaInformation',
      0x001d: 'GPSDateStamp',
      0x001e: 'GPSDifferential',
      0x001f: 'GPSHPositioningError'
    },
    0xa005: {
      // InteroperabilityIFDPointer
      0x0001: 'InteroperabilityIndex'
    }
  };

  // IFD1 directory can contain any IFD0 tags:
  ExifMapProto.tags.ifd1 = ExifMapProto.tags;

  ExifMapProto.stringValues = {
    ExposureProgram: {
      0: 'Undefined',
      1: 'Manual',
      2: 'Normal program',
      3: 'Aperture priority',
      4: 'Shutter priority',
      5: 'Creative program',
      6: 'Action program',
      7: 'Portrait mode',
      8: 'Landscape mode'
    },
    MeteringMode: {
      0: 'Unknown',
      1: 'Average',
      2: 'CenterWeightedAverage',
      3: 'Spot',
      4: 'MultiSpot',
      5: 'Pattern',
      6: 'Partial',
      255: 'Other'
    },
    LightSource: {
      0: 'Unknown',
      1: 'Daylight',
      2: 'Fluorescent',
      3: 'Tungsten (incandescent light)',
      4: 'Flash',
      9: 'Fine weather',
      10: 'Cloudy weather',
      11: 'Shade',
      12: 'Daylight fluorescent (D 5700 - 7100K)',
      13: 'Day white fluorescent (N 4600 - 5400K)',
      14: 'Cool white fluorescent (W 3900 - 4500K)',
      15: 'White fluorescent (WW 3200 - 3700K)',
      17: 'Standard light A',
      18: 'Standard light B',
      19: 'Standard light C',
      20: 'D55',
      21: 'D65',
      22: 'D75',
      23: 'D50',
      24: 'ISO studio tungsten',
      255: 'Other'
    },
    Flash: {
      0x0000: 'Flash did not fire',
      0x0001: 'Flash fired',
      0x0005: 'Strobe return light not detected',
      0x0007: 'Strobe return light detected',
      0x0009: 'Flash fired, compulsory flash mode',
      0x000d: 'Flash fired, compulsory flash mode, return light not detected',
      0x000f: 'Flash fired, compulsory flash mode, return light detected',
      0x0010: 'Flash did not fire, compulsory flash mode',
      0x0018: 'Flash did not fire, auto mode',
      0x0019: 'Flash fired, auto mode',
      0x001d: 'Flash fired, auto mode, return light not detected',
      0x001f: 'Flash fired, auto mode, return light detected',
      0x0020: 'No flash function',
      0x0041: 'Flash fired, red-eye reduction mode',
      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
      0x0047: 'Flash fired, red-eye reduction mode, return light detected',
      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
      0x004d:
        'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
      0x004f:
        'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
      0x0059: 'Flash fired, auto mode, red-eye reduction mode',
      0x005d:
        'Flash fired, auto mode, return light not detected, red-eye reduction mode',
      0x005f:
        'Flash fired, auto mode, return light detected, red-eye reduction mode'
    },
    SensingMethod: {
      1: 'Undefined',
      2: 'One-chip color area sensor',
      3: 'Two-chip color area sensor',
      4: 'Three-chip color area sensor',
      5: 'Color sequential area sensor',
      7: 'Trilinear sensor',
      8: 'Color sequential linear sensor'
    },
    SceneCaptureType: {
      0: 'Standard',
      1: 'Landscape',
      2: 'Portrait',
      3: 'Night scene'
    },
    SceneType: {
      1: 'Directly photographed'
    },
    CustomRendered: {
      0: 'Normal process',
      1: 'Custom process'
    },
    WhiteBalance: {
      0: 'Auto white balance',
      1: 'Manual white balance'
    },
    GainControl: {
      0: 'None',
      1: 'Low gain up',
      2: 'High gain up',
      3: 'Low gain down',
      4: 'High gain down'
    },
    Contrast: {
      0: 'Normal',
      1: 'Soft',
      2: 'Hard'
    },
    Saturation: {
      0: 'Normal',
      1: 'Low saturation',
      2: 'High saturation'
    },
    Sharpness: {
      0: 'Normal',
      1: 'Soft',
      2: 'Hard'
    },
    SubjectDistanceRange: {
      0: 'Unknown',
      1: 'Macro',
      2: 'Close view',
      3: 'Distant view'
    },
    FileSource: {
      3: 'DSC'
    },
    ComponentsConfiguration: {
      0: '',
      1: 'Y',
      2: 'Cb',
      3: 'Cr',
      4: 'R',
      5: 'G',
      6: 'B'
    },
    Orientation: {
      1: 'Original',
      2: 'Horizontal flip',
      3: 'Rotate 180 CCW',
      4: 'Vertical flip',
      5: 'Vertical flip + Rotate 90 CW',
      6: 'Rotate 90 CW',
      7: 'Horizontal flip + Rotate 90 CW',
      8: 'Rotate 90 CCW'
    }
  };

  ExifMapProto.getText = function (name) {
    var value = this.get(name);
    switch (name) {
      case 'LightSource':
      case 'Flash':
      case 'MeteringMode':
      case 'ExposureProgram':
      case 'SensingMethod':
      case 'SceneCaptureType':
      case 'SceneType':
      case 'CustomRendered':
      case 'WhiteBalance':
      case 'GainControl':
      case 'Contrast':
      case 'Saturation':
      case 'Sharpness':
      case 'SubjectDistanceRange':
      case 'FileSource':
      case 'Orientation':
        return this.stringValues[name][value]
      case 'ExifVersion':
      case 'FlashpixVersion':
        if (!value) return
        return String.fromCharCode(value[0], value[1], value[2], value[3])
      case 'ComponentsConfiguration':
        if (!value) return
        return (
          this.stringValues[name][value[0]] +
          this.stringValues[name][value[1]] +
          this.stringValues[name][value[2]] +
          this.stringValues[name][value[3]]
        )
      case 'GPSVersionID':
        if (!value) return
        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]
    }
    return String(value)
  };

  ExifMapProto.getAll = function () {
    var map = {};
    var prop;
    var obj;
    var name;
    for (prop in this) {
      if (Object.prototype.hasOwnProperty.call(this, prop)) {
        obj = this[prop];
        if (obj && obj.getAll) {
          map[this.ifds[prop].name] = obj.getAll();
        } else {
          name = this.tags[prop];
          if (name) map[name] = this.getText(name);
        }
      }
    }
    return map
  };

  ExifMapProto.getName = function (tagCode) {
    var name = this.tags[tagCode];
    if (typeof name === 'object') return this.ifds[tagCode].name
    return name
  }

  // Extend the map of tag names to tag codes:
  ;(function () {
    var tags = ExifMapProto.tags;
    var prop;
    var ifd;
    var subTags;
    // Map the tag names to tags:
    for (prop in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, prop)) {
        ifd = ExifMapProto.ifds[prop];
        if (ifd) {
          subTags = tags[prop];
          for (prop in subTags) {
            if (Object.prototype.hasOwnProperty.call(subTags, prop)) {
              ifd.map[subTags[prop]] = Number(prop);
            }
          }
        } else {
          ExifMapProto.map[tags[prop]] = Number(prop);
        }
      }
    }
  })();
});
}(loadImageExifMap));

var loadImageIptc = {exports: {}};

/*
 * JavaScript Load Image IPTC Parser
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * Copyright 2018, Dave Bevan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports, loadImageMeta.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  /**
   * IPTC tag map
   *
   * @name IptcMap
   * @class
   */
  function IptcMap() {}

  IptcMap.prototype.map = {
    ObjectName: 5
  };

  IptcMap.prototype.types = {
    0: 'Uint16', // ApplicationRecordVersion
    200: 'Uint16', // ObjectPreviewFileFormat
    201: 'Uint16', // ObjectPreviewFileVersion
    202: 'binary' // ObjectPreviewData
  };

  /**
   * Retrieves IPTC tag value
   *
   * @param {number|string} id IPTC tag code or name
   * @returns {object} IPTC tag value
   */
  IptcMap.prototype.get = function (id) {
    return this[id] || this[this.map[id]]
  };

  /**
   * Retrieves string for the given DataView and range
   *
   * @param {DataView} dataView Data view interface
   * @param {number} offset Offset start
   * @param {number} length Offset length
   * @returns {string} String value
   */
  function getStringValue(dataView, offset, length) {
    var outstr = '';
    var end = offset + length;
    for (var n = offset; n < end; n += 1) {
      outstr += String.fromCharCode(dataView.getUint8(n));
    }
    return outstr
  }

  /**
   * Retrieves tag value for the given DataView and range
   *
   * @param {number} tagCode tag code
   * @param {IptcMap} map IPTC tag map
   * @param {DataView} dataView Data view interface
   * @param {number} offset Range start
   * @param {number} length Range length
   * @returns {object} Tag value
   */
  function getTagValue(tagCode, map, dataView, offset, length) {
    if (map.types[tagCode] === 'binary') {
      return new Blob([dataView.buffer.slice(offset, offset + length)])
    }
    if (map.types[tagCode] === 'Uint16') {
      return dataView.getUint16(offset)
    }
    return getStringValue(dataView, offset, length)
  }

  /**
   * Combines IPTC value with existing ones.
   *
   * @param {object} value Existing IPTC field value
   * @param {object} newValue New IPTC field value
   * @returns {object} Resulting IPTC field value
   */
  function combineTagValues(value, newValue) {
    if (value === undefined) return newValue
    if (value instanceof Array) {
      value.push(newValue);
      return value
    }
    return [value, newValue]
  }

  /**
   * Parses IPTC tags.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} segmentOffset Segment offset
   * @param {number} segmentLength Segment length
   * @param {object} data Data export object
   * @param {object} includeTags Map of tags to include
   * @param {object} excludeTags Map of tags to exclude
   */
  function parseIptcTags(
    dataView,
    segmentOffset,
    segmentLength,
    data,
    includeTags,
    excludeTags
  ) {
    var value, tagSize, tagCode;
    var segmentEnd = segmentOffset + segmentLength;
    var offset = segmentOffset;
    while (offset < segmentEnd) {
      if (
        dataView.getUint8(offset) === 0x1c && // tag marker
        dataView.getUint8(offset + 1) === 0x02 // record number, only handles v2
      ) {
        tagCode = dataView.getUint8(offset + 2);
        if (
          (!includeTags || includeTags[tagCode]) &&
          (!excludeTags || !excludeTags[tagCode])
        ) {
          tagSize = dataView.getInt16(offset + 3);
          value = getTagValue(tagCode, data.iptc, dataView, offset + 5, tagSize);
          data.iptc[tagCode] = combineTagValues(data.iptc[tagCode], value);
          if (data.iptcOffsets) {
            data.iptcOffsets[tagCode] = offset;
          }
        }
      }
      offset += 1;
    }
  }

  /**
   * Tests if field segment starts at offset.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} offset Segment offset
   * @returns {boolean} True if '8BIM<EOT><EOT>' exists at offset
   */
  function isSegmentStart(dataView, offset) {
    return (
      dataView.getUint32(offset) === 0x3842494d && // Photoshop segment start
      dataView.getUint16(offset + 4) === 0x0404 // IPTC segment start
    )
  }

  /**
   * Returns header length.
   *
   * @param {DataView} dataView Data view interface
   * @param {number} offset Segment offset
   * @returns {number} Header length
   */
  function getHeaderLength(dataView, offset) {
    var length = dataView.getUint8(offset + 7);
    if (length % 2 !== 0) length += 1;
    // Check for pre photoshop 6 format
    if (length === 0) {
      // Always 4
      length = 4;
    }
    return length
  }

  loadImage.parseIptcData = function (dataView, offset, length, data, options) {
    if (options.disableIptc) {
      return
    }
    var markerLength = offset + length;
    while (offset + 8 < markerLength) {
      if (isSegmentStart(dataView, offset)) {
        var headerLength = getHeaderLength(dataView, offset);
        var segmentOffset = offset + 8 + headerLength;
        if (segmentOffset > markerLength) {
          // eslint-disable-next-line no-console
          console.log('Invalid IPTC data: Invalid segment offset.');
          break
        }
        var segmentLength = dataView.getUint16(offset + 6 + headerLength);
        if (offset + segmentLength > markerLength) {
          // eslint-disable-next-line no-console
          console.log('Invalid IPTC data: Invalid segment size.');
          break
        }
        // Create the iptc object to store the tags:
        data.iptc = new IptcMap();
        if (!options.disableIptcOffsets) {
          data.iptcOffsets = new IptcMap();
        }
        parseIptcTags(
          dataView,
          segmentOffset,
          segmentLength,
          data,
          options.includeIptcTags,
          options.excludeIptcTags || { 202: true } // ObjectPreviewData
        );
        return
      }
      // eslint-disable-next-line no-param-reassign
      offset += 1;
    }
  };

  // Registers this IPTC parser for the APP13 JPEG metadata segment:
  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData);

  loadImage.IptcMap = IptcMap;

  // Adds the following properties to the parseMetaData callback data:
  // - iptc: The iptc tags, parsed by the parseIptcData method

  // Adds the following options to the parseMetaData method:
  // - disableIptc: Disables IPTC parsing when true.
  // - disableIptcOffsets: Disables storing IPTC tag offsets when true.
  // - includeIptcTags: A map of IPTC tags to include for parsing.
  // - excludeIptcTags: A map of IPTC tags to exclude from parsing.
});
}(loadImageIptc));

var loadImageIptcMap = {exports: {}};

/*
 * JavaScript Load Image IPTC Map
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * Copyright 2018, Dave Bevan
 *
 * IPTC tags mapping based on
 * https://iptc.org/standards/photo-metadata
 * https://exiftool.org/TagNames/IPTC.html
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(loadImage.exports, loadImageIptc.exports);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var IptcMapProto = loadImage.IptcMap.prototype;

  IptcMapProto.tags = {
    0: 'ApplicationRecordVersion',
    3: 'ObjectTypeReference',
    4: 'ObjectAttributeReference',
    5: 'ObjectName',
    7: 'EditStatus',
    8: 'EditorialUpdate',
    10: 'Urgency',
    12: 'SubjectReference',
    15: 'Category',
    20: 'SupplementalCategories',
    22: 'FixtureIdentifier',
    25: 'Keywords',
    26: 'ContentLocationCode',
    27: 'ContentLocationName',
    30: 'ReleaseDate',
    35: 'ReleaseTime',
    37: 'ExpirationDate',
    38: 'ExpirationTime',
    40: 'SpecialInstructions',
    42: 'ActionAdvised',
    45: 'ReferenceService',
    47: 'ReferenceDate',
    50: 'ReferenceNumber',
    55: 'DateCreated',
    60: 'TimeCreated',
    62: 'DigitalCreationDate',
    63: 'DigitalCreationTime',
    65: 'OriginatingProgram',
    70: 'ProgramVersion',
    75: 'ObjectCycle',
    80: 'Byline',
    85: 'BylineTitle',
    90: 'City',
    92: 'Sublocation',
    95: 'State',
    100: 'CountryCode',
    101: 'Country',
    103: 'OriginalTransmissionReference',
    105: 'Headline',
    110: 'Credit',
    115: 'Source',
    116: 'CopyrightNotice',
    118: 'Contact',
    120: 'Caption',
    121: 'LocalCaption',
    122: 'Writer',
    125: 'RasterizedCaption',
    130: 'ImageType',
    131: 'ImageOrientation',
    135: 'LanguageIdentifier',
    150: 'AudioType',
    151: 'AudioSamplingRate',
    152: 'AudioSamplingResolution',
    153: 'AudioDuration',
    154: 'AudioOutcue',
    184: 'JobID',
    185: 'MasterDocumentID',
    186: 'ShortDocumentID',
    187: 'UniqueDocumentID',
    188: 'OwnerID',
    200: 'ObjectPreviewFileFormat',
    201: 'ObjectPreviewFileVersion',
    202: 'ObjectPreviewData',
    221: 'Prefs',
    225: 'ClassifyState',
    228: 'SimilarityIndex',
    230: 'DocumentNotes',
    231: 'DocumentHistory',
    232: 'ExifCameraInfo',
    255: 'CatalogSets'
  };

  IptcMapProto.stringValues = {
    10: {
      0: '0 (reserved)',
      1: '1 (most urgent)',
      2: '2',
      3: '3',
      4: '4',
      5: '5 (normal urgency)',
      6: '6',
      7: '7',
      8: '8 (least urgent)',
      9: '9 (user-defined priority)'
    },
    75: {
      a: 'Morning',
      b: 'Both Morning and Evening',
      p: 'Evening'
    },
    131: {
      L: 'Landscape',
      P: 'Portrait',
      S: 'Square'
    }
  };

  IptcMapProto.getText = function (id) {
    var value = this.get(id);
    var tagCode = this.map[id];
    var stringValue = this.stringValues[tagCode];
    if (stringValue) return stringValue[value]
    return String(value)
  };

  IptcMapProto.getAll = function () {
    var map = {};
    var prop;
    var name;
    for (prop in this) {
      if (Object.prototype.hasOwnProperty.call(this, prop)) {
        name = this.tags[prop];
        if (name) map[name] = this.getText(name);
      }
    }
    return map
  };

  IptcMapProto.getName = function (tagCode) {
    return this.tags[tagCode]
  }

  // Extend the map of tag names to tag codes:
  ;(function () {
    var tags = IptcMapProto.tags;
    var map = IptcMapProto.map || {};
    var prop;
    // Map the tag names to tags:
    for (prop in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, prop)) {
        map[tags[prop]] = Number(prop);
      }
    }
  })();
});
}(loadImageIptcMap));

var loadImageOrientation = {exports: {}};

/*
 * JavaScript Load Image Orientation
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

(function (module) {
(function (factory) {
  if (module.exports) {
    factory(
      loadImage.exports,
      loadImageScale.exports,
      loadImageMeta.exports
    );
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
})(function (loadImage) {

  var originalTransform = loadImage.transform;
  var originalRequiresCanvas = loadImage.requiresCanvas;
  var originalRequiresMetaData = loadImage.requiresMetaData;
  var originalTransformCoordinates = loadImage.transformCoordinates;
  var originalGetTransformedOptions = loadImage.getTransformedOptions

  ;(function ($) {
    // Guard for non-browser environments (e.g. server-side rendering):
    if (!$.global.document) return
    // black+white 3x2 JPEG, with the following meta information set:
    // - EXIF Orientation: 6 (Rotated 90 CCW)
    // Image data layout (B=black, F=white):
    // BFF
    // BBB
    var testImageURL =
      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +
      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +
      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +
      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/x' +
      'ABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAA' +
      'AAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQ' +
      'voP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXw' +
      'H/9k=';
    var img = document.createElement('img');
    img.onload = function () {
      // Check if the browser supports automatic image orientation:
      $.orientation = img.width === 2 && img.height === 3;
      if ($.orientation) {
        var canvas = $.createCanvas(1, 1, true);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, 1, 1, 1, 1, 0, 0, 1, 1);
        // Check if the source image coordinates (sX, sY, sWidth, sHeight) are
        // correctly applied to the auto-orientated image, which should result
        // in a white opaque pixel (e.g. in Safari).
        // Browsers that show a transparent pixel (e.g. Chromium) fail to crop
        // auto-oriented images correctly and require a workaround, e.g.
        // drawing the complete source image to an intermediate canvas first.
        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1074354
        $.orientationCropBug =
          ctx.getImageData(0, 0, 1, 1).data.toString() !== '255,255,255,255';
      }
    };
    img.src = testImageURL;
  })(loadImage);

  /**
   * Determines if the orientation requires a canvas element.
   *
   * @param {object} [options] Options object
   * @param {boolean} [withMetaData] Is metadata required for orientation
   * @returns {boolean} Returns true if orientation requires canvas/meta
   */
  function requiresCanvasOrientation(options, withMetaData) {
    var orientation = options && options.orientation;
    return (
      // Exif orientation for browsers without automatic image orientation:
      (orientation === true && !loadImage.orientation) ||
      // Orientation reset for browsers with automatic image orientation:
      (orientation === 1 && loadImage.orientation) ||
      // Orientation to defined value, requires meta for orientation reset only:
      ((!withMetaData || loadImage.orientation) &&
        orientation > 1 &&
        orientation < 9)
    )
  }

  /**
   * Determines if the image requires an orientation change.
   *
   * @param {number} [orientation] Defined orientation value
   * @param {number} [autoOrientation] Auto-orientation based on Exif data
   * @returns {boolean} Returns true if an orientation change is required
   */
  function requiresOrientationChange(orientation, autoOrientation) {
    return (
      orientation !== autoOrientation &&
      ((orientation === 1 && autoOrientation > 1 && autoOrientation < 9) ||
        (orientation > 1 && orientation < 9))
    )
  }

  /**
   * Determines orientation combinations that require a rotation by 180.
   *
   * The following is a list of combinations that return true:
   *
   * 2 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)
   * 4 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)
   *
   * 5 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)
   * 7 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)
   *
   * 6 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)
   * 8 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)
   *
   * @param {number} [orientation] Defined orientation value
   * @param {number} [autoOrientation] Auto-orientation based on Exif data
   * @returns {boolean} Returns true if rotation by 180 is required
   */
  function requiresRot180(orientation, autoOrientation) {
    if (autoOrientation > 1 && autoOrientation < 9) {
      switch (orientation) {
        case 2:
        case 4:
          return autoOrientation > 4
        case 5:
        case 7:
          return autoOrientation % 2 === 0
        case 6:
        case 8:
          return (
            autoOrientation === 2 ||
            autoOrientation === 4 ||
            autoOrientation === 5 ||
            autoOrientation === 7
          )
      }
    }
    return false
  }

  // Determines if the target image should be a canvas element:
  loadImage.requiresCanvas = function (options) {
    return (
      requiresCanvasOrientation(options) ||
      originalRequiresCanvas.call(loadImage, options)
    )
  };

  // Determines if metadata should be loaded automatically:
  loadImage.requiresMetaData = function (options) {
    return (
      requiresCanvasOrientation(options, true) ||
      originalRequiresMetaData.call(loadImage, options)
    )
  };

  loadImage.transform = function (img, options, callback, file, data) {
    originalTransform.call(
      loadImage,
      img,
      options,
      function (img, data) {
        if (data) {
          var autoOrientation =
            loadImage.orientation && data.exif && data.exif.get('Orientation');
          if (autoOrientation > 4 && autoOrientation < 9) {
            // Automatic image orientation switched image dimensions
            var originalWidth = data.originalWidth;
            var originalHeight = data.originalHeight;
            data.originalWidth = originalHeight;
            data.originalHeight = originalWidth;
          }
        }
        callback(img, data);
      },
      file,
      data
    );
  };

  // Transforms coordinate and dimension options
  // based on the given orientation option:
  loadImage.getTransformedOptions = function (img, opts, data) {
    var options = originalGetTransformedOptions.call(loadImage, img, opts);
    var exifOrientation = data.exif && data.exif.get('Orientation');
    var orientation = options.orientation;
    var autoOrientation = loadImage.orientation && exifOrientation;
    if (orientation === true) orientation = exifOrientation;
    if (!requiresOrientationChange(orientation, autoOrientation)) {
      return options
    }
    var top = options.top;
    var right = options.right;
    var bottom = options.bottom;
    var left = options.left;
    var newOptions = {};
    for (var i in options) {
      if (Object.prototype.hasOwnProperty.call(options, i)) {
        newOptions[i] = options[i];
      }
    }
    newOptions.orientation = orientation;
    if (
      (orientation > 4 && !(autoOrientation > 4)) ||
      (orientation < 5 && autoOrientation > 4)
    ) {
      // Image dimensions and target dimensions are switched
      newOptions.maxWidth = options.maxHeight;
      newOptions.maxHeight = options.maxWidth;
      newOptions.minWidth = options.minHeight;
      newOptions.minHeight = options.minWidth;
      newOptions.sourceWidth = options.sourceHeight;
      newOptions.sourceHeight = options.sourceWidth;
    }
    if (autoOrientation > 1) {
      // Browsers which correctly apply source image coordinates to
      // auto-oriented images
      switch (autoOrientation) {
        case 2:
          // Horizontal flip
          right = options.left;
          left = options.right;
          break
        case 3:
          // 180 Rotate CCW
          top = options.bottom;
          right = options.left;
          bottom = options.top;
          left = options.right;
          break
        case 4:
          // Vertical flip
          top = options.bottom;
          bottom = options.top;
          break
        case 5:
          // Horizontal flip + 90 Rotate CCW
          top = options.left;
          right = options.bottom;
          bottom = options.right;
          left = options.top;
          break
        case 6:
          // 90 Rotate CCW
          top = options.left;
          right = options.top;
          bottom = options.right;
          left = options.bottom;
          break
        case 7:
          // Vertical flip + 90 Rotate CCW
          top = options.right;
          right = options.top;
          bottom = options.left;
          left = options.bottom;
          break
        case 8:
          // 90 Rotate CW
          top = options.right;
          right = options.bottom;
          bottom = options.left;
          left = options.top;
          break
      }
      // Some orientation combinations require additional rotation by 180:
      if (requiresRot180(orientation, autoOrientation)) {
        var tmpTop = top;
        var tmpRight = right;
        top = bottom;
        right = left;
        bottom = tmpTop;
        left = tmpRight;
      }
    }
    newOptions.top = top;
    newOptions.right = right;
    newOptions.bottom = bottom;
    newOptions.left = left;
    // Account for defined browser orientation:
    switch (orientation) {
      case 2:
        // Horizontal flip
        newOptions.right = left;
        newOptions.left = right;
        break
      case 3:
        // 180 Rotate CCW
        newOptions.top = bottom;
        newOptions.right = left;
        newOptions.bottom = top;
        newOptions.left = right;
        break
      case 4:
        // Vertical flip
        newOptions.top = bottom;
        newOptions.bottom = top;
        break
      case 5:
        // Vertical flip + 90 Rotate CW
        newOptions.top = left;
        newOptions.right = bottom;
        newOptions.bottom = right;
        newOptions.left = top;
        break
      case 6:
        // 90 Rotate CW
        newOptions.top = right;
        newOptions.right = bottom;
        newOptions.bottom = left;
        newOptions.left = top;
        break
      case 7:
        // Horizontal flip + 90 Rotate CW
        newOptions.top = right;
        newOptions.right = top;
        newOptions.bottom = left;
        newOptions.left = bottom;
        break
      case 8:
        // 90 Rotate CCW
        newOptions.top = left;
        newOptions.right = top;
        newOptions.bottom = right;
        newOptions.left = bottom;
        break
    }
    return newOptions
  };

  // Transform image orientation based on the given EXIF orientation option:
  loadImage.transformCoordinates = function (canvas, options, data) {
    originalTransformCoordinates.call(loadImage, canvas, options, data);
    var orientation = options.orientation;
    var autoOrientation =
      loadImage.orientation && data.exif && data.exif.get('Orientation');
    if (!requiresOrientationChange(orientation, autoOrientation)) {
      return
    }
    var ctx = canvas.getContext('2d');
    var width = canvas.width;
    var height = canvas.height;
    var sourceWidth = width;
    var sourceHeight = height;
    if (
      (orientation > 4 && !(autoOrientation > 4)) ||
      (orientation < 5 && autoOrientation > 4)
    ) {
      // Image dimensions and target dimensions are switched
      canvas.width = height;
      canvas.height = width;
    }
    if (orientation > 4) {
      // Destination and source dimensions are switched
      sourceWidth = height;
      sourceHeight = width;
    }
    // Reset automatic browser orientation:
    switch (autoOrientation) {
      case 2:
        // Horizontal flip
        ctx.translate(sourceWidth, 0);
        ctx.scale(-1, 1);
        break
      case 3:
        // 180 Rotate CCW
        ctx.translate(sourceWidth, sourceHeight);
        ctx.rotate(Math.PI);
        break
      case 4:
        // Vertical flip
        ctx.translate(0, sourceHeight);
        ctx.scale(1, -1);
        break
      case 5:
        // Horizontal flip + 90 Rotate CCW
        ctx.rotate(-0.5 * Math.PI);
        ctx.scale(-1, 1);
        break
      case 6:
        // 90 Rotate CCW
        ctx.rotate(-0.5 * Math.PI);
        ctx.translate(-sourceWidth, 0);
        break
      case 7:
        // Vertical flip + 90 Rotate CCW
        ctx.rotate(-0.5 * Math.PI);
        ctx.translate(-sourceWidth, sourceHeight);
        ctx.scale(1, -1);
        break
      case 8:
        // 90 Rotate CW
        ctx.rotate(0.5 * Math.PI);
        ctx.translate(0, -sourceHeight);
        break
    }
    // Some orientation combinations require additional rotation by 180:
    if (requiresRot180(orientation, autoOrientation)) {
      ctx.translate(sourceWidth, sourceHeight);
      ctx.rotate(Math.PI);
    }
    switch (orientation) {
      case 2:
        // Horizontal flip
        ctx.translate(width, 0);
        ctx.scale(-1, 1);
        break
      case 3:
        // 180 Rotate CCW
        ctx.translate(width, height);
        ctx.rotate(Math.PI);
        break
      case 4:
        // Vertical flip
        ctx.translate(0, height);
        ctx.scale(1, -1);
        break
      case 5:
        // Vertical flip + 90 Rotate CW
        ctx.rotate(0.5 * Math.PI);
        ctx.scale(1, -1);
        break
      case 6:
        // 90 Rotate CW
        ctx.rotate(0.5 * Math.PI);
        ctx.translate(0, -height);
        break
      case 7:
        // Horizontal flip + 90 Rotate CW
        ctx.rotate(0.5 * Math.PI);
        ctx.translate(width, -height);
        ctx.scale(-1, 1);
        break
      case 8:
        // 90 Rotate CCW
        ctx.rotate(-0.5 * Math.PI);
        ctx.translate(-width, 0);
        break
    }
  };
});
}(loadImageOrientation));

/* global module, require */

var js = loadImage.exports;

class Image$1 {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let imageTool = builderStuff.querySelector('#divImageTool');
    let imageResizer;
    if (!imageTool) {
      let html = `
                <div id="divImageTool" class="is-tool">
                    <div role="button" tabindex="0" class="image-embed" style="${this.builder.opts.imageEmbed ? '' : 'display:none;'}width:40px;height:40px;overflow:hidden;">
                        <div style="position:absolute;width:100%;height:100%;"><svg class="is-icon-flex" style="position: absolute;top: 13px;left: 15px;width: 14px;height: 14px;"><use xlink:href="#ion-image"></use></svg></div>
                        <input title="${util.out('Change Image')}" data-title="${util.out('Change Image')}" id="fileEmbedImage" type="file" accept="image/*" style="position:absolute;top:-20px;left:0;width:40px;height:60px;opacity: 0;cursor: pointer;"/>
                    </div>
                    <button tabindex="0" title="${util.out('Link')}" data-title="${util.out('Link')}" class="image-link" style="width:40px;height:40px;"><svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#ion-link"></use></svg></button> 
                    <button tabindex="0" title="${util.out('Select')}" data-title="${util.out('Select')}" class="open-asset" style="display:none;width:40px;height:40px;"><svg class="is-icon-flex" style="width:17px;height:17px;color:#fff"><use xlink:href="#icon-folder2"></use></svg></button> 
                    <button tabindex="0" title="${util.out('Edit')}" data-title="${util.out('Edit')}" class="image-edit" style="width:40px;height:40px;"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-android-create"></use></svg></button>
                </div>
                <div id="divImageProgress">
                    <div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </div>
                <div id="divImageResizerOverlay" class="is-tool">
                </div>
                <div id="divImageResizer" class="keep-selection" style="position:absolute;">
                </div>
                `;
      dom.appendHtml(builderStuff, html);
      imageTool = builderStuff.querySelector('#divImageTool');
      this.imageTool = imageTool;
      imageResizer = document.querySelector('#divImageResizer');
      this.imageResizer = imageResizer;
      imageResizer.addEventListener('wheel', () => {
        this.hideImageResizer();
      }, {
        passive: true
      });
      const imageResizerOverlay = document.querySelector('#divImageResizerOverlay');
      this.builder.moveable = new Moveable(document.body, {
        target: imageResizer,
        resizable: true,
        throttleResize: 0,
        keepRatio: true
      }).on('resizeStart', () => {
        imageResizerOverlay.style.display = 'block'; // prevent cursor moving not smooth above iframe, so overlay is used.
      }).on('resize', ({
        target,
        width,
        height
      }) => {
        if (width === 0 || height === 0 || isNaN(width) || isNaN(height)) {
          return;
        }

        // hide image tool
        this.imageTool.style.display = '';

        // hide element tool
        let elementTool;
        if (!this.builder.iframe) {
          elementTool = builderStuff.querySelector('.is-element-tool');
        } else {
          elementTool = contentStuff.querySelector('.is-element-tool');
        }
        elementTool.style.display = '';
        let activeImage = this.builder.activeImage;
        let newPos = this.builder.util.getElementPosition(activeImage);
        if (this.builder.iframe) {
          let scaleX = newPos.scaleX;
          let scaleY = newPos.scaleY;
          width = width / scaleX;
          height = height / scaleY;
        }
        let bCircular = false;
        if (dom.hasClass(activeImage.parentNode, 'img-circular')) {
          activeImage = activeImage.parentNode;
          bCircular = true;
        }
        let zoom = this.builder.opts.zoom;
        let win = this.builder.win;
        if (!bCircular) {
          activeImage.style.width = `${width / zoom}px`;
          activeImage.style.height = 'auto';
        } else {
          let pl = parseFloat(win.getComputedStyle(activeImage.parentNode).getPropertyValue('padding-left'));
          let pr = parseFloat(win.getComputedStyle(activeImage.parentNode).getPropertyValue('padding-right'));
          let maxWidth = activeImage.parentNode.offsetWidth * zoom - pl - pr;
          if (width >= maxWidth) width = maxWidth;
          if (height >= width) {
            activeImage.style.width = `${width / zoom}px`;
            activeImage.style.height = `${width / zoom}px`;
            activeImage.querySelector('img').style.width = `${width / zoom}px`;
            activeImage.querySelector('img').style.height = `${width / zoom}px`;
          } else {
            activeImage.style.width = `${width / zoom}px`;
            activeImage.style.height = `${height / zoom}px`;
            activeImage.querySelector('img').style.width = `${width / zoom}px`;
            activeImage.querySelector('img').style.height = `${height / zoom}px`;
          }
        }
        newPos = this.builder.util.getElementPosition(activeImage);
        let top = newPos.top + window.pageYOffset;
        let left = newPos.left + window.pageXOffset;
        target.style.top = top + 'px';
        target.style.left = left + 'px';
        target.style.width = activeImage.offsetWidth + 'px';
        target.style.height = activeImage.offsetHeight + 'px';
        this.repositionHandler(activeImage.offsetWidth, activeImage.offsetHeight);

        // https://stackoverflow.com/questions/29908261/prevent-text-selection-on-mouse-drag
        // prevent text selection
        if (document.selection) {
          document.selection.empty();
        } else {
          window.getSelection().removeAllRanges();
        }
        imageResizer.setAttribute('data-resizing', '1'); // important: see util.hidePops()
      }).on('resizeEnd', ({
        target
      }) => {
        imageResizer.removeAttribute('data-resizing');
        imageResizerOverlay.style.display = '';
        let activeImage = this.builder.activeImage;
        let bCircular = false;
        if (dom.hasClass(activeImage.parentNode, 'img-circular')) {
          activeImage = activeImage.parentNode;
          bCircular = true;
        }

        // https://stackoverflow.com/questions/25197184/get-the-height-of-an-element-minus-padding-margin-border-widths
        var cs = getComputedStyle(activeImage.parentNode);
        var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
        var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

        // Element width and height minus padding and border
        var elementWidth = activeImage.parentNode.offsetWidth - paddingX - borderX;
        let win = this.builder.win;
        let currentWidth;
        if (!bCircular) {
          const parentWidth = elementWidth; //activeImage.parentNode.offsetWidth;
          currentWidth = activeImage.offsetWidth;
          const percentage = currentWidth / parentWidth * 100;
          activeImage.style.width = percentage + '%';
        } else {
          const _screenwidth = win.innerWidth;
          currentWidth = activeImage.offsetWidth;
          const percentage = currentWidth / _screenwidth * 100;
          activeImage.style.width = percentage + 'vw';
          activeImage.style.height = percentage + 'vw';
          const img = activeImage.querySelector('img');
          if (img) {
            img.style.width = '100%';
            img.style.height = '100%';
          }
        }
        if (this.builder.opts.emailMode) {
          activeImage.setAttribute('width', currentWidth);
        }
        target.setAttribute('data-resized', 1);
        setTimeout(() => {
          target.setAttribute('data-resized', 0);
        }, 300);
        this.builder.opts.onChange();
      });
      const movControlBox = document.querySelector('.moveable-control-box');
      if (movControlBox) movControlBox.style.display = 'none';
      imageResizer.addEventListener('click', () => {
        if (!this.builder.activeImage) return;
        this.builder.activeImage.click();
        this.repositionImageTool();
        this.builder.elmTool.repositionElementTool();
      });

      // Browse local image
      let elm = imageTool.querySelector('#fileEmbedImage');
      dom.addEventListener(elm, 'change', e => {
        this.builder.uo.saveForUndo();
        var input = e.target;
        let img = this.builder.activeImage;
        let imageProgress = builderStuff.querySelector('#divImageProgress');
        imageProgress.style.display = 'table';
        imageProgress.style.width = img.offsetWidth * this.builder.opts.zoom + 'px';
        imageProgress.style.height = img.offsetHeight * this.builder.opts.zoom + 'px';
        const newPos = this.builder.util.getElementPosition(img);
        let top = newPos.top + window.pageYOffset;
        let left = newPos.left + window.pageXOffset;
        imageProgress.style.top = top + 'px';
        imageProgress.style.left = left + 'px';

        //The #fileEmbedImage triggered 2 times in IE (because of clearInputs below). This makes input.files[0].name returns error on 2nd trigger. Just add try{}!
        try {
          img.setAttribute('data-filename', input.files[0].name); //needed for saveimage.js | 

          // img.crossOrigin = 'anonymous';

          this.processImage(input.files[0], img, () => {
            imageProgress.style.display = 'none';
            elm = imageTool.querySelector('#fileEmbedImage');
            elm.value = ''; //clear input

            //Check if image is part of module snippet. If so, refresh the (active) module (hide imageTool). If not, refresh imageTool position
            this.refreshIfIsModule(img);
            this.startImageMonitor(img);

            //Trigger Change event
            this.builder.opts.onChange();
            this.builder.elmTool.refresh();
            if (this.builder.onImageChange) this.builder.onImageChange();
          });
        } catch (e) {
          imageProgress.style.display = 'none';
        }
      });

      // Trigger onImageBrowseClick (if set), will cancel browsing local image
      if (this.builder.opts.onImageBrowseClick) {
        elm = imageTool.querySelector('.image-embed');
        dom.addEventListener(elm, 'click', e => {
          this.builder.opts.onImageBrowseClick();
          e.preventDefault();
          return false;
        });
      }
      const btnImageLink = imageTool.querySelector('.image-link');
      dom.addEventListener(btnImageLink, 'click', () => {
        this.renderPanel();
        let modalImageLink = builderStuff.querySelector('.imagelink');
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox) movControlBox.style.display = 'none'; //needed by Safari (prevent z-index problem)

        if (this.builder.opts.onImageSettingClick) {
          this.builder.opts.onImageSettingClick();
          return false;
        }
        let img = this.builder.activeImage;
        let lnk;
        if (img.parentNode.tagName.toLowerCase() === 'a' && img.parentNode.childElementCount === 1) {
          lnk = img.parentNode;
        }

        //get values
        let src = img.getAttribute('src'); //img.src;
        let title = img.getAttribute('alt');
        let inputSrc = modalImageLink.querySelector('.input-src');
        if (src.indexOf('base64') === -1) {
          inputSrc.value = src;
        } else {
          inputSrc.value = '[Image Data]';
        }
        let inputTitle = modalImageLink.querySelector('.input-title');
        inputTitle.value = title;
        let inputLink = modalImageLink.querySelector('.input-link');
        inputLink.value = '';
        let inputTarget = modalImageLink.querySelector('.input-newwindow');
        inputTarget.checked = false;
        let inputLightbox = modalImageLink.querySelector('.input-openlightbox');
        inputLightbox.checked = false;
        if (lnk) {
          inputLink.value = lnk.getAttribute('href');
          if (title === '') {
            let lnkTitle = lnk.getAttribute('title');
            if (lnkTitle) inputTitle.value = lnkTitle;
          }
          var target = lnk.getAttribute('target');
          if (target === '_blank') {
            inputTarget.checked = true;
          } else {
            inputTarget.checked = false;
          }
          if (dom.hasClass(lnk, 'is-lightbox')) {
            inputLightbox.checked = true;
          } else {
            inputLightbox.checked = false;
          }
        }
        util.showModal(modalImageLink, true, () => {
          btnImageLink.removeAttribute('data-focus');
          btnImageLink.focus();
        }, true);
        btnImageLink.setAttribute('data-focus', true);
        inputSrc.focus();
      });
      const btnOpenAsset = imageTool.querySelector('.open-asset');
      if (this.builder.opts.onImageSelectClick || this.builder.opts.imageselect) {
        btnOpenAsset.style.display = 'block';
        dom.addEventListener(btnOpenAsset, 'click', () => {
          let img = this.builder.activeImage;
          let currentSrc = img ? img.getAttribute('src') : '';
          this.builder.openImageSelect(src => {
            this.builder.uo.saveForUndo();
            let img = this.builder.activeImage;
            img.addEventListener('load', () => {
              if (this.builder.activeModule) {
                this.refreshIfIsModule(this.builder.activeModule);
                this.builder.activeModule.click();
              } else {
                this.repositionImageTool();
                this.builder.elmTool.repositionElementTool();
              }
            });
            img.setAttribute('src', src);
            this.builder.opts.onChange();
            this.builder.opts.onRender();
            if (this.builder.onImageChange) this.builder.onImageChange();
          }, currentSrc);
        });
      } else {
        btnOpenAsset.style.display = 'none';
      }

      // Edit (crop) image
      const btnImageEdit = imageTool.querySelector('.image-edit');
      dom.addEventListener(btnImageEdit, 'click', () => {
        this.renderPanel();
        let modalImageEdit = builderStuff.querySelector('.imageedit');
        let img = this.builder.activeImage;
        let preview = modalImageEdit.querySelector('.imageedit-preview');
        preview.innerHTML = '<img style="max-width:100%;object-fit:contain;height:100%;"/>';
        let imagePreview = modalImageEdit.querySelector('img');
        if (this.builder.onImageEditClick) {
          let result = this.builder.onImageEditClick(img, imagePreview);
          if (!result) return;
        }
        util.showModal(modalImageEdit, true, () => {
          btnImageEdit.removeAttribute('data-focus');
          btnImageEdit.focus();
        });
        btnImageEdit.setAttribute('data-focus', true);
        const maxW = 800;
        const maxH = 550;
        preview.style.height = '';
        if (img.offsetWidth < maxW && img.offsetHeight < maxH) {
          preview.style.width = img.offsetWidth + 'px';
        } else {
          let h = maxW * img.offsetHeight / img.offsetWidth; // test useing maxW
          if (h <= maxH) {
            //ok
            preview.style.width = maxW + 'px';
          } else {
            preview.style.height = maxH + 'px';
          }
        }
        if (window.innerHeight <= 800) {
          preview.style.height = '350px';
        }

        // imagePreview.src = img.src;
        if (img.src.indexOf('base64') === -1) {
          imagePreview.src = img.src + (img.src.indexOf('?') === -1 ? '?' : '&') + `timestamp=${new Date().getTime()}`;
        } else {
          imagePreview.src = img.src;
        }
        if (this.builder.setCropperConfig) {
          this.cropper = new Cropper(imagePreview, this.builder.setCropperConfig);
        } else {
          this.cropper = new Cropper(imagePreview, {
            zoomable: false
          });
        }
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox) movControlBox.style.display = 'none'; //needed by Safari (prevent z-index problem)
      });
    }
  }

  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let modalImageLink = builderStuff.querySelector('.imagelink');
    if (!modalImageLink) {
      let html = `
                <div class="is-modal imageedit" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                    <div class="is-modal-content">
                        <div class="imageedit-crop" style="display:flex;height:80px;align-items:center;align-self:flex-start;">
                            <button title="5x5" data-crop-size="1" style="width: 60px;height: 60px;">5x5</button>
                            <button title="4x3" data-crop-size="1.33333" style="width: 60px;height: 45px;">4x3</button>
                            <button title="3x4" data-crop-size="0.75" style="width: 45px;height: 60px;">3x4</button>
                            <button title="6x4" data-crop-size="1.5" style="width: 60px;height: 40px;">6x4</button>
                            <button title="4x6" data-crop-size="0.6666" style="width: 40px;height: 60px;">4x6</button>
                            <button title="16x9" data-crop-size="1.77" style="width: 60px;height: 35px;">16x9</button>
                            <button title="${util.out('Free')}" data-crop-size="" style="width: 60px;height: 45px;">${util.out('Free')}</button>
                        </div>
                        <div class="imageedit-preview" style="max-width:1000px;width:100%;max-height:550px;">
                        </div>
                        <div style="margin-top:15px;text-align:right;align-self:flex-end;">
                            <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                            <button title="${util.out('Apply')}" class="input-ok classic-primary">${util.out('Apply')}</button>
                        </div>
                    </div>
                </div>
                
                <div class="is-modal imagelink" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                    <div class="is-modal-content">

                        <label for="inpImageLinkSource" style="display:block">${util.out('Source')}:</label>
                        <div class="image-src">
                            <input id="inpImageLinkSource" class="input-src" type="text"/>
                            <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                                ${this.builder.opts.selectIcon}
                            </button>
                
                            <div class="image-larger1 is-btn classic" style="position:relative;flex:none;box-shadow: 0px 3px 6px -6px rgba(0, 0, 0, 0.32);">
                                <form class="form-upload-larger" target="frameTargetImageUpload" method="post" action="${this.builder.opts.largerImageHandler}" enctype="multipart/form-data" style="border-radius:1px;position:absolute;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;">
				                    <input id="hidRefId1" name="hidRefId" type="hidden" value="" />
                                    <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                    <input onclick="blur()" title="${util.out('Select')}" id="fileImage1" name="fileImage" type="file" accept="image/*" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                                </form>

                                <iframe id="frameTargetImageUpload" name="frameTargetImageUpload" tabindex="-1" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                            </div>
                        </div>

                        <label for="inpImageLinkTitle" style="margin-top:14px;display:block">${util.out('Title')}:</label>
                        <input id="inpImageLinkTitle" class="input-title" type="text" style="width:100%;border-top: none;"/>

                        <label for="inpImageLinkLink" style="margin-top:14px;display:block">${util.out('Link')}:</label>
                        <div class="image-link">
                            <input id="inpImageLinkLink" class="input-link" type="text" style="width:100%;border-top: none;"/>
                            <button title="${util.out('Select')}" class="input-select2" style="flex:none;">
                                ${this.builder.opts.selectIcon}
                            </button>
                            
                            <button title="${util.out(this.builder.opts.otherSelectCaption)}" class="input-select-other" style="display:none;width:50px">${this.builder.opts.otherSelectIcon}</button>
   
                            <div class="image-larger2 is-btn classic" style="position:relative;flex:none;box-shadow: 0px 3px 6px -6px rgba(0, 0, 0, 0.32);">
                                <form class="form-upload-larger" target="frameTargetImageUpload" method="post" action="${this.builder.opts.fileHandler ? this.builder.opts.fileHandler : this.builder.opts.largerImageHandler}" enctype="multipart/form-data" style="border-radius:1px;position:absolute;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;">
				                    <input id="hidRefId2" name="hidRefId" type="hidden" value="" />
                                    <svg class="is-icon-flex"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                    <input onclick="blur()" title="${util.out('Select')}" id="fileImage2" name="fileImage" type="file" accept="*" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                                </form>
                            </div>
                        </div>

                        <label style="display:block;margin-top:14px;">
                            <input class="input-newwindow" id="__input_newwindow2" type="checkbox" />  ${util.out('Open new window')}&nbsp;
                        </label>
                        <label id="lblImageLinkOpenLightbox" style="${this.builder.useLightbox ? 'display:block' : 'display:none'};margin-top:5px;margin-bottom:14px;">
                            <input class="input-openlightbox" id="__input_openlightbox2" type="checkbox" />  ${util.out('Open in a lightbox (for image, video or Youtube)')}&nbsp;
                        </label>
                        
                        <div style="text-align:right;margin-top:14px;">
                            <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                            <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                        </div>
                    </div>
                </div>
                `;
      dom.appendHtml(builderStuff, html);
      let modalImageLink = builderStuff.querySelector('.imagelink');
      if (this.builder.opts.onOtherSelectClick || this.builder.opts.otherSelect) {
        modalImageLink.querySelector('.input-select-other').style.display = 'block';
        const inputSelectOther = modalImageLink.querySelector('.input-select-other');
        if (inputSelectOther) dom.addEventListener(inputSelectOther, 'click', e => {
          if (this.builder.opts.onOtherSelectClick) {
            this.builder.opts.onOtherSelectClick({
              targetInput: modalImageLink.querySelector('.input-link'),
              theTrigger: modalImageLink.querySelector('.input-select-other')
            });
          } else {
            let modalFileSelect = builderStuff.querySelector('.is-modal.otherselect');
            if (this.builder.opts.assetRefresh) {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
              this.builder.opts.assetRefresh = false;
            }
            if (modalFileSelect.querySelector('iframe').src === 'about:blank') {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
            }
            util.showModal(modalFileSelect, false, () => {
              inputSelectOther.removeAttribute('data-focus');
              inputSelectOther.focus();
            }, false, this.builder.assetPanelFullScreen);
            inputSelectOther.setAttribute('data-focus', true);
          }
          this.builder.targetInput = modalImageLink.querySelector('.input-link'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          this.builder.targetAssetType = 'all';
          e.preventDefault();
          e.stopImmediatePropagation();
        });
      }
      if (this.builder.opts.largerImageHandler === '' && !this.builder.opts.onLargerImageUpload) {
        modalImageLink.querySelector('.image-larger1').style.display = 'none';
        modalImageLink.querySelector('.image-larger2').style.display = 'none';
      }
      if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
        modalImageLink.querySelector('.input-select').style.display = 'none';
        modalImageLink.querySelector('.input-select2').style.display = 'none';
      }

      // Cancel
      let elm = modalImageLink.querySelector('.input-cancel');
      dom.addEventListener(elm, 'click', () => {
        util.hideModal(modalImageLink);
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox) movControlBox.style.display = 'none'; //needed by Safari (prevent z-index problem)
      });

      // Apply link to image
      elm = modalImageLink.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        this.builder.uo.saveForUndo();
        let img = this.builder.activeImage;
        let lnk;
        if (img.parentNode.tagName.toLowerCase() === 'a' && img.parentNode.childElementCount === 1) {
          lnk = img.parentNode;
        }
        let src = modalImageLink.querySelector('.input-src').value;
        let title = modalImageLink.querySelector('.input-title').value;
        let link = modalImageLink.querySelector('.input-link').value;
        if (src.indexOf('[Image Data]') === -1) {
          img.setAttribute('src', src);
        }
        img.setAttribute('alt', title);
        if (link !== '') {
          if (lnk) {
            lnk.setAttribute('href', link);
            lnk.setAttribute('title', title);
            if (modalImageLink.querySelector('.input-newwindow').checked) {
              lnk.setAttribute('target', '_blank');
            } else {
              lnk.removeAttribute('target');
            }
            if (modalImageLink.querySelector('.input-openlightbox').checked) {
              dom.addClass(lnk, 'is-lightbox');
            } else {
              dom.removeClass(lnk, 'is-lightbox');
            }
          } else {
            //Create link
            lnk = dom.createElement('a');
            lnk.setAttribute('href', link);
            lnk.setAttribute('title', title);
            lnk.innerHTML = img.outerHTML;
            if (modalImageLink.querySelector('.input-newwindow').checked) {
              lnk.setAttribute('target', '_blank');
            } else {
              lnk.removeAttribute('target');
            }
            if (modalImageLink.querySelector('.input-openlightbox').checked) {
              dom.addClass(lnk, 'is-lightbox');
            } else {
              dom.removeClass(lnk, 'is-lightbox');
            }
            img.outerHTML = lnk.outerHTML;
          }
        } else {
          if (lnk) {
            //Remove link
            lnk.outerHTML = lnk.innerHTML;
          }
        }

        //Check if image is part of module snippet. If so, refresh the (active) module (hide imageTool). If not, refresh imageTool position
        this.refreshIfIsModule(img);
        this.builder.opts.onChange();
        this.builder.opts.onRender();
        util.hideModal(modalImageLink);
        this.builder.elmTool.refresh();
        if (this.builder.onImageChange) this.builder.onImageChange();
      });

      // Select image (opens Asset Manager plugin or custom dialog)
      let divImageSrc = modalImageLink.querySelector('.image-src');
      if (this.builder.opts.onImageSelectClick || this.builder.opts.imageselect) {
        const btnImageSelect = modalImageLink.querySelector('.input-select');
        if (btnImageSelect) dom.addEventListener(btnImageSelect, 'click', () => {
          if (this.builder.opts.onImageSelectClick) {
            this.builder.opts.onImageSelectClick({
              targetInput: modalImageLink.querySelector('.input-src'),
              theTrigger: btnImageSelect
            });
          } else {
            let modalImageSelect = builderStuff.querySelector('.is-modal.imageselect');
            let iframe = modalImageSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.imageselect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.imageselect;
            }
            util.showModal(modalImageSelect, false, () => {
              btnImageSelect.removeAttribute('data-focus');
              btnImageSelect.focus();
            }, false, this.builder.assetPanelFullScreen);
            btnImageSelect.setAttribute('data-focus', true);
          }
          this.builder.targetInput = modalImageLink.querySelector('.input-src'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          this.builder.targetAssetType = 'image';
        });
        const btnImageSelect2 = modalImageLink.querySelector('.input-select2');
        if (btnImageSelect2) dom.addEventListener(btnImageSelect2, 'click', () => {
          if (this.builder.opts.onFileSelectClick) {
            this.builder.opts.onFileSelectClick({
              targetInput: modalImageLink.querySelector('.input-link'),
              theTrigger: btnImageSelect2
            });
            this.builder.targetInput = modalImageLink.querySelector('.input-link'); // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = null;
            this.builder.targetAssetType = 'all';
          } else if (this.builder.opts.fileselect !== '') {
            let modalFileSelect = builderStuff.querySelector('.is-modal.fileselect');
            let iframe = modalFileSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.fileselect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.fileselect;
            }
            util.showModal(modalFileSelect, false, () => {
              btnImageSelect2.removeAttribute('data-focus');
              btnImageSelect2.focus();
            }, false, this.builder.assetPanelFullScreen);
            btnImageSelect2.setAttribute('data-focus', true);
            this.builder.targetInput = modalImageLink.querySelector('.input-link'); // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = null;
            this.builder.targetAssetType = 'all';
          } else if (this.builder.opts.onImageSelectClick) {
            this.builder.opts.onImageSelectClick({
              targetInput: modalImageLink.querySelector('.input-link'),
              theTrigger: btnImageSelect2
            });
            this.builder.targetInput = modalImageLink.querySelector('.input-link'); // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = null;
            this.builder.targetAssetType = 'media';
          } else {
            let modalImageSelect = builderStuff.querySelector('.is-modal.imageselect');
            let iframe = modalImageSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.imageselect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.imageselect;
            }
            util.showModal(modalImageSelect, false, () => {
              btnImageSelect2.removeAttribute('data-focus');
              btnImageSelect2.focus();
            }, false, this.builder.assetPanelFullScreen);
            btnImageSelect2.setAttribute('data-focus', true);
            this.builder.targetInput = modalImageLink.querySelector('.input-link'); // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = null;
            this.builder.targetAssetType = 'media';
          }
        });
      } else {
        dom.removeClass(divImageSrc, 'image-select');
      }
      let fileLargerImage1 = modalImageLink.querySelector('#fileImage1');
      dom.addEventListener(fileLargerImage1, 'change', e => {
        let element = fileLargerImage1;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        modalImageLink.querySelector('#hidRefId1').value = this.builder.opts.customval;
        if (this.builder.opts.onLargerImageUpload) {
          this.builder.opts.onLargerImageUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerImage1.value = ''; // Clear Input
      });

      let fileLargerImage2 = modalImageLink.querySelector('#fileImage2');
      dom.addEventListener(fileLargerImage2, 'change', e => {
        let element = fileLargerImage2;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        modalImageLink.querySelector('#hidRefId2').value = this.builder.opts.customval;
        if (this.builder.opts.onFileUpload) {
          this.builder.opts.onFileUpload(e);
        } else if (this.builder.opts.onLargerImageUpload) {
          this.builder.opts.onLargerImageUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerImage2.value = ''; // Clear Input
      });

      // Image Edit Dialog (.is-modal.imageedit) ~~~~~~~~~~~~
      let modalImageEdit = builderStuff.querySelector('.imageedit');

      // Set crop proportion
      let cropOptions = modalImageEdit.querySelector('.imageedit-crop');
      let btns = cropOptions.querySelectorAll('button');
      Array.prototype.forEach.call(btns, btn => {
        dom.addEventListener(btn, 'click', () => {
          let aspectRatio = btn.getAttribute('data-crop-size') * 1;
          this.cropper.setAspectRatio(aspectRatio);
        });
      });

      // Cancel image edit
      let btnCancel = modalImageEdit.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        util.hideModal(modalImageEdit);
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox && !this.builder.hideImageResizer) movControlBox.style.display = 'block'; //needed by Safari (prevent z-index problem)
      });

      // Apply (crop) image
      elm = modalImageEdit.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        this.builder.uo.saveForUndo();
        let img = this.builder.activeImage;
        let attr = img.getAttribute('data-filename');
        let extension = 'jpg';
        if (attr) {
          extension = attr.substr(attr.lastIndexOf('.') + 1).toLowerCase();
        } else {
          // no data-filename found (image from snippets)
          let f = img.src;
          if (f.indexOf('/') > -1) img.setAttribute('data-filename', f.substr(f.lastIndexOf('/') + 1));else img.setAttribute('data-filename', f);
          extension = f.substr(f.lastIndexOf('.') + 1).toLowerCase();
        }
        if (this.builder.opts.imageRenameOnEdit) {
          let basename = '';
          if (img.src.indexOf('base64') === -1) {
            let src = img.getAttribute('src');
            let filename = src.substring(src.lastIndexOf('/') + 1);
            basename = dom.baseName(filename);
          } else {
            basename = dom.baseName(img.getAttribute('data-filename'));
          }
          let newname = '';
          if (basename.indexOf('-edit') !== -1) {
            basename = basename.substr(0, basename.indexOf('-edit'));
          }
          newname = basename + '-edit' + util.makeId();
          newname = newname.replaceAll('%20', '-'); // fix 404 error after file upload

          img.setAttribute('data-filename', newname + '.' + extension);
        }
        if (extension === 'jpg' || extension === 'jpeg' || extension === 'webm' || extension === 'webp') {
          img.src = this.cropper.getCroppedCanvas({
            fillColor: '#fff',
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high'
          }).toDataURL('image/jpeg');
        } else {
          img.src = this.cropper.getCroppedCanvas({}).toDataURL();
        }

        //Check if image is part of module snippet. If so, refresh the (active) module (hide imageTool). If not, refresh imageTool position
        this.refreshIfIsModule(img);

        //Trigger Change event
        this.builder.opts.onChange();
        util.hideModal(modalImageEdit);
        this.builder.elmTool.refresh();
        if (this.builder.onImageChange) this.builder.onImageChange();
      });
    }
  }
  startImageMonitor(target) {
    let observer;
    const config = {
      attributes: true
    };
    observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        if (mutation.attributeName === 'src') {
          // console.log('Image Changed:' + target.src);

          if (this.builder.onImageSrcChange) this.builder.onImageSrcChange();
          stopImageMonitor(); // Stop the monitor when the image changes
        }
      });
    });

    observer.observe(target, config);
    function stopImageMonitor() {
      if (observer) {
        observer.disconnect();
        // console.log('Monitor Stopped');
      }
    }
  }
  open() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    this.renderPanel();
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none'; //needed by Safari (prevent z-index problem)

    if (this.builder.opts.onImageSettingClick) {
      this.builder.opts.onImageSettingClick();
      return false;
    }
    const modalImageLink = builderStuff.querySelector('.imagelink');
    let img = this.builder.activeImage;
    let lnk = img.closest('a');
    let src = img.getAttribute('src');
    let title = img.getAttribute('alt');
    let inputSrc = modalImageLink.querySelector('.input-src');
    if (src.indexOf('base64') === -1) {
      inputSrc.value = src;
    } else {
      inputSrc.value = '[Image Data]';
    }
    let inputTitle = modalImageLink.querySelector('.input-title');
    inputTitle.value = title;
    let inputLink = modalImageLink.querySelector('.input-link');
    inputLink.value = '';
    let inputTarget = modalImageLink.querySelector('.input-newwindow');
    inputTarget.checked = false;
    let inputLightbox = modalImageLink.querySelector('.input-openlightbox');
    inputLightbox.checked = false;
    if (lnk) {
      inputLink.value = lnk.getAttribute('href');
      if (title === '') {
        let lnkTitle = lnk.getAttribute('title');
        if (lnkTitle) inputTitle.value = lnkTitle;
      }
      var target = lnk.getAttribute('target');
      if (target === '_blank') {
        inputTarget.checked = true;
      } else {
        inputTarget.checked = false;
      }
      if (lnk.classList.contains('is-lightbox')) {
        inputLightbox.checked = true;
      } else {
        inputLightbox.checked = false;
      }
    }
    util.showModal(modalImageLink, true, () => {

      // btnImageLink.removeAttribute('data-focus');
      // btnImageLink.focus();
    }, true);

    // btnImageLink.setAttribute('data-focus', true);

    inputSrc.focus();
  }
  change(input) {
    // still not used
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    this.builder.uo.saveForUndo();
    let img = this.builder.activeImage;
    let imageProgress = builderStuff.querySelector('#divImageProgress');
    imageProgress.style.display = 'table';
    imageProgress.style.width = img.offsetWidth * this.builder.opts.zoom + 'px';
    imageProgress.style.height = img.offsetHeight * this.builder.opts.zoom + 'px';
    const newPos = util.getElementPosition(img);
    let top = newPos.top + window.pageYOffset;
    let left = newPos.left + window.pageXOffset;
    imageProgress.style.top = top + 'px';
    imageProgress.style.left = left + 'px';
    try {
      img.setAttribute('data-filename', input.files[0].name); //needed for saveimage.js | 
      this.processImage(input.files[0], img, () => {
        imageProgress.style.display = 'none';
        input.value = ''; //clear input

        //Check if image is part of module snippet. If so, refresh the (active) module (hide imageTool). If not, refresh imageTool position
        this.refreshIfIsModule(img);

        //Trigger Change event
        this.builder.opts.onChange();
        this.builder.elmTool.refresh();
      });
    } catch (e) {
      imageProgress.style.display = 'none';
    }
  }
  edit() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    this.renderPanel();
    const modalImageEdit = builderStuff.querySelector('.imageedit');
    let img = this.builder.activeImage;
    let preview = modalImageEdit.querySelector('.imageedit-preview');
    preview.innerHTML = '<img style="max-width:100%;object-fit:contain;height:100%;"/>';
    let imagePreview = modalImageEdit.querySelector('img');
    if (this.builder.onImageEditClick) {
      let result = this.builder.onImageEditClick(img, imagePreview);
      if (!result) return;
    }
    util.showModal(modalImageEdit, true, () => {

      // btnImageEdit.removeAttribute('data-focus');
      // btnImageEdit.focus();
    });

    // btnImageEdit.setAttribute('data-focus', true);

    const maxW = 800;
    const maxH = 550;
    preview.style.height = '';
    if (img.offsetWidth < maxW && img.offsetHeight < maxH) {
      preview.style.width = img.offsetWidth + 'px';
    } else {
      let h = maxW * img.offsetHeight / img.offsetWidth; // test useing maxW
      if (h <= maxH) {
        //ok
        preview.style.width = maxW + 'px';
      } else {
        preview.style.height = maxH + 'px';
      }
    }
    if (window.innerHeight <= 800) {
      preview.style.height = '350px';
    }

    // imagePreview.src = img.src;
    if (img.src.indexOf('base64') === -1) {
      imagePreview.src = img.src + (img.src.indexOf('?') === -1 ? '?' : '&') + `timestamp=${new Date().getTime()}`;
    } else {
      imagePreview.src = img.src;
    }
    if (this.builder.setCropperConfig) {
      this.cropper = new Cropper(imagePreview, this.builder.setCropperConfig);
    } else {
      this.cropper = new Cropper(imagePreview, {
        zoomable: false
      });
    }
    const movControlBox = document.querySelector('.moveable-control-box');
    if (movControlBox) movControlBox.style.display = 'none'; //needed by Safari (prevent z-index problem)
  }

  refreshIfIsModule(elm) {
    const dom = this.builder.dom;
    const util = this.builder.util;
    let isModule = dom.parentsHasAttribute(elm, 'data-html');
    if (isModule) {
      if (this.imageTool) this.imageTool.style.display = '';

      // Extra: make image[data-image-embed] clickable/editable
      if (elm.hasAttribute('data-sync')) {
        let originalSrc = elm.getAttribute('data-src');
        let originalFilename = elm.getAttribute('data-filename');
        if (originalSrc) {
          let element = elm;
          while (!element.getAttribute('data-html')) {
            element = element.parentNode;
          }
          let module = element;
          let imgs = module.querySelectorAll('img');
          Array.prototype.forEach.call(imgs, img => {
            if (img.src === originalSrc) {
              img.src = elm.src;
              img.removeAttribute('data-src');
              img.setAttribute('data-filename', originalFilename);
            }
          });
          elm.removeAttribute('data-src');
        }
      }
      setTimeout(() => {
        util.refreshModule();
        if (this.imageTool) this.imageTool.style.display = '';
      }, 1000);
    } else {
      elm.onload = () => {
        this.refresh();
      };
    }
  }
  refresh() {
    const util = this.builder.util;
    const dom = this.builder.dom;
    if (this.builder.activeImage) {
      let imageTool = this.imageTool;
      imageTool.style.display = '';
      setTimeout(() => {
        let elm = this.builder.activeImage;
        if (!elm) return;
        if (dom.hasClass(elm.parentNode, 'img-circular')) {
          elm = elm.parentNode;
        }
        const newPos = util.getElementPosition(elm);
        let scaleX = newPos.scaleX;
        imageTool.style.display = 'flex';
        let _toolwidth = imageTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

        let w = elm.offsetWidth * scaleX * this.builder.opts.zoom;
        let top = newPos.top + window.pageYOffset;
        let left = newPos.left + window.pageXOffset;
        let toolLeft = left + (w / 2 - _toolwidth / 2);

        //Adjust left in case an element is outside the screen
        const _screenwidth = window.innerWidth;
        if (!this.builder.iframe) {
          if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left;
        } else {
          let adjX = this.builder.iframe.getBoundingClientRect().left + window.pageXOffset;
          if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left + adjX;
        }
        imageTool.style.top = top + 'px';
        imageTool.style.left = toolLeft + 'px';
        let imageResizer = this.imageResizer;
        imageResizer.style.top = top + 'px';
        imageResizer.style.left = left + 'px';
        imageResizer.style.width = elm.offsetWidth * this.builder.opts.zoom + 'px';
        imageResizer.style.height = elm.offsetHeight * this.builder.opts.zoom + 'px';
        if (!this.builder.hideImageResizer) imageResizer.style.display = 'block';
        this.repositionHandler(elm.offsetWidth, elm.offsetHeight);

        // moveable
        if (this.builder.moveable) this.builder.moveable.updateRect();
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox && !this.builder.hideImageResizer) movControlBox.style.display = 'block';
        if (elm.offsetWidth === 0) {
          // when there is image link applied

          // let imageTool = this.imageTool;
          imageTool.style.display = '';
          this.builder.activeImage = null;

          // let imageResizer = this.imageResizer;
          imageResizer.style.display = 'none';

          // moveable
          imageResizer.style.top = '-10px';
          imageResizer.style.left = '-10px';
          imageResizer.style.width = '1px';
          imageResizer.style.height = '1px';
          if (this.builder.moveable) this.builder.moveable.updateRect();
          const movControlBox = document.querySelector('.moveable-control-box');
          if (movControlBox) movControlBox.style.display = 'none';
        }
        util.repositionColumnTool();
      }, 0); // refesh() is called after img onload, so no need to have a delay.
    }
  }

  repositionImageTool() {
    // = refresh(), but without delay
    const util = this.builder.util;
    const dom = this.builder.dom;
    if (this.builder.activeImage) {
      let imageTool = this.imageTool;
      if (!imageTool) return;
      let elm = this.builder.activeImage;
      if (dom.hasClass(elm.parentNode, 'img-circular')) {
        elm = elm.parentNode;
      }
      const newPos = util.getElementPosition(elm);
      let scaleX = newPos.scaleX;
      imageTool.style.display = 'flex';
      let _toolwidth = imageTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

      let w = elm.offsetWidth * scaleX * this.builder.opts.zoom;
      let top = newPos.top + window.pageYOffset;
      let left = newPos.left + window.pageXOffset;
      let toolLeft = left + (w / 2 - _toolwidth / 2);

      //Adjust left in case an element is outside the screen
      const _screenwidth = window.innerWidth;
      if (!this.builder.iframe) {
        if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left;
      } else {
        let adjX = this.builder.iframe.getBoundingClientRect().left + window.pageXOffset;
        if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left + adjX;
      }
      imageTool.style.top = top + 'px';
      imageTool.style.left = toolLeft + 'px';
      if (!this.builder.activeImage.hasAttribute('data-noresize') && (this.builder.imageResizeOnBlock || !this.builder.activeImage.closest('.is-block'))) {
        let imageResizer = this.imageResizer;
        imageResizer.style.top = top + 'px';
        imageResizer.style.left = left + 'px';
        imageResizer.style.width = elm.offsetWidth * this.builder.opts.zoom + 'px';
        imageResizer.style.height = elm.offsetHeight * this.builder.opts.zoom + 'px';
        if (!this.builder.hideImageResizer) imageResizer.style.display = 'block';
        this.repositionHandler(elm.offsetWidth, elm.offsetHeight);

        // moveable
        if (this.builder.moveable) this.builder.moveable.updateRect();
        const movControlBox = document.querySelector('.moveable-control-box');
        if (movControlBox && !this.builder.hideImageResizer) movControlBox.style.display = 'block';
      }
    }
  }
  hideImageResizer() {
    let imageResizer = this.imageResizer;
    if (!imageResizer) return;
    imageResizer.style.display = 'none';

    // moveable
    imageResizer.style.top = '-10px';
    imageResizer.style.left = '-10px';
    imageResizer.style.width = '1px';
    imageResizer.style.height = '1px';
    if (this.builder.moveable) {
      this.builder.moveable.updateRect();
      document.querySelector('.moveable-control-box').style.display = 'none';
    }
  }
  hideImageTool() {
    let imageTool = this.imageTool;
    if (imageTool) imageTool.style.display = '';
    this.hideImageResizer();
  }
  click(e) {
    const util = this.builder.util;
    const dom = this.builder.dom;
    let elm = e.target;

    //Image
    if (elm.tagName.toLowerCase() === 'img') {
      /* <img data-fixed src=".." /> (image must be fixed, cannot be replaced) */
      let fixedImage = false;
      if (elm.hasAttribute('data-fixed')) {
        fixedImage = true;
      }
      if (!fixedImage) {
        this.builder.activeImage = elm;
        if (dom.hasClass(elm.parentNode, 'img-circular')) {
          elm = elm.parentNode;
        }
        const newPos = util.getElementPosition(elm);
        let scaleX = newPos.scaleX;
        this.renderTool();
        let imageTool = this.imageTool;
        imageTool.style.display = 'flex';
        let _toolwidth = imageTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

        let w = elm.offsetWidth * scaleX * this.builder.opts.zoom;
        let top = newPos.top + window.pageYOffset;
        let left = newPos.left + window.pageXOffset;
        let toolLeft = left + (w / 2 - _toolwidth / 2);

        //Adjust left in case an element is outside the screen
        const _screenwidth = window.innerWidth;
        if (!this.builder.iframe) {
          if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left;
        } else {
          let adjX = this.builder.iframe.getBoundingClientRect().left + window.pageXOffset;
          if (_toolwidth + left > _screenwidth) toolLeft = elm.getBoundingClientRect().left + adjX;
        }
        imageTool.style.top = top + 'px';
        imageTool.style.left = toolLeft + 'px';

        // Image Resizer
        if (!elm.hasAttribute('data-noresize') && (this.builder.imageResizeOnBlock || !elm.closest('.is-block'))) {
          let imageResizer = this.imageResizer;
          const newPos = util.getElementPosition(elm);
          let top = newPos.top + window.pageYOffset;
          let left = newPos.left + window.pageXOffset;
          let scaleX = newPos.scaleX;
          let scaleY = newPos.scaleY;
          imageResizer.style.top = top + 'px';
          imageResizer.style.left = left + 'px';
          imageResizer.style.width = elm.offsetWidth * this.builder.opts.zoom * scaleX + 'px';
          imageResizer.style.height = elm.offsetHeight * this.builder.opts.zoom * scaleY + 'px';
          if (!this.builder.hideImageResizer) imageResizer.style.display = 'block';
          this.repositionHandler(elm.offsetWidth, elm.offsetHeight);

          //Get & save original image width
          let imgwidth = elm.style.width;
          let imgwidthpx;
          if (imgwidth.indexOf('%') !== -1) {
            imgwidth = imgwidth.replace('%', '') * 1;
            imgwidthpx = elm.offsetWidth * 100 / imgwidth;
          } else {
            imgwidthpx = elm.offsetWidth;
          }
          imageResizer.setAttribute('data-width', Math.round(imgwidthpx));

          // moveable
          if (this.builder.moveable) this.builder.moveable.updateRect();
          const movControlBox = document.querySelector('.moveable-control-box');
          if (movControlBox && !this.builder.hideImageResizer) movControlBox.style.display = 'block';
          const handleImageToolClickOut = e => {
            let elm = e.target;
            if (!elm) return;
            if (!elm.closest('#divImageResizer') && !elm.closest('#divImageTool') && !elm.closest('.is-modal') && !elm.closest('.keep-selection') && !elm.closest('.sl-wrapper') && !elm.closest('.sl-overlay') && !elm.closest('.sl-close') && !elm.closest('img')) {
              // click outside

              // hide
              this.hideImageTool();
              document.removeEventListener('click', handleImageToolClickOut);
              if (this.builder.iframeDocument) {
                this.builder.doc.removeEventListener('click', handleImageToolClickOut);
              }
              this.builder.handleImageToolClickOut_ = false;
            }
          };
          if (!this.builder.handleImageToolClickOut_) {
            document.addEventListener('click', handleImageToolClickOut);
            if (this.builder.iframeDocument) {
              this.builder.doc.addEventListener('click', handleImageToolClickOut);
            }
            this.builder.handleImageToolClickOut_ = true;
          }
        } else {
          let imageResizer = this.imageResizer;
          imageResizer.style.display = 'none';

          // moveable
          imageResizer.style.top = '-10px';
          imageResizer.style.left = '-10px';
          imageResizer.style.width = '1px';
          imageResizer.style.height = '1px';
          if (this.builder.moveable) this.builder.moveable.updateRect();
          const movControlBox = document.querySelector('.moveable-control-box');
          if (movControlBox) movControlBox.style.display = 'none';
        }
        if (this.builder.canvas) ; else {
          let prog = false;
          if (e.screenX && e.screenX !== 0 && e.screenY && e.screenY !== 0) ; else {
            // console.log('Programmatically');
            prog = true;
          }
          if (prog) {
            this.hideImageTool();
          }
        }
      } else {
        this.builder.activeImage = null;
        this.hideImageTool();
      }
    } else {
      this.builder.activeImage = null;
    }
  }

  // Image Resizer
  repositionHandler(width, height) {
    const util = this.builder.util;
    let imageResizer = document.querySelector('#divImageResizer');
    imageResizer.style.width = width * this.builder.opts.zoom + 'px';
    imageResizer.style.height = height * this.builder.opts.zoom + 'px';
    const newPos = util.getElementPosition(imageResizer);
    let scaleX = newPos.scaleX;
    let scaleY = newPos.scaleY;
    imageResizer.style.width = width * this.builder.opts.zoom * scaleX + 'px';
    imageResizer.style.height = height * this.builder.opts.zoom * scaleY + 'px';
  }
  processImage(file, targetImg, processImageDone) {
    //file can also be an URL (from the same host), ex. file = "/assets/image.jpg";

    if (!file) {
      processImageDone();
      return false;
    }
    if (!document.getElementById('myTmpCanvasNoCrop')) {
      var new_canvas = document.createElement('canvas');
      new_canvas.id = 'myTmpCanvasNoCrop';
      new_canvas.style.display = 'none';
      document.querySelector('body').appendChild(new_canvas);
    }
    var extension;
    if (!file.name) {
      //file is an URL
      extension = file.substr(file.lastIndexOf('.') + 1).toLowerCase();
    } else {
      //file is an image file
      extension = file.name.substr(file.name.lastIndexOf('.') + 1).toLowerCase();
    }
    var type, quality;
    if (extension === 'jpg' || extension === 'jpeg') {
      type = 'image/jpeg';
      quality = this.builder.opts.imageQuality;
    } else {
      type = 'image/png';
      quality = 1;
    }
    if (this.builder.opts.maxEmbedImageWidth === -1) {
      js(file, img => {
        targetImg.src = img.toDataURL(type, quality);
        processImageDone();
      }, {
        canvas: true
      });
    } else {
      js(file, img => {
        targetImg.src = img.toDataURL(type, quality);
        processImageDone();
      }, {
        maxWidth: this.builder.opts.maxEmbedImageWidth,
        maxHeight: this.builder.opts.maxEmbedImageWidth,
        canvas: true
      });
    }
  }
}

const dom$h = new Dom();
class Tabs {
  constructor(opts = {}) {
    let defaults = {
      element: document
    };
    Object.assign(this, defaults, opts);

    // Close all dropdown
    const closeAllDropdowns = () => {
      let elms = this.element.querySelectorAll('.is-tabs-more');
      Array.prototype.forEach.call(elms, elm => {
        elm.style.display = 'none';
        elm.setAttribute('aria-expanded', false);
      });
      document.removeEventListener('click', handleClickOut);
    };
    const handleClickOut = e => {
      if (!(e.target.closest('.is-tab-more') || e.target.closest('[data-menu]'))) {
        closeAllDropdowns();
      }
    };

    // Open Tab Content
    const select = tab => {
      const group = tab.parentNode.getAttribute('data-group');
      const menuid = tab.getAttribute('data-menu');
      if (menuid) {
        // Open Dropdown

        document.addEventListener('click', handleClickOut);
        tab.setAttribute('aria-expanded', true);
        this.element.querySelector('#' + menuid).style.display = 'block';
        let activeItem = this.element.querySelector('.is-tabs-more[data-group="' + group + '"] > li.active');
        if (activeItem) activeItem.focus();else {
          let dropdown = this.element.querySelector('.is-tabs-more[data-group="' + group + '"]');
          dropdown.focus();
        }
        return false;
      }
      if (dom$h.hasClass(tab, 'active')) {
        return false;
      }
      const id = tab.getAttribute('data-content');
      if (!id) {
        return false;
      }

      // Highlight selected
      let samegrouptabs = this.element.querySelectorAll('.is-tabs[data-group="' + group + '"] > a');
      Array.prototype.forEach.call(samegrouptabs, samegrouptab => {
        dom$h.removeClass(samegrouptab, 'active');
      });
      samegrouptabs = this.element.querySelectorAll('.is-tabs-more[data-group="' + group + '"] > li');
      Array.prototype.forEach.call(samegrouptabs, samegrouptab => {
        dom$h.removeClass(samegrouptab, 'active');
      });
      dom$h.addClass(tab, 'active');
      let samegroupcontents = this.element.querySelectorAll('.is-tab-content[data-group="' + group + '"]');
      Array.prototype.forEach.call(samegroupcontents, samegroupcontent => {
        samegroupcontent.style.display = 'none';
        dom$h.removeClass(samegroupcontent, 'active');
      });
      const content = this.element.querySelector('#' + id);
      content.style.display = 'flex';
      dom$h.addClass(content, 'active');
      const tabMore = this.element.querySelector('.is-tabs-more');
      if (tabMore) tabMore.style.display = 'none';

      // Close all dropdown
      closeAllDropdowns();
      this.setupTabKey(content);
      return false;
    };
    let tabs = this.element.querySelectorAll('.is-tabs a');
    Array.prototype.forEach.call(tabs, tab => {
      tab.addEventListener('keydown', e => {
        e.preventDefault();
        if (e.which === 39 && e.target.nextElementSibling) {
          // arrow right key pressed
          e.target.nextElementSibling.focus();
        } else if (e.which === 37 && e.target.previousElementSibling) {
          // arrow left key pressed
          e.target.previousElementSibling.focus();
        } else if (e.keyCode === 13 || e.keyCode === 32) {
          // enter or spacebar key
          select(e.target);
        } else if (e.which === 9 && !e.shiftKey) {
          // tab key pressed

          // Redirect to tab content
          let inputs = [];
          const group = tab.parentNode.getAttribute('data-group');
          let tabContent = tab.parentNode.parentNode.querySelector('.is-tab-content[data-group="' + group + '"].active');
          let controls = tabContent.querySelectorAll('.is-tabs.active, a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex]');
          controls.forEach(control => {
            inputs.push(control);
          });
          if (inputs.length === 0) return;
          let firstInput = inputs[0];
          firstInput.focus();
        }
      });
      tab.addEventListener('click', e => {
        e.preventDefault();
        select(e.target);
      });
    });
    const dropdowns = this.element.querySelectorAll('.is-tabs-more'); // //When dropdown opens, press arrow down will set focus on the first item
    Array.prototype.forEach.call(dropdowns, dropdown => {
      dropdown.addEventListener('keydown', e => {
        e.preventDefault();
        if (e.keyCode === 40 && e.target.nextElementSibling) {
          // down
          dropdown.querySelector('li').focus(); // focus on the first item
        } else if (e.keyCode === 27) {
          // escape key
          closeAllDropdowns();
        }
      });
    });
    tabs = this.element.querySelectorAll('.is-tabs-more li');
    Array.prototype.forEach.call(tabs, tab => {
      tab.addEventListener('keydown', e => {
        e.preventDefault();
        e.stopImmediatePropagation(); // a must, to prevent .is-tabs-more keydown

        if (e.keyCode === 38 && e.target.previousElementSibling) {
          // up
          e.target.previousElementSibling.focus();
        } else if (e.keyCode === 40 && e.target.nextElementSibling) {
          // down
          e.target.nextElementSibling.focus();
        } else if (e.keyCode === 27) {
          // escape key
          closeAllDropdowns();
        } else if (e.keyCode === 13 || e.keyCode === 32) {
          // enter or spacebar key

          select(e.target);
          if (e.target.closest('.is-tabs-more')) {
            const id = tab.parentNode.getAttribute('id');
            const btn = this.element.querySelector('.is-tabs a[data-menu="' + id + '"]');
            if (btn) btn.focus();
          }
        }
      });
      tab.addEventListener('click', e => {
        e.preventDefault();
        select(e.target);
        if (e.target.closest('.is-tabs-more')) {
          const id = tab.parentNode.getAttribute('id');
          const btn = this.element.querySelector('.is-tabs a[data-menu="' + id + '"]');
          if (btn) btn.focus();
        }
      });
    });
  }
  setupTabKey(area) {
    // Redirect to tab content
    let inputs = [];
    let controls = area.querySelectorAll('.is-tabs.active, a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex]');
    controls.forEach(control => {
      inputs.push(control);
    });
    if (inputs.length === 0) return;
    let firstInput = inputs[0];
    let lastInput = inputs[inputs.length - 1];
    lastInput.addEventListener('keydown', e => {
      if (e.which === 9 && !e.shiftKey) {
        e.preventDefault();

        // goto parent
        let id = area.getAttribute('id');
        const item = this.element.querySelector('li[data-content="' + id + '"],a[data-content="' + id + '"]');
        if (item.closest('.is-tabs-more')) {
          // part of dropdown

          id = item.parentNode.getAttribute('id');
          const btn = this.element.querySelector('.is-tabs a[data-menu="' + id + '"]');
          if (btn) btn.focus();
        } else {
          item.focus();
        }
      }
    });
    firstInput.addEventListener('keydown', e => {
      if (e.which === 9 && e.shiftKey) {
        e.preventDefault();

        // goto parent
        let id = area.getAttribute('id');
        const item = this.element.querySelector('li[data-content="' + id + '"],a[data-content="' + id + '"]');
        if (item.closest('.is-tabs-more')) {
          // part of dropdown

          id = item.parentNode.getAttribute('id');
          const btn = this.element.querySelector('.is-tabs a[data-menu="' + id + '"]');
          if (btn) btn.focus();
        } else {
          item.focus();
        }
      }
    });
  }
}

class ButtonEditor {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const dom = this.builder.dom;
    this.dom = dom;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    let buttonModal = builderStuff.querySelector('.is-modal.buttoneditor');
    if (!buttonModal) {
      let html = `
            <div class="is-modal is-modal-content buttoneditor" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-bar is-draggable">
                    ${util.out('Button')}
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
                <div style="padding:0;height:100%;">
                    <div class="is-tabs" data-group="button" style="position:relative;z-index:1">
                        <a title="${util.out('General')}" href="" data-content="divButtonGeneral" class="active">${util.out('General')}</a>
                        <a title="${util.out('Hover')}" href="" data-content="divButtonHover">${util.out('Hover')}</a>
                        <a title="${util.out('Text')}" href="" data-content="divButtonText">${util.out('Text')}</a>
                        <a title="${util.out('Saved')}" href="" data-content="divMyButtons">${util.out('Saved')}</a>
                        <a title="${util.out('Templates')}" href="" data-content="divButtonTemplates">${util.out('Templates')}</a>
                    </div>
                    <div id="divButtonGeneral" class="is-tab-content active" tabindex="-1" data-group="button" style="display: flex;
                        height: 100%;
                        width:100%;
                        overflow-y: auto;
                        position: absolute;
                        border-top: 82px solid transparent;
                        box-sizing: border-box;
                        top: 0px;">

                        <div class="flex flex-row">
                            <div class="flex flex-col" style="margin-right: 40px;">
                                <div>
                                    <span>${util.out('Background Color')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Background Color')}" class="bg-color-command" style="width:45px;height:40px;border:rgb(0 0 0 / 6%) 1px solid;margin-right:4px"></button>
                                </div>
                            </div>
                            
                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Text Color')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Text Color')}" class="text-color-command" style="width:45px;height:40px;border:rgb(0 0 0 / 6%) 1px solid;margin-right:4px"></button>
                                </div>
                            </div>
                            <div class="flex flex-col" style="margin-left: 60px;">
                                <div>
                                    <span>${util.out('Width')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Auto')}" data-command="auto" class="width-command" style="margin-right:4px">${util.out('Auto')}</button>
                                    <button title="${util.out('Full')}" data-command="full" class="width-command" style="margin-right:4px">${util.out('Full')}</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col" style="margin-right: 40px;">
                                <div>
                                    <span>${util.out('Border Color')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Transparent')}" data-command="transparent" class="border-color-command" style="margin-right:4px">${util.out('Transparent')}</button>
                                    <button title="${util.out('Current')}" data-command="current" class="border-color-command" style="margin-right:4px">${util.out('Current')}</button>
                                </div>
                            </div>

                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Border Thickness')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('No Border')}" data-command="0" class="border-width-command" style="margin-right:4px">${util.out('No Border')}</button>
                                    <button title="1px" data-command="1" class="border-width-command" style="text-transform:none;margin-right:4px">1px</button>
                                    <button title="2px" data-command="2" class="border-width-command" style="text-transform:none;margin-right:4px">2px</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col" style="margin-right: 20px;">
                                <div>
                                    <span>${util.out('Padding Left/Right')}</span>:
                                </div>
                                <div class="flex flex-row" style="margin-top:5px">
                                    <button title="2" data-command="2" class="paddingx-command" style="margin-right:4px">2</button>
                                    <button title="3" data-command="3" class="paddingx-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="paddingx-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="paddingx-command" style="margin-right:4px">5</button>
                                    <button title="6" data-command="6" class="paddingx-command" style="margin-right:4px">6</button>
                                    <button title="7" data-command="7" class="paddingx-command" style="margin-right:4px">7</button>
                                    <button title="8" data-command="8" class="paddingx-command" style="margin-right:4px">8</button>
                                    <button title="9" data-command="9" class="paddingx-command" style="margin-right:4px">9</button>
                                    <button title="10" data-command="10" class="paddingx-command" style="margin-right:4px">10</button>
                                    <button title="11" data-command="11" class="paddingx-command" style="margin-right:4px">11</button>
                                    <button title="12" data-command="12" class="paddingx-command" style="margin-right:4px">12</button>
                                </div>
                            </div>

                            <div class="flex flex-col" style="display:none">
                                <div>
                                    <span>${util.out('Padding Y')}</span>:
                                </div>
                                <div class="flex flex-row" style="margin-top:5px">
                                    <button title="0" data-command="0" class="paddingy-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="paddingy-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="paddingy-command" style="margin-right:4px">2</button>
                                    <button title="3" data-command="3" class="paddingy-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="paddingy-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="paddingy-command" style="margin-right:4px">5</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col" style="margin-right: 20px;">
                                <div>
                                    <span>${util.out('Padding Top')}</span>:
                                </div>
                                <div class="flex flex-row" style="margin-top:5px">
                                    <button title="0" data-command="0" class="paddingtop-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="paddingtop-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="paddingtop-command" style="margin-right:4px">2</button>
                                    <button title="3" data-command="3" class="paddingtop-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="paddingtop-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="paddingtop-command" style="margin-right:4px">5</button>
                                </div>
                            </div>

                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Padding Bottom')}</span>:
                                </div>
                                <div class="flex flex-row" style="margin-top:5px">
                                    <button title="0" data-command="0" class="paddingbottom-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="paddingbottom-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="paddingbottom-command" style="margin-right:4px">2</button>
                                    <button title="3" data-command="3" class="paddingbottom-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="paddingbottom-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="paddingbottom-command" style="margin-right:4px">5</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-col" style="margin:15px 0 0">
                            <div>
                                <span>${util.out('Border Radius')}</span>:
                            </div>
                            <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                <button title="${util.out('None')}" data-command="none" class="border-radius-command" style="margin-right:4px">${util.out('None')}</button>
                                <button title="${util.out('SM')}" data-command="sm" class="border-radius-command" style="margin-right:4px">${util.out('SM')}</button>
                                <button title="${util.out('Normal')}" data-command="normal" class="border-radius-command" style="margin-right:4px">${util.out('Normal')}</button>
                                <button title="${util.out('MD')}" data-command="md" class="border-radius-command" style="margin-right:4px">${util.out('MD')}</button>
                                <button title="${util.out('LG')}" data-command="lg" class="border-radius-command" style="margin-right:4px">${util.out('LG')}</button>
                                <button title="${util.out('XL')}" data-command="xl" class="border-radius-command" style="margin-right:4px">${util.out('XL')}</button>
                                <button title="${util.out('2XL')}" data-command="2xl" class="border-radius-command" style="margin-right:4px">${util.out('2XL')}</button>
                                <button title="${util.out('3XL')}" data-command="3xl" class="border-radius-command" style="margin-right:4px">${util.out('3XL')}</button>
                                <button title="${util.out('Full')}" data-command="full" class="border-radius-command" style="margin-right:4px">${util.out('Full')}</button>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col" style="margin-right: 20px;">
                                <div>
                                    <span>${util.out('Margin Left')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="0" data-command="0" class="ml-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="ml-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="ml-command" style="margin-right:2px">2</button>
                                    <button title="3" data-command="3" class="ml-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="ml-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="ml-command" style="margin-right:4px">5</button>
                                </div>
                            </div>

                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Margin Right')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="0" data-command="0" class="mr-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="mr-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="mr-command" style="margin-right:2px">2</button>
                                    <button title="3" data-command="3" class="mr-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="mr-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="mr-command" style="margin-right:4px">5</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col" style="margin-right: 20px;">
                                <div>
                                    <span>${util.out('Margin Top')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="0" data-command="0" class="mt-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="mt-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="mt-command" style="margin-right:2px">2</button>
                                    <button title="3" data-command="3" class="mt-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="mt-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="mt-command" style="margin-right:4px">5</button>
                                </div>
                            </div>

                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Margin Bottom')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="0" data-command="0" class="mb-command" style="margin-right:4px">0</button>
                                    <button title="1" data-command="1" class="mb-command" style="margin-right:4px">1</button>
                                    <button title="2" data-command="2" class="mb-command" style="margin-right:2px">2</button>
                                    <button title="3" data-command="3" class="mb-command" style="margin-right:4px">3</button>
                                    <button title="4" data-command="4" class="mb-command" style="margin-right:4px">4</button>
                                    <button title="5" data-command="5" class="mb-command" style="margin-right:4px">5</button>
                                </div>
                            </div>

                        </div>

                    </div>
                    <div id="divButtonHover" class="is-tab-content" tabindex="-1" data-group="button">
  
                        <div class="flex flex-row">
                            <div class="flex-col" style="margin-right: 40px;">
                                <div>
                                    <span>${util.out('Background Color')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Background Color')}" class="bg-color-hover-command" style="width:45px;height:40px;border:rgb(0 0 0 / 6%) 1px solid;margin-right:4px"></button>
                                </div>
                            </div>
                    
                            <div class="flex-col">
                                <div>
                                    <span>${util.out('Text Color')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Dark')}" data-command="dark" class="text-color-hover-command" style="margin-right:4px">${util.out('Dark')}</button>
                                    <button title="${util.out('Light')}" data-command="light" class="text-color-hover-command" style="margin-right:4px">${util.out('Light')}</button>
                                    <button title="${util.out('Current')}" data-command="current" class="text-color-hover-command" style="margin-right:4px">${util.out('Current')}</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-col" style="margin:15px 0 0">
                            <div>
                                <span>${util.out('Border Color')}</span>:
                            </div>
                            <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                <button title="${util.out('Transparent')}" data-command="transparent" class="border-color-hover-command" style="margin-right:4px">${util.out('Transparent')}</button>
                                <button title="${util.out('Current')}" data-command="current" class="border-color-hover-command" style="margin-right:4px">${util.out('Current')}</button>
                            </div>
                        </div>

                    </div>
                    <div id="divButtonText" class="is-tab-content" tabindex="-1" data-group="button">

                        <div class="flex flex-row">
                            <div class="flex flex-col" style="width:250px;margin-right:40px;">
                                <div>
                                    <span>${util.out('Font Size')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="12" data-command="12" class="font-size-command" style="margin-right:4px">12</button>
                                    <button title="13" data-command="13" class="font-size-command" style="margin-right:4px">13</button>
                                    <button title="14" data-command="14" class="font-size-command" style="margin-right:4px">14</button>
                                    <button title="15" data-command="15" class="font-size-command" style="margin-right:4px">15</button>
                                    <button title="16" data-command="16" class="font-size-command" style="margin-right:4px">16</button>
                                    <button title="17" data-command="17" class="font-size-command" style="margin-right:4px">17</button>
                                    <button title="18" data-command="18" class="font-size-command" style="margin-right:4px">18</button>
                                    <button title="19" data-command="19" class="font-size-command" style="margin-right:4px">19</button>
                                    <button title="21" data-command="21" class="font-size-command" style="margin-right:4px">21</button>
                                    <button title="24" data-command="24" class="font-size-command" style="margin-right:4px">24</button>
                                    <button title="28" data-command="28" class="font-size-command" style="margin-right:4px">28</button>
                                    <button title="32" data-command="32" class="font-size-command" style="margin-right:4px">32</button>
                                </div>
                            </div>

                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Upper/Lower')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="${util.out('Bold')}" class="textbold-command" style="width:38px;font-family:serif;font-size:14px;text-transform:initial;margin-right:4px">B</button>
                                    <button title="${util.out('Upper/Lower')}" class="textcase-command" style="width:38px;font-family:serif;font-size:14px;text-transform:initial;margin-right:4px">Aa</button>
                                    <button title="${util.out('Underline')}" class="textunderline-command" style="width:38px;text-decoration:underline;font-family:serif;font-size:14px;text-transform:initial;margin-right:4px">U</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex flex-row" style="margin:15px 0 0">
                            <div class="flex flex-col">
                                <div>
                                    <span>${util.out('Letter Spacing')}</span>:
                                </div>
                                <div class="flex flex-row flex-wrap" style="margin-top:5px">
                                    <button title="0" data-command="normal" class="letter-spacing-command" style="margin-right:4px">0</button>
                                    <button title="25" data-command="wide" class="letter-spacing-command" style="margin-right:4px">25</button>
                                    <button title="50" data-command="wider" class="letter-spacing-command" style="margin-right:4px">50</button>
                                    <button title="75" data-command="75" class="letter-spacing-command" style="margin-right:4px">75</button>
                                    <button title="100" data-command="widest" class="letter-spacing-command" style="margin-right:4px">100</button>
                                    <button title="125" data-command="125" class="letter-spacing-command" style="margin-right:4px">125</button>
                                    <button title="150" data-command="150" class="letter-spacing-command" style="margin-right:4px">150</button>
                                    <button title="175" data-command="175" class="letter-spacing-command" style="margin-right:4px">175</button>
                                    <button title="200" data-command="200" class="letter-spacing-command" style="margin-right:4px">200</button>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    <div id="divMyButtons" class="is-tab-content" tabindex="-1" data-group="button">


                        <button title="${util.out('Save Current Button')}" class="input-save" style="width:220px;position: relative;z-index: 1;">${util.out('Save Current Button')}</button>
                       
                        <div id="divMyButtonList"></div>

                    </div>
                    <div id="divButtonTemplates" class="is-tab-content" tabindex="-1" data-group="button">

                        <div id="divButtonTemplateList"></div>

                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      buttonModal = builderStuff.querySelector('.is-modal.buttoneditor');
      let btnClose = buttonModal.querySelector('.is-modal-close');
      dom.addEventListener(btnClose, 'click', () => {
        dom.removeClass(buttonModal, 'active');
      });
      let btns;

      //background color
      const btnBgColor = buttonModal.querySelector('.bg-color-command');
      btnBgColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // this.builder.simpleColorPicker((colorClass)=>{

        //     const activeButton = this.builder.activeButton||this.builder.activeLinkButton||this.builder.activeLink;

        //     dom.removeClassesByPrefix(activeButton, 'bg-');
        //     dom.addClass(activeButton, colorClass);

        //     this.applyDefault(activeButton);

        //     setTimeout(()=>{
        //         const currBg = dom.getStyle(activeButton,'background-color');
        //         btnBgColor.style.backgroundColor = currBg;
        //     },160);

        //     this.builder.opts.onChange();
        // });

        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          activeButton.style.backgroundColor = color;
          activeButton.setAttribute('data-bg', color);
          dom.removeClassesByPrefix(activeButton, 'bg-');
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, activeButton.style.backgroundColor, () => {
          btnBgColor.removeAttribute('data-focus');
          btnBgColor.focus();
        });
        btnBgColor.setAttribute('data-focus', true);
      });

      //text color
      const btnTextColor = buttonModal.querySelector('.text-color-command');
      btnTextColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // this.builder.simpleColorPicker((colorClass)=>{

        //     const activeButton = this.builder.activeButton||this.builder.activeLinkButton||this.builder.activeLink;

        //     dom.removeClassesByPrefix(activeButton, 'text-');
        //     dom.addClass(activeButton, colorClass);

        //     this.applyDefault(activeButton);

        //     setTimeout(function(){
        //         const currColor = dom.getStyle(activeButton,'color');
        //         btnTextColor.style.backgroundColor = currColor;
        //     },160);

        //     this.builder.opts.onChange();

        // }, 'text');

        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          activeButton.style.color = color;
          dom.removeClassesByPrefix(activeButton, 'text-');
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, activeButton.style.color, () => {
          btnTextColor.removeAttribute('data-focus');
          btnTextColor.focus();
        });
        btnTextColor.setAttribute('data-focus', true);
      });

      //hover background color
      const btnHoverBgColor = buttonModal.querySelector('.bg-color-hover-command');
      btnHoverBgColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // this.builder.simpleColorPicker((colorClass)=>{

        //     const activeButton = this.builder.activeButton||this.builder.activeLinkButton||this.builder.activeLink;

        //     dom.removeClassesByPrefix(activeButton, 'hover:bg-');
        //     if(colorClass) dom.addClass(activeButton, 'hover:' + colorClass);

        //     this.applyDefault(activeButton);

        //     this.getVisibleBgColor(colorClass, (color)=>{
        //         btnHoverBgColor.style.backgroundColor = color;
        //     });

        //     this.builder.opts.onChange();
        // });

        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        let hoverbgcolor = activeButton.getAttribute('data-hover-bg');
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          if (color === '') {
            activeButton.removeAttribute('data-bg');
            activeButton.removeAttribute('data-hover-bg');
            activeButton.removeAttribute('onmouseover');
            activeButton.removeAttribute('onmouseout');
          } else {
            activeButton.setAttribute('data-bg', activeButton.style.backgroundColor);
            activeButton.setAttribute('data-hover-bg', color);
            activeButton.setAttribute('onmouseover', 'if(this.getAttribute(\'data-hover-bg\'))this.style.backgroundColor=this.getAttribute(\'data-hover-bg\');');
            activeButton.setAttribute('onmouseout', 'if(this.getAttribute(\'data-bg\'))this.style.backgroundColor=this.getAttribute(\'data-bg\');else this.style.backgroundColor=\'\'');
          }
          dom.removeClassesByPrefix(activeButton, 'hover:bg-');
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, hoverbgcolor ? hoverbgcolor : '', () => {
          btnHoverBgColor.removeAttribute('data-focus');
          btnHoverBgColor.focus();
        });
        btnHoverBgColor.setAttribute('data-focus', true);
      });

      //hover text color
      const btnHoverTextColor = buttonModal.querySelectorAll('.text-color-hover-command');
      btnHoverTextColor.forEach(btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo(true); // checkLater = true

          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          if (activeButton.classList) {
            activeButton.classList.forEach(item => {
              if (item.indexOf('hover:text-') === 0) {
                dom.removeClass(activeButton, item);
              }
            });
          }
          if (val === 'dark') dom.addClass(activeButton, 'hover:text-black');else if (val === 'light') dom.addClass(activeButton, 'hover:text-white');else ;
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.text-color-hover-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //border color
      btns = buttonModal.querySelectorAll('.border-color-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClass(activeButton, 'border-transparent');
          dom.removeClass(activeButton, 'border-current');
          if (val === 'transparent') dom.addClass(activeButton, 'border-transparent');else if (val === 'current') dom.addClass(activeButton, 'border-current');
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.border-color-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //hover border color
      btns = buttonModal.querySelectorAll('.border-color-hover-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClass(activeButton, 'hover:border-transparent');
          dom.removeClass(activeButton, 'hover:border-current');
          if (val === 'transparent') dom.addClass(activeButton, 'hover:border-transparent');else if (val === 'current') dom.addClass(activeButton, 'hover:border-current');
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.border-color-hover-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //border width
      btns = buttonModal.querySelectorAll('.border-width-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClass(activeButton, 'border-0');
          dom.removeClass(activeButton, 'border-2');
          dom.removeClass(activeButton, 'border');
          if (val === '0') dom.addClass(activeButton, 'border-0');else if (val === '1') dom.addClass(activeButton, 'border');else if (val === '2') dom.addClass(activeButton, 'border-2');
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.border-width-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //border radius
      btns = buttonModal.querySelectorAll('.border-radius-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClass(activeButton, 'rounded');
          dom.removeClassesByPrefix(activeButton, 'rounded-');
          if (val === 'normal') dom.addClass(activeButton, 'rounded');else dom.addClass(activeButton, 'rounded-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.border-radius-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //padding x
      btns = buttonModal.querySelectorAll('.paddingx-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'px-');
          if (val === '2') {
            dom.addClass(activeButton, 'px-2');
          }
          if (val === '3') {
            dom.addClass(activeButton, 'px-3');
          }
          if (val === '4') {
            dom.addClass(activeButton, 'px-4');
          }
          if (val === '5') {
            dom.addClass(activeButton, 'px-5');
          }
          if (val === '6') {
            dom.addClass(activeButton, 'px-6');
          }
          if (val === '7') {
            dom.addClass(activeButton, 'px-7');
          }
          if (val === '8') {
            dom.addClass(activeButton, 'px-8');
          }
          if (val === '9') {
            dom.addClass(activeButton, 'px-9');
          }
          if (val === '10') {
            dom.addClass(activeButton, 'px-10');
          }
          if (val === '11') {
            dom.addClass(activeButton, 'px-11');
          }
          if (val === '12') {
            dom.addClass(activeButton, 'px-12');
          }
          if (val === '14') {
            dom.addClass(activeButton, 'px-14');
          }
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.paddingx-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //padding y
      btns = buttonModal.querySelectorAll('.paddingy-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'py-');
          if (val === '0') {
            dom.addClass(activeButton, 'py-0');
          }
          if (val === '1') {
            dom.addClass(activeButton, 'py-1');
          }
          if (val === '2') {
            dom.addClass(activeButton, 'py-2');
          }
          if (val === '3') {
            dom.addClass(activeButton, 'py-3');
          }
          if (val === '4') {
            dom.addClass(activeButton, 'py-4');
          }
          if (val === '5') {
            dom.addClass(activeButton, 'py-5');
          }
          if (val === '6') {
            dom.addClass(activeButton, 'py-6');
          }
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.paddingy-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //padding top
      btns = buttonModal.querySelectorAll('.paddingtop-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'pt-');
          if (val === '0') {
            dom.addClass(activeButton, 'pt-0');
          }
          if (val === '1') {
            dom.addClass(activeButton, 'pt-1');
          }
          if (val === '2') {
            dom.addClass(activeButton, 'pt-2');
          }
          if (val === '3') {
            dom.addClass(activeButton, 'pt-3');
          }
          if (val === '4') {
            dom.addClass(activeButton, 'pt-4');
          }
          if (val === '5') {
            dom.addClass(activeButton, 'pt-5');
          }
          if (val === '6') {
            dom.addClass(activeButton, 'pt-6');
          }

          // Cleanup
          if ((activeButton.classList.contains('pt-0') || activeButton.classList.contains('pt-1') || activeButton.classList.contains('pt-2') || activeButton.classList.contains('pt-3') || activeButton.classList.contains('pt-4') || activeButton.classList.contains('pt-5')) && (activeButton.classList.contains('pt-0') || activeButton.classList.contains('pb-1') || activeButton.classList.contains('pb-2') || activeButton.classList.contains('pb-3') || activeButton.classList.contains('pb-4') || activeButton.classList.contains('pb-5'))) {
            activeButton.classList.remove('py-0');
            activeButton.classList.remove('py-1');
            activeButton.classList.remove('py-2');
            activeButton.classList.remove('py-3');
            activeButton.classList.remove('py-4');
            activeButton.classList.remove('p5-4');
          }
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.paddingtop-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //padding bottom
      btns = buttonModal.querySelectorAll('.paddingbottom-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'pb-');
          if (val === '0') {
            dom.addClass(activeButton, 'pb-0');
          }
          if (val === '1') {
            dom.addClass(activeButton, 'pb-1');
          }
          if (val === '2') {
            dom.addClass(activeButton, 'pb-2');
          }
          if (val === '3') {
            dom.addClass(activeButton, 'pb-3');
          }
          if (val === '4') {
            dom.addClass(activeButton, 'pb-4');
          }
          if (val === '5') {
            dom.addClass(activeButton, 'pb-5');
          }
          if (val === '6') {
            dom.addClass(activeButton, 'pb-6');
          }

          // Cleanup
          if ((activeButton.classList.contains('pt-0') || activeButton.classList.contains('pt-1') || activeButton.classList.contains('pt-2') || activeButton.classList.contains('pt-3') || activeButton.classList.contains('pt-4') || activeButton.classList.contains('pt-5')) && (activeButton.classList.contains('pt-0') || activeButton.classList.contains('pb-1') || activeButton.classList.contains('pb-2') || activeButton.classList.contains('pb-3') || activeButton.classList.contains('pb-4') || activeButton.classList.contains('pb-5'))) {
            activeButton.classList.remove('py-0');
            activeButton.classList.remove('py-1');
            activeButton.classList.remove('py-2');
            activeButton.classList.remove('py-3');
            activeButton.classList.remove('py-4');
            activeButton.classList.remove('p5-4');
          }
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.paddingbottom-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //Font size
      btns = buttonModal.querySelectorAll('.font-size-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'size-');
          dom.addClass(activeButton, 'size-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.font-size-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //width
      btns = buttonModal.querySelectorAll('.width-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          if (val === 'auto') {
            activeButton.classList.remove('flex');
            activeButton.classList.remove('justify-center');
            activeButton.classList.remove('items-center');
            activeButton.classList.add('inline-block');
          }
          if (val === 'full') {
            activeButton.classList.remove('inline-block');
            activeButton.classList.add('flex');
            activeButton.classList.add('justify-center');
            activeButton.classList.add('items-center');
          }
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.width-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //text case
      const btnTextCase = buttonModal.querySelector('.textcase-command');
      btnTextCase.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        if (dom.hasClass(activeButton, 'uppercase')) {
          dom.removeClass(activeButton, 'uppercase');
        } else {
          dom.addClass(activeButton, 'uppercase');
        }
        this.applyDefault(activeButton);

        // Button on/off
        const btnTextCase = buttonModal.querySelector('.textcase-command');
        if (dom.hasClass(btnTextCase, 'on')) {
          dom.removeClass(btnTextCase, 'on');
        } else {
          dom.addClass(btnTextCase, 'on');
        }
        this.builder.opts.onChange();
      });

      //text underline
      const btnTextUnderline = buttonModal.querySelector('.textunderline-command');
      btnTextUnderline.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        if (dom.hasClass(activeButton, 'underline')) {
          dom.removeClass(activeButton, 'underline');
          dom.addClass(activeButton, 'no-underline');
        } else {
          dom.removeClass(activeButton, 'no-underline');
          dom.addClass(activeButton, 'underline');
        }
        this.applyDefault(activeButton);

        // Button on/off
        const btnTextUnderline = buttonModal.querySelector('.textunderline-command');
        if (dom.hasClass(btnTextUnderline, 'on')) {
          dom.removeClass(btnTextUnderline, 'on');
        } else {
          dom.addClass(btnTextUnderline, 'on');
        }
        this.builder.opts.onChange();
      });

      //text bold
      const btnTextBold = buttonModal.querySelector('.textbold-command');
      btnTextBold.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        if (dom.hasClass(activeButton, 'font-semibold')) {
          dom.removeClass(activeButton, 'font-semibold');
          dom.addClass(activeButton, 'font-normal');
        } else {
          dom.removeClass(activeButton, 'font-normal');
          dom.addClass(activeButton, 'font-semibold');
        }
        this.applyDefault(activeButton);

        // Button on/off
        const btnTextBold = buttonModal.querySelector('.textbold-command');
        if (dom.hasClass(btnTextBold, 'on')) {
          dom.removeClass(btnTextBold, 'on');
        } else {
          dom.addClass(btnTextBold, 'on');
        }
        this.builder.opts.onChange();
      });

      //Letter Spacing
      btns = buttonModal.querySelectorAll('.letter-spacing-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'tracking-');
          dom.addClass(activeButton, 'tracking-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.letter-spacing-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //Margin Left
      btns = buttonModal.querySelectorAll('.ml-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'ml-');
          dom.addClass(activeButton, 'ml-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.ml-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //Margin Right
      btns = buttonModal.querySelectorAll('.mr-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'mr-');
          dom.addClass(activeButton, 'mr-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.mr-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //Margin Top
      btns = buttonModal.querySelectorAll('.mt-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'mt-');
          dom.addClass(activeButton, 'mt-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.mt-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //Margin Bottom
      btns = buttonModal.querySelectorAll('.mb-command');
      Array.prototype.forEach.call(btns, btn => {
        btn.addEventListener('click', () => {
          this.builder.uo.saveForUndo();
          const val = btn.getAttribute('data-command');
          const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
          dom.removeClassesByPrefix(activeButton, 'mb-');
          dom.addClass(activeButton, 'mb-' + val);
          this.applyDefault(activeButton);

          // Button on/off
          const items = buttonModal.querySelectorAll('.mb-command');
          items.forEach(item => {
            dom.removeClass(item, 'on');
          });
          dom.addClass(btn, 'on');
          this.builder.opts.onChange();
        });
      });

      //save button
      const btnSave = buttonModal.querySelector('.input-save');
      btnSave.addEventListener('click', () => {
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        let mybuttons = [];
        if (localStorage.getItem('_savedbuttons') != null) {
          mybuttons = JSON.parse(localStorage.getItem('_savedbuttons'));
        }

        // cleanup before saving
        dom.removeClass(activeButton, 'active');
        dom.removeClass(activeButton, 'elm-active');
        let dataBg = activeButton.getAttribute('data-bg');
        // if(!dataBg) {
        //     if(activeButton.style.backgroundColor) dataBg=activeButton.style.backgroundColor;
        // }
        const dataHoverBg = activeButton.getAttribute('data-hover-bg');
        // const color = activeButton.style.color;
        const cssText = activeButton.style.cssText;
        mybuttons.push({
          id: mybuttons.length,
          className: activeButton.className,
          bg: dataBg ? dataBg : '',
          hoverBg: dataHoverBg ? dataHoverBg : '',
          // color: color?color:'',
          cssText: cssText
        });
        localStorage.setItem('_savedbuttons', JSON.stringify(mybuttons));
        this.renderMyButtons();
      });
      new Tabs({
        element: buttonModal
      });
      new Draggable$2({
        selector: '.is-modal.buttoneditor .is-draggable'
      });
    }
    this.buttonModal = buttonModal;
  }
  open() {
    // dom.addClass(this.buttonModal, 'active');
    this.util.showModal(this.buttonModal, false);
    this.realtime();
    this.renderMyButtons();
    this.renderTemplates();
  }
  realtime() {
    const dom = this.dom;
    const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
    const btnBgColor = this.buttonModal.querySelector('.bg-color-command');
    btnBgColor.style.backgroundColor = '';
    let currColor;
    const btnTextColor = this.buttonModal.querySelector('.text-color-command');
    btnTextColor.style.backgroundColor = '';
    const btnHoverBgColor = this.buttonModal.querySelector('.bg-color-hover-command');
    btnHoverBgColor.style.backgroundColor = '';
    if (activeButton.classList) {
      activeButton.classList.forEach(item => {
        if (item.indexOf('hover:bg-') === 0) {
          this.getVisibleBgColor(item.replace('hover:', ''), color => {
            btnHoverBgColor.style.backgroundColor = color;
            activeButton.setAttribute('data-hover-bg', color); //new inline

            if (!activeButton.hasAttribute('data-bg')) {
              // fix needed data-bg
              activeButton.setAttribute('data-bg', btnBgColor.style.backgroundColor); // needed by hover
            }

            activeButton.setAttribute('onmouseover', 'if(this.getAttribute(\'data-hover-bg\'))this.style.backgroundColor=this.getAttribute(\'data-hover-bg\');');
            activeButton.setAttribute('onmouseout', 'if(this.getAttribute(\'data-bg\'))this.style.backgroundColor=this.getAttribute(\'data-bg\');else this.style.backgroundColor=\'\'');
          });
        }
        if (item.indexOf('bg-') === 0) {
          this.getVisibleBgColor(item, color => {
            btnBgColor.style.backgroundColor = color;
            activeButton.setAttribute('data-bg', color); //new inline
          });
        }

        if (item.indexOf('text-') === 0) {
          this.getVisibleTextColor(item, color => {
            btnTextColor.style.backgroundColor = color;
            currColor = color;
          });
        }
      });
    }
    if (!currColor) {
      // if no text-[color] found
      currColor = dom.getStyle(activeButton, 'color');
      btnTextColor.style.backgroundColor = currColor;
    }

    // NEW: inline color
    if (activeButton.hasAttribute('data-bg')) {
      btnBgColor.style.backgroundColor = activeButton.getAttribute('data-bg');
    } else {
      if (activeButton.style.backgroundColor) {
        btnBgColor.style.backgroundColor = activeButton.style.backgroundColor;
      }
    }
    if (activeButton.getAttribute('data-hover-bg')) btnHoverBgColor.style.backgroundColor = activeButton.getAttribute('data-hover-bg');
    if (activeButton.style.color) btnTextColor.style.backgroundColor = activeButton.style.color;
    let btn;
    btn = this.buttonModal.querySelector('.text-color-hover-command.on');
    dom.removeClass(btn, 'on');
    if (dom.hasClass(activeButton, 'hover:text-black')) {
      btn = this.buttonModal.querySelector('.text-color-hover-command[data-command="dark"]');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(activeButton, 'hover:text-white')) {
      btn = this.buttonModal.querySelector('.text-color-hover-command[data-command="light"]');
      dom.addClass(btn, 'on');
    } else {
      btn = this.buttonModal.querySelector('.text-color-hover-command[data-command="current"]');
      dom.addClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.border-color-hover-command.on');
    dom.removeClass(btn, 'on');
    if (dom.hasClass(activeButton, 'hover:border-transparent')) {
      btn = this.buttonModal.querySelector('.border-color-hover-command[data-command="transparent"]');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(activeButton, 'hover:border-current')) {
      btn = this.buttonModal.querySelector('.border-color-hover-command[data-command="current"]');
      dom.addClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.border-color-command.on');
    dom.removeClass(btn, 'on');
    if (dom.hasClass(activeButton, 'border-transparent')) {
      btn = this.buttonModal.querySelector('.border-color-command[data-command="transparent"]');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(activeButton, 'border-current')) {
      btn = this.buttonModal.querySelector('.border-color-command[data-command="current"]');
      dom.addClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.width-command.on');
    dom.removeClass(btn, 'on');
    if (dom.hasClass(activeButton, 'flex')) {
      btn = this.buttonModal.querySelector('.width-command[data-command="full"]');
      dom.addClass(btn, 'on');
    } else {
      btn = this.buttonModal.querySelector('.width-command[data-command="auto"]');
      dom.addClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.textcase-command');
    if (dom.hasClass(activeButton, 'uppercase')) {
      dom.addClass(btn, 'on');
    } else {
      dom.removeClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.textunderline-command');
    if (dom.hasClass(activeButton, 'underline')) {
      dom.addClass(btn, 'on');
    } else {
      dom.removeClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.font-size-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.paddingx-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.paddingy-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.paddingtop-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.paddingbottom-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.border-radius-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.letter-spacing-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.ml-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.mr-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.mt-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.mb-command.on');
    dom.removeClass(btn, 'on');
    btn = this.buttonModal.querySelector('.textbold-command');
    if (dom.hasClass(activeButton, 'font-semibold')) {
      dom.addClass(btn, 'on');
    } else {
      dom.removeClass(btn, 'on');
    }
    if (dom.hasClass(activeButton, 'rounded')) {
      btn = this.buttonModal.querySelector('.border-radius-command[data-command="normal"]');
      dom.addClass(btn, 'on');
    }
    btn = this.buttonModal.querySelector('.border-width-command.on');
    dom.removeClass(btn, 'on');
    if (dom.hasClass(activeButton, 'border-0')) {
      btn = this.buttonModal.querySelector('.border-width-command[data-command="0"]');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(activeButton, 'border-2')) {
      btn = this.buttonModal.querySelector('.border-width-command[data-command="2"]');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(activeButton, 'border')) {
      btn = this.buttonModal.querySelector('.border-width-command[data-command="1"]');
      dom.addClass(btn, 'on');
    }
    if (activeButton.classList) {
      activeButton.classList.forEach(item => {
        if (item.indexOf('size-') === 0) {
          let val = item.replace('size-', '');
          let btn = this.buttonModal.querySelector(`.font-size-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('px-') === 0) {
          let val = item.replace('px-', '');
          let btn = this.buttonModal.querySelector(`.paddingx-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('py-') === 0) {
          let val = item.replace('py-', '');
          let btn = this.buttonModal.querySelector(`.paddingy-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
          if (!(activeButton.classList.contains('pt-0') || activeButton.classList.contains('pt-1') || activeButton.classList.contains('pt-2') || activeButton.classList.contains('pt-3') || activeButton.classList.contains('pt-4') || activeButton.classList.contains('pt-5'))) {
            let btn = this.buttonModal.querySelector(`.paddingtop-command[data-command="${val}"]`);
            dom.addClass(btn, 'on');
          }
          if (!(activeButton.classList.contains('pb-0') || activeButton.classList.contains('pb-1') || activeButton.classList.contains('pb-2') || activeButton.classList.contains('pb-3') || activeButton.classList.contains('pb-4') || activeButton.classList.contains('pb-5'))) {
            let btn = this.buttonModal.querySelector(`.paddingbottom-command[data-command="${val}"]`);
            dom.addClass(btn, 'on');
          }
        }
        if (item.indexOf('pt-') === 0) {
          let val = item.replace('pt-', '');
          let btn = this.buttonModal.querySelector(`.paddingtop-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('pb-') === 0) {
          let val = item.replace('pb-', '');
          let btn = this.buttonModal.querySelector(`.paddingbottom-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('rounded-') === 0) {
          let val = item.replace('rounded-', '');
          let btn = this.buttonModal.querySelector(`.border-radius-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('tracking-') === 0) {
          let val = item.replace('tracking-', '');
          let btn = this.buttonModal.querySelector(`.letter-spacing-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('ml-') === 0) {
          let val = item.replace('ml-', '');
          let btn = this.buttonModal.querySelector(`.ml-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('mr-') === 0) {
          let val = item.replace('mr-', '');
          let btn = this.buttonModal.querySelector(`.mr-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('mt-') === 0) {
          let val = item.replace('mt-', '');
          let btn = this.buttonModal.querySelector(`.mt-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
        if (item.indexOf('mb-') === 0) {
          let val = item.replace('mb-', '');
          let btn = this.buttonModal.querySelector(`.mb-command[data-command="${val}"]`);
          dom.addClass(btn, 'on');
        }
      });
    }
  }
  hide() {
    const dom = this.dom;
    dom.removeClass(this.buttonModal, 'active');
  }
  getVisibleBgColor(className, callback) {
    const dom = this.dom;
    const elm = document.createElement('div');
    elm.className = className;
    this.builderStuff.appendChild(elm);
    let currColor = dom.getStyle(elm, 'background-color');
    callback(currColor);
    this.builderStuff.removeChild(elm);
  }
  getVisibleTextColor(className, callback) {
    const dom = this.dom;
    const elm = document.createElement('div');
    elm.className = className;
    this.builderStuff.appendChild(elm);
    let currColor = dom.getStyle(elm, 'color');
    callback(currColor);
    this.builderStuff.removeChild(elm);
  }
  renderTemplates() {
    const templates = [/* rounded */

    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-7 border-current hover:border-current font-normal leading-14 rounded-full tracking-wide">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-7 text-black leading-14 rounded-full border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-7 border-current hover:border-current font-normal leading-14 tracking-wide rounded-full" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-7 font-normal leading-14 border-transparent rounded-full size-17 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, /* square */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 border-current hover:border-current font-normal leading-14 rounded tracking-wide">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 border-current hover:border-current font-normal leading-14 tracking-wide rounded" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded size-17 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-6 font-normal leading-14 border-transparent rounded ml-0 mt-1 size-17 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, /* MEDIUM */

    /* rounded */

    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed rounded-full tracking-wide">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed tracking-wide rounded-full" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-9 font-normal leading-relaxed border-transparent rounded-full size-18 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, /* square */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-8 border-current hover:border-current font-normal leading-relaxed rounded tracking-wide">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-8 text-black leading-relaxed rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-8 border-current hover:border-current font-normal leading-relaxed tracking-wide rounded" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded size-18 tracking-wide hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 px-8 font-normal leading-relaxed border-transparent rounded ml-0 mt-1 size-18 tracking-wide hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, /* LARGER */

    /* rounded */

    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-12 uppercase border-current hover:border-current font-normal leading-relaxed rounded-full tracking-75">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-12 uppercase text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-75" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-12 uppercase border-current hover:border-current font-normal leading-relaxed tracking-75 rounded-full" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-12 uppercase font-normal leading-relaxed border-transparent rounded-full size-16 tracking-75 hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, /* square */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-11 uppercase border-current hover:border-current font-normal leading-relaxed rounded tracking-75">Read More</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-11 uppercase text-black leading-relaxed rounded border-transparent hover:border-transparent font-normal tracking-75" style="background-color: rgb(240, 240, 240);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(255, 127, 0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(83,98,208);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 size-16 px-11 uppercase border-current hover:border-current font-normal leading-relaxed tracking-75 rounded" style="color: rgb(255, 255, 255);">Get Started</a>
                `
    }, /* colors */
    {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(0, 200, 218);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(55, 148, 59);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded size-16 tracking-75 hover:border-transparent" style="color: rgb(255, 255, 255); background-color: rgb(233,2,0);">Get Started</a>
                `
    }, {
      html: `
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 pt-3 pb-3 px-11 uppercase font-normal leading-relaxed border-transparent rounded ml-0 mt-1 size-16 tracking-75 hover:border-transparent" style="color: rgb(0, 0, 0); background-color: rgb(254, 222, 76);">Get Started</a>
                `
    }, {
      text: 'Order Now',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid rounded-full border-current ml-1 mr-1 px-8 py-2 text-pink-600 hover:text-white  bg-white hover:bg-pink-500 hover:border-transparent size-18 font-semibold tracking-75 leading-relaxed'
    }, {
      text: 'Explore',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline font-semibold border-2 border-solid tracking-200 rounded-full border-current size-12 ml-1 mr-1 py-0 px-3 text-indigo-600 hover:text-white bg-white hover:bg-indigo-500 hover:border-transparent leading-relaxed'
    }, {
      text: 'View Demo',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid border-transparent ml-1 mr-1 hover:border-transparent rounded bg-gray-200 hover:bg-gray-300 size-16 py-1 px-5 font-normal tracking-wide text-gray-800 leading-relaxed'
    }, {
      text: 'Get Started',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid ml-1 mr-1 rounded size-16 text-black py-1 px-5 font-normal border-current hover: hover:border-current tracking-wide leading-relaxed'
    }, {
      text: 'Create',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid border-transparent ml-1 mr-1 hover:border-transparent size-12 rounded bg-yellow-300 text-black bg-white hover:bg-yellow-400 font-normal px-3 py-0 tracking-75 leading-relaxed'
    }, {
      text: 'Hello!',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid border-current ml-1 mr-1 hover:text-white hover:border-transparent rounded-lg size-24 font-normal py-2 tracking-150 px-12 text-orange-500 bg-white hover:bg-orange-500 leading-relaxed'
    }, {
      text: 'Build',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid border-transparent ml-1 mr-1 text-violet-700 hover:border-transparent hover:bg-cyan-200 rounded uppercase size-12 tracking-75 px-4 py-1 font-semibold bg-cyan-200 leading-relaxed'
    }, {
      text: 'Contact',
      className: 'transition-all inline-block whitespace-nowrap border-2 border-solid rounded-none no-underline hover:border-transparent ml-1 mr-1 cursor-pointer bg-white text-red-600 border-current hover:bg-red-600 hover:text-white uppercase size-12 font-semibold py-2 px-6 tracking-150 leading-relaxed'
    }, {
      text: 'Read More',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer border-2 border-solid border-transparent ml-1 mr-1 hover:border-transparent rounded size-16 py-1 px-5 font-normal tracking-wide text-gray-800 underline leading-relaxed'
    }, {
      text: 'Send a Message',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid ml-1 mr-1 rounded tracking-75 uppercase px-6 py-2 size-12 hover:border-transparent font-semibold bg-gray-200 border-transparent hover:bg-gray-300 text-gray-800 leading-relaxed'
    }, {
      text: 'Our Works',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid ml-1 mr-1 rounded tracking-75 uppercase px-6 py-2 size-12 border-current hover:text-white hover:border-transparent hover:bg-indigo-500 text-indigo-500 font-semibold leading-relaxed'
    }, {
      text: 'Read More',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-1 tracking-75 uppercase py-2 size-14 px-8 rounded font-normal ml-1 border-transparent bg-gray-200 hover:bg-gray-300 hover:border-transparent text-gray-800 leading-relaxed'
    }, {
      text: 'Get a Quote',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-1 tracking-75 uppercase py-2 size-14 px-8 border-current rounded text-black hover:border-current font-normal ml-1 leading-relaxed'
    }, {
      text: 'Try Demo',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid border-transparent hover:border-transparent bg-gray-200 hover:bg-gray-300 size-16 text-black font-normal uppercase py-3 px-11 tracking-75 mr-3 ml-0 rounded-md leading-relaxed'
    }, {
      text: 'Buy Now',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid size-16 tracking-75 font-normal uppercase px-11 py-3 hover:text-white hover:bg-teal-500 bg-teal-400 text-white border-transparent hover:border-transparent ml-0 mr-2 rounded-md leading-relaxed'
    }, {
      text: 'Play',
      className: 'transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid ml-1 mr-1 size-16 text-black tracking-75 font-normal uppercase px-11 border-current hover:border-current py-3 rounded leading-relaxed'
    }];
    let html = '';
    for (let i = 0; i < templates.length; i++) {
      if (templates[i].html) {
        html += templates[i].html;
      } else {
        html += `<a class="${templates[i].className}" href="#" role="button" tabindex="0">${templates[i].text}</a>`;
      }
    }
    document.querySelector('#divButtonTemplateList').innerHTML = html;
    let btns = this.buttonModal.querySelectorAll('#divButtonTemplateList a');
    Array.prototype.forEach.call(btns, btn => {
      btn.addEventListener('click', e => {
        this.builder.uo.saveForUndo();
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;

        // this.applyStyles(activeButton, btn);

        // this.cleanupOldClasses(activeButton);

        activeButton.removeAttribute('style');
        activeButton.removeAttribute('onmouseover');
        activeButton.removeAttribute('onmouseout');
        activeButton.removeAttribute('data-bg');
        activeButton.removeAttribute('data-hover-bg');
        activeButton.setAttribute('class', btn.getAttribute('class'));
        if (btn.hasAttribute('style')) activeButton.setAttribute('style', btn.getAttribute('style'));
        if (btn.hasAttribute('onmouseover')) activeButton.setAttribute('onmouseover', btn.getAttribute('onmouseover'));
        if (btn.hasAttribute('onmouseout')) activeButton.setAttribute('onmouseout', btn.getAttribute('onmouseout'));
        if (btn.hasAttribute('data-bg')) {
          activeButton.setAttribute('data-bg', btn.getAttribute('data-bg'));
          activeButton.style.backgroundColor = btn.getAttribute('data-bg');
        }
        if (btn.hasAttribute('data-hover-bg')) {
          activeButton.setAttribute('data-hover-bg', btn.getAttribute('data-hover-bg'));
        }
        activeButton.classList.remove('active');
        if (activeButton.tagName.toLowerCase() === 'a') {
          activeButton.setAttribute('role', 'button');
        }
        this.realtime();
        this.builder.opts.onChange();
        e.preventDefault();
        return false;
      });
    });
  }
  renderMyButtons() {
    const dom = this.dom;
    if (!localStorage.getItem('_savedbuttons')) return;
    let mybuttons = JSON.parse(localStorage.getItem('_savedbuttons'));
    let html_mybuttons = '';
    for (let i = 0; i < mybuttons.length; i++) {
      let sDataBg = '';
      if (mybuttons[i].bg !== '') sDataBg = ` data-bg="${mybuttons[i].bg}"`;
      let sDataHoverBg = '';
      if (mybuttons[i].hoverBg !== '') sDataHoverBg = ` data-hover-bg="${mybuttons[i].hoverBg}"`;
      if (sDataHoverBg !== '' && sDataBg === '') {
        sDataBg = ' data-bg=""';
      }
      html_mybuttons += `<a data-id="${mybuttons[i].id}"${sDataBg}${sDataHoverBg} class="${mybuttons[i].className}" href="#" style="${mybuttons[i].cssText}">Button<span class="is-button-remove"><svg class="is-icon-flex" style="fill:rgba(255, 255, 266, 1);width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></span></a>`;
    }
    document.querySelector('#divMyButtonList').innerHTML = html_mybuttons;
    let btns = this.buttonModal.querySelectorAll('#divMyButtonList a');
    Array.prototype.forEach.call(btns, btn => {
      if (btn.getAttribute('data-hover-bg')) {
        btn.setAttribute('onmouseover', 'if(this.getAttribute(\'data-hover-bg\'))this.style.backgroundColor=this.getAttribute(\'data-hover-bg\');');
        btn.setAttribute('onmouseout', 'if(this.getAttribute(\'data-bg\'))this.style.backgroundColor=this.getAttribute(\'data-bg\');else this.style.backgroundColor=\'\'');
      }
      btn.addEventListener('click', e => {
        this.builder.uo.saveForUndo();
        const activeButton = this.builder.activeButton || this.builder.activeLinkButton || this.builder.activeLink;
        var links = this.buttonModal.querySelectorAll('#divMyButtonList a');
        Array.prototype.forEach.call(links, link => {
          dom.removeClass(link, 'active');
        });
        dom.addClass(btn, 'active');

        // this.applyStyles(activeButton, btn);

        // this.cleanupOldClasses(activeButton);

        activeButton.removeAttribute('style');
        activeButton.removeAttribute('onmouseover');
        activeButton.removeAttribute('onmouseout');
        activeButton.removeAttribute('data-bg');
        activeButton.removeAttribute('data-hover-bg');
        activeButton.setAttribute('class', btn.getAttribute('class'));
        if (btn.hasAttribute('style')) activeButton.setAttribute('style', btn.getAttribute('style'));
        if (btn.hasAttribute('onmouseover')) activeButton.setAttribute('onmouseover', btn.getAttribute('onmouseover'));
        if (btn.hasAttribute('onmouseout')) activeButton.setAttribute('onmouseout', btn.getAttribute('onmouseout'));
        if (btn.hasAttribute('data-bg')) {
          activeButton.setAttribute('data-bg', btn.getAttribute('data-bg'));
          activeButton.style.backgroundColor = btn.getAttribute('data-bg');
        }
        if (btn.hasAttribute('data-hover-bg')) {
          activeButton.setAttribute('data-hover-bg', btn.getAttribute('data-hover-bg'));
        }
        activeButton.classList.remove('active');
        if (activeButton.tagName.toLowerCase() === 'a') {
          activeButton.setAttribute('role', 'button');
        }
        this.builder.opts.onChange();
        this.realtime();
        e.preventDefault();
        return false;
      });
    });
    btns = this.buttonModal.querySelectorAll('.is-button-remove');
    Array.prototype.forEach.call(btns, btn => {
      btn.addEventListener('click', e => {
        let button = e.target.closest('a');
        const id = button.getAttribute('data-id');
        if (localStorage.getItem('_savedbuttons') != null) {
          let mybuttons = JSON.parse(localStorage.getItem('_savedbuttons'));
          for (let i = 0; i < mybuttons.length; i++) {
            if (mybuttons[i].id === parseInt(id)) {
              mybuttons.splice(i, 1);
              for (let j = 0; j < mybuttons.length; j++) {
                mybuttons[j].id = j;
              }
              localStorage.setItem('_savedbuttons', JSON.stringify(mybuttons));

              // button.parentNode.removeChild(button);
              this.renderMyButtons();
              e.stopImmediatePropagation();
              e.preventDefault();
              return false;
            }
          }
        }
        e.stopImmediatePropagation();
        e.preventDefault();
        return false;
      });
    });
  }
  applyStyles(link, button) {
    link.style.backgroundColor = '';
    link.style.color = '';
    link.className = button.className.replace(' active ', '').replace('active ', '').replace(' active', '');
    const dataBg = button.getAttribute('data-bg');
    if (dataBg) {
      link.setAttribute('data-bg', dataBg);
      link.style.backgroundColor = dataBg;
    } else {
      link.removeAttribute('data-bg');
      link.style.backgroundColor = '';
    }
    const dataHoverBg = button.getAttribute('data-hover-bg');
    if (dataHoverBg) link.setAttribute('data-hover-bg', dataHoverBg);else link.removeAttribute('data-hover-bg');
    if (button.style.color) link.style.color = button.style.color;else button.style.color = '';
    this.applyDefault(link);
    this.realtime();
  }
  applyDefault(link) {
    const dom = this.dom;
    // dom.addClass(link, 'transition-all');
    // if(!dom.hasClass(link,'flex')) dom.addClass(link, 'inline-block');
    // dom.addClass(link, 'cursor-pointer');
    // dom.addClass(link, 'border-solid');
    // dom.addClass(link, 'leading-relaxed');

    link.removeAttribute('data-hover-bgcolor');
    link.removeAttribute('data-hover-color');
    link.removeAttribute('data-hover-bordercolor');
    dom.addClass(link, 'whitespace-nowrap');
    if (link.tagName.toLowerCase() === 'a') {
      link.setAttribute('role', 'button');
    }
  }
  cleanupOldClasses(link) {
    const dom = this.dom;
    dom.removeClass(link, 'is-btn-ghost1');
    dom.removeClass(link, 'is-btn-ghost2');
    dom.removeClass(link, 'is-upper');
    dom.removeClass(link, 'is-btn-small');
    dom.removeClass(link, 'is-btn');
    dom.removeClass(link, 'is-rounded-30');
    dom.removeClass(link, 'btn-primary');
    dom.removeClass(link, 'btn-default');
    dom.removeClass(link, 'btn');
  }
}

class Hyperlink {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let linkTool = builderStuff.querySelector('#divLinkTool');
    if (!linkTool) {
      let html = `<div id="divLinkTool" class="is-tool">
            <button title="${util.out('Edit Button')}" data-title="${util.out('Edit Button')}" class="link-button-edit" style="display:none;"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-android-create"></use></svg></button>
                <button title="${util.out('Link')}" data-title="${util.out('Link')}" class="link-edit"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-link"></use></svg></button>
                <button title="${util.out('Duplicate')}" data-title="${util.out('Duplicate')}" class="link-duplicate"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
                <button title="${util.out('Delete')}" data-title="${util.out('Delete')}" class="link-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        linkTool = builderStuff.querySelector('#divLinkTool');
      } else {
        linkTool = contentStuff.querySelector('#divLinkTool');
      }
      this.linkTool = linkTool;
      let linkEdit = linkTool.querySelector('.link-edit');
      dom.addEventListener(linkEdit, 'click', () => {
        this.editLink();
      });
      let buttonEdit = linkTool.querySelector('.link-button-edit');
      dom.addEventListener(buttonEdit, 'click', () => {
        this.editButton();
      });
      let linkDuplicate = linkTool.querySelector('.link-duplicate');
      dom.addEventListener(linkDuplicate, 'click', () => {
        if (this.builder.activeLink) {
          this.builder.uo.saveForUndo();
          if (this.builder.opts.emailMode) {
            var element = this.builder.activeLink;
            while (element.tagName.toLowerCase() !== 'table' && !dom.hasClass(element, 'button')) {
              element = element.parentNode;
            }
            element = element.parentNode;
            let activeLinkTD = element;
            const newlinkTD = activeLinkTD.cloneNode(true);

            // if there is active icon class, do not copy the class
            let iconActive = newlinkTD.querySelector('.icon-active');
            if (iconActive) dom.removeClass(iconActive, 'icon-active');
            newlinkTD.style.paddingRight = '15px';
            activeLinkTD.parentNode.insertBefore(newlinkTD, activeLinkTD);
            this.showTool(this.builder.activeLink);
          } else {
            const newlink = this.builder.activeLink.cloneNode(true);

            // if there is active icon class, do not copy the class
            let iconActive = newlink.querySelector('.icon-active');
            if (iconActive) dom.removeClass(iconActive, 'icon-active');
            this.builder.activeLink.parentNode.insertBefore(newlink, this.builder.activeLink);
            this.showTool(this.builder.activeLink);
          }
        }
      });
      let linkRemove = linkTool.querySelector('.link-remove');
      dom.addEventListener(linkRemove, 'click', () => {
        this.builder.uo.saveForUndo();
        if (this.builder.opts.emailMode) {
          var element = this.builder.activeLink;
          while (element.tagName.toLowerCase() !== 'table' && !dom.hasClass(element, 'button')) {
            element = element.parentNode;
          }
          element = element.parentNode;
          let activeLinkTD = element;
          if (activeLinkTD) activeLinkTD.parentNode.removeChild(activeLinkTD);
          linkTool.style.display = '';
        } else {
          if (this.builder.activeLink) this.builder.activeLink.parentNode.removeChild(this.builder.activeLink);
          linkTool.style.display = '';
        }

        // if there is active icon, set null.
        let iconActive = this.builder.activeLink.querySelector('.icon-active');
        if (iconActive) this.builder.activeIcon = null;
      });
    }
  }
  renderButtonPanel() {
    const builderStuff = this.builder.builderStuff;
    let buttonModal = builderStuff.querySelector('.is-modal.buttoneditor');
    if (!buttonModal) {
      this.buttonEditor = new ButtonEditor(this.builder);
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let modal = builderStuff.querySelector('.is-modal.createlink');
    if (!modal) {
      let html = `
            <div class="is-modal createlink" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">  
                    <label for="inpCreateLinkUrl">${util.out('Link')}:</label>
                    <div class="link-src">
                        <input id="inpCreateLinkUrl" class="input-url" type="text"/>
                        <button title="${util.out('Select')}" class="input-select">
                            ${this.builder.opts.selectIcon}
                        </button>
                        <button title="${util.out(this.builder.opts.otherSelectCaption)}" class="input-select-other" style="display:none;width:50px">
                            ${this.builder.opts.otherSelectIcon}
                        </button>
                        <div class="div-anyfile-upload is-btn classic" style="position: relative; flex: 0 0 auto; width: 50px; height: 43px; box-shadow: rgba(0, 0, 0, 0.32) 0px 3px 6px -6px;">
                            <form class="form-upload-larger" target="frameTargetAnyfileUpload" method="post" action="${this.builder.opts.fileHandler}" enctype="multipart/form-data" style="overflow:hidden;position:absolute;top:0;left:0;width:100%;height:100%;border-radius:1px;display:flex;align-items: center;justify-content: center;">
                                <input class="input-anyfile-customval" name="hidRefId" type="hidden" value="${this.builder.customval}" />
                                <svg class="is-icon-flex"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                <input type="file" onclick="blur()" tabindex="0" class="input-anyfile-upload" name="fileImage" accept="*" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;"/>
                            </form>
                            <iframe tabindex="-1" id="frameTargetAnyfileUpload" name="frameTargetAnyfileUpload" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                        </div>
                    </div>
                    <label style="display:block;margin-top:14px;">
                        <input class="input-newwindow" id="__input_newwindow" type="checkbox" />  ${util.out('Open new window')}&nbsp;
                    </label>
                    <label id="lblOpenLightbox" style="${this.builder.useLightbox ? 'display:block' : 'display:none'};margin-top:5px;margin-bottom:14px;">
                        <input class="input-openlightbox" id="__input_openlightbox" type="checkbox" />  ${util.out('Open in a lightbox (for image, video or Youtube)')}&nbsp;
                    </label>

                    <label id="lblCreateLinkText" for="inpCreateLinkText" style="margin-top:14px;display:block">${util.out('Text')}:</label>
                    <input id="inpCreateLinkText" class="input-text" type="text" style="width:100%;"/>
                    
                    <label for="inpCreateLinkTitle" style="margin-top:14px;display:block">${util.out('Title')}:</label>
                    <input id="inpCreateLinkTitle" class="input-title" type="text" style="width:100%;"/>
                    
                    <div style="text-align:right;margin-top:14px;">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      modal = builderStuff.querySelector('.is-modal.createlink');
      this.modal = modal;
      if (this.builder.opts.fileHandler === '' && !this.builder.opts.onFileUpload) {
        builderStuff.querySelector('.div-anyfile-upload').style.display = 'none';
      }
      let inputFile = builderStuff.querySelector('.input-anyfile-upload');
      dom.addEventListener(inputFile, 'change', e => {
        let element = inputFile;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        if (this.builder.opts.onFileUpload) {
          this.builder.opts.onFileUpload(e);
        } else {
          frmUpload.submit();
        }
        inputFile.value = ''; // Clear Input
      });

      let inputOk = modal.querySelector('.input-ok');
      dom.addEventListener(inputOk, 'click', () => {
        this.builder.uo.saveForUndo();
        let link = this.builder.activeLink;
        if (link) {
          // Edit Existing Link

          let url = modal.querySelector('.input-url').value;
          let title = modal.querySelector('.input-title').value;
          let linktext = modal.querySelector('.input-text').value;
          if (linktext === '') linktext = url;
          if (url !== '') {
            link.setAttribute('href', url);
            if (modal.querySelector('.input-newwindow').checked) {
              link.setAttribute('target', '_blank');
            } else {
              link.removeAttribute('target');
            }
            if (modal.querySelector('.input-openlightbox').checked) {
              dom.addClass(link, 'is-lightbox');
            } else {
              dom.removeClass(link, 'is-lightbox');
            }
            if (this.builder.activeIcon) ; else {
              link.innerHTML = linktext;
            }
            link.setAttribute('title', title);
          } else {
            // link.outerHTML = link.innerHTML;
            this.hideTool();
            if (this.builder.activeIcon) {
              this.builder.activeIcon.setAttribute('dummy-sel', '');
              link.outerHTML = this.builder.activeIcon.outerHTML;
              let icon = this.builder.doc.querySelector('[dummy-sel]');
              icon.removeAttribute('dummy-sel');
              this.builder.activeIcon = icon;
              this.builder.activeIcon.click();
            } else {
              link.outerHTML = link.innerHTML;
            }
          }

          //Trigger Change event
          this.builder.opts.onChange();
        } else {
          // Create New Link

          util.restoreSelection();
          let url = modal.querySelector('.input-url').value;
          let title = modal.querySelector('.input-title').value;
          let linktext = modal.querySelector('.input-text').value;
          if (linktext === '') linktext = url;
          if (url !== '') {
            this.builder.uo.saveForUndo();
            let activeLink;
            if (this.builder.activeIcon) {
              // Icon is selected

              let iconhtml = this.builder.activeIcon.outerHTML;
              this.builder.activeIcon.outerHTML = `<a dummy-sel="1" href="${url}">${iconhtml}</a>`;
              activeLink = this.builder.doc.querySelector('[dummy-sel]');
              activeLink.removeAttribute('dummy-sel');
              if (modal.querySelector('.input-newwindow').checked) {
                activeLink.setAttribute('target', '_blank');
              } else {
                activeLink.removeAttribute('target');
              }
              if (modal.querySelector('.input-openlightbox').checked) {
                dom.addClass(activeLink, 'is-lightbox');
              } else {
                dom.removeClass(activeLink, 'is-lightbox');
              }
              activeLink.setAttribute('title', title);
              this.builder.activeIcon = activeLink.childNodes[0];
              if (!util.appleMobile) {
                this.builder.activeIcon.click();
                dom.selectElementContents(this.builder.activeIcon);

                // https://stackoverflow.com/questions/29908261/prevent-text-selection-on-mouse-drag
                // prevent text selection
                if (this.builder.doc.selection) {
                  this.builder.doc.selection.empty();
                } else {
                  window.getSelection().removeAllRanges();
                }
              }
            } else {
              const selectionText = this.builder.selectionText;
              const selectionElm = this.builder.selectionElm;
              let selection;
              if (selectionText) {
                selection = selectionText;
                const range = selection.getRangeAt(0);
                const fragment = range.extractContents();
                const link = this.builder.doc.createElement('a'); //

                link.setAttribute('href', url);
                link.setAttribute('title', title);
                if (modal.querySelector('.input-newwindow').checked) {
                  link.setAttribute('target', '_blank');
                } else {
                  link.removeAttribute('target');
                }
                if (modal.querySelector('.input-openlightbox').checked) {
                  dom.addClass(link, 'is-lightbox');
                } else {
                  dom.removeClass(link, 'is-lightbox');
                }
                link.appendChild(fragment);
                range.insertNode(link);
                link.innerHTML = linktext;
                selection.selectAllChildren(link);
              } else if (selectionElm) {
                selection = selectionElm;
                selectionElm.innerHTML = `<a class="dummylink" href="dummy">${linktext}</a>`;
                let link = this.builder.doc.querySelector('.dummylink'); //

                link.setAttribute('href', url);
                link.setAttribute('title', title);
                if (modal.querySelector('.input-newwindow').checked) {
                  link.setAttribute('target', '_blank');
                } else {
                  link.removeAttribute('target');
                }
                if (modal.querySelector('.input-openlightbox').checked) {
                  dom.addClass(link, 'is-lightbox');
                } else {
                  dom.removeClass(link, 'is-lightbox');
                }

                // if(!util.appleMobile) dom.selectElementContents(link); 
                dom.selectElementContents(link);
                dom.removeClass(link, 'dummylink');
              }
            }
          }

          //save selection
          util.saveSelection();

          //Trigger Change event
          this.builder.opts.onChange();

          //Trigger Render event
          this.builder.opts.onRender();
        }
        util.hideModal(modal);
      });
      let inputCancel = modal.querySelector('.input-cancel');
      dom.addEventListener(inputCancel, 'click', () => {
        util.hideModal(modal);
        if (!util.appleMobile) util.restoreSelection();
      });
      if (this.builder.opts.onOtherSelectClick || this.builder.opts.otherSelect !== '') {
        modal.querySelector('.input-select-other').style.display = 'block';
        let inputSelectOther = modal.querySelector('.input-select-other');
        dom.addEventListener(inputSelectOther, 'click', e => {
          if (this.builder.opts.onOtherSelectClick) {
            this.builder.opts.onOtherSelectClick({
              targetInput: modal.querySelector('.input-url'),
              theTrigger: modal.querySelector('.input-select-other')
            });
          } else {
            let modalFileSelect = builderStuff.querySelector('.is-modal.otherselect');
            if (this.builder.opts.assetRefresh) {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
              this.builder.opts.assetRefresh = false;
            }
            if (modalFileSelect.querySelector('iframe').src === 'about:blank') {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
            }
            util.showModal(modalFileSelect, false, () => {
              inputSelectOther.removeAttribute('data-focus');
              inputSelectOther.focus();
            }, false, this.builder.assetPanelFullScreen);
            inputSelectOther.setAttribute('data-focus', true);
          }
          this.builder.targetInput = modal.querySelector('.input-url'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          this.builder.targetAssetType = 'all';
          e.preventDefault();
          e.stopImmediatePropagation();
        });
      }
      if (this.builder.opts.onFileSelectClick || this.builder.opts.fileselect !== '') {
        modal.querySelector('.input-select').style.display = 'block';
        modal.querySelector('.input-url').style.width = '444px';
        let inputSelect = modal.querySelector('.input-select');
        dom.addEventListener(inputSelect, 'click', () => {
          if (this.builder.opts.onFileSelectClick) {
            this.builder.opts.onFileSelectClick({
              targetInput: modal.querySelector('.input-url'),
              theTrigger: modal.querySelector('.input-select')
            });
          } else {
            let modalFileSelect = builderStuff.querySelector('.is-modal.fileselect');
            if (this.builder.opts.assetRefresh) {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.fileselect;
              this.builder.opts.assetRefresh = false;
            }
            if (modalFileSelect.querySelector('iframe').src === 'about:blank') {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.fileselect;
            }
            util.showModal(modalFileSelect, false, null, false, this.builder.assetPanelFullScreen);
          }
          this.builder.targetInput = modal.querySelector('.input-url'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          this.builder.targetAssetType = 'all';
        });
      } else {
        modal.querySelector('.input-select').style.display = 'none';
        modal.querySelector('.input-url').style.width = '100%';
      }
    }
  }
  click(col, e) {
    const dom = this.builder.dom;
    let customcode = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
    }
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    const elm = e.target;
    this.builder.activeLink = null;
    this.builder.activeLinkButton = null;
    if ((elm.tagName.toLowerCase() === 'a' || dom.parentsHasTag(elm, 'a')) && !customcode && !noedit && !_protected) {
      if (elm.childNodes.length > 0) {
        // Sometimes happens when click a link icon, but not exactly on the icon <i>, but the link <a>
        if (elm.childNodes[0].tagName) if (elm.childNodes[0].tagName.toLowerCase() === 'i' && elm.childNodes.length === 1 && elm.childNodes[0].innerHTML === '') {
          const icons = document.querySelectorAll('.icon-active');
          Array.prototype.forEach.call(icons, icon => {
            dom.removeClass(icon, 'icon-active');
          });
          dom.addClass(elm.childNodes[0], 'icon-active');
          dom.selectElementContents(elm.childNodes[0]);
          this.builder.activeIcon = elm.childNodes[0];
        }
      }
      if (elm.tagName.toLowerCase() === 'img') {
        return;
      }
      let link;
      if (elm.tagName.toLowerCase() === 'a') {
        link = elm;
      } else {
        let element = elm;
        while (element.tagName.toLowerCase() !== 'a') {
          element = element.parentNode;
        }
        link = element;
      }
      this.builder.activeLink = link;

      // Button Stuff
      let isButton;
      let display = dom.getStyle(link, 'display');
      if (display === 'inline-block' || display === 'block' || display === 'flex') {
        isButton = true;
      }
      if (isButton) {
        this.builder.activeLinkButton = link;
      }
      // /Button Stuff

      this.showTool(link);
      e.preventDefault();
    }
  }
  showTool(link) {
    this.renderTool();
    const linkTool = this.linkTool;
    const dom = this.builder.dom;
    let linkDisplay = dom.getStyle(link, 'display');
    if (linkDisplay === 'inline' & !this.builder.activeIcon) {
      linkTool.querySelector('.link-duplicate').style.display = 'none';
      linkTool.querySelector('.link-remove').style.display = 'none';
    } else {
      linkTool.querySelector('.link-duplicate').style.display = 'block';
      linkTool.querySelector('.link-remove').style.display = 'block';
    }

    // Button Stuff
    if (this.builder.useButtonPlugin) {
      linkTool.querySelector('.link-button-edit').style.display = 'none';
    } else {
      if (link && this.builder.activeLinkButton) linkTool.querySelector('.link-button-edit').style.display = 'block';else linkTool.querySelector('.link-button-edit').style.display = 'none';
    }
    if (this.buttonEditor) if (dom.hasClass(this.buttonEditor.buttonModal, 'active')) {
      this.buttonEditor.realtime();
    }
    // /Button Stuff

    let left, top;
    top = link.getBoundingClientRect().top + this.builder.win.pageYOffset;
    if (this.builder.activeIcon) top = this.builder.activeIcon.getBoundingClientRect().top + this.builder.win.pageYOffset;
    left = link.getBoundingClientRect().left;
    linkTool.style.display = 'flex';
    const w = linkTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = linkTool.offsetHeight;
    linkTool.style.top = top - h - 3 + 'px';
    linkTool.style.left = left + link.offsetWidth * this.builder.opts.zoom - w + 'px';
    const handleLinkButtonClick = e => {
      let elm = e.target;
      if (!elm) return;
      if (!elm.closest('#divLinkTool') && !elm.closest('.is-modal') && !elm.closest('.keep-selection') && !elm.closest('a')) {
        // click outside

        this.hideTool();

        // Hide Button Editor Modal
        if (this.buttonEditor) this.buttonEditor.hide();
        document.removeEventListener('click', handleLinkButtonClick);
        if (this.builder.iframeDocument) {
          this.builder.doc.removeEventListener('click', handleLinkButtonClick);
        }
        this.builder.handleLinkButtonClick_ = false;
      }
    };
    if (!this.builder.handleLinkButtonClick_) {
      document.addEventListener('click', handleLinkButtonClick);
      if (this.builder.iframeDocument) {
        this.builder.doc.addEventListener('click', handleLinkButtonClick);
      }
      this.builder.handleLinkButtonClick_ = true;
    }
  }
  hideTool() {
    if (this.linkTool) this.linkTool.style.display = '';
  }

  // Button Stuff
  editButton() {
    this.renderButtonPanel();
    this.buttonEditor.open();
  }
  createLink() {
    this.renderPanel();
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    util.getSelection(); // new

    let text = dom.getSelected();
    let modal = builderStuff.querySelector('.is-modal.createlink');
    modal.querySelector('.input-url').value = '';
    modal.querySelector('.input-newwindow').checked = false;
    modal.querySelector('.input-openlightbox').checked = false;
    modal.querySelector('.input-title').value = '';
    modal.querySelector('.input-text').value = '';
    modal.querySelector('#lblCreateLinkText').style.display = '';
    modal.querySelector('#inpCreateLinkText').style.display = '';
    let link = this.builder.activeLink;
    if (link) {
      let url = link.getAttribute('href');
      let target = link.getAttribute('target');
      let title = link.getAttribute('title');
      let linktext = link.innerHTML;
      modal.querySelector('.input-url').value = url;
      if (target === '_blank') {
        modal.querySelector('.input-newwindow').checked = true;
      } else {
        modal.querySelector('.input-newwindow').checked = false;
      }
      if (dom.hasClass(link, 'is-lightbox')) {
        modal.querySelector('.input-openlightbox').checked = true;
      } else {
        modal.querySelector('.input-openlightbox').checked = false;
      }
      modal.querySelector('.input-title').value = title;
      modal.querySelector('.input-text').value = linktext;
    } else {
      modal.querySelector('.input-text').value = text;
      if (this.builder.activeIcon) {
        modal.querySelector('#lblCreateLinkText').style.display = 'none';
        modal.querySelector('#inpCreateLinkText').style.display = 'none';
      }
    }
    util.showModal(modal, true, () => {
      if (!util.appleMobile) util.restoreSelection();
    }, true);
    modal.querySelector('.input-url').focus();
  }
  editLink() {
    this.renderPanel();
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let link = this.builder.activeLink;
    let modal = builderStuff.querySelector('.is-modal.createlink');
    let icon = link.querySelector('i');
    modal.querySelector('#lblCreateLinkText').style.display = '';
    modal.querySelector('#inpCreateLinkText').style.display = '';
    if (link.childElementCount === 1 && icon) {
      if (dom.hasClass(icon, 'icon')) {
        modal.querySelector('#lblCreateLinkText').style.display = 'none';
        modal.querySelector('#inpCreateLinkText').style.display = 'none';
      }
    }
    let url = link.getAttribute('href');
    let target = link.getAttribute('target');
    let title = link.getAttribute('title');
    let linktext = link.innerHTML;
    modal.querySelector('.input-url').value = url;
    if (target === '_blank') {
      modal.querySelector('.input-newwindow').checked = true;
    } else {
      modal.querySelector('.input-newwindow').checked = false;
    }
    if (dom.hasClass(link, 'is-lightbox')) {
      modal.querySelector('.input-openlightbox').checked = true;
    } else {
      modal.querySelector('.input-openlightbox').checked = false;
    }
    modal.querySelector('.input-title').value = title;
    modal.querySelector('.input-text').value = linktext;
    util.showModal(modal, true, null, true);
    modal.querySelector('.input-url').focus();
  }
}

class Button {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    let buttonTool = builderStuff.querySelector('#divButtonTool');
    if (!buttonTool) {
      let html = `<div id="divButtonTool" class="is-tool">
                <button title="${util.out('Edit Button')}" data-title="${util.out('Edit Button')}" class="button-edit"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-android-create"></use></svg></button>
                <button title="${util.out('Duplicate')}" data-title="${util.out('Duplicate')}" class="button-duplicate"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
                <button title="${util.out('Delete')}" data-title="${util.out('Delete')}" class="button-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        buttonTool = builderStuff.querySelector('#divButtonTool');
      } else {
        buttonTool = contentStuff.querySelector('#divButtonTool');
      }
      this.buttonTool = buttonTool;
      let buttonEdit = buttonTool.querySelector('.button-edit');
      dom.addEventListener(buttonEdit, 'click', () => {
        // old: 10853

        this.editButton();
      });
      let buttonDuplicate = buttonTool.querySelector('.button-duplicate');
      dom.addEventListener(buttonDuplicate, 'click', () => {
        if (this.builder.activeButton) {
          this.builder.uo.saveForUndo();
          const newButton = this.builder.activeButton.cloneNode(true);
          let elmActive = newButton.querySelector('.elm-active');
          if (elmActive) dom.removeClass(elmActive, 'elm-active');
          this.builder.activeButton.parentNode.insertBefore(newButton, this.builder.activeButton);
          this.showTool(this.builder.activeButton);
        }
      });
      let buttonRemove = buttonTool.querySelector('.button-remove');
      dom.addEventListener(buttonRemove, 'click', () => {
        this.builder.uo.saveForUndo();
        if (this.builder.activeButton) this.builder.activeButton.parentNode.removeChild(this.builder.activeButton);
        buttonTool.style.display = '';
        this.builder.activeButton = null;
      });
    }
  }
  renderPanel() {
    let buttonModal = this.builderStuff.querySelector('.is-modal.buttoneditor');
    if (!buttonModal) {
      this.buttonEditor = new ButtonEditor(this.builder);
    }
  }
  click(col, e) {
    let customcode = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
    }
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    const elm = e.target;
    this.builder.activeButton = null;
    const btn = elm.closest('button');
    if (btn && !customcode && !noedit && !_protected) {
      this.builder.activeButton = btn;
      this.renderTool();
      this.showTool(btn);
      const handleButtonClick = e => {
        let elm = e.target;
        if (!elm) return;
        if (!elm.closest('#divButtonTool') && !elm.closest('.is-modal') && !elm.closest('.keep-selection') && !elm.closest('button')) {
          // click outside

          // hide
          this.hideTool();
          // console.log('HIDE');

          // Hide Button Editor Modal
          if (this.buttonEditor) this.buttonEditor.hide();
          document.removeEventListener('click', handleButtonClick);
          if (this.builder.iframeDocument) {
            this.builder.doc.removeEventListener('click', handleButtonClick);
          }
          this.builder.handleButtonClick_ = false;
        }
      };
      if (!this.builder.handleButtonClick_) {
        document.addEventListener('click', handleButtonClick);
        if (this.builder.iframeDocument) {
          this.builder.doc.addEventListener('click', handleButtonClick);
        }
        this.builder.handleButtonClick_ = true;
      }
      e.preventDefault();
    }
  }
  editButton() {
    this.renderPanel();
    this.buttonEditor.open();
  }
  showTool(activeButton) {
    const dom = this.builder.dom;
    if (this.buttonEditor) if (dom.hasClass(this.buttonEditor.buttonModal, 'active')) {
      this.buttonEditor.realtime();
    }
    const buttonTool = this.buttonTool;
    let top = activeButton.getBoundingClientRect().top + this.builder.win.pageYOffset;
    let left = activeButton.getBoundingClientRect().left;
    buttonTool.style.display = 'flex';
    const w = buttonTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = buttonTool.offsetHeight;
    buttonTool.style.top = top - h - 3 + 'px';
    buttonTool.style.left = left + activeButton.offsetWidth * this.builder.opts.zoom - w + 'px';
  }
  hideTool() {
    if (this.buttonTool) this.buttonTool.style.display = '';
  }
}

class Spacer {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    if (this.spacerTool) return;
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let spacerTool = builderStuff.querySelector('.is-spacer-tool');
    if (!spacerTool) {
      let html = `
            <div id="divSpacerTool" class="is-tool is-spacer-tool">
                <button title="${util.out('Decrease')}" data-value="-"><svg class="is-icon-flex"><use xlink:href="#ion-ios-minus-empty"></use></svg></button>
                <button title="${util.out('Increase')}" data-value="+" style="border-left: none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        spacerTool = builderStuff.querySelector('.is-spacer-tool');
      } else {
        spacerTool = contentStuff.querySelector('.is-spacer-tool');
      }
      this.spacerTool = spacerTool;
      const btns = spacerTool.querySelectorAll('button');
      Array.prototype.forEach.call(btns, btn => {
        dom.addEventListener(btn, 'click', () => {
          this.builder.uo.saveForUndo();
          const command = btn.getAttribute('data-value');
          let spacer = this.builder.activeSpacer;
          if (command === '-') {
            if (dom.hasClass(spacer, 'height-300')) {
              dom.removeClass(spacer, 'height-300');
              dom.addClass(spacer, 'height-280');
            } else if (dom.hasClass(spacer, 'height-280')) {
              dom.removeClass(spacer, 'height-280');
              dom.addClass(spacer, 'height-260');
            } else if (dom.hasClass(spacer, 'height-260')) {
              dom.removeClass(spacer, 'height-260');
              dom.addClass(spacer, 'height-240');
            } else if (dom.hasClass(spacer, 'height-240')) {
              dom.removeClass(spacer, 'height-240');
              dom.addClass(spacer, 'height-220');
            } else if (dom.hasClass(spacer, 'height-220')) {
              dom.removeClass(spacer, 'height-220');
              dom.addClass(spacer, 'height-200');
            } else if (dom.hasClass(spacer, 'height-200')) {
              dom.removeClass(spacer, 'height-200');
              dom.addClass(spacer, 'height-180');
            } else if (dom.hasClass(spacer, 'height-180')) {
              dom.removeClass(spacer, 'height-180');
              dom.addClass(spacer, 'height-160');
            } else if (dom.hasClass(spacer, 'height-160')) {
              dom.removeClass(spacer, 'height-160');
              dom.addClass(spacer, 'height-140');
            } else if (dom.hasClass(spacer, 'height-140')) {
              dom.removeClass(spacer, 'height-140');
              dom.addClass(spacer, 'height-120');
            } else if (dom.hasClass(spacer, 'height-120')) {
              dom.removeClass(spacer, 'height-120');
              dom.addClass(spacer, 'height-100');
            } else if (dom.hasClass(spacer, 'height-100')) {
              dom.removeClass(spacer, 'height-100');
              dom.addClass(spacer, 'height-80');
            } else if (dom.hasClass(spacer, 'height-80')) {
              dom.removeClass(spacer, 'height-80');
              dom.addClass(spacer, 'height-60');
            } else if (dom.hasClass(spacer, 'height-60')) {
              dom.removeClass(spacer, 'height-60');
              dom.addClass(spacer, 'height-40');
            } else if (dom.hasClass(spacer, 'height-40')) {
              dom.removeClass(spacer, 'height-40');
              dom.addClass(spacer, 'height-20');
            }
            // else { }
          } else {
            if (dom.hasClass(spacer, 'height-20')) {
              dom.removeClass(spacer, 'height-20');
              dom.addClass(spacer, 'height-40');
            } else if (dom.hasClass(spacer, 'height-40')) {
              dom.removeClass(spacer, 'height-40');
              dom.addClass(spacer, 'height-60');
            } else if (dom.hasClass(spacer, 'height-60')) {
              dom.removeClass(spacer, 'height-60');
              dom.addClass(spacer, 'height-80');
            } else if (dom.hasClass(spacer, 'height-80')) {
              dom.removeClass(spacer, 'height-80');
              dom.addClass(spacer, 'height-100');
            } else if (dom.hasClass(spacer, 'height-100')) {
              dom.removeClass(spacer, 'height-100');
              dom.addClass(spacer, 'height-120');
            } else if (dom.hasClass(spacer, 'height-120')) {
              dom.removeClass(spacer, 'height-120');
              dom.addClass(spacer, 'height-140');
            } else if (dom.hasClass(spacer, 'height-140')) {
              dom.removeClass(spacer, 'height-140');
              dom.addClass(spacer, 'height-160');
            } else if (dom.hasClass(spacer, 'height-160')) {
              dom.removeClass(spacer, 'height-160');
              dom.addClass(spacer, 'height-180');
            } else if (dom.hasClass(spacer, 'height-180')) {
              dom.removeClass(spacer, 'height-180');
              dom.addClass(spacer, 'height-200');
            } else if (dom.hasClass(spacer, 'height-200')) {
              dom.removeClass(spacer, 'height-200');
              dom.addClass(spacer, 'height-220');
            } else if (dom.hasClass(spacer, 'height-220')) {
              dom.removeClass(spacer, 'height-220');
              dom.addClass(spacer, 'height-240');
            } else if (dom.hasClass(spacer, 'height-240')) {
              dom.removeClass(spacer, 'height-240');
              dom.addClass(spacer, 'height-260');
            } else if (dom.hasClass(spacer, 'height-260')) {
              dom.removeClass(spacer, 'height-260');
              dom.addClass(spacer, 'height-280');
            } else if (dom.hasClass(spacer, 'height-280')) {
              dom.removeClass(spacer, 'height-280');
              dom.addClass(spacer, 'height-300');
            }
          }
          this.showTool(spacer);
          this.builder.opts.onChange();
          if (this.builder.onSpacerChange) this.builder.onSpacerChange();
        });
      });
    }
  }
  click(e) {
    const dom = this.builder.dom;
    const elm = e.target;
    if (dom.hasClass(elm, 'spacer')) {
      this.builder.activeSpacer = elm;

      // prevent text selection
      if (document.selection) {
        document.selection.empty();
      } else {
        window.getSelection().removeAllRanges();
      }
      this.showTool(elm);
    } else {
      this.hideTool();
    }
  }
  showTool(elm) {
    this.renderTool();
    let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
    let left = elm.getBoundingClientRect().left;
    this.spacerTool.style.display = 'flex';
    const w = this.spacerTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = this.spacerTool.offsetHeight;
    this.spacerTool.style.top = top + (elm.offsetHeight * this.builder.opts.zoom - h) / 2 + 'px';
    this.spacerTool.style.left = left + (elm.offsetWidth * this.builder.opts.zoom - w) / 2 + 'px';
  }
  hideTool() {
    if (this.spacerTool) this.spacerTool.style.display = '';
  }
}

class Module {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    this.dom = dom;
    let moduleTool = builderStuff.querySelector('.is-module-tool');
    if (!moduleTool) {
      let html = `
            <div class="is-tool is-module-tool">
                <button class="btn-module-refresh" title="${util.out('Refresh')}" data-title="${util.out('Refresh')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#icon-reload"></use></svg></button>
                <button class="btn-module-settings" title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        moduleTool = builderStuff.querySelector('.is-module-tool');
      } else {
        moduleTool = contentStuff.querySelector('.is-module-tool');
      }
      this.moduleTool = moduleTool;
      const btnModuleSettings = moduleTool.querySelector('.btn-module-settings');
      btnModuleSettings.addEventListener('click', async () => {
        this.edit(btnModuleSettings);
      });
      const btnModuleRefresh = moduleTool.querySelector('.btn-module-refresh');
      btnModuleRefresh.addEventListener('click', async () => {
        let module = this.builder.activeModule;
        module.click();
        util.refreshModuleLayout(module);
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let moduleModal = builderStuff.querySelector('.is-modal.custommodule');
    if (!moduleModal) {
      let html = `

            <input id="hidContentModuleCode" type="hidden" />
            <input id="hidContentModuleSettings" type="hidden" />
            
            <div class="is-modal custommodule" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <div class="is-modal-bar is-draggable">
                        ${util.out('Module Settings')}
                        <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                    </div>
                    <iframe tabindex="0" style="position: absolute;top: 0;left: 0;width:100%;height:100%;border:none;border-bottom:90px solid transparent;border-top:40px solid transparent;margin:0;box-sizing:border-box;" src="about:blank"></iframe>
                    <div style="width:100%;height:90px;padding: 20px; box-sizing: border-box;position:absolute;left:0;bottom:0;overflow:hidden;text-align:right">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div> 
            `;
      dom.appendHtml(builderStuff, html);
      moduleModal = builderStuff.querySelector('.is-modal.custommodule');
      this.moduleModal = moduleModal;
      let btnOk = moduleModal.querySelector('.input-ok');
      dom.addEventListener(btnOk, 'click', () => {
        let modalIframe = moduleModal.querySelector('iframe');
        if (modalIframe.contentWindow.construct) modalIframe.contentWindow.construct();
        this.builder.uo.saveForUndo();
        let module = this.builder.activeModule;

        //Save Html (original)
        module.setAttribute('data-html', encodeURIComponent(builderStuff.querySelector('#hidContentModuleCode').value));

        //Save Settings (original)
        module.setAttribute('data-settings', encodeURIComponent(builderStuff.querySelector('#hidContentModuleSettings').value));

        //Render (programmatically)
        let html = builderStuff.querySelector('#hidContentModuleCode').value;
        html = html.replace(/{id}/g, util.makeId());
        html = html.replace(/<script>/g, `${this.builder.nonce ? `<script nonce="${this.builder.nonce}">` : '<script>'}`);
        module.innerHTML = '';
        var range = document.createRange();
        range.setStart(module, 0);
        module.appendChild(range.createContextualFragment(html));
        let subblocks = module.querySelectorAll('[data-subblock]');
        var i = 1;
        Array.prototype.forEach.call(subblocks, subblock => {
          if (module.getAttribute('data-html-' + i)) {
            subblock.innerHTML = decodeURIComponent(module.getAttribute('data-html-' + i));
          }
          i++;
        });
        let builderActive = this.builder.doc.querySelector('.builder-active');
        if (builderActive) this.builder.applyBehaviorOn(builderActive);
        this.builder.opts.onChange();
        this.builder.opts.onRender();

        // util.hideControls();

        // util.repositionColumnTool(true);
        // if(this.builder.onRefreshTool) this.builder.onRefreshTool();

        // module.click();

        this.builder.hideModal(moduleModal);
      });
      let btnCancel = moduleModal.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        this.builder.hideModal(moduleModal);
      });
    }
  }
  async edit(btn) {
    const util = this.builder.util;
    const dom = this.builder.dom;
    this.renderPanel();
    let module = this.builder.activeModule;
    const moduleModal = this.moduleModal;

    // Set a flag to indicate active module
    dom.removeAttributes(this.builder.doc.querySelectorAll('[data-module-active]'), 'data-module-active');
    module.setAttribute('data-module-active', '1');

    //show modal
    var modulename = module.getAttribute('data-module');
    var moduleDesc = module.getAttribute('data-module-desc');
    if (moduleDesc) {
      moduleModal.querySelector('.is-modal-bar').innerHTML = util.out(moduleDesc) + `<button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">
            <svg class="is-icon-flex" style="width:30px;height:30px;"><use xlink:href="#ion-ios-close-empty"></use></svg>
            </button>`;
    } else {
      moduleModal.querySelector('.is-modal-bar').innerHTML = util.out('Module Settings') + `<button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">
            <svg class="is-icon-flex" style="width:30px;height:30px;"><use xlink:href="#ion-ios-close-empty"></use></svg>
            </button>`;
    }
    var w = module.getAttribute('data-dialog-width');
    if (!w || w === '') {
      w = '900px';
    }
    var h = module.getAttribute('data-dialog-height');
    if (!h || h === '') {
      h = '570px';
    }
    if (modulename === 'slider-builder') {
      moduleModal.querySelector('div:not(.is-modal-overlay)').style.width = '90vw';
      w = '1500px';
      h = '80vh';
    }
    moduleModal.querySelector('div:not(.is-modal-overlay)').style.maxWidth = w;
    moduleModal.querySelector('div:not(.is-modal-overlay)').style.height = h;
    let btnClose = moduleModal.querySelector('.is-modal-close');
    dom.addEventListener(btnClose, 'click', () => {
      util.hideModal(moduleModal);
    });
    var index = 1;
    const builders = module.querySelectorAll('[data-subblock]');
    Array.prototype.forEach.call(builders, builder => {
      // Glide Slider Support
      if (dom.hasClass(builder.parentNode, 'glide__slide--clone')) return;
      let builderhtml = builder.innerHTML;
      module.setAttribute('data-html-' + index, encodeURIComponent(builderhtml));
      index++;
    });
    if (module.getAttribute('data-panel') === 'side' && this.builder.controlPanel) ; else {
      let iframe = moduleModal.querySelector('iframe');
      iframe.style.opacity = 0.001;
      util.showModal(moduleModal, true, () => {
        if (btn) {
          btn.removeAttribute('data-focus');
          btn.focus();
        }
      });
      if (btn) btn.setAttribute('data-focus', true);

      // var d = new Date();
      // moduleModal.querySelector('iframe').src = this.builder.opts.modulePath + modulename + '.html?' + d.getTime(); //always refreshed

      let result = await fetch(this.builder.opts.modulePath + modulename + '.html');
      result = await result.text();
      result = result.replace(/<script>/g, `${this.builder.nonce ? `<script nonce="${this.builder.nonce}">` : '<script>'}`);
      iframe.srcdoc = result;
      setTimeout(() => {
        iframe.style.opacity = '';
      }, 1);
    }
  }
  click(col) {
    let custommodule = false;
    if (col.hasAttribute('data-module')) {
      // Column contains custom module.
      custommodule = true;
    }
    if (custommodule) {
      this.builder.activeModule = col;
      this.renderTool();
      this.moduleTool.style.display = 'flex';
      const btn = this.moduleTool.querySelector('.btn-module-settings');
      if (col.getAttribute('data-panel') === 'side' && this.builder.controlPanel) {
        btn.style.display = 'none';
      } else {
        btn.style.display = '';
      }
      this.repositionModuleTool();
    } else {
      this.builder.activeModule = null;
      if (this.moduleTool) this.moduleTool.style.display = '';
    }
  }
  repositionModuleTool() {
    if (!this.builder.activeModule) return;
    if (this.moduleTool.style.display !== 'flex') return;
    let elm = this.builder.activeModule;

    // this.moduleTool.style.display = 'flex';
    let _toolwidth = this.moduleTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

    let w = elm.offsetWidth * this.builder.opts.zoom;
    let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
    let left = elm.getBoundingClientRect().left - 2;
    left = left + (w - _toolwidth);

    //Adjust left in case an element is outside the screen
    const _screenwidth = window.innerWidth;
    if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
    this.moduleTool.style.top = top + 'px';
    this.moduleTool.style.left = left + 'px';
  }
}

class Code {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let codeTool = builderStuff.querySelector('.is-code-tool');
    if (!codeTool) {
      let html = `
            <div class="is-tool is-code-tool">
                <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        codeTool = builderStuff.querySelector('.is-code-tool');
      } else {
        codeTool = contentStuff.querySelector('.is-code-tool');
      }
      this.codeTool = codeTool;
      let btn = codeTool.querySelector('button');
      dom.addEventListener(btn, 'click', () => {
        this.edit(btn);
      });
    }
  }
  edit() {
    const builderStuff = this.builder.builderStuff;
    const dom = this.builder.dom;
    let codeblock = this.builder.activeCodeBlock;
    this.builder.htmlutil.renderPanel();

    // Find editable areas (is-builder) in custom code blocks and save them to data-html-1, data-html-2, and so on.
    let tmpbuilder = builderStuff.querySelector('#tmp_buildercontent');
    if (tmpbuilder) tmpbuilder.parentNode.removeChild(tmpbuilder);
    dom.appendHtml(builderStuff, '<div id="tmp_buildercontent" style="position:absolute;top:0;left:0;width:1px;height:1px;overflow:hidden;visibility:hidden;"></div>');
    tmpbuilder = builderStuff.querySelector('#tmp_buildercontent');
    let index = 1;
    const builders = codeblock.querySelectorAll('is-builder');
    Array.prototype.forEach.call(builders, builder => {
      let builderhtml = builder.innerHTML;
      tmpbuilder = builderStuff.querySelector('#tmp_buildercontent');
      tmpbuilder.innerHTML = builderhtml;
      let elms = tmpbuilder.querySelectorAll('.elm-active');
      dom.removeClasses(elms, 'elm-active');
      elms = tmpbuilder.querySelectorAll('.elm-inspected');
      dom.removeClasses(elms, 'elm-inspected');
      elms = tmpbuilder.querySelectorAll('.cell-active');
      dom.removeClasses(elms, 'cell-active');
      elms = tmpbuilder.querySelectorAll('.row-active');
      dom.removeClasses(elms, 'row-active');
      elms = tmpbuilder.querySelectorAll('.row-outline');
      dom.removeClasses(elms, 'row-outline');
      elms = tmpbuilder.querySelectorAll('.row-outline');
      dom.removeClasses(elms, 'row-outline');
      elms = tmpbuilder.querySelectorAll('[data-click]');
      dom.removeAttributes(elms, 'data-click');
      elms = tmpbuilder.querySelectorAll('[contenteditable]');
      dom.removeAttributes(elms, 'contenteditable');
      elms = tmpbuilder.querySelectorAll('[data-module-active]');
      dom.removeAttributes(elms, 'data-module-active');
      dom.removeElements(tmpbuilder.querySelectorAll('.is-row-tool'));
      dom.removeElements(tmpbuilder.querySelectorAll('.is-col-tool'));
      dom.removeElements(tmpbuilder.querySelectorAll('.is-rowadd-tool'));
      dom.removeElements(tmpbuilder.querySelectorAll('.ovl'));
      dom.removeElements(tmpbuilder.querySelectorAll('.row-add-initial'));
      elms = tmpbuilder.querySelectorAll('[data-keep]');
      dom.removeAttributes(elms, 'data-keep');
      builderhtml = tmpbuilder.innerHTML.trim();
      builderhtml = builderhtml.replace(/<font/g, '<span').replace(/<\/font/g, '</span');
      codeblock.setAttribute('data-html-' + index, encodeURIComponent(builderhtml));
      index++;
    });
    let html = decodeURIComponent(codeblock.getAttribute('data-html'));
    html = html.replace(/<script>/g, `${this.builder.nonce ? `<script nonce="${this.builder.nonce}">` : '<script>'}`);
    tmpbuilder.parentNode.removeChild(tmpbuilder);

    // Use existing modal

    let viewhtml;
    if (this.builder.opts.htmlSyntaxHighlighting) {
      viewhtml = builderStuff.querySelector('.viewhtmlmonaco');
    } else {
      viewhtml = builderStuff.querySelector('.viewhtml');
    }
    let textarea = viewhtml.querySelector('textarea');

    // Prevent {id} get formatted.
    html = html.replaceAll('{id}', '__id__');
    let beautify = JsBeautify.html;
    html = beautify(html);
    html = html.replaceAll('__id__', '{id}');
    textarea.value = html;
    this.builder.htmlutil.view('code');
  }
  click(col) {
    let customcode = false;
    if (col.hasAttribute('data-html') && !col.hasAttribute('data-module')) {
      // Column contains custom code.
      customcode = true;
    }
    if (customcode) {
      this.builder.activeCodeBlock = col;
      let elm = col;
      this.renderTool();
      this.codeTool.style.display = 'flex';
      let _toolwidth = this.codeTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

      let w = elm.offsetWidth * this.builder.opts.zoom;
      let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
      let left = elm.getBoundingClientRect().left - 2;
      left = left + (w - _toolwidth);

      //Adjust left in case an element is outside the screen
      const _screenwidth = window.innerWidth;
      if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
      this.codeTool.style.top = top + 'px';
      this.codeTool.style.left = left + 'px';
    } else {
      this.builder.activeCodeBlock = null;
      if (this.codeTool) this.codeTool.style.display = '';
    }
  }
}

class Iframe {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let iframeTool = builderStuff.querySelector('.is-iframe-tool');
    if (!iframeTool) {
      let html = `
            <div class="is-tool is-iframe-tool">
                <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        iframeTool = builderStuff.querySelector('.is-iframe-tool');
      } else {
        iframeTool = contentStuff.querySelector('.is-iframe-tool');
      }
      this.iframeTool = iframeTool;
      let btn = iframeTool.querySelector('button');
      dom.addEventListener(btn, 'click', () => {
        this.renderPanel();
        const iframeModal = this.iframeModal;
        let iframe = this.builder.activeIframe;
        let src = iframe.src;
        let embeddedYoutubeRegex = /^.*\/\/www.youtube.com\/embed\//;
        let embeddedVimeoRegex = /^.*\/\/player.vimeo.com\/video\//;
        const inpSrc = iframeModal.querySelector('.input-src');
        const inpEmbedCode = iframeModal.querySelector('.input-embedcode');
        inpSrc.value = '';
        inpEmbedCode.value = '';
        util.showModal(iframeModal, true, () => {
          btn.removeAttribute('data-focus');
          btn.focus();
        });
        if (embeddedYoutubeRegex.exec(src) != null || embeddedVimeoRegex.exec(src) != null) {
          inpEmbedCode.style.display = 'none';
          inpSrc.style.display = 'block';
          inpSrc.value = src;
          inpSrc.focus();
        } else {
          inpSrc.style.display = 'none';
          inpEmbedCode.style.display = 'block';
          inpEmbedCode.value = iframe.outerHTML;
          inpEmbedCode.focus();
        }
        btn.setAttribute('data-focus', true);
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let iframeModal = builderStuff.querySelector('.is-modal.iframelink');
    if (!iframeModal) {
      let html = `
            <div class="is-modal iframelink" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <input class="input-src" id="__iframelink_input_src" type="text" placeholder="Source" style="width:100%;margin-bottom:12px;"/>
                    <textarea class="input-embedcode" id="__iframelink_input_embedcode" type="text" placeholder="Embed Code" style="width:100%;height:300px;margin-bottom:12px;display:none;"></textarea>
                    <div style="text-align:right">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      iframeModal = builderStuff.querySelector('.is-modal.iframelink');
      this.iframeModal = iframeModal;
      let btnOk = iframeModal.querySelector('.input-ok');
      dom.addEventListener(btnOk, 'click', () => {
        this.builder.uo.saveForUndo();
        let iframe = this.builder.activeIframe;
        let iframeParent = iframe.parentNode;
        if (iframeModal.querySelector('.input-src').value !== '') {
          var src = iframeModal.querySelector('.input-src').value;
          var youRegex = /^http[s]?:\/\/(((www.youtube.com\/watch\?(feature=player_detailpage&)?)v=)|(youtu.be\/))([^#&?]*)/;
          var vimeoRegex = /^.*(vimeo\.com\/)((channels\/[A-z]+\/)|(groups\/[A-z]+\/videos\/)|(video\/))?([0-9]+)\/?/;
          var youRegexMatches = youRegex.exec(src);
          var vimeoRegexMatches = vimeoRegex.exec(src);
          if ((youRegexMatches !== null || vimeoRegexMatches !== null) && src.indexOf('player.vimeo.com') === -1 && src.indexOf('youtube.com/embed/') === -1) {
            if (youRegexMatches != null && youRegexMatches.length >= 7) {
              var youMatch = youRegexMatches[6];
              src = 'https://www.youtube.com/embed/' + youMatch + '?rel=0';
            }
            if (vimeoRegexMatches != null && vimeoRegexMatches.length >= 7) {
              var vimeoMatch = vimeoRegexMatches[6];
              src = 'https://player.vimeo.com/video/' + vimeoMatch;
            }
            iframe.src = src;
          } else {
            iframe.src = src;
          }
          this.builder.opts.onChange();
        } else {
          const inpEmbedCode = iframeModal.querySelector('.input-embedcode');
          const embedcode = inpEmbedCode.value;
          if (embedcode.toLowerCase().indexOf('<iframe') === -1) {
            if (!alert(util.out('Please enter <iframe> element.'))) inpEmbedCode.focus();
            return;
          }
          if (embedcode !== '') {
            iframe.outerHTML = embedcode;
          }
          this.builder.activeIframe = iframeParent.querySelector('iframe');
          let builderActive = this.builder.doc.querySelector('.builder-active');
          if (builderActive) this.builder.applyBehaviorOn(builderActive);
          this.builder.opts.onChange();
          if (this.builder.onIframeChange) this.builder.onIframeChange();
        }
        util.hideModal(iframeModal);
      });
      let btnCancel = iframeModal.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        util.hideModal(iframeModal);
      });
    }
  }
  click(e) {
    const dom = this.builder.dom;
    if (dom.hasClass(e.target, 'ovl') && e.target.parentNode.querySelector('audio')) return;
    if (dom.hasClass(e.target, 'ovl')) {
      //iframe overlay

      e.target.style.display = 'none';
      this.builder.activeIframe = e.target.parentNode.querySelector('iframe');
      let elm = this.builder.activeIframe;
      this.renderTool();
      this.iframeTool.style.display = 'flex';
      let _toolwidth = this.iframeTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

      let w = elm.offsetWidth * this.builder.opts.zoom;
      let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
      let left = elm.getBoundingClientRect().left - 2;
      left = left + (w - _toolwidth);

      //Adjust left in case an element is outside the screen
      const _screenwidth = window.innerWidth;
      if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
      this.iframeTool.style.top = top + 'px';
      this.iframeTool.style.left = left + 'px';
    } else {
      let ovls = this.builder.doc.querySelectorAll('.ovl');
      Array.prototype.forEach.call(ovls, ovl => {
        ovl.style.display = 'block';
      });
      this.builder.activeIframe = null;
      if (this.iframeTool) this.iframeTool.style.display = '';
    }
  }
}

class Table {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let tableTool = builderStuff.querySelector('.is-table-tool');
    if (!tableTool) {
      //
      //<div class="is-modal-bar is-draggable" style="background:#f9f9f9;"></div>
      let html = `
            <div class="is-tool is-table-tool">
                <button title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        tableTool = builderStuff.querySelector('.is-table-tool');
      } else {
        tableTool = contentStuff.querySelector('.is-table-tool');
      }
      this.tableTool = tableTool;
      let btn = tableTool.querySelector('button');
      dom.addEventListener(btn, 'click', () => {
        // old 10317

        if (this.tableModal && this.tableModal.classList.contains('active')) {
          this.hideTableEditor();
        } else {
          this.renderPanel();
          this.showTableEditor();
        }
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let tableModal = builderStuff.querySelector('.is-modal.edittable');
    if (!tableModal) {
      let html = `
            <div class="is-modal is-modal-content edittable" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-bar is-draggable">
                    ${util.out('Table')}
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
                <div style="padding:0">
                    <div class="is-tabs" data-group="table">
                        <a title="${util.out('Style')}" id="tabTableGeneral" href="" data-content="divTableGeneral" class="active">${util.out('Style')}</a>
                        <a title="${util.out('Layout')}" id="tabTableLayout" href="" data-content="divTableLayout">${util.out('Layout')}</a>
                    </div>
                    <div id="divTableGeneral" class="is-tab-content active" tabindex="-1" data-group="table" style="display:block">

                        <div style="display:flex;padding-bottom:12px">
                            <div style="padding-right:15px">
                                <div>${util.out('Background')}:</div>
                                <div>
                                    <button title="${util.out('Background Color')}" class="input-table-bgcolor is-btn-color"></button>
                                </div>
                            </div>
                            <div>
                                <div>${util.out('Text Color')}:</div>
                                <div>
                                    <button title="${util.out('Text Color')}" class="input-table-textcolor is-btn-color"></button>
                                </div>
                            </div>
                        </div>

                        <div style="padding-bottom:12px;">
                            <div>${util.out('Border Thickness')}:</div>
                            <div>
                                <select id="selCellBorderWidth" style="width:120px;"><option value="0">No Border</option><option value="1">1</option><option value="2">2</option><option value="3">3</option></select>  
                            </div>
                        </div>
                        
                        <div style="padding-bottom:12px;">
                            <div>${util.out('Border Color')}:</div>
                            <div>
                                <button title="${util.out('Border Color')}" class="input-table-bordercolor is-btn-color"></button>
                            </div>
                        </div>
                        
                        <div style="padding-bottom:12px;">
                            <div>${util.out('Apply To')}:</div>
                            <div>
                                <select id="selTableApplyTo" style="width:120px;">
                                    <option value="table">${util.out('Table')}</option>
                                    <option value="currentrow">${util.out('Current Row')}</option>
                                    <option value="currentcol">${util.out('Current Column')}</option>
                                    <option value="evenrows">${util.out('Even Rows')}</option>
                                    <option value="oddrows">${util.out('Odd Rows')}</option>  
                                    <option value="currentcell">${util.out('Current Cell')}</option>  
                                </select>
                            </div>
                        </div>

                    </div>

                    <div id="divTableLayout" class="is-tab-content" tabindex="-1" data-group="table">
                    
                        <div style="padding-bottom:12px;">
                            <div>${util.out('Insert Row')}:</div>
                            <div style="display:flex">
                                <button class="classic" title="${util.out('Above')}" data-table-cmd="rowabove" title="${util.out('Above')}" style="margin-right:15px"> ${util.out('Above')} </button>
                                <button class="classic" title="${util.out('Below')}" data-table-cmd="rowbelow" title="${util.out('Below')}" style=""> ${util.out('Below')} </button>
                            </div> 
                        </div>
                        
                        <div style="padding-bottom:15px;">
                            <div>${util.out('Insert Column')}:</div>
                            <div style="display:flex">
                                <button class="classic" title="${util.out('Left')}" data-table-cmd="columnleft" title="${util.out('Left')}" style="margin-right:15px"> ${util.out('Left')} </button> 
                                <button class="classic" title="${util.out('Right')}" data-table-cmd="columnright" title="${util.out('Right')}" style=""> ${util.out('Right')} </button> 
                            </div> 
                        </div>

                        <div style="padding-bottom:15px;">
                            <button class="classic" title="${util.out('Delete Row')}" data-table-cmd="delrow" title="Delete Row" style=""> ${util.out('Delete Row')} </button> 
                        </div>

                        <div style="padding-bottom:15px;">    
                            <button class="classic" title="${util.out('Delete Column')}" data-table-cmd="delcolumn" title="Delete Column" style=""> ${util.out('Delete Column')} </button> 
                        </div>
                        
                        <div>    
                            <button class="classic" title="${util.out('Merge Cell')}" data-table-cmd="mergecell" style="">${util.out('Merge Cell')}</button> 
                        </div>
                    </div>
                </div>
            </div>
            
            `;
      dom.appendHtml(builderStuff, html);
      tableModal = builderStuff.querySelector('.is-modal.edittable');
      this.tableModal = tableModal;
      const btnBgColor = tableModal.querySelector('.input-table-bgcolor');
      btnBgColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo();
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          if (!this.builder.activeTd) return;

          //Apply format
          var applyto = tableModal.querySelector('#selTableApplyTo').value;
          var oTable = this.builder.activeTable;
          var oRow = this.builder.activeTd.parentNode;
          var oCell = this.builder.activeTd;
          if (applyto === 'currentcell') {
            this.builder.activeTd.style.backgroundColor = color;
          }
          for (var i = 0; i < oTable.rows.length; i++) {
            var oTR = oTable.rows[i];
            for (var j = 0; j < oTR.cells.length; j++) {
              var oTD = oTR.cells[j];
              if (applyto === 'table' || applyto === 'evenrows' && isEven(i + 1) || applyto === 'oddrows' && !isEven(i + 1) || applyto === 'currentrow' && oTR === this.builder.activeTd.parentNode || applyto === 'currentcol' && j === getCellIndex(oTable, oRow, oCell)) {
                oTD.style.backgroundColor = color;
              }
            }
          }
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, btnBgColor.style.backgroundColor, () => {
          btnBgColor.removeAttribute('data-focus');
          btnBgColor.focus();
        });
        btnBgColor.setAttribute('data-focus', true);
      });
      const btnTextColor = tableModal.querySelector('.input-table-textcolor');
      btnTextColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo();
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          if (!this.builder.activeTd) return;

          //Apply format
          var applyto = tableModal.querySelector('#selTableApplyTo').value;
          var oTable = this.builder.activeTable;
          var oRow = this.builder.activeTd.parentNode;
          var oCell = this.builder.activeTd;
          if (applyto === 'currentcell') {
            this.builder.activeTd.style.color = color;
          }
          for (var i = 0; i < oTable.rows.length; i++) {
            var oTR = oTable.rows[i];
            for (var j = 0; j < oTR.cells.length; j++) {
              var oTD = oTR.cells[j];
              if (applyto === 'table' || applyto === 'evenrows' && isEven(i + 1) || applyto === 'oddrows' && !isEven(i + 1) || applyto === 'currentrow' && oTR === this.builder.activeTd.parentNode || applyto === 'currentcol' && j === getCellIndex(oTable, oRow, oCell)) {
                oTD.style.color = color;
              }
            }
          }
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, btnTextColor.style.backgroundColor, () => {
          btnTextColor.removeAttribute('data-focus');
          btnTextColor.focus();
        });
        btnTextColor.setAttribute('data-focus', true);
      });
      const btnBorderColor = tableModal.querySelector('.input-table-bordercolor');
      btnBorderColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo();
        let elm = e.target;
        this.builder.colorPicker.open(color => {
          if (!this.builder.activeTd) return;
          var borderwidth = tableModal.querySelector('#selCellBorderWidth').value;
          if (borderwidth === '0') {
            tableModal.querySelector('#selCellBorderWidth').value = 1;
            borderwidth = 1;
          }

          //Apply format
          var applyto = tableModal.querySelector('#selTableApplyTo').value;
          var oTable = this.builder.activeTable;
          var oRow = this.builder.activeTd.parentNode;
          var oCell = this.builder.activeTd;
          if (applyto === 'currentcell') {
            this.builder.activeTd.style.borderWidth = borderwidth + 'px';
            this.builder.activeTd.style.borderStyle = 'solid';
            this.builder.activeTd.style.borderColor = color;
          }
          for (var i = 0; i < oTable.rows.length; i++) {
            var oTR = oTable.rows[i];
            for (var j = 0; j < oTR.cells.length; j++) {
              var oTD = oTR.cells[j];
              if (applyto === 'table' || applyto === 'evenrows' && isEven(i + 1) || applyto === 'oddrows' && !isEven(i + 1) || applyto === 'currentrow' && oTR === this.builder.activeTd.parentNode || applyto === 'currentcol' && j === getCellIndex(oTable, oRow, oCell)) {
                oTD.style.borderWidth = borderwidth + 'px';
                oTD.style.borderStyle = 'solid';
                oTD.style.borderColor = color;
              }
            }
          }
          elm.style.backgroundColor = color; // preview

          //Trigger Change event
          this.builder.opts.onChange();
        }, btnBorderColor.style.backgroundColor, () => {
          btnBorderColor.removeAttribute('data-focus');
          btnBorderColor.focus();
        });
        btnBorderColor.setAttribute('data-focus', true);
      });
      let selBorderWidth = tableModal.querySelector('#selCellBorderWidth');
      selBorderWidth.addEventListener('change', () => {
        if (!this.builder.activeTd) return;
        this.builder.uo.saveForUndo();
        let val = selBorderWidth.value;
        let bordercolor = tableModal.querySelector('.input-table-bordercolor').style.backgroundColor;
        if (bordercolor === '') {
          bordercolor = '#000000';
        }

        //Apply format
        var applyto = tableModal.querySelector('#selTableApplyTo').value;
        var oTable = this.builder.activeTable;
        var oRow = this.builder.activeTd.parentNode;
        var oCell = this.builder.activeTd;
        if (applyto === 'currentcell') {
          this.builder.activeTd.style.borderWidth = val + 'px';
          this.builder.activeTd.style.borderStyle = 'solid';
          this.builder.activeTd.style.borderColor = bordercolor;
          if (val === '0') {
            this.builder.activeTd.style.borderWidth = '';
            this.builder.activeTd.style.borderStyle = '';
            this.builder.activeTd.style.borderColor = '';
            tableModal.querySelector('.input-table-bordercolor').style.backgroundColor = '';
          }
        }
        for (var i = 0; i < oTable.rows.length; i++) {
          var oTR = oTable.rows[i];
          for (var j = 0; j < oTR.cells.length; j++) {
            var oTD = oTR.cells[j];
            if (applyto === 'table' || applyto === 'evenrows' && isEven(i + 1) || applyto === 'oddrows' && !isEven(i + 1) || applyto === 'currentrow' && oTR === this.builder.activeTd.parentNode || applyto === 'currentcol' && j === getCellIndex(oTable, oRow, oCell)) {
              oTD.style.borderWidth = val + 'px';
              oTD.style.borderStyle = 'solid';
              oTD.style.borderColor = bordercolor;
              if (val === '0') {
                oTD.style.borderWidth = '';
                oTD.style.borderStyle = '';
                oTD.style.borderColor = '';
                tableModal.querySelector('.input-table-bordercolor').style.backgroundColor = '';
              }
            }
          }
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });

      //Table Layout

      let btn = tableModal.querySelector('[data-table-cmd="rowabove"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oRow = this.builder.activeTd.parentNode;
        let oNewRow = oTable.insertRow(oRow.rowIndex);
        for (var i = 0; i < oRow.cells.length; i++) {
          var oNewCell = oNewRow.insertCell(oNewRow.cells.length);
          if (this.builder.activeTd.getAttribute('style')) oNewCell.setAttribute('style', this.builder.activeTd.getAttribute('style'));
          // oNewCell.setAttribute('valign', 'top'); 
          oNewCell.style.verticalAlign = 'top';
          oNewCell.innerHTML = '<br>';
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="rowbelow"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oRow = this.builder.activeTd.parentNode;
        let oNewRow = oTable.insertRow(oRow.rowIndex + 1);
        for (var i = 0; i < oRow.cells.length; i++) {
          var oNewCell = oNewRow.insertCell(oNewRow.cells.length);
          if (this.builder.activeTd.getAttribute('style')) oNewCell.setAttribute('style', this.builder.activeTd.getAttribute('style'));
          // oNewCell.setAttribute('valign', 'top'); 
          oNewCell.style.verticalAlign = 'top';
          oNewCell.innerHTML = '<br>';
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="columnleft"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oCell = this.builder.activeTd;
        var nCellIndex = oCell.cellIndex;
        for (var i = 0; i < oTable.rows.length; i++) {
          var oRowTmp = oTable.rows[i];
          var oNewCell = oRowTmp.insertCell(nCellIndex);
          if (this.builder.activeTd.getAttribute('style')) oNewCell.setAttribute('style', this.builder.activeTd.getAttribute('style'));
          // oNewCell.setAttribute('valign', 'top'); 
          oNewCell.style.verticalAlign = 'top';
          oNewCell.innerHTML = '<br>';
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="columnright"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oCell = this.builder.activeTd;
        var nCellIndex = oCell.cellIndex;
        for (var i = 0; i < oTable.rows.length; i++) {
          var oRowTmp = oTable.rows[i];
          var oNewCell = oRowTmp.insertCell(nCellIndex + 1);
          if (this.builder.activeTd.getAttribute('style')) oNewCell.setAttribute('style', this.builder.activeTd.getAttribute('style'));
          // oNewCell.setAttribute('valign', 'top'); 
          oNewCell.style.verticalAlign = 'top';
          oNewCell.innerHTML = '<br>';
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="delrow"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oRow = this.builder.activeTd.parentNode;
        oTable.deleteRow(oRow.rowIndex);
        this.builder.activeTable = null;
        this.builder.activeTd = null;
        if (oTable.rows.length === 0) {
          oTable.parentNode.removeChild(oTable);
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="delcolumn"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oCell = this.builder.activeTd;
        var nCellIndex = oCell.cellIndex;
        for (var i = 0; i < oTable.rows.length; i++) oTable.rows[i].deleteCell(nCellIndex);
        this.builder.activeTable = null;
        this.builder.activeTd = null;
        if (oTable.rows[0].cells.length === 0) {
          oTable.parentNode.removeChild(oTable);
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      btn = tableModal.querySelector('[data-table-cmd="mergecell"]');
      btn.addEventListener('click', () => {
        if (!this.builder.activeTd) return;

        //Save for Undo
        this.builder.uo.saveForUndo();
        let oTable = this.builder.activeTable;
        let oRow = this.builder.activeTd.parentNode;
        let oCell = this.builder.activeTd;
        oCell.colSpan = oCell.colSpan + 1; /*LATER: Merge 2 cell which has already colspan.*/

        if (oCell.cellIndex + 1 < oTable.rows[oRow.rowIndex].cells.length) {
          oTable.rows[oRow.rowIndex].deleteCell(oCell.cellIndex + 1);
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      let btnClose = tableModal.querySelector('.is-modal-close');
      dom.addEventListener(btnClose, 'click', () => {
        dom.removeClass(tableModal, 'active');
      });
      new Tabs({
        element: tableModal
      });
      new Draggable$2({
        selector: '.is-modal.edittable .is-draggable'
      });
    }
  }
  showTableEditor() {
    const tableModal = this.tableModal;
    this.builder.util.showModal(tableModal);
    this.realtime();
    const handleTableClick = e => {
      // console.log('handleTableClick');
      let elm = e.target;
      if (!elm) return;
      if (!elm.closest('.is-table-tool') && !elm.closest('.is-sidebar') && !elm.closest('.is-modal') && !elm.closest('.keep-selection') && !elm.closest('table')) {
        // click outside

        // hide
        this.hideTableEditor();
        // console.log('HIDE');

        document.removeEventListener('click', handleTableClick);
        if (this.builder.iframeDocument) {
          this.builder.doc.removeEventListener('click', handleTableClick);
        }
        this.builder.handleTableClick_ = false;
      }
      if (elm.closest('table')) {
        this.realtime();
      }
    };
    if (!this.builder.handleTableClick_) {
      document.addEventListener('click', handleTableClick);
      if (this.builder.iframeDocument) {
        this.builder.doc.addEventListener('click', handleTableClick);
      }
      this.builder.handleTableClick_ = true;
    }
  }
  hideTableEditor() {
    const tableModal = this.tableModal;
    if (tableModal) this.builder.util.hideModal(tableModal);
  }
  realtime() {
    const tableModal = this.tableModal;
    if (tableModal.classList.contains('active') && this.builder.activeTable) {
      let activeTd = this.builder.activeTd;
      if (activeTd) {
        tableModal.querySelector('.input-table-bgcolor').style.backgroundColor = activeTd.style.backgroundColor;
        tableModal.querySelector('.input-table-textcolor').style.backgroundColor = activeTd.style.color;
        tableModal.querySelector('.input-table-bordercolor').style.backgroundColor = activeTd.style.borderColor;
        tableModal.querySelector('#selCellBorderWidth').value = parseInt(activeTd.style.borderWidth);
      }
    } else {
      tableModal.querySelector('.input-table-bgcolor').style.backgroundColor = '';
      tableModal.querySelector('.input-table-textcolor').style.backgroundColor = '';
      tableModal.querySelector('.input-table-bordercolor').style.backgroundColor = '';
      tableModal.querySelector('#selCellBorderWidth').value = 0;
    }
  }
  click(e) {
    const dom = this.builder.dom;
    let elm = e.target;
    if (!elm) return;
    const table = elm.closest('table');
    if (table) {
      let td = elm.closest('td');
      if (dom.hasClass(table, 'default')) {
        // only edit table.default

        this.builder.activeTd = td;
        this.builder.activeTable = table;
        this.renderTool();
        this.tableTool.style.display = 'flex';
        let _toolwidth = this.tableTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

        let w = table.offsetWidth * this.builder.opts.zoom;
        let top = table.getBoundingClientRect().top + this.builder.win.pageYOffset;
        let left = table.getBoundingClientRect().left - 2;
        left = left + (w - _toolwidth);

        //Adjust left in case an element is outside the screen
        const _screenwidth = window.innerWidth;
        if (_toolwidth + left > _screenwidth) left = table.getBoundingClientRect().left;
        this.tableTool.style.top = top + 'px';
        this.tableTool.style.left = left + 'px';
      } else {
        this.builder.activeTd = null;
        this.builder.activeTable = null;
        if (this.tableTool) this.tableTool.style.display = '';
      }
    } else {
      this.builder.activeTd = null;
      this.builder.activeTable = null;
      if (this.tableTool) this.tableTool.style.display = '';
    }
  }
}
function isEven(someNumber) {
  return someNumber % 2 === 0 ? true : false;
}
function getCellIndex(oTable, oTR, oTD) {
  var nCount = 0;
  var bFinish = false;
  for (var i = 0; i < oTR.cells.length; i++) {
    if (bFinish === false) {
      nCount += oTR.cells[i].colSpan;
    }
    if (oTD === oTR.cells[i]) bFinish = true;
  }
  nCount = nCount - (oTD.colSpan - 1);
  var nCellIndex = nCount - 1;
  return nCellIndex;
}

class Video {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let videoTool = builderStuff.querySelector('.is-video-tool');
    if (!videoTool) {
      let html = `
            <div class="is-tool is-video-tool">
                <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        videoTool = builderStuff.querySelector('.is-video-tool');
      } else {
        videoTool = contentStuff.querySelector('.is-video-tool');
      }
      this.videoTool = videoTool;
      let btn = this.videoTool.querySelector('button');
      dom.addEventListener(btn, 'click', () => {
        this.renderPanel();
        const videoModal = this.videoModal;
        let video = this.builder.activeVideo;
        let source = video.querySelector('source');
        let url = '';
        if (source) url = source.getAttribute('src');
        videoModal.querySelector('.input-url').value = url;
        const inpShowControls = videoModal.querySelector('.input-video-controls');
        if (video.hasAttribute('controls')) {
          inpShowControls.checked = true;
        } else {
          inpShowControls.checked = false;
        }
        const inpLoop = videoModal.querySelector('.input-video-loop');
        if (video.hasAttribute('loop')) {
          inpLoop.checked = true;
        } else {
          inpLoop.checked = false;
        }
        const inpAutoplay = videoModal.querySelector('.input-video-autoplay');
        if (video.hasAttribute('autoplay')) {
          inpAutoplay.checked = true;
        } else {
          inpAutoplay.checked = false;
        }
        util.showModal(videoModal, true, () => {
          btn.removeAttribute('data-focus');
          btn.focus();
        });
        btn.setAttribute('data-focus', true);
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    const videoModal = builderStuff.querySelector('.is-modal.videolink');
    if (!videoModal) {
      let html = `
            <div class="is-modal videolink" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <label for="inpVideoLinkSource" style="display:block">${util.out('Source')}:</label>
                    <div class="video-url">
                        <input id="inpVideoLinkSource" class="input-url" type="text"/>
                        <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                            ${this.builder.opts.selectIcon}
                        </button>
                        <div class="video-larger1 input-upload is-btn classic" style="position:relative;flex:none;box-shadow: 0px 3px 6px -6px rgba(0, 0, 0, 0.32);">
                            <form class="form-upload-larger" target="frameTargetVideoUpload" method="post" action="${this.builder.opts.videoHandler}" enctype="multipart/form-data" style="position:absolute;top:0;left:0;display:flex;justify-content:center;align-items:center;width:100%;height:100%;">
                                <input id="hidRefId5" name="hidRefId" type="hidden" value="" />
                                <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                <input title="${util.out('Select')}" id="fileVideo1" name="fileImage" type="file" accept="video/mp4" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                            </form>

                            <iframe tabindex="0" id="frameTargetVideoUpload" name="frameTargetVideoUpload" tabIndex="-1" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                        </div>
                    </div>
                    
                    <label style="display:block;margin-top:14px;">
                        <input class="input-video-controls" id="__input_video_controls" type="checkbox" />  ${util.out('Show Controls')}&nbsp;
                    </label>
                    <label style="display:block;margin-top:5px;">
                        <input class="input-video-loop" id="__input_video_loop" type="checkbox" />  ${util.out('Loop')}&nbsp;
                    </label>
                    <label style="display:block;margin-top:5px;">
                        <input class="input-video-autoplay" id="__input_video_autoplay" type="checkbox" />  ${util.out('Autoplay')}&nbsp;
                    </label>
                    
                    <div style="text-align:right;margin-top:14px;">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      const videoModal = builderStuff.querySelector('.is-modal.videolink');
      this.videoModal = videoModal;
      if (this.builder.opts.videoHandler === '' && !this.builder.opts.onVideoUpload) {
        videoModal.querySelector('.video-larger1').style.display = 'none';
      }
      if (!this.builder.opts.onVideoSelectClick && this.builder.opts.videoSelect === '') {
        videoModal.querySelector('.input-select').style.display = 'none';
      }
      let inpSelectVideo = videoModal.querySelector('.input-select');
      if (inpSelectVideo) dom.addEventListener(inpSelectVideo, 'click', () => {
        if (this.builder.opts.onVideoSelectClick) {
          this.builder.opts.onVideoSelectClick({
            targetInput: videoModal.querySelector('.input-url'),
            theTrigger: inpSelectVideo
          });
        } else {
          let modalVideoSelect = builderStuff.querySelector('.is-modal.videoselect');
          let iframe = modalVideoSelect.querySelector('iframe');
          if (this.builder.opts.assetRefresh) {
            iframe.src = this.builder.opts.videoSelect;
          }
          if (iframe.src === 'about:blank') {
            iframe.src = this.builder.opts.videoSelect;
          }
          util.showModal(modalVideoSelect, false, () => {
            inpSelectVideo.removeAttribute('data-focus');
            inpSelectVideo.focus();
          }, false, this.builder.assetPanelFullScreen);
          inpSelectVideo.setAttribute('data-focus', true);
        }
        this.builder.targetInput = videoModal.querySelector('.input-url'); // used by selectAsset() (see contentbuilder.js)
        this.builder.targetCallback = null;
        this.builder.targetAssetType = 'video';
      });
      let fileLargerVideo = videoModal.querySelector('#fileVideo1');
      dom.addEventListener(fileLargerVideo, 'change', e => {
        let element = fileLargerVideo;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        videoModal.querySelector('#hidRefId5').value = this.builder.opts.customval;
        if (this.builder.opts.onVideoUpload) {
          this.builder.opts.onVideoUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerVideo.value = '';
      });
      let btnOk = videoModal.querySelector('.input-ok');
      dom.addEventListener(btnOk, 'click', () => {
        this.builder.uo.saveForUndo();
        let video = this.builder.activeVideo;
        if (videoModal.querySelector('.input-video-controls').checked) {
          video.setAttribute('controls', '');
        } else {
          video.removeAttribute('controls');
        }
        if (videoModal.querySelector('.input-video-loop').checked) {
          video.setAttribute('loop', '');
        } else {
          video.removeAttribute('loop');
        }
        if (videoModal.querySelector('.input-video-autoplay').checked) {
          video.setAttribute('autoplay', '');
        } else {
          video.removeAttribute('autoplay');
        }
        if (videoModal.querySelector('.input-url').value !== '') {
          let url = videoModal.querySelector('.input-url').value;
          let source = video.querySelector('source');
          if (url !== source.getAttribute('src')) {
            if (source) source.setAttribute('src', url);
            setTimeout(function () {
              // refresh
              video.pause();
              video.load();
              // video.play();
            }, 100);
          }
          this.builder.opts.onChange();
        }
        this.builder.hideModal(videoModal);
        if (this.builder.onVideoChange) this.builder.onVideoChange();
      });
      let btnCancel = videoModal.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        this.builder.hideModal(videoModal);
      });
    }
  }
  click(e) {
    let elm = e.target;
    if (elm.tagName.toLowerCase() === 'video') {
      if (elm.closest('[data-html]')) {
        this.builder.activeVideo = null;
        this.videoTool.style.display = '';
        return;
      }
      this.renderTool();
      const videoTool = this.videoTool;
      this.builder.activeVideo = elm;
      videoTool.style.display = 'flex';
      let _toolwidth = videoTool.offsetWidth;
      let w = elm.offsetWidth * this.builder.opts.zoom;
      let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
      let left = elm.getBoundingClientRect().left;
      left = left + (w - _toolwidth);

      // Adjust left in case an element is outside the screen
      const _screenwidth = window.innerWidth;
      if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
      videoTool.style.top = top + 'px';
      videoTool.style.left = left + 'px';
    } else {
      this.builder.activeVideo = null;
      if (this.videoTool) this.videoTool.style.display = '';
    }
  }
  repositionVideoTool() {
    let elm = this.builder.activeVideo;
    if (!elm) return;
    if (!this.videoTool) return;
    this.videoTool.style.display = 'flex';
    let _toolwidth = this.videoTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

    let w = elm.offsetWidth * this.builder.opts.zoom;
    let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
    let left = elm.getBoundingClientRect().left;
    left = left + (w - _toolwidth);
    // left = left + (w/2 - _toolwidth/2);

    //Adjust left in case an element is outside the screen
    const _screenwidth = window.innerWidth;
    if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
    this.videoTool.style.top = top + 'px';
    this.videoTool.style.left = left + 'px';
  }
}

class Audio {
  constructor(builder) {
    this.builder = builder;
  }
  renderTool() {
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let audioTool = builderStuff.querySelector('.is-audio-tool');
    if (!audioTool) {
      let html = `
            <div class="is-tool is-audio-tool">
                <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:37px;height:37px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        audioTool = builderStuff.querySelector('.is-audio-tool');
      } else {
        audioTool = contentStuff.querySelector('.is-audio-tool');
      }
      this.audioTool = audioTool;
      let btn = this.audioTool.querySelector('button');
      dom.addEventListener(btn, 'click', () => {
        let audio = this.builder.activeAudio;
        let source = audio.querySelector('source');
        let url = '';
        if (source) url = source.getAttribute('src');
        this.renderPanel();
        const audioModal = this.audioModal;
        audioModal.querySelector('.input-url').value = url;
        util.showModal(audioModal, true, () => {
          btn.removeAttribute('data-focus');
          btn.focus();
        });
        btn.setAttribute('data-focus', true);
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    const audioModal = builderStuff.querySelector('.is-modal.audiolink');
    if (!audioModal) {
      let html = `
            <div class="is-modal audiolink" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <label for="inpAudioLinkSource" style="display:block">${util.out('Source')}:</label>
                    <div class="audio-url">
                        <input id="inpAudioLinkSource" class="input-url" type="text"/>
                        <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                            ${this.builder.opts.selectIcon}
                        </button>
                        <div class="audio-file-upload input-upload is-btn classic" style="position:relative;flex:none;box-shadow: 0px 3px 6px -6px rgba(0, 0, 0, 0.32);">
                            <form class="form-upload-larger" target="frameTargetAudioUpload" method="post" action="${this.builder.opts.audioHandler}" enctype="multipart/form-data" style="position:absolute;top:0;left:0;display:flex;justify-content:center;align-items:center;width:100%;height:100%;">
                                <input id="hidRefAudio" name="hidRefId" type="hidden" value="" />
                                <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                <input title="${util.out('Select')}" id="fileAudio1" name="fileImage" type="file" accept="audio/mp3" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                            </form>

                            <iframe tabindex="0" id="frameTargetAudioUpload" name="frameTargetAudioUpload" tabIndex="-1" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                        </div>
                    </div>
                    
                    <div style="text-align:right;margin-top:14px;">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      const audioModal = builderStuff.querySelector('.is-modal.audiolink');
      this.audioModal = audioModal;
      if (this.builder.opts.audioHandler === '' && !this.builder.opts.onAudioUpload) {
        audioModal.querySelector('.audio-file-upload').style.display = 'none';
      }
      if (!this.builder.opts.onAudioSelectClick && this.builder.opts.audioSelect === '') {
        audioModal.querySelector('.input-select').style.display = 'none';
      }
      let inpSelectAudio = audioModal.querySelector('.input-select');
      if (inpSelectAudio) dom.addEventListener(inpSelectAudio, 'click', () => {
        if (this.builder.opts.onAudioSelectClick) {
          this.builder.opts.onAudioSelectClick({
            targetInput: audioModal.querySelector('.input-url'),
            theTrigger: inpSelectAudio
          });
        } else {
          let modalAudioSelect = builderStuff.querySelector('.is-modal.audioselect');
          let iframe = modalAudioSelect.querySelector('iframe');
          if (this.builder.opts.assetRefresh) {
            iframe.src = this.builder.opts.audioSelect;
          }
          if (iframe.src === 'about:blank') {
            iframe.src = this.builder.opts.audioSelect;
          }
          util.showModal(modalAudioSelect, false, () => {
            inpSelectAudio.removeAttribute('data-focus');
            inpSelectAudio.focus();
          }, false, this.builder.assetPanelFullScreen);
          inpSelectAudio.setAttribute('data-focus', true);
        }
        this.builder.targetInput = audioModal.querySelector('.input-url'); // used by selectAsset() (see contentbuilder.js)
        this.builder.targetCallback = null;
        this.builder.targetAssetType = 'audio';
      });
      let fileLargerAudio = audioModal.querySelector('#fileAudio1');
      dom.addEventListener(fileLargerAudio, 'change', e => {
        let element = fileLargerAudio;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        audioModal.querySelector('#hidRefAudio').value = this.builder.opts.customval;
        if (this.builder.opts.onAudioUpload) {
          this.builder.opts.onAudioUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerAudio.value = ''; // Clear Input
      });

      let btnOk = audioModal.querySelector('.input-ok');
      dom.addEventListener(btnOk, 'click', () => {
        this.builder.uo.saveForUndo();
        let audio = this.builder.activeAudio;
        if (audioModal.querySelector('.input-url').value !== '') {
          let url = audioModal.querySelector('.input-url').value;

          //Render
          let source = audio.querySelector('source');
          if (url !== source.getAttribute('src')) {
            if (source) source.setAttribute('src', url);
            setTimeout(function () {
              // refresh
              audio.pause();
              audio.load();
              // audio.play();
            }, 100);
          }

          //Trigger Change event
          this.builder.opts.onChange();
        }
        this.builder.hideModal(audioModal);
      });
      let btnCancel = audioModal.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        this.builder.hideModal(audioModal);
      });
    }
  }
  click(e) {
    const dom = this.builder.dom;
    if (dom.hasClass(e.target, 'ovl') && e.target.parentNode.querySelector('audio')) {
      e.target.style.display = 'none';
      let elm = e.target.parentNode.querySelector('audio');
      this.builder.activeAudio = elm;
      this.renderTool();
      this.audioTool.style.display = 'flex';
      let _toolwidth = this.audioTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

      let w = elm.offsetWidth * this.builder.opts.zoom;
      let top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
      let left = elm.getBoundingClientRect().left;
      left = left + (w - _toolwidth);

      //Adjust left in case an element is outside the screen
      const _screenwidth = window.innerWidth;
      if (_toolwidth + left > _screenwidth) left = elm.getBoundingClientRect().left;
      this.audioTool.style.top = top + 'px';
      this.audioTool.style.left = left + 'px';
    } else {
      this.builder.activeAudio = null;
      if (this.audioTool) this.audioTool.style.display = '';
    }
  }
}

// Currently not used

class Svg {
  constructor(builder) {
    this.builder = builder;
    const dom = this.builder.dom;
    this.dom = dom;
    const util = this.builder.util;
    this.util = util;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    const contentStuff = this.builder.contentStuff;
    this.contentStuff = contentStuff;
    this.renderTool();
  }
  renderTool() {
    const builderStuff = this.builderStuff;
    const contentStuff = this.contentStuff;
    const dom = this.dom;
    const util = this.util;
    let svgTool = builderStuff.querySelector('.is-svg-tool');
    if (!svgTool) {
      let html = `
            <div class="is-tool is-svg-tool">
                <button class="btn-svg-settings" title="${util.out('Settings')}" data-title="${util.out('Settings')}"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        svgTool = builderStuff.querySelector('.is-svg-tool');
      } else {
        svgTool = contentStuff.querySelector('.is-svg-tool');
      }
      this.svgTool = svgTool;
      const btnSvgSettings = svgTool.querySelector('.btn-svg-settings');
      btnSvgSettings.addEventListener('click', async () => {
        this.edit(btnSvgSettings);
      });
    }
  }
  renderPanel() {
    const util = this.util;
    const builderStuff = this.builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    let svgModal = builderStuff.querySelector('.is-modal.svgsettings');
    if (!svgModal) {
      let html = `

            <div class="is-modal svgsettings" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content scroll">
                    <label for="inpSvgCode" style="display:block">${util.out('Embed SVG')}:</label>
                    <div class="audio-url">
                        <textarea id="inpSvgCode" class="input-url"></textarea>
                    </div>
                    <div style="text-align:right;margin-top:14px;">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      svgModal = builderStuff.querySelector('.is-modal.svgsettings');
      this.svgModal = svgModal;
      let btnOk = svgModal.querySelector('.input-ok');
      dom.addEventListener(btnOk, 'click', () => {
        const inpSvgCode = svgModal.querySelector('#inpSvgCode');
        const parser = new DOMParser();
        const doc = parser.parseFromString(inpSvgCode.value, 'text/html');
        const elm = doc.querySelector('svg');
        if (!elm) return;
        elm.classList.add('svgdummy');
        this.builder.uo.saveForUndo();
        let svg = this.builder.activeSvg;
        if (svg) {
          // Update
          svg.outerHTML = doc.body.innerHTML;
        } else {
          // Insert
          this.builder.util.pasteHtmlAtCaret(doc.body.innerHTML, true);
        }
        let newSvg = this.builder.doc.querySelector('.svgdummy');
        if (newSvg) {
          newSvg.classList.remove('svgdummy');
          this.builder.activeSvg = newSvg;
          dom.selectElementContents(newSvg);
          util.saveSelection();
        }
        this.builder.opts.onChange();
        this.builder.hideModal(svgModal);
      });
      let btnCancel = svgModal.querySelector('.input-cancel');
      dom.addEventListener(btnCancel, 'click', () => {
        this.builder.hideModal(svgModal);
      });
    }
  }
  async edit(btn) {
    this.renderPanel();
    const svgModal = this.svgModal;
    const dom = this.dom;
    let btnClose = svgModal.querySelector('.is-modal-close');
    dom.addEventListener(btnClose, 'click', () => {
      this.util.hideModal(svgModal);
    });
    this.util.showModal(svgModal, true, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    });
    if (btn) btn.setAttribute('data-focus', true);
    const inpSvgCode = svgModal.querySelector('#inpSvgCode');
    inpSvgCode.value = '';
    let svg = this.builder.activeSvg;
    if (svg) inpSvgCode.value = svg.outerHTML;
    inpSvgCode.focus();
  }
  click(e) {
    const elm = e.target;
    const svg = elm.closest('svg');
    if (svg) {
      this.builder.activeSvg = svg;

      // prevent text selection
      if (document.selection) {
        document.selection.empty();
      } else {
        window.getSelection().removeAllRanges();
      }

      // Use the current icon-active class
      this.builder.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
      svg.classList.add('icon-active');
      this.showTool(svg);
    } else {
      this.builder.activeSvg = null;
      this.hideTool();
    }
  }
  showTool() {
    this.svgTool.style.display = 'flex';
    this.repositionModuleTool();
  }
  hideTool() {
    this.svgTool.style.display = '';
  }
  repositionModuleTool() {
    if (!this.builder.activeSvg) return;
    if (!this.svgTool) return;
    if (this.svgTool.style.display !== 'flex') return;
    let svg = this.builder.activeSvg;
    let toolwidth = this.svgTool.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.

    let w = svg.getBoundingClientRect().width;
    let top, left;
    if (w < 200) {
      left = svg.getBoundingClientRect().left + w;
      top = svg.getBoundingClientRect().top + this.builder.win.pageYOffset;
    } else {
      left = svg.getBoundingClientRect().left + w - toolwidth;
      top = svg.getBoundingClientRect().top + this.builder.win.pageYOffset + 3;
    }
    this.svgTool.style.top = top + 'px';
    this.svgTool.style.left = left + 'px';
  }
}

class Element$1 {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    this.hyperlink = new Hyperlink(builder);
    this.button = new Button(builder);
    this.image = new Image$1(builder);
    this.spacer = new Spacer(builder);
    this.module = new Module(builder);
    this.code = new Code(builder);
    this.iframe = new Iframe(builder);
    this.table = new Table(builder);
    this.video = new Video(builder);
    this.audio = new Audio(builder);
    this.svg = new Svg(builder);
  }
  applyBehavior(col) {
    const dom = this.dom;
    let customcode = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
    }
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    if (customcode || noedit || _protected) {
      if (noedit) {
        // For locked column
        let ces = col.querySelectorAll('[contenteditable]');
        Array.prototype.forEach.call(ces, ce => {
          ce.contentEditable = false;
        });
      }
      return;
    }

    // Set contentEditable FALSE on special elements

    let sociallinks = col.querySelectorAll('.is-social');
    Array.prototype.forEach.call(sociallinks, sociallink => {
      sociallink.contentEditable = false;
    });
    let spacers = col.querySelectorAll('.spacer');
    Array.prototype.forEach.call(spacers, spacer => {
      spacer.contentEditable = false;
    });
    let lines = col.querySelectorAll('hr');
    Array.prototype.forEach.call(lines, line => {
      line.contentEditable = false;
    });

    // Others

    let links = col.querySelectorAll('a');
    Array.prototype.forEach.call(links, link => {
      let linkDisplay = dom.getStyle(link, 'display');
      if (linkDisplay === 'inline-block') {
        //link button
        link.contentEditable = true;
        if (link.parentNode !== col) link.parentNode.contentEditable = false;
      }
    });

    //iframe overlay (need to be added so that embeded video, map, etc can be selected). First click will disable/hide the overlay. Outside click will re-enable it.
    let divs = col.querySelectorAll('.embed-responsive');
    Array.prototype.forEach.call(divs, div => {
      let overlay = div.querySelector('.ovl');
      if (!overlay) {
        dom.appendHtml(div, '<div class="ovl" style="position:absolute;background:#fff;opacity:0.01;cursor:pointer;top:0;left:0px;width:100%;height:100%;z-index:1"></div>');
        overlay = div.querySelector('.ovl');
        dom.addEventListener(overlay, 'click', () => {
          // show iframe overlay to make it clickable => for others
          let ovls = document.querySelectorAll('.ovl');
          Array.prototype.forEach.call(ovls, ovl => {
            ovl.style.display = 'block';
          });
          overlay.style.display = 'none';
        });
      }
    });
    let audios = col.querySelectorAll('audio');
    Array.prototype.forEach.call(audios, audio => {
      let overlay = audio.parentNode.querySelector('.ovl');
      if (!overlay) {
        dom.appendHtml(audio.parentNode, '<div class="ovl" style="position:absolute;background:#fff;opacity:0.01;cursor:pointer;top:0;left:0px;width:100%;height:100%;z-index:1"></div>');
        overlay = audio.parentNode.querySelector('.ovl');
        dom.addEventListener(overlay, 'click', () => {
          // show iframe overlay to make it clickable => for others
          let ovls = document.querySelectorAll('.ovl');
          Array.prototype.forEach.call(ovls, ovl => {
            ovl.style.display = '';
          });
          overlay.style.display = 'none';
        });
      }
      setTimeout(() => {
        // In case of add snippet, after apply behavior, snippet will be automatically clicked/selected.
        // So check the snippet if it is selected (active). If so, hide the overlay.
        if (overlay.closest('.elm-active')) {
          overlay.click();
          // overlay.style.display = 'none';
        } else {
          overlay.style.display = '';
        }
      }, 300);
    });
  }
  click(col, e) {
    const dom = this.dom;
    const elm = e.target;
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    let customcode = false;
    let subblock = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
      if (dom.parentsHasAttribute(elm, 'data-subblock')) {
        subblock = true;
      }
    }
    if (!customcode && !noedit && !_protected || subblock) {
      //previously this is commented: && !noedit && !_protected

      // Icon
      const icons = this.builder.doc.querySelectorAll('.icon-active');
      icons.forEach(icon => icon.classList.remove('icon-active'));
      this.builder.activeIcon = null;
      if (elm.tagName.toLowerCase() === 'i' && elm.innerHTML === '') {
        elm.classList.add('icon-active');
        dom.selectElementContents(elm);
        this.builder.activeIcon = elm;

        // https://stackoverflow.com/questions/29908261/prevent-text-selection-on-mouse-drag
        // prevent text selection
        if (document.selection) {
          document.selection.empty();
        } else {
          window.getSelection().removeAllRanges();
        }
      }

      // Image (must be placed before //Link)
      this.image.click(e);

      // Button
      this.button.click(col, e);

      // Link
      this.hyperlink.click(col, e);
      if ((elm.tagName.toLowerCase() === 'a' || dom.parentsHasTag(elm, 'a')) && !customcode) {
        e.preventDefault();
      }

      // Table
      this.table.click(e);

      // Iframe
      this.iframe.click(e);

      // Video
      this.video.click(e);

      // Audio
      this.audio.click(e);

      // Spacer
      this.spacer.click(e);

      // Svg
      this.svg.click(e);
    } else {
      this.util.hideControls();

      // Extra: make image[data-image-embed] clickable/editable
      if (e.target.tagName.toLowerCase() === 'img' && e.target.hasAttribute('data-image-embed')) {
        this.image.click(e);
        if (e.target.hasAttribute('data-sync')) {
          let img = e.target;
          img.setAttribute('data-src', img.src);
        }
      } else if (e.target.tagName.toLowerCase() === 'img' && col.hasAttribute('data-image-allowed')) {
        this.image.click(e);
      }
    }

    // Custom Code
    this.code.click(col, e);

    // Module
    this.module.click(col, e);
  }
}

class Modal {
  constructor(opts = {}) {
    let defaults = {
      animateModal: false,
      elementToAnimate: '',
      stuffPlacement: '#_cbhtml'
    };
    this.opts = Object.assign(this, defaults, opts);
    this.id = this.makeId();
    let builderStuff = document.querySelector(this.opts.stuffPlacement);
    if (!builderStuff) {
      builderStuff = document.createElement('div');
      builderStuff.id = '_cbhtml';
      document.body.appendChild(builderStuff);
    }
    this.builderStuff = builderStuff;

    // Stuff placement for this (single) instance
    const objStuff = document.createElement('div');
    objStuff.id = this.id;
    builderStuff.appendChild(objStuff);
    this.objStuff = objStuff;
  }
  confirm(message, callback, animated) {
    let html = `<div class="is-modal is-confirm" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="padding-bottom:20px;">
                <div style="margin: 20px 0 30px;font-size: 14px;">${message}</div>
                <button title="${this.out('Delete')}" class="input-ok classic">${this.out('Delete')}</button>
            </div>
        </div>`;
    let confirmModal = this.objStuff.querySelector('.is-confirm');
    if (!confirmModal) {
      this.objStuff.insertAdjacentHTML('beforeend', html);
      confirmModal = this.builderStuff.querySelector('.is-confirm');
    }
    this.show(confirmModal, false, () => {
      //this function runs when overlay is clicked. Remove modal.
      confirmModal.parentNode.removeChild(confirmModal);

      //do task
      callback(false);
    }, animated);
    let buttonok = confirmModal.querySelector('.is-confirm .input-ok');
    this.addEventListener(buttonok, 'click', () => {
      this.hide(confirmModal);
      confirmModal.parentNode.removeChild(confirmModal); //remove modal

      //do task
      callback(true);
    });
  }
  show(modal, overlayStay, cancelCallback, animated) {
    this.addClass(modal, 'active');

    // animated param (if set) will overide global setting
    let animate = false;
    if (!(typeof animated === 'undefined' || animated === null)) {
      // animated param is set
      animate = animated;
    } else {
      // if animated param is not set
      animate = this.opts.animateModal; // use global setting
    }

    if (animate) {
      const buildercontainers = document.querySelectorAll(this.opts.elementToAnimate);
      Array.prototype.forEach.call(buildercontainers, buildercontainer => {
        // buildercontainer.style.transform = 'scale(0.98)';
        // buildercontainer.style.WebkitTransform= 'scale(0.98)';
        // buildercontainer.style.MozTransform= 'scale(0.98)';
        buildercontainer.style.transform = `scale(${this.builder.opts.zoom - 0.02})`;
        buildercontainer.style.WebkitTransform = `scale(${this.builder.opts.zoom - 0.02})`;
        buildercontainer.style.MozTransform = `scale(${this.builder.opts.zoom - 0.02})`;
        buildercontainer.setAttribute('scaled-down', '1');
      });
    }
    if (!modal.querySelector('.is-modal-overlay')) {
      let html;
      if (overlayStay) {
        html = '<div class="is-modal-overlay overlay-stay"></div>';
      } else {
        html = '<div class="is-modal-overlay"></div>';
      }
      modal.insertAdjacentHTML('afterbegin', html);
      if (!overlayStay) {
        let overlay = modal.querySelector('.is-modal-overlay');
        this.addEventListener(overlay, 'click', () => {
          //cancelCallback
          if (cancelCallback) cancelCallback();
          this.hide(modal);
        });
      }
    }
  }
  hide(modal) {
    if (this.opts.elementToAnimate !== '') {
      const buildercontainers = document.querySelectorAll(this.opts.elementToAnimate);
      Array.prototype.forEach.call(buildercontainers, buildercontainer => {
        // buildercontainer.style.transform = '';
        // buildercontainer.style.WebkitTransform= '';
        // buildercontainer.style.MozTransform= '';
        if (buildercontainer.getAttribute('scaled-down')) {
          buildercontainer.style.transform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.style.WebkitTransform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.style.MozTransform = `scale(${this.builder.opts.zoom})`;
          buildercontainer.removeAttribute('scaled-down');
        }
      });
    }
    this.removeClass(modal, 'active');
  }

  // http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
  makeId() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  addClass(element, classname) {
    if (!element) return;
    if (this.hasClass(element, classname)) return;
    if (element.classList.length === 0) element.className = classname;else element.className = element.className + ' ' + classname;
  }
  removeClass(element, classname) {
    if (!element) return;
    if (element.classList.length > 0) {
      element.className = element.className.replace(classname, '');
    }
  }
  hasClass(element, classname) {
    if (!element) return false;
    return element.classList ? element.classList.contains(classname) : new RegExp('\\b' + classname + '\\b').test(element.className);
  }
  addEventListener(parent, type, listener) {
    parent.addEventListener(type, listener);
  }
}

/*
- doesn't accept 3 digit hex
*/
class ColorPicker {
  constructor(opts = {}) {
    let defaults = {
      onPick: function () {},
      color: '',
      colors: ['#ff9f01', '#f57c00', '#e64918', '#d32f2f', '#5d4038', '#37474f', '#353535', '#fbc02c', '#b0b42a', '#689f39', '#c21f5b', '#7b21a2', '#522da8', '#616161', '#01b8c9', '#009688', '#388d3c', '#0388d0', '#1465c0', '#2f3f9e', '#9e9e9e'],
      renderOn: '',
      animateModal: false,
      elementToAnimate: '',
      stuffPlacement: '#_cbhtml',
      lang: []
    };
    this.opts = Object.assign(this, defaults, opts);
    this.id = makeid$1();
    let builderStuff = document.querySelector(this.opts.stuffPlacement);
    if (!builderStuff) {
      builderStuff = document.createElement('div');
      builderStuff.id = '_cbhtml';
      builderStuff.className = 'is-ui';
      document.body.appendChild(builderStuff);
    }
    this.builderStuff = builderStuff;

    // Stuff placement for this (single) instance
    const objStuff = document.createElement('div');
    objStuff.id = this.id;
    builderStuff.appendChild(objStuff);
    this.objStuff = objStuff;
    const modal = new Modal({
      animateModal: this.opts.animateModal,
      elementToAnimate: this.opts.elementToAnimate,
      stuffPlacement: this.opts.stuffPlacement
    });
    this.modal = modal;
    let html_colors = '';
    if (this.opts.colors.length > 0) {
      html_colors += '<div class="color-default">';
      for (var i = 0; i < this.opts.colors.length; i++) {
        if (this.opts.colors[i] === '#ffffff') {
          html_colors += '<button title="' + this.opts.colors[i] + '" data-color="' + this.opts.colors[i] + '" style="background:' + this.opts.colors[i] + ';outline:rgba(222,222,222,0.75) 1px solid"></button>';
        } else {
          html_colors += '<button title="' + this.opts.colors[i] + '" data-color="' + this.opts.colors[i] + '" style="background:' + this.opts.colors[i] + ';"></button>';
        }
      }
      html_colors += '</div>';
    }
    let html_opacbg = '';
    for (i = 0; i < 105; i++) {
      if (i % 2 === 0) {
        html_opacbg += '<div class="dot-1"></div>';
      } else {
        html_opacbg += '<div class="dot-2"></div>';
      }
    }
    let html_previewbg = '';
    for (i = 0; i < 25; i++) {
      if (i % 2 === 0) {
        html_previewbg += '<div class="dot-3"></div>';
      } else {
        html_previewbg += '<div class="dot-4"></div>';
      }
    }
    let html = `<div class="pickcolor" style="width:269px;padding:12px;box-sizing:border-box;">
            ${html_colors}
            <div class="color-gradient"></div>

            <div class="div-color-opacity" style="height: 10px; margin: 12px 0px 17px;position:relative;">
                <div style="position:absolute;top:0;left:0;width:100%;height:21px;display:flex;flex-direction:column;flex-flow:wrap">
                    ${html_opacbg}
                </div>
                <input type="range" min="0" max="100" value="100" class="color-opacity is-rangeslider" style="position:relative;background: transparent;margin: 0 !important;">
            </div>
            <div style="display:flex;margin:25px 0 3px;">
                <button title="${this.out('B')}" data-color="#000000" style="background:#111;color:#f3f3f3;border:transparent 1px solid;width:35px;height:35px;line-height:35px;font-size:10px;border-right:none;">${this.out('B')}</button>
                <button title="${this.out('W')}" data-color="#ffffff" style="border: rgb(0 0 0 / 6%) 1px solid;background:#fff;color:#111;width:35px;height:35px;line-height:35px;font-size:10px;">${this.out('W')}</button>
                <button title="${this.out('Clear')}" data-color="" class="clear" style="width:140px;height:35px;line-height:35px;border-right:none;">${this.out('Clear')}</button>
                <button title="${this.out('More')}" class="input-hsl" style="width:35px;height:35px;line-height:35px;font-size:10px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>
            </div>
            <div style="display:flex">
                <div style="flex-grow: 0;flex-shrink: 0;flex-basis: 37px;height:34px;box-sizing:border-box;margin-top:8px;position:relative;">
                    <div style="position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;flex-flow:wrap;overflow:hidden;">
                        ${html_previewbg}
                    </div>
                    <button class="is-color-preview" tabindex="0" style="outline:none;cursor:default;position:absolute;top:0;left:0;width:100%;height:100%;transition:none;"></button>
                </div>
                <input class="input-text" id="{id}" type="text" style="width:209px;height:35px;margin-top:8px;font-size:13px;"/>
                <button title="${this.out('Apply')}" class="input-ok" style="height:35px;margin-top:8px;"><svg class="is-icon-flex"><use xlink:href="#icon-ok"></use></svg></use></svg></svg></button>
            </div>
        </div>`;
    let html_modal = `<div class="is-modal pickcolor" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content">
                <div class="is-modal-bar is-draggable"></div>
                <div>

                    ${html_colors}
                    <div class="color-gradient"></div>
        
                    <div class="div-color-opacity" style="height: 10px; margin: 12px 0px 17px;position:relative;">
                        <div style="position:absolute;top:0;left:0;width:100%;height:21px;display:flex;flex-direction:column;flex-flow:wrap">
                            ${html_opacbg}
                        </div>
                        <input type="range" min="0" max="100" value="100" class="color-opacity is-rangeslider" style="position:relative;background: transparent;margin: 0 !important;">
                    </div>
                    <div style="display:flex;margin:25px 0 3px;">
                        <button title="${this.out('B')}" data-color="#000000" style="background:#111;color:#f3f3f3;border:transparent 1px solid;width:35px;height:35px;line-height:35px;font-size:10px;border-right:none;">${this.out('B')}</button>
                        <button title="${this.out('W')}" data-color="#ffffff" style="background:#fff;color:#111;width:35px;height:35px;line-height:35px;font-size:10px;">${this.out('W')}</button>
                        <button title="${this.out('Clear')}" data-color="" class="clear" style="width:140px;height:35px;line-height:35px;border-right:none;">${this.out('Clear')}</button>
                        <button title="${this.out('More')}" class="input-hsl" style="width:35px;height:35px;line-height:35px;font-size:10px;"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>
                    </div>
                    <div style="display:flex">
                        <div style="flex-grow: 0;flex-shrink: 0;flex-basis: 37px;height:35px;box-sizing:border-box;margin-top:8px;position:relative;">
                            <div style="position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;flex-flow:wrap;overflow:hidden;">
                                ${html_previewbg}
                            </div>
                            <button class="is-color-preview" tabindex="0" style="outline:none;cursor:default;position:absolute;top:0;left:0;width:100%;height:100%;transition:none;"></button>
                        </div>
                        <input class="input-text" id="{id}" type="text" style="width:209px;height:35px;margin-top:8px;font-size:13px;"/>
                        <button title="${this.out('Apply')}" class="input-ok" style="height:35px;margin-top:8px;"><svg class="is-icon-flex"><use xlink:href="#icon-ok"></use></svg></use></svg></svg></button>
                    </div>
                    
                </div>
            </div>
        </div>`;
    let html_more = `<div class="is-modal pickcolormore" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="padding: 12px">
                <div class="is-modal-bar is-draggable"></div>
                <div>
                    
                    <div class="color-swatch"></div>
                    
                    <div class="div-color-hue" style="height: 23px;margin: 10px 0 0;position:relative">
                        <input type="range" min="0" max="360" value="0" class="color-hue is-rangeslider" style="position:relative;background:transparent;margin:0 !important;z-index:1">
                    </div>

                </div>
            </div>
        </div>`;
    let pickcolor;
    if (this.opts.renderOn !== '') {
      pickcolor = document.querySelector(this.opts.renderOn);
      pickcolor.insertAdjacentHTML('beforeend', html.replace(/{id}/g, this.makeId()));
    } else {
      objStuff.insertAdjacentHTML('beforeend', html_modal.replace(/{id}/g, this.makeId()));
      pickcolor = objStuff.querySelector('.is-modal.pickcolor');
    }
    objStuff.insertAdjacentHTML('beforeend', html_more);
    const pickcolormore = objStuff.querySelector('.is-modal.pickcolormore');
    this.pickcolor = pickcolor;
    this.pickcolormore = pickcolormore;
    const setupTabKeys = div => {
      let inputs = div.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), *[tabindex]');
      if (inputs.length === 0) return;
      let firstInput = inputs[0];
      let lastInput = inputs[inputs.length - 1];
      // firstInput.focus();

      // console.log(lastInput)
      // console.log(firstInput)

      // Redirect last tab to first input
      lastInput.addEventListener('keydown', e => {
        if (e.which === 9 && !e.shiftKey) {
          e.preventDefault();
          firstInput.focus();
        }
      });

      // Redirect first shift+tab to last input
      firstInput.addEventListener('keydown', e => {
        if (e.which === 9 && e.shiftKey) {
          e.preventDefault();
          lastInput.focus();
        }
      });
    };
    setupTabKeys(pickcolor);
    new Draggable$2({
      selector: '#' + this.id + ' .is-draggable'
    });
    let tmp = document.createElement('div');
    tmp.style.backgroundColor = this.opts.color; //hex will be converted to rgb
    let s = tmp.style.backgroundColor; //rgb

    let rgb;
    if (s !== '') {
      rgb = RGBvalues.color(s);
      this.baseRGB = rgb;
    }
    let colorswatch = pickcolormore.querySelector('.color-swatch');
    let colorgradient = pickcolor.querySelector('.color-gradient');
    if (rgb) {
      let hueValue;
      if (s !== '') {
        hueValue = rgbToHue(rgb.r, rgb.g, rgb.b);
      } else {
        hueValue = 0;
      }
      hslSwatch(colorswatch, hueValue);
      let hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      colorSwatch(colorgradient, hueValue, hsl[1]);
    } else {
      let hueValue;
      hueValue = 0;
      hslSwatch(colorswatch, hueValue);
      let hsl = rgbToHsl(255, 255, 255);
      colorSwatch(colorgradient, hueValue, hsl[1]);
    }
    setupTabKeys(pickcolormore);
    let elm = pickcolor.querySelector('.input-hsl');
    this.addEventListener(elm, 'click', () => {
      this.openMore();
    });
    var colorHue = pickcolormore.querySelector('.color-hue');
    colorHue.oninput = () => {
      let value = colorHue.value / 360;
      let hue = value * 361;
      hslSwatch(colorswatch, hue);
    };
    let hueswatch = document.createElement('div');

    //hueswatch.style = 'display:flex;position:absolute;top:0;left:0;'; //not working in IE11
    hueswatch.style.display = 'flex';
    hueswatch.style.position = 'absolute';
    hueswatch.style.width = 'calc(100% + 1px)';
    hueswatch.style.top = 0;
    hueswatch.style.left = 0;
    let hslacolors = generateHslaColors(45, 100, 1.0, 360);
    for (i = 0; i < hslacolors.length - 1; i++) {
      let item = document.createElement('div');
      item.style.backgroundColor = hslacolors[i];
      item.style.width = '1px';
      item.style.height = '24px';
      hueswatch.appendChild(item);
    }
    pickcolormore.querySelector('.div-color-hue').appendChild(hueswatch);
    const colorOpacity = pickcolor.querySelector('.color-opacity');
    // colorOpacity.onfocus = () => {
    // };
    colorOpacity.oninput = () => {
      let value = colorOpacity.value / 100;
      let rgb = this.baseRGB;
      if (rgb) {
        let val;
        if (value === 1) {
          val = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
        } else {
          val = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + value + ')';
        }
        let inputPreview = pickcolor.querySelector('.is-color-preview');
        inputPreview.style.backgroundColor = val;
        let inputColor = pickcolor.querySelector('.input-text');
        inputColor.value = val;

        // Out
        this.opts.onPick(val);
        colorOpacity.focus();
      }
    };
    // colorOpacity.onchange = () => {
    //     let val = colorOpacity.value;
    // };

    if (rgb) if (rgb.a) {
      colorOpacity.value = rgb.a * 100;
    } else {
      colorOpacity.value = 1 * 100;
    }
    // colorOpacitySlider._update();

    // Preview
    let transp = colorOpacity.value / 100;
    let val = '';
    let bgImage = '';
    if (rgb) {
      if (transp * 1 === 1) {
        val = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
      } else {
        val = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + transp + ')';
      }
      bgImage = 'linear-gradient(90deg, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0), rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',1))';
    }
    pickcolor.querySelector('.div-color-opacity .color-opacity').style.backgroundImage = bgImage;

    //initial preview
    let inputPreview = pickcolor.querySelector('.is-color-preview');
    inputPreview.style.background = 'none';
    if (val !== '') inputPreview.style.backgroundColor = val;
    let inputColor = pickcolor.querySelector('.input-text');
    inputColor.value = val;

    // let userAgentString = navigator.userAgent; 
    // let firefoxAgent = userAgentString.indexOf('Firefox') > -1; 
    // if(!firefoxAgent) {
    //     this.addEventListener(inputColor, 'keydown', (e) => {
    //         if (e.which === 13 || e.keyCode === 13 || e.key === 'Enter') {
    //             this.setColor(e.target.value);
    //             e.preventDefault();
    //             e.stopImmediatePropagation();
    //         }
    //     });
    // }
    this.addEventListener(inputColor, 'keydown', e => {
      if (e.which === 13 || e.keyCode === 13 || e.key === 'Enter') {
        this.setColor(e.target.value);
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    });
    let inputOk = pickcolor.querySelector('.input-ok');
    this.addEventListener(inputOk, 'click', () => {
      this.setColor(inputColor.value);
    });
    let elms = pickcolor.querySelectorAll('[data-color]');
    Array.prototype.forEach.call(elms, elm => {
      this.addEventListener(elm, 'click', e => {
        let elm = e.target;
        let base = elm.getAttribute('data-color');
        let rgb = hexToRgb(base);
        this.baseRGB = rgb;
        if (!this.parentsHasClass(elm, 'color-gradient') && base !== '') {
          if (rgb.r === rgb.g && rgb.g === rgb.b) {
            graySwatch(colorgradient);
          } else {
            let hue = rgbToHue(rgb.r, rgb.g, rgb.b);
            hslSwatch(colorswatch, hue);
            let colorgradient = pickcolor.querySelector('.color-gradient');
            let hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            colorSwatch(colorgradient, hue, hsl[1]);
          }
        }

        // Preview
        let transp = colorOpacity.value / 100;
        let val = '';
        let bgImage = '';
        if (rgb) {
          if (transp * 1 === 1) {
            val = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
          } else {
            val = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + transp + ')';
          }
          bgImage = 'linear-gradient(90deg, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0), rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',1))';
        }
        pickcolor.querySelector('.div-color-opacity .color-opacity').style.backgroundImage = bgImage;
        let inputPreview = pickcolor.querySelector('.is-color-preview');
        inputPreview.style.backgroundColor = val;
        let inputColor = pickcolor.querySelector('.input-text');
        inputColor.value = val;

        // Out
        this.opts.onPick(val);
        elm.focus();
      });
    });
    elms = pickcolormore.querySelectorAll('[data-color]');
    Array.prototype.forEach.call(elms, elm => {
      this.addEventListener(elm, 'click', () => {
        let base = elm.getAttribute('data-color');
        let rgb = hexToRgb(base);
        this.baseRGB = rgb;
        let hue = rgbToHue(rgb.r, rgb.g, rgb.b);
        let hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        colorSwatch(colorgradient, hue, hsl[1]);

        // Preview
        let transp = colorOpacity.value / 100;
        let val = '';
        let bgImage = '';
        if (rgb) {
          if (transp * 1 === 1) {
            val = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
          } else {
            val = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + transp + ')';
          }
          bgImage = 'linear-gradient(90deg, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0), rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',1))';
        }
        pickcolor.querySelector('.div-color-opacity .color-opacity').style.backgroundImage = bgImage;
        let inputPreview = pickcolor.querySelector('.is-color-preview');
        inputPreview.style.backgroundColor = val;
        let inputColor = pickcolor.querySelector('.input-text');
        inputColor.value = val;

        // Out
        this.opts.onPick(val);
        elm.focus();
      });
    });
  } //constructor

  makeId() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  out(s) {
    if (this.opts.lang) {
      let val = this.opts.lang[s];
      if (val) return val;else {
        return s;
      }
    } else {
      return s;
    }
  }
  openMore() {
    const handleKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key
        this.pickcolormore.classList.remove('active'); // hide

        this.pickcolormore.removeEventListener('keydown', handleKeyDown);
        let btnHsl = this.pickcolor.querySelector('.input-hsl');
        btnHsl.focus();
      }
    };
    this.modal.show(this.pickcolormore, false, () => {
      // this.pickcolormore.classList.remove('active'); // hide => not needed

      this.pickcolormore.removeEventListener('keydown', handleKeyDown);
      // if(cancelCallback) cancelCallback(); => Doesn't work! Because it is passed into this.modal object.

      let btnHsl = this.pickcolor.querySelector('.input-hsl');
      btnHsl.focus();
    }, false);
    this.pickcolormore.addEventListener('keydown', handleKeyDown);
    let input = this.pickcolormore.querySelector('input');
    input.focus();
  }
  open(onPick, color, cancelCallback) {
    if (onPick) {
      this.opts.onPick = onPick;
    }
    if (color) {
      this.opts.color = color;
      this.setColor(color, true);
    } else {
      let inputColor = this.pickcolor.querySelector('.input-text');
      inputColor.value = '';
    }
    const handleKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key
        this.pickcolor.classList.remove('active'); // hide

        this.pickcolor.removeEventListener('keydown', handleKeyDown);
        if (cancelCallback) cancelCallback();
      }
    };
    this.cancel = cancelCallback;
    this.modal.show(this.pickcolor, false, () => {
      // this.pickcolor.classList.remove('active'); // hide => not needed

      this.pickcolor.removeEventListener('keydown', handleKeyDown);
      // if(cancelCallback) cancelCallback(); => Doesn't work! Because it is passed into this.modal object.
      if (this.cancel) this.cancel();
    }, false);
    this.pickcolor.addEventListener('keydown', handleKeyDown);
    let inputColor = this.pickcolor.querySelector('.input-text');
    inputColor.focus();
  }
  isColorName(color) {
    const colorNamePattern = /^([a-z]+)$/i;
    return colorNamePattern.test(color);
  }
  convertColorToRGB(colorName) {
    const tempElement = document.createElement('div');
    tempElement.style.color = colorName;
    document.body.appendChild(tempElement);
    const computedColor = window.getComputedStyle(tempElement).color;
    document.body.removeChild(tempElement);

    // Extract RGB values from the computed color
    const rgbValues = computedColor.match(/\d+/g);
    return `rgb(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]})`;
  }
  setColor(color, noCallback) {
    let pickcolor = this.pickcolor;
    let pickcolormore = this.pickcolormore;
    let colorOpacity = pickcolor.querySelector('.color-opacity');
    let colorgradient = pickcolor.querySelector('.color-gradient');
    const isColorName = this.isColorName(color);
    if (isColorName) {
      color = this.convertColorToRGB(color);
    }
    let base = color;
    let rgb;
    if (base.indexOf('rgb') !== -1) {
      //rgb
      rgb = RGBvalues.color(base);
    }
    if (base.indexOf('#') !== -1) {
      //hex
      rgb = hexToRgb(base);
    }
    if (!rgb) {
      graySwatch(colorgradient);
      colorOpacity.value = 1 * 100;
      // this.colorOpacitySlider._update();
      pickcolor.querySelector('.div-color-opacity .color-opacity').style.backgroundImage = '';
      let inputPreview = pickcolor.querySelector('.is-color-preview');
      inputPreview.style.background = 'none';
      let inputColor = pickcolor.querySelector('.input-text');
      inputColor.value = '';
      return;
    }
    this.baseRGB = rgb;
    if (rgb.r === rgb.g && rgb.g === rgb.b) {
      graySwatch(colorgradient);
    } else {
      let colorswatch = pickcolormore.querySelector('.color-swatch');
      let hue = rgbToHue(rgb.r, rgb.g, rgb.b);
      hslSwatch(colorswatch, hue);
      let hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      colorSwatch(colorgradient, hue, hsl[1]);
    }
    if (rgb.a || rgb.a === 0) {
      colorOpacity.value = rgb.a * 100;
    } else {
      colorOpacity.value = 1 * 100;
    }
    // this.colorOpacitySlider._update();

    // Preview
    let transp = colorOpacity.value / 100;
    let val = '';
    let bgImage = '';
    if (rgb) {
      if (transp * 1 === 1) {
        val = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
      } else {
        val = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + transp + ')';
      }
      bgImage = 'linear-gradient(90deg, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0), rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',1))';
    }
    pickcolor.querySelector('.div-color-opacity .color-opacity').style.backgroundImage = bgImage;
    let inputPreview = pickcolor.querySelector('.is-color-preview');
    inputPreview.style.backgroundColor = val;
    let inputColor = pickcolor.querySelector('.input-text');
    inputColor.value = val;

    // Out
    if (!noCallback) this.opts.onPick(val);
  }
  addEventListener(parent, type, listener) {
    parent.addEventListener(type, listener);
  }
  parentsHasClass(element, classname) {
    while (element) {
      if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
      if (!element.classList) return false;
      if (element.classList.contains(classname)) {
        return true;
      }
      element = element.parentNode;
    }
  }
}

// source: http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
function makeid$1() {
  let text = '';
  let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
  let text2 = '';
  let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
  return text + text2;
}

// source: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
function hexToRgb(hex) {
  if (hex === '') return null;
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

// https://stackoverflow.com/questions/3080421/javascript-color-gradient
function hex(c) {
  var s = '0123456789abcdef';
  var i = parseInt(c);
  if (i === 0 || isNaN(c)) return '00';
  i = Math.round(Math.min(Math.max(0, i), 255));
  return s.charAt((i - i % 16) / 16) + s.charAt(i % 16);
}
function rgbToHex(rgb) {
  return hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
}
function generateHslaColors(saturation, lightness, alpha, amount) {
  let colors = [];
  let huedelta = Math.trunc(360 / amount);
  for (let i = 0; i < amount; i++) {
    let hue = i * huedelta;
    colors.push(`hsla(${hue},${lightness}%,${saturation}%,${alpha})`);
  }
  return colors;
}

// https://css-tricks.com/hsl-hsla-is-great-for-programmatic-color-control/
// https://codepen.io/chriscoyier/pen/YvPLRg
function hslSwatch(elm, hue) {
  let x, y;
  let len = 10;
  let step = 2 * (100 / len) - 100 / len;
  let adj = step / 2;
  if (elm.innerHTML === '') {
    for (x = 0; x < len; ++x) {
      let tr = document.createElement('div');
      tr.style.width = '100%';
      // tr.id = 'row-' + x;
      tr.classList.add('row-' + x);
      elm.appendChild(tr);
      for (y = 0; y < len; ++y) {
        let sat = x * (100 / (len - 1)) + adj;
        let light = y * (100 / len) + adj;

        //Rounded values
        if (light > 50 && light <= 55) light = 50;
        if (sat > 100) sat = 100;
        //if(x===0)sat=0;

        let rgb = hslToRgb(hue, sat, light);
        let hex = '#' + rgbToHex(rgb);
        let td = document.createElement('button');
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);

        // let row = elm.querySelector('#row-' + x);
        let row = elm.querySelector('.row-' + x);
        row.appendChild(td);
      }
    }
  } else {
    for (x = 0; x < len; ++x) {
      let tr = elm.childNodes[x];
      for (y = 0; y < len; ++y) {
        let td = tr.childNodes[y];
        let sat = x * (100 / (len - 1)) + adj; //adj makes 0 (dark) to 9 become 0.x (not too dark) to 9.x (close to 10 / white)
        let light = y * (100 / len) + adj;

        //Rounded values
        if (light > 50 && light <= 55) light = 50;
        if (sat > 100) sat = 100;
        //if(x===0)sat=0;

        let rgb = hslToRgb(hue, sat, light);
        let hex = '#' + rgbToHex(rgb);
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);
      }
    }
  }
}
function colorSwatch(elm, hue, sat) {
  let x, y;
  let rownum = 5;
  let colnum = 7;
  let step = 2 * (100 / colnum) - 100 / colnum;
  //let adj = step/2;

  if (elm.innerHTML === '') {
    for (x = 0; x < rownum; ++x) {
      let tr = document.createElement('div');
      tr.style.width = '100%';
      // tr.id = 'row-' + x;
      tr.classList.add('row-' + x);
      elm.appendChild(tr);
      for (y = 0; y < colnum; ++y) {
        let z = (x - rownum) * -1 - 1; //convert 0 to 11 become 11 to 0

        let light = y * (100 / colnum);
        light = light + z * (step / rownum);

        //Rounded values
        if (y === 0) light = y * (100 / colnum);
        let rgb = hslToRgb(hue, sat, light);
        let hex = '#' + rgbToHex(rgb);
        let td = document.createElement('button');
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);

        // let row = elm.querySelector('#row-' + x);
        let row = elm.querySelector('.row-' + x);
        row.appendChild(td);
      }
    }
  } else {
    let tr, td;
    for (x = 0; x < rownum; ++x) {
      tr = elm.childNodes[x];
      for (y = 0; y < colnum; ++y) {
        td = tr.childNodes[y];
        let z = (x - rownum) * -1 - 1; //convert 0 to 11 become 11 to 0

        let light = y * (100 / colnum);
        light = light + z * (step / rownum);

        //Rounded values
        if (x === colnum - 1 && y === 0) {
          light = 0;
        }
        let rgb = hslToRgb(hue, sat, light);
        let hex = '#' + rgbToHex(rgb);
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);
      }
    }
  }
}
function graySwatch(elm) {
  let x, y;
  let rownum = 5;
  let colnum = 7;
  let step = 2 * (100 / colnum) - 100 / colnum;
  if (elm.innerHTML === '') {
    for (x = 0; x < rownum; ++x) {
      let tr = document.createElement('div');
      tr.style.width = '100%';
      // tr.id = 'row-' + x;
      tr.classList.add('row-' + x);
      elm.appendChild(tr);
      for (y = 0; y < colnum; ++y) {
        let z = (x - rownum) * -1 - 1; //convert 0 to 11 become 11 to 0

        let light = y * (100 / colnum);
        light = light + z * (step / rownum);
        if (y === 0) light = y * (100 / colnum);
        let rgb = hslToRgb(0, 0, light);
        let hex = '#' + rgbToHex(rgb);
        let td = document.createElement('div');
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);

        // let row = elm.querySelector('#row-' + x);
        let row = elm.querySelector('.row-' + x);
        row.appendChild(td);
      }
    }
  } else {
    let tr, td;
    for (x = 0; x < rownum; ++x) {
      tr = elm.childNodes[x];
      for (y = 0; y < colnum; ++y) {
        td = tr.childNodes[y];
        let z = (x - rownum) * -1 - 1; //convert 0 to 11 become 11 to 0

        let light = y * (100 / colnum);
        light = light + z * (step / rownum);
        if (x === colnum - 1 && y === 0) {
          light = 0;
        }
        let rgb = hslToRgb(0, 0, light);
        let hex = '#' + rgbToHex(rgb);
        td.title = hex;
        td.style.background = hex;
        td.setAttribute('data-color', hex);
      }
    }
  }
}
function hueToRgb(m1, m2, h) {
  if (h < 0) h = h + 1;else if (h > 1) h = h - 1;
  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;else if (h * 2 < 1) return m2;else if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;else return m1;
}
function hslToRgb(h, s, l) {
  h /= 360;
  s /= 100;
  l /= 100;
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
    m1 = l * 2 - m2,
    r = parseInt(hueToRgb(m1, m2, h + 1 / 3) * 255),
    g = parseInt(hueToRgb(m1, m2, h) * 255),
    b = parseInt(hueToRgb(m1, m2, h - 1 / 3) * 255);
  return [r, g, b];
}

// https://stackoverflow.com/questions/39118528/rgb-to-hsl-conversion
function rgbToHue(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var c = max - min;
  var hue;
  var segment;
  var shift;
  if (c === 0) {
    hue = 0;
  } else {
    switch (max) {
      case r:
        segment = (g - b) / c;
        shift = 0 / 60; // R / (360 / hex sides)
        if (segment < 0) {
          // hue > 180, full rotation
          shift = 360 / 60; // R / (360 / hex sides)
        }

        hue = segment + shift;
        break;
      case g:
        segment = (b - r) / c;
        shift = 120 / 60; // G / (360 / hex sides)
        hue = segment + shift;
        break;
      case b:
        segment = (r - g) / c;
        shift = 240 / 60; // B / (360 / hex sides)
        hue = segment + shift;
        break;
    }
  }
  return hue * 60; // hue is in [0,6], scale it up
}

// https://stackoverflow.com/questions/10970958/get-a-color-component-from-an-rgb-string-in-javascript
var RGBvalues = function () {
  var _hex2dec = function (v) {
    return parseInt(v, 16);
  };
  var _splitHEX = function (hex) {
    var c;
    if (hex.length === 4) {
      c = hex.replace('#', '').split('');
      return {
        r: _hex2dec(c[0] + c[0]),
        g: _hex2dec(c[1] + c[1]),
        b: _hex2dec(c[2] + c[2])
      };
    } else {
      return {
        r: _hex2dec(hex.slice(1, 3)),
        g: _hex2dec(hex.slice(3, 5)),
        b: _hex2dec(hex.slice(5))
      };
    }
  };
  var _splitRGB = function (rgb) {
    var c = rgb.slice(rgb.indexOf('(') + 1, rgb.indexOf(')')).split(',');
    var flag = false,
      obj;
    c = c.map(function (n, i) {
      // return (i !== 3) ? parseInt(n, 10) : flag = true, parseFloat(n);
      if (i !== 3) {
        return parseInt(n, 10);
      } else {
        flag = true;
        return parseFloat(n);
      }
    });
    obj = {
      r: c[0],
      g: c[1],
      b: c[2]
    };
    if (flag) obj.a = c[3];
    return obj;
  };
  var color = function (col) {
    var slc = col.slice(0, 1);
    if (slc === '#') {
      return _splitHEX(col);
    } else if (slc.toLowerCase() === 'r') {
      return _splitRGB(col);
    } else {
      console.log('!Ooops! RGBvalues.color(' + col + ') : HEX, RGB, or RGBa strings only');
    }
  };
  return {
    color: color
  };
}();

// https://codepen.io/pankajparashar/pen/oFzIg
function rgbToHsl(r, g, b) {
  //r /= 255, g /= 255, b /= 255;
  r = r / 255;
  g = g / 255;
  b = b / 255;
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h * 100 + 0.5 | 0, s * 100 + 0.5 | 0, l * 100 + 0.5 | 0];
}

class GradientPicker {
  constructor(opts = {}) {
    let defaults = {
      colors: ['#ff9f01', '#f57c00', '#e64918', '#d32f2f', '#5d4038', '#37474f', '#353535', '#fbc02c', '#b0b42a', '#689f39', '#c21f5b', '#7b21a2', '#522da8', '#616161', '#01b8c9', '#009688', '#388d3c', '#0388d0', '#1465c0', '#2f3f9e', '#9e9e9e'],
      gradientcolors: [['linear-gradient(0deg, rgb(255, 57, 25), rgb(249, 168, 37))'], ['linear-gradient(0deg, rgb(255, 57, 25), rgb(255, 104, 15))'], ['linear-gradient(0deg, #FF5722, #FF9800)'], ['linear-gradient(0deg, #613ca2, rgb(110, 123, 217))'], ['linear-gradient(0deg, rgb(65, 70, 206), rgb(236, 78, 130))'], ['linear-gradient(0deg, rgb(0, 150, 102), rgb(90, 103, 197))'], ['linear-gradient(30deg, rgb(249, 119, 148), rgb(98, 58, 162))'], ['linear-gradient(0deg, rgb(223, 70, 137), rgb(90, 103, 197))'], ['linear-gradient(0deg, rgb(40, 53, 147), rgb(90, 103, 197))'], ['linear-gradient(0deg, rgb(21, 101, 192), rgb(52, 169, 239))'], ['linear-gradient(0deg, rgb(32, 149, 219), rgb(139, 109, 230))'], ['linear-gradient(0deg, rgb(90, 103, 197), rgb(0, 184, 201))'], ['linear-gradient(0deg, rgb(0, 184, 201), rgb(253, 187, 45))'], ['linear-gradient(0deg, rgb(255, 208, 100), rgb(239, 98, 159))'], ['linear-gradient(0deg, rgb(0, 214, 223), rgb(130, 162, 253))'], ['linear-gradient(0deg, rgb(50, 234, 251), rgb(248, 247, 126))'], ['linear-gradient(0deg, rgb(141, 221, 255), rgb(255, 227, 255))'], ['linear-gradient(0deg, rgb(255, 170, 170), rgb(255, 255, 200))'], ['linear-gradient(0deg, rgb(239, 239, 239), rgb(252, 252, 252))']],
      animateModal: false,
      elementToAnimate: '',
      stuffPlacement: '#_cbhtml',
      lang: []
    };
    this.opts = Object.assign(this, defaults, opts);
    this.id = makeid();
    let builderStuff = document.querySelector(this.opts.stuffPlacement);
    if (!builderStuff) {
      builderStuff = document.createElement('div');
      builderStuff.id = '_cbhtml';
      builderStuff.className = 'is-ui';
      document.body.appendChild(builderStuff);
    }
    this.builderStuff = builderStuff;

    // Stuff placement for this (single) instance
    const objStuff = document.createElement('div');
    objStuff.id = this.id;
    builderStuff.appendChild(objStuff);
    this.objStuff = objStuff;
    const modal = new Modal({
      animateModal: this.opts.animateModal,
      elementToAnimate: this.opts.elementToAnimate,
      stuffPlacement: this.opts.stuffPlacement
    });
    this.modal = modal;
    let html_gradcolors = '';
    for (var i = 0; i < this.opts.gradientcolors.length; i++) {
      html_gradcolors += `<button data-elmgradient="${this.opts.gradientcolors[i][0]}" data-textcolor="${this.opts.gradientcolors[i][1] ? this.opts.gradientcolors[i][1] : ''}" style="background-image:${this.opts.gradientcolors[i][0]};"></button>`;
    }
    let html = `
            <div class="is-modal pickgradientcolor" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <div class="is-modal-bar is-draggable"></div>
                    <div style="padding:12px 12px 12px">
                        <div class="div-gradients" style="display: flex;flex-flow: wrap;margin-bottom:10px;">
                            ${html_gradcolors}
                            <button class="input-gradient-clear" title="${this.out('Clear')}" data-value="" style="width:35px;height:35px;"><svg class="is-icon-flex" style="width:23px;height:23px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                        </div>
                        <div class="is-settings" style="margin-bottom:0">
                            <div class="is-label" style="margin-top:0">${this.out('Custom')}:</div>
                            <div class="div-custom-gradients" style="height:auto;display: flex;flex-flow: wrap;"></div>
                            <div>
                                <button title="${this.out('Select Color')}" class="input-gradient-color1 is-btn-color" data-value="dark" style="border-right:none"></button>
                                <button title="${this.out('Select Color')}" class="input-gradient-color2 is-btn-color" data-value="dark"></button>
                                <input type="text" class="input-gradient-deg" id="{id}" value="0" style="width:60px;height:35px;margin-left:7px;margin-right:5px;font-size:14px;"/> deg
                            </div>
                        </div>
                        <div class="is-settings" style="margin-bottom:0">
                            <button title="${this.out('Add')}" class="input-gradient-save classic" style="width:100%;border:none;"> ${this.out('Add')} </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    objStuff.insertAdjacentHTML('beforeend', html.replace(/{id}/g, this.makeId()));
    const pickGradient = objStuff.querySelector('.is-modal.pickgradientcolor');
    this.pickGradient = pickGradient;
    const setupTabKeys = div => {
      let inputs = div.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), *[tabindex]');
      if (inputs.length === 0) return;
      let firstInput = inputs[0];
      let lastInput = inputs[inputs.length - 1];
      // firstInput.focus();

      // console.log(lastInput)
      // console.log(firstInput)

      // Redirect last tab to first input
      lastInput.addEventListener('keydown', e => {
        if (e.which === 9 && !e.shiftKey) {
          e.preventDefault();
          firstInput.focus();
        }
      });

      // Redirect first shift+tab to last input
      firstInput.addEventListener('keydown', e => {
        if (e.which === 9 && e.shiftKey) {
          e.preventDefault();
          lastInput.focus();
        }
      });
    };
    setupTabKeys(pickGradient);
    new Draggable$2({
      selector: '#' + this.id + ' .is-draggable'
    });
    const colorPicker = new ColorPicker({
      colors: this.opts.colors,
      animateModal: this.opts.animateModal,
      elementToAnimate: this.opts.container,
      lang: this.opts.lang
    });
    let btnColor1 = objStuff.querySelector('.input-gradient-color1');
    btnColor1.addEventListener('click', () => {
      colorPicker.open(color => {
        if (color === '') color = 'transparent';

        // set element style
        let color1 = color;
        let color2 = objStuff.querySelector('.input-gradient-color2').style.backgroundColor;
        let deg = objStuff.querySelector('.input-gradient-deg').value;
        if (color2 === '') color2 = '#ffffff';
        let css = `linear-gradient(${deg}deg, ${color1}, ${color2})`;
        this.targetElement.style.backgroundImage = css;
        if (this.opts.onChange) this.opts.onChange(css);

        // update preview
        btnColor1.style.backgroundColor = color;
      }, btnColor1.style.backgroundColor, () => {
        btnColor1.removeAttribute('data-focus');
        btnColor1.focus();
      });
      btnColor1.setAttribute('data-focus', true);
    });
    let btnColor2 = objStuff.querySelector('.input-gradient-color2');
    btnColor2.addEventListener('click', () => {
      colorPicker.open(color => {
        if (color === '') color = 'transparent';

        // set element style
        let color1 = objStuff.querySelector('.input-gradient-color1').style.backgroundColor;
        let color2 = color;
        let deg = objStuff.querySelector('.input-gradient-deg').value;
        if (color1 === '') color1 = '#ffffff';
        let css = `linear-gradient(${deg}deg, ${color1}, ${color2})`;
        this.targetElement.style.backgroundImage = css;
        if (this.opts.onChange) this.opts.onChange(css);

        // update preview
        btnColor2.style.backgroundColor = color;
      }, btnColor2.style.backgroundColor, () => {
        btnColor2.removeAttribute('data-focus');
        btnColor2.focus();
      });
      btnColor2.setAttribute('data-focus', true);
    });

    // Apply default gradient
    let btns = objStuff.querySelectorAll('.div-gradients [data-elmgradient]');
    Array.prototype.forEach.call(btns, btn => {
      let grad = btn.getAttribute('data-elmgradient');
      let textcolor = btn.getAttribute('data-textcolor');
      btn.addEventListener('click', () => {
        this.targetElement.style.backgroundImage = grad;
        if (this.opts.onChange) this.opts.onChange(grad, textcolor);

        // Read gradient
        const s = this.targetElement.style.backgroundImage;
        if (s.indexOf('linear-gradient') !== -1) {
          const result = getGradient(s);
          if (result !== null) {
            try {
              let color1 = result.colorStopList[0].color;
              let color2 = result.colorStopList[1].color;
              let line = result.line;
              this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = color1;
              this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = color2;
              if (line.indexOf('deg') !== -1) {
                this.objStuff.querySelector('.input-gradient-deg').value = line.replace('deg', '');
              }
            } catch (e) {
              // Do Nothing
            }
          }
        }
        let btns = objStuff.querySelectorAll('.div-gradients [data-elmgradient]');
        Array.prototype.forEach.call(btns, btn => {
          this.removeClass(btn, 'active');
        });
        this.addClass(btn, 'active');
      });
    });
    let btnClear = objStuff.querySelector('.input-gradient-clear');
    btnClear.addEventListener('click', () => {
      this.targetElement.style.backgroundImage = '';
      if (this.opts.onChange) this.opts.onChange('');
      this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = '';
      this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = '';
      this.objStuff.querySelector('.input-gradient-deg').value = '0';
    });
    let inputDeg = objStuff.querySelector('.input-gradient-deg');
    inputDeg.addEventListener('keyup', () => {
      // set element style
      let color1 = objStuff.querySelector('.input-gradient-color1').style.backgroundColor;
      let color2 = objStuff.querySelector('.input-gradient-color2').style.backgroundColor;
      let deg = inputDeg.value;

      // if(color1 === '') color1 = '#ffffff';
      // if(color2 === '') color2 = '#ffffff';

      let css = `linear-gradient(${deg}deg, ${color1}, ${color2})`;
      this.targetElement.style.backgroundImage = css;
      if (this.opts.onChange) this.opts.onChange(css);
    });
    let btnSave = objStuff.querySelector('.input-gradient-save');
    btnSave.addEventListener('click', () => {
      let color1 = objStuff.querySelector('.input-gradient-color1').style.backgroundColor;
      let color2 = objStuff.querySelector('.input-gradient-color2').style.backgroundColor;
      let deg = inputDeg.value;

      // if(color1 === '') color1 = '#ffffff';
      // if(color2 === '') color2 = '#ffffff';

      let css = `linear-gradient(${deg}deg, ${color1}, ${color2})`;

      // Save
      let customgradcolors = [];
      if (localStorage.getItem('_customgradcolors') !== null) {
        customgradcolors = JSON.parse(localStorage.getItem('_customgradcolors'));
      }
      customgradcolors.push(css);
      localStorage.setItem('_customgradcolors', JSON.stringify(customgradcolors));

      // Render custom gradients
      if (localStorage.getItem('_customgradcolors') !== null) {
        let customgradcolors = JSON.parse(localStorage.getItem('_customgradcolors'));
        let html_gradcolors = '';
        for (var i = 0; i < customgradcolors.length; i++) {
          html_gradcolors += `<button class="is-elmgrad-item" data-elmgradient="${customgradcolors[i]}" style="background-image:${customgradcolors[i]};"><div class="is-elmgrad-remove"><svg class="is-icon-flex" style="fill:rgba(255, 255, 255, 1);width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></div></button>`;
        }
        this.objStuff.querySelector('.div-custom-gradients').innerHTML = html_gradcolors;
      }

      // Apply custom gradient
      let btns = this.objStuff.querySelectorAll('.div-custom-gradients [data-elmgradient]');
      Array.prototype.forEach.call(btns, btn => {
        let grad = btn.getAttribute('data-elmgradient');
        btn.addEventListener('click', () => {
          this.targetElement.style.backgroundImage = grad;
          if (this.opts.onChange) this.opts.onChange(grad);

          // Read gradient
          const s = this.targetElement.style.backgroundImage;
          if (s.indexOf('linear-gradient') !== -1) {
            const result = getGradient(s);
            if (result !== null) {
              try {
                let color1 = result.colorStopList[0].color;
                let color2 = result.colorStopList[1].color;
                let line = result.line;
                this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = color1;
                this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = color2;
                if (line.indexOf('deg') !== -1) {
                  this.objStuff.querySelector('.input-gradient-deg').value = line.replace('deg', '');
                }
              } catch (e) {
                // Do Nothing
              }
            }
          }
          let btns = objStuff.querySelectorAll('.div-custom-gradients [data-elmgradient]');
          Array.prototype.forEach.call(btns, btn => {
            this.removeClass(btn, 'active');
          });
          this.addClass(btn, 'active');
        });
      });

      // Delete custom gradient
      let btnsRemoveGrad = this.objStuff.querySelectorAll('.div-custom-gradients .is-elmgrad-remove');
      Array.prototype.forEach.call(btnsRemoveGrad, btnRemoveGrad => {
        btnRemoveGrad.addEventListener('click', () => {
          //Custom grad colors
          let customgradcolors = [];
          if (localStorage.getItem('_customgradcolors') !== null) {
            customgradcolors = JSON.parse(localStorage.getItem('_customgradcolors'));
          }
          var css = btnRemoveGrad.parentNode.getAttribute('data-elmgradient');
          for (var i = 0; i < customgradcolors.length; i++) {
            if (customgradcolors[i] === css) {
              customgradcolors.splice(i, 1);
            }
          }
          localStorage.setItem('_customgradcolors', JSON.stringify(customgradcolors));
          btnRemoveGrad.parentNode.parentNode.removeChild(btnRemoveGrad.parentNode);
          return false;
        });
      });
    });
  } //constructor

  makeId() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  out(s) {
    if (this.opts.lang) {
      let val = this.opts.lang[s];
      if (val) return val;else {
        return s;
      }
    } else {
      return s;
    }
  }
  open(elm, onChange, onFinish) {
    this.opts.onChange = onChange;
    this.opts.onFinish = onFinish;
    this.targetElement = elm;

    // Read gradient
    this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = '';
    this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = '';
    this.objStuff.querySelector('.input-gradient-deg').value = '0';
    const s = elm.style.backgroundImage;
    if (s.indexOf('linear-gradient') !== -1) {
      const result = getGradient(s);
      if (result !== null) {
        try {
          let color1 = result.colorStopList[0].color;
          let color2 = result.colorStopList[1].color;
          let line = result.line;
          this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = color1;
          this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = color2;
          if (line.indexOf('deg') !== -1) {
            this.objStuff.querySelector('.input-gradient-deg').value = line.replace('deg', '');
          }
        } catch (e) {
          // Do Nothing
        }
      }
    }

    // Save original style
    this.original = s;

    // Render custom gradients
    let customgradcolors = [];
    if (localStorage.getItem('_customgradcolors') !== null) {
      customgradcolors = JSON.parse(localStorage.getItem('_customgradcolors'));
      let html_gradcolors = '';
      for (var i = 0; i < customgradcolors.length; i++) {
        html_gradcolors += `<button class="is-elmgrad-item" data-elmgradient="${customgradcolors[i]}" style="background-image:${customgradcolors[i]};"><div class="is-elmgrad-remove"><svg class="is-icon-flex" style="fill:rgba(255, 255, 255, 1);width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></div></button>`;
      }
      this.objStuff.querySelector('.div-custom-gradients').innerHTML = html_gradcolors;
    }

    // Apply custom gradient
    let btns = this.objStuff.querySelectorAll('.div-custom-gradients [data-elmgradient]');
    Array.prototype.forEach.call(btns, btn => {
      let grad = btn.getAttribute('data-elmgradient');
      btn.addEventListener('click', () => {
        this.targetElement.style.backgroundImage = grad;
        if (this.opts.onChange) this.opts.onChange(grad);

        // Read gradient
        const s = this.targetElement.style.backgroundImage;
        if (s.indexOf('linear-gradient') !== -1) {
          const result = getGradient(s);
          if (result !== null) {
            try {
              let color1 = result.colorStopList[0].color;
              let color2 = result.colorStopList[1].color;
              let line = result.line;
              this.objStuff.querySelector('.input-gradient-color1').style.backgroundColor = color1;
              this.objStuff.querySelector('.input-gradient-color2').style.backgroundColor = color2;
              if (line.indexOf('deg') !== -1) {
                this.objStuff.querySelector('.input-gradient-deg').value = line.replace('deg', '');
              }
            } catch (e) {
              // Do Nothing
            }
          }
        }
        let btns = this.objStuff.querySelectorAll('.div-custom-gradients [data-elmgradient]');
        Array.prototype.forEach.call(btns, btn => {
          this.removeClass(btn, 'active');
        });
        this.addClass(btn, 'active');
      });
    });

    // Delete custom gradient
    let btnsRemoveGrad = this.objStuff.querySelectorAll('.div-custom-gradients .is-elmgrad-remove');
    Array.prototype.forEach.call(btnsRemoveGrad, btnRemoveGrad => {
      btnRemoveGrad.addEventListener('click', () => {
        //Custom grad colors
        let customgradcolors = [];
        if (localStorage.getItem('_customgradcolors') !== null) {
          customgradcolors = JSON.parse(localStorage.getItem('_customgradcolors'));
        }
        var css = btnRemoveGrad.parentNode.getAttribute('data-elmgradient');
        for (var i = 0; i < customgradcolors.length; i++) {
          if (customgradcolors[i] === css) {
            customgradcolors.splice(i, 1);
          }
        }
        localStorage.setItem('_customgradcolors', JSON.stringify(customgradcolors));
        btnRemoveGrad.parentNode.parentNode.removeChild(btnRemoveGrad.parentNode);
        return false;
      });
    });
    const handleKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key
        this.pickGradient.classList.remove('active'); // hide

        this.pickGradient.removeEventListener('keydown', handleKeyDown);

        // no change
        if (this.opts.onFinish) {
          this.opts.onFinish(false);
        }
      }
    };
    this.modal.show(this.pickGradient, false, () => {
      this.pickGradient.removeEventListener('keydown', handleKeyDown);
      if (this.original === this.targetElement.style.backgroundImage) {
        // no change
        if (this.opts.onFinish) {
          this.opts.onFinish(false);
        }
      } else {
        // changed
        if (this.opts.onFinish) {
          this.opts.onFinish(true);
        }
      }
    }, false);
    this.pickGradient.addEventListener('keydown', handleKeyDown);
    const btn = this.pickGradient.querySelector('button');
    btn.focus();
  }
  addClass(element, classname) {
    if (!element) return;
    if (this.hasClass(element, classname)) return;
    if (element.classList.length === 0) element.className = classname;else element.className = element.className + ' ' + classname;
    //else element.classList.add(classname); //error if there is -
  }

  removeClass(element, classname) {
    if (!element) return;
    if (element.classList.length > 0) {
      element.className = element.className.replace(classname, '');
    }
  }
  hasClass(element, classname) {
    if (!element) return false;
    return element.classList ? element.classList.contains(classname) : new RegExp('\\b' + classname + '\\b').test(element.className);
  }
}

// source: http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
function makeid() {
  let text = '';
  let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
  let text2 = '';
  let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
  return text + text2;
}

// source: https://stackoverflow.com/questions/20215440/parse-css-gradient-rule-with-javascript-regex 
function getGradient(input) {
  var result,
    regExpLib = generateRegExp(),
    //rGradientEnclosedInBrackets = /.*gradient\s*\(((?:\([^\)]*\)|[^\)\(]*)*)\)/,// Captures inside brackets - max one additional inner set.
    rGradientEnclosedInBrackets = /.*gradient\s*\(((?:\([^)]*\)|[^)(]*)*)\)/,
    // Oct 29, 2019
    match = rGradientEnclosedInBrackets.exec(input);
  if (match !== null) {
    // Get the parameters for the gradient
    result = parseGradient(regExpLib, match[1]);
    if (result.original.trim() !== match[1].trim()) {
      // Did not match the input exactly - possible parsing error.
      result.parseWarning = true;
    }
  } else {
    result = 'Failed to find gradient';
  }
  return result;
}
var combineRegExp = function (regexpList, flags) {
  var i,
    source = '';
  for (i = 0; i < regexpList.length; i++) {
    if (typeof regexpList[i] === 'string') {
      source += regexpList[i];
    } else {
      source += regexpList[i].source;
    }
  }
  return new RegExp(source, flags);
};
var generateRegExp = function () {
  // Note any variables with "Capture" in name include capturing bracket set(s).
  var searchFlags = 'gi',
    // ignore case for angles, "rgb" etc
    rAngle = /(?:[+-]?\d*\.?\d+)(?:deg|grad|rad|turn)/,
    // Angle +ive, -ive and angle types
    rSideCornerCapture = /to\s+((?:(?:left|right)(?:\s+(?:top|bottom))?))/,
    // optional 2nd part
    rComma = /\s*,\s*/,
    // Allow space around comma.
    //rColorHex = /\#(?:[a-f0-9]{6}|[a-f0-9]{3})/, // 3 or 6 character form
    rColorHex = /#(?:[a-f0-9]{6}|[a-f0-9]{3})/,
    // 3 or 6 character form // Oct 29, 2019
    rDigits3 = /\(\s*(?:\d{1,3}\s*,\s*){2}\d{1,3}\s*\)/,
    // "(1, 2, 3)"
    rDigits4 = /\(\s*(?:\d{1,3}\s*,\s*){2}\d{1,3}\s*,\s*\d*\.?\d+\)/,
    // "(1, 2, 3, 4)"
    rValue = /(?:[+-]?\d*\.?\d+)(?:%|[a-z]+)?/,
    // ".9", "-5px", "100%".
    rKeyword = /[_a-z-][_a-z0-9-]*/,
    // "red", "transparent", "border-collapse".
    rColor = combineRegExp(['(?:', rColorHex, '|', '(?:rgb|hsl)', rDigits3, '|', '(?:rgba|hsla)', rDigits4, '|', rKeyword, ')'], ''),
    rColorStop = combineRegExp([rColor, '(?:\\s+', rValue, '(?:\\s+', rValue, ')?)?'], ''),
    // Single Color Stop, optional %, optional length.
    rColorStopList = combineRegExp(['(?:', rColorStop, rComma, ')*', rColorStop], ''),
    // List of color stops min 1.
    rLineCapture = combineRegExp(['(?:(', rAngle, ')|', rSideCornerCapture, ')'], ''),
    // Angle or SideCorner
    rGradientSearch = combineRegExp(['(?:(', rLineCapture, ')', rComma, ')?(', rColorStopList, ')'], searchFlags),
    // Capture 1:"line", 2:"angle" (optional), 3:"side corner" (optional) and 4:"stop list".
    rColorStopSearch = combineRegExp(['\\s*(', rColor, ')', '(?:\\s+', '(', rValue, '))?', '(?:', rComma, '\\s*)?'], searchFlags); // Capture 1:"color" and 2:"position" (optional).

  return {
    gradientSearch: rGradientSearch,
    colorStopSearch: rColorStopSearch
  };
};
var parseGradient = function (regExpLib, input) {
  var result, matchGradient, matchColorStop, stopResult;

  // reset search position, because we reuse regex.
  regExpLib.gradientSearch.lastIndex = 0;
  matchGradient = regExpLib.gradientSearch.exec(input);
  if (matchGradient !== null) {
    result = {
      original: matchGradient[0],
      colorStopList: []
    };

    // // Line (Angle or Side-Corner).
    // if (!!matchGradient[1]) {
    //     result.line = matchGradient[1];
    // }
    // // Angle or undefined if side-corner.
    // if (!!matchGradient[2]) {
    //     result.angle = matchGradient[2];
    // }
    // // Side-corner or undefined if angle.
    // if (!!matchGradient[3]) {
    //     result.sideCorner = matchGradient[3];
    // }

    // Oct 29, 2019
    // Line (Angle or Side-Corner).
    if (matchGradient[1]) {
      result.line = matchGradient[1];
    }
    // Angle or undefined if side-corner.
    if (matchGradient[2]) {
      result.angle = matchGradient[2];
    }
    // Side-corner or undefined if angle.
    if (matchGradient[3]) {
      result.sideCorner = matchGradient[3];
    }

    // reset search position, because we reuse regex.
    regExpLib.colorStopSearch.lastIndex = 0;

    // Loop though all the color-stops.
    matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);
    while (matchColorStop !== null) {
      stopResult = {
        color: matchColorStop[1]
      };

      // // Position (optional).
      // if (!!matchColorStop[2]) {
      //     stopResult.position = matchColorStop[2];
      // }

      // Oct 29, 2019
      // Position (optional).
      if (matchColorStop[2]) {
        stopResult.position = matchColorStop[2];
      }
      result.colorStopList.push(stopResult);

      // Continue searching from previous position.
      matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);
    }
  }

  // Can be undefined if match not found.
  return result;
};

class RowTool {
  constructor(builder) {
    this.builder = builder;
    this.grid = new Grid(builder); // a must (also for ContentBox's command.js)
  }

  // Render row & column tools on each row
  render(row) {
    const dom = this.builder.dom;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    let rowtool = row.querySelector('.is-row-tool');
    if (!rowtool) {
      let html = `<div class="is-tool is-row-tool">
                <div title="${util.out('Move')}" role="button" tabindex="-1" class="row-handle" style="width:100%;cursor:move;text-align:center;"><svg class="is-icon-flex"><use xlink:href="#ion-move"></use></svg></div>
                <button type="button" tabindex="-1" title="${util.out('More')}" class="row-more"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('Grid Editor')}" class="row-grideditor"><svg class="is-icon-flex"><use xlink:href="#ion-grid"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('Delete')}" class="row-remove"><svg class="is-icon-flex"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            </div>
            <div class="is-tool is-col-tool">
                <button type="button" tabindex="-1" title="${util.out('Add')}" class="cell-add"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('More')}" class="cell-more"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('Delete')}" class="cell-remove"><svg class="is-icon-flex" style="margin-left:-1px"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            </div>
            `;
      dom.appendHtml(row, html);
      rowtool = row.querySelector('.is-row-tool');
      // Prepare for tooltip
      let elms = rowtool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
        if (!this.builder.iframe) {
          this.builder.tooltip.set(elm, 5, 3);
        } else {
          this.builder.tooltip.set(elm, 5, 3, true);
        }
      });
      let coltool = row.querySelector('.is-col-tool');
      // Prepare for tooltip
      elms = coltool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
        if (!this.builder.iframe) {
          this.builder.tooltip.set(elm, 5, 3);
        } else {
          this.builder.tooltip.set(elm, 5, 3, true);
        }
      });

      // Check for backward compatibility
      let marginLeft = window.getComputedStyle(coltool, null).getPropertyValue('margin-left');
      if (parseInt(marginLeft) === 0) {
        this.builder.backwardCompatible();
      }
      const btnCellAdd = coltool.querySelector('.cell-add');
      if (btnCellAdd) dom.addEventListener(btnCellAdd, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        const viewportHeight = window.innerHeight;
        const newPos = util.getElementPosition(btnCellAdd);
        let top = newPos.top;
        let left = newPos.left;
        renderQuickAdd(this.builder);
        let quickadd = this.builder.builderStuff.querySelector('.is-pop.quickadd');
        let tabs = quickadd.querySelector('.is-pop-tabs');
        tabs.style.display = 'flex';
        util.showPop(quickadd, false, btnCellAdd);
        const h = quickadd.offsetHeight;
        if (viewportHeight - top > h) {
          // pop bottom
          quickadd.style.top = top + window.pageYOffset + 35 + 'px';
          quickadd.style.left = left + 'px';
          dom.removeClass(quickadd, 'arrow-bottom');
          dom.removeClass(quickadd, 'arrow-right');
          dom.removeClass(quickadd, 'arrow-left');
          dom.removeClass(quickadd, 'center');
          dom.addClass(quickadd, 'arrow-top');
          dom.addClass(quickadd, 'left');
        } else {
          // pop top
          quickadd.style.top = top + window.pageYOffset - h - 8 + 'px';
          quickadd.style.left = left + 'px';
          dom.removeClass(quickadd, 'arrow-top');
          dom.removeClass(quickadd, 'arrow-right');
          dom.removeClass(quickadd, 'arrow-left');
          dom.removeClass(quickadd, 'center');
          dom.addClass(quickadd, 'arrow-bottom');
          dom.addClass(quickadd, 'left');
        }
        let val = quickadd.querySelector('.active').getAttribute('data-value');
        if (val === 'left') {
          quickadd.setAttribute('data-mode', 'cell-left');
        } else {
          quickadd.setAttribute('data-mode', 'cell-right');
        }

        //handleQuickAddClickOut
        const handleQuickAddClickOut = e => {
          // console.log('handleQuickAddClickOut');
          let elm = e.target;
          if (!elm) return;
          if (!elm.closest('.quickadd') && !elm.closest('.row-add') && !elm.closest('.is-rowadd-tool') && !elm.closest('.cell-add') && !elm.closest('.elm-add') && !elm.closest('.row-add-initial')) {
            // click outside

            // hide
            const quickadd = builderStuff.querySelector('.quickadd');
            util.hidePop(quickadd);

            // clear events
            document.removeEventListener('click', handleQuickAddClickOut);
            if (this.builder.iframeDocument) {
              this.builder.doc.removeEventListener('click', handleQuickAddClickOut);
            }
            this.builder.handleQuickAddClickOut_ = false;
          }
        };
        if (!this.builder.handleQuickAddClickOut_) {
          document.addEventListener('click', handleQuickAddClickOut);
          if (this.builder.iframeDocument) {
            this.builder.doc.addEventListener('click', handleQuickAddClickOut);
          }
          this.builder.handleQuickAddClickOut_ = true;
        }
      });
      const btnCellMore = coltool.querySelector('.cell-more');
      if (btnCellMore) dom.addEventListener(btnCellMore, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        const viewportHeight = window.innerHeight;
        const newPos = util.getElementPosition(btnCellMore);
        let top = newPos.top;
        let left = newPos.left;
        this.builder.colTool.renderColMore();
        const columnMore = builderStuff.querySelector('.columnmore');
        setTimeout(() => {
          // give delay after renderColMore()
          util.showPop(columnMore, false, btnCellMore);
          const h = columnMore.offsetHeight;
          if (viewportHeight - top > h) {
            columnMore.style.top = top + window.pageYOffset + 35 + 'px';
            columnMore.style.left = left - 7 + 'px';
            dom.removeClass(columnMore, 'arrow-bottom');
            dom.removeClass(columnMore, 'arrow-right');
            dom.removeClass(columnMore, 'arrow-left');
            dom.removeClass(columnMore, 'center');
            dom.removeClass(columnMore, 'right');
            dom.addClass(columnMore, 'arrow-top');
            dom.addClass(columnMore, 'left');
          } else {
            columnMore.style.top = top + window.pageYOffset - h - 8 + 'px';
            columnMore.style.left = left - 7 + 'px';
            dom.removeClass(columnMore, 'arrow-top');
            dom.removeClass(columnMore, 'arrow-right');
            dom.removeClass(columnMore, 'arrow-left');
            dom.removeClass(columnMore, 'center');
            dom.removeClass(columnMore, 'right');
            dom.addClass(columnMore, 'arrow-bottom');
            dom.addClass(columnMore, 'left');
          }
        }, 0);
        const btnCellLocking = columnMore.querySelector('.cell-locking');
        if (cell.hasAttribute('data-noedit')) {
          dom.addClass(btnCellLocking, 'on');
        } else {
          dom.removeClass(btnCellLocking, 'on');
        }

        // columnMore 

        const btnIncrease = columnMore.querySelector('.cell-increase');
        const btnDecrease = columnMore.querySelector('.cell-decrease');
        const btnPrev = columnMore.querySelector('.cell-prev');
        const btnNext = columnMore.querySelector('.cell-next');
        const btnUp = columnMore.querySelector('.cell-up');
        const btnDown = columnMore.querySelector('.cell-down');
        const btnDuplicate = columnMore.querySelector('.cell-duplicate');
        const btnLock = columnMore.querySelector('.cell-locking');
        const separator = columnMore.querySelector('.is-separator');
        let nogrid = cell.closest('[nogrid]'); //dom.parentsHasAttribute(col, 'nogrid');
        if (nogrid) {
          btnPrev.style.display = 'none';
          btnNext.style.display = 'none';
          btnUp.style.display = 'none';
          btnDown.style.display = 'none';
          if (btnIncrease) btnIncrease.style.display = 'none';
          if (btnDecrease) btnDecrease.style.display = 'none';
          btnDuplicate.style.display = 'none';
          btnPrev.setAttribute('disabled', 'disabled');
          btnNext.setAttribute('disabled', 'disabled');
          btnUp.setAttribute('disabled', 'disabled');
          btnDown.setAttribute('disabled', 'disabled');
          btnIncrease.setAttribute('disabled', 'disabled');
          btnDecrease.setAttribute('disabled', 'disabled');
          btnDuplicate.setAttribute('disabled', 'disabled');
          let btnColHtml = columnMore.querySelector('.cell-html');
          if (btnColHtml) btnColHtml.style.display = '';
          if (cell.getAttribute('data-html')) {
            columnMore.querySelector('.cell-html').style.display = 'none';
            this.columnTool.querySelector('.cell-more').style.display = 'none';
            columnMore.querySelector('.cell-html').setAttribute('disabled', 'disabled');
            this.columnTool.querySelector('.cell-more').setAttribute('disabled', 'disabled');
          }
        } else {
          btnPrev.style.display = '';
          btnNext.style.display = '';
          btnUp.style.display = '';
          btnDown.style.display = '';
          if (btnIncrease) btnIncrease.style.display = '';
          if (btnDecrease) btnDecrease.style.display = '';
          btnDuplicate.style.display = '';
          btnPrev.removeAttribute('disabled');
          btnNext.removeAttribute('disabled');
          btnUp.removeAttribute('disabled');
          btnDown.removeAttribute('disabled');
          if (btnIncrease) btnIncrease.removeAttribute('disabled');
          if (btnDecrease) btnDecrease.removeAttribute('disabled');
          btnDuplicate.removeAttribute('disabled');
          let btnColHtml = columnMore.querySelector('.cell-html');
          if (btnColHtml) {
            btnColHtml.style.display = '';
            btnColHtml.removeAttribute('disabled');
          }
          let row = cell.parentNode;
          let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
          if (row.querySelector('.is-row-overlay')) {
            num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
          }

          if (row.childElementCount - num === 1) {
            //-num => minus is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
            btnPrev.style.display = 'none';
            btnNext.style.display = 'none';
            if (btnIncrease) btnIncrease.style.display = 'none';
            if (btnDecrease) btnDecrease.style.display = 'none';
            btnPrev.setAttribute('disabled', 'disabled');
            btnNext.setAttribute('disabled', 'disabled');
            if (btnIncrease) btnIncrease.setAttribute('disabled', 'disabled');
            if (btnDecrease) btnDecrease.setAttribute('disabled', 'disabled');
          } else {
            btnPrev.style.display = '';
            btnNext.style.display = '';
            if (btnIncrease) btnIncrease.style.display = '';
            if (btnDecrease) btnDecrease.style.display = '';
            btnPrev.removeAttribute('disabled');
            btnNext.removeAttribute('disabled');
            if (btnIncrease) btnIncrease.removeAttribute('disabled');
            if (btnDecrease) btnDecrease.removeAttribute('disabled');
          }

          // let btnColHtml = columnMore.querySelector('.cell-html');
          let btnColDuplicate = btnDuplicate;
          if (cell.getAttribute('data-html')) {
            if (btnColHtml) {
              btnColHtml.style.display = 'none';
              btnColHtml.setAttribute('disabled', 'disabled');
            }
            if (btnColDuplicate) {
              btnColDuplicate.style.display = 'none';
              btnColDuplicate.setAttribute('disabled', 'disabled');
            }
          } else {
            if (btnColHtml) {
              btnColHtml.style.display = '';
              btnColHtml.removeAttribute('disabled');
            }
            if (btnColDuplicate) {
              btnColDuplicate.style.display = '';
              btnColDuplicate.removeAttribute('disabled');
            }
          }
        }
        if (cell.classList.contains('column-lock')) {
          btnPrev.style.display = 'none';
          btnNext.style.display = 'none';
          btnUp.style.display = 'none';
          btnDown.style.display = 'none';
          btnIncrease.style.display = 'none';
          btnDecrease.style.display = 'none';
          btnDuplicate.style.display = 'none';
          separator.style.display = 'none';
          btnLock.style.display = 'none';
        } else {
          separator.style.display = '';
          btnLock.style.display = '';
        }
      });
      const btnCellRemove = coltool.querySelector('.cell-remove');
      if (btnCellRemove) dom.addEventListener(btnCellRemove, 'click', () => {
        const grid = new Grid(this.builder);
        grid.removeColumn();
        util.clearControls();
        if (this.builder.onSelectChange) this.builder.onSelectChange();
      });
      let btnGridEditor = rowtool.querySelector('.row-grideditor');
      if (btnGridEditor) dom.addEventListener(btnGridEditor, 'click', () => {
        this.showGridEditor();
      });
      const btnMore = rowtool.querySelector('.row-more');
      if (btnMore) dom.addEventListener(btnMore, 'click', () => {
        let row;
        let cell = util.cellSelected();
        if (cell) {
          row = cell.parentNode;
        } else {
          row = util.rowSelected();
        }
        if (!row) return;

        //Change to row selection
        dom.removeClass(row, 'row-outline');

        //Hide Column tool (new!)
        util.hideColumnTool();

        /*
        const newPos = util.getElementPosition(btnMore);
        let top = newPos.top + window.pageYOffset;
        let left = newPos.left + window.pageXOffset;
         this.renderRowMore();
        const rowMore = this.rowMore;
         // rowMore.style.display = 'flex';
        util.showPop(rowMore, false, btnMore);
        //const w = rowMore.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        //const h = rowMore.offsetHeight;
        rowMore.style.top = (top - 8) + 'px';
         dom.removeClass(rowMore,'arrow-bottom');
        dom.removeClass(rowMore,'arrow-left');
        dom.removeClass(rowMore,'arrow-right');
        dom.removeClass(rowMore,'center');
        dom.removeClass(rowMore,'right');
        dom.removeClass(rowMore,'left');
         if(this.builder.opts.rowTool === 'right') {
            
            rowMore.style.left = (left - rowMore.offsetWidth - 10) + 'px';
             dom.addClass(rowMore,'arrow-right');
            dom.addClass(rowMore,'left');
         } else {
             rowMore.style.left = (left + 35) + 'px';
             dom.addClass(rowMore,'arrow-left');
            dom.addClass(rowMore,'left');
         }
        */

        const viewportHeight = window.innerHeight;
        const newPos = util.getElementPosition(btnMore);
        let top = newPos.top;
        let left = newPos.left;
        this.renderRowMore();
        const rowMore = this.rowMore;
        setTimeout(() => {
          // give delay after renderRowMore()
          util.showPop(rowMore, false, btnMore);
          const h = rowMore.offsetHeight;
          dom.removeClass(rowMore, 'arrow-bottom');
          dom.removeClass(rowMore, 'arrow-left');
          dom.removeClass(rowMore, 'arrow-right');
          dom.removeClass(rowMore, 'center');
          dom.removeClass(rowMore, 'right');
          dom.removeClass(rowMore, 'left');
          if (this.builder.opts.rowTool === 'right') {
            rowMore.style.left = left - rowMore.offsetWidth - 10 + 'px';
            dom.addClass(rowMore, 'arrow-right');
            dom.addClass(rowMore, 'left');
          } else {
            rowMore.style.left = left + 35 + 'px';
            dom.addClass(rowMore, 'arrow-left');
            dom.addClass(rowMore, 'left');
          }
          if (viewportHeight - top > h) {
            rowMore.style.top = top + window.pageYOffset - 8 + 'px';
          } else {
            rowMore.style.top = top + window.pageYOffset - h + btnMore.offsetHeight + 'px';
          }
        }, 0);
        let btnRowHtml = rowMore.querySelector('.row-html');
        let btnRowDuplicate = rowMore.querySelector('.row-duplicate');
        if (row.querySelector('[data-html]')) {
          if (btnRowHtml) btnRowHtml.style.display = 'none';
          if (btnRowDuplicate) btnRowDuplicate.style.display = 'none';
        } else {
          if (btnRowHtml) btnRowHtml.style.display = '';
          if (btnRowDuplicate) btnRowDuplicate.style.display = '';
        }
        let currentLocking = false;
        let elms = row.querySelectorAll('[data-noedit]');
        elms.forEach(elm => {
          if (!elm.hasAttribute('data-html')) {
            currentLocking = true;
          }
        });
        const btnRowLocking = rowMore.querySelector('.row-locking');
        if (currentLocking) {
          dom.addClass(btnRowLocking, 'on');
        } else {
          dom.removeClass(btnRowLocking, 'on');
        }
      });
      let elm = rowtool.querySelector('.row-remove');
      if (elm) dom.addEventListener(elm, 'click', () => {
        this.grid.removeRow();
        util.clearControls();
        if (this.builder.onSelectChange) this.builder.onSelectChange();
      });
    }
  }
  renderRowMore() {
    const builder = this.builder;
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let rowMore = builderStuff.querySelector('.rowmore');
    let htmlbutton = '';
    if (builder.opts.rowHtmlEditor) htmlbutton = `<button type="button" title="${util.out('HTML')}" class="row-html">
                <span><svg class="is-icon-flex" style="margin-right:-3px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></span>${util.out('HTML')}
            </button>`;
    if (!rowMore) {
      let html = `<div class="is-pop rowmore" style="z-index:10002;" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="display:flex;flex-flow:wrap;">
                    <button type="button" title="${util.out('Move Up')}" class="row-up"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></span>${util.out('Move Up')}</button>
                    <button type="button" title="${util.out('Move Down')}" class="row-down"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></span>${util.out('Move Down')}</button>
                    <button type="button" title="${util.out('Duplicate')}" class="row-duplicate"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></span>${util.out('Duplicate')}</button>
                    ${htmlbutton}
                    <div class="is-separator"></div>
                    <button type="button" title="${util.out('Lock')}" class="row-locking"><span><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-lock"></use></svg></span>${util.out('Lock')}</button>
                    <button type="button" title="${util.out('Settings')}" class="row-settings"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></span>${util.out('Settings')}</button>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      rowMore = builderStuff.querySelector('.rowmore');
      this.rowMore = rowMore;

      // Open Row Settings
      let elm = rowMore.querySelector('.row-settings');
      if (elm) dom.addEventListener(elm, 'click', () => {
        if (this.builder.controlPanel) {
          this.builder.controlpanel.select('row', true);
          util.hidePop(this.rowMore);
          return;
        }
        this.renderPanel();
        const rowSettings = this.rowSettings;
        const row = this.rowOverlay();
        if (!row) return;
        this.readRowStyles(row);

        //save selection
        util.saveSelection();
        util.showModal(rowSettings, false, () => {
          let rtetool = builderStuff.querySelector('.is-rte-tool');
          if (rtetool.style.display === 'flex') {
            // means text selection
            util.restoreSelection();
          }
        });
        util.hidePop(this.rowMore);
      });
      elm = rowMore.querySelector('.row-up');
      if (elm) dom.addEventListener(elm, 'click', () => {
        this.grid.moveRowUp();
      });
      elm = rowMore.querySelector('.row-down');
      if (elm) dom.addEventListener(elm, 'click', () => {
        this.grid.moveRowDown();
      });
      elm = rowMore.querySelector('.row-duplicate');
      if (elm) dom.addEventListener(elm, 'click', () => {
        this.grid.duplicateRow();
        util.hidePop(rowMore);

        //Hide Column tool (new!)
        util.hideColumnTool();
        util.clearControls();
      });
      elm = rowMore.querySelector('.row-html');
      if (elm) dom.addEventListener(elm, 'click', () => {
        let row;
        let cell = util.cellSelected();
        if (cell) {
          row = cell.parentNode;
        } else {
          row = util.rowSelected();
        }
        if (!row) return;
        const htmlutil = new HtmlUtil(builder);
        htmlutil.view('row');
      });

      // Lock/Unlock Row
      const btnRowLocking = rowMore.querySelector('.row-locking');
      if (btnRowLocking) dom.addEventListener(btnRowLocking, 'click', e => {
        let row = util.rowSelected();
        if (!row) return;
        let currentLocking = false;
        let elms = row.querySelectorAll('[data-noedit]');
        elms.forEach(elm => {
          if (!elm.hasAttribute('data-html')) {
            currentLocking = true;
          }
        });
        if (!currentLocking) {
          Array.from(row.children).map(cell => {
            if (cell.classList.contains('is-row-tool')) return;
            if (cell.classList.contains('is-col-tool')) return;
            if (cell.classList.contains('is-rowadd-tool')) return;
            if (cell.classList.contains('is-row-overlay')) return;
            cell.setAttribute('data-noedit', '');
            cell.contentEditable = false;
            util.clearActiveElement(true);
            builder.colTool.showHideLockIndicator(cell);
            builder.element.applyBehavior(cell);
          });
          dom.addClass(btnRowLocking, 'on');
        } else {
          Array.from(row.children).map(cell => {
            if (cell.classList.contains('is-row-tool')) return;
            if (cell.classList.contains('is-col-tool')) return;
            if (cell.classList.contains('is-rowadd-tool')) return;
            if (cell.classList.contains('is-row-overlay')) return;
            cell.removeAttribute('data-noedit');
            cell.contentEditable = true;
            builder.colTool.showHideLockIndicator(cell);
            builder.element.applyBehavior(cell);
          });
          dom.removeClass(btnRowLocking, 'on');
        }
        util.hidePop(rowMore);
        e.preventDefault();
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    let rowSettings = builderStuff.querySelector('.is-modal.rowsettings');
    if (!rowSettings) {
      let html = `
            <div class="is-modal rowsettings" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <div class="is-modal-bar is-draggable">
                        ${util.out('Row Settings')}
                        <button class="is-modal-close" title="${util.out('Close')}" tabindex="-1">&#10005;</button>
                    </div>

                    <div style="padding:0;margin-top:35px;">

                        <div class="is-tabs" data-group="rowsettings">
                            <a title="${util.out('General')}" id="tabRowGeneral" href="#" data-content="divRowGeneral" class="active">${util.out('General')}</a>
                            <a title="${util.out('More')}" id="tabRowMore" href="#" data-content="divRowMore">${util.out('More')}</a>
                        </div>
                        <div id="divRowGeneral" class="is-tab-content active" data-group="rowsettings" style="display:flex" tabindex="-1">
                        
                            <div style="padding-bottom: 3px;">${util.out('Background Color')}:</div>
                            <div style="display:flex;">
                                <button title="${util.out('Background Color')}" class="input-row-bgcolor is-btn-color" style="margin-right:15px"></button>
                                <button title="${util.out('Gradient')}" class="input-row-gradient classic" data-value="+"> ${util.out('Gradient')} </button>
                            </div>

                            <div style="padding-top:20px;padding-bottom: 3px;">${util.out('Background Image')}:</div>
                            <div>
                                <div class="cell-bgimage-preview"></div>
                                <div style="display: flex">
                                    <button title="${util.out('Image')}" class="input-cell-bgimage">
                                        <svg class="is-icon-flex"><use xlink:href="#ion-image"></use></svg>
                                        <span>${util.out('Image')}</span>
                                    </button>
                                    <button title="${util.out('Select')}" class="input-select">
                                        ${this.builder.opts.selectIcon}
                                    </button>
                                    <button title="${util.out('Remove')}" class="input-row-bgremove"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                                    <button title="${util.out('Adjust')}" class="input-row-bgimageadjust" style="width:40px"><svg class="is-icon-flex"><use xlink:href="#ion-wrench"></use></svg></button>
                                </div>
                            </div>

                            <div style="padding:30px 0 10px;">
                                <label class="label-row-grayscale label-checkbox" for="chkRowGrayscale"><input id="chkRowGrayscale" class="chk-row-grayscale" type="checkbox" /> ${util.out('Grayscale')}</label>
                            </div>

                            <div class="div-row-wrapcolumns" style="display:none;flex-direction:column;padding-bottom:7px">
                                <div style="padding-top:20px;padding-bottom:3px;">${util.out('Wrap Columns (Breakpoint)')}:</div>
                                <div style="padding-top:3px;padding-bottom:5px;display:flex;align-items: center;">

                                    <label class="flex mr-3" title="${util.out('Tablet (Landscape)')}">
                                        <input type="radio" id="rdoColMdWrap" name="boxWrap" value="md">
                                        <svg class="is-icon-flex" style="margin-left:3px;width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                                    </label>
                                    <label class="flex mr-3" title="${util.out('Tablet (Portrait)')}">
                                        <input type="radio" id="rdoColSmWrap" name="boxWrap" value="sm">
                                        <svg class="is-icon-flex" style="margin-left:3px;width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                                    </label>
                                    <label class="flex" title="${util.out('Mobile')}">
                                        <input type="radio" id="rdoColXsWrap" name="boxWrap" value="xs">
                                        <svg class="is-icon-flex" style="margin-left:3px;width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                                    </label>

                                </div>
                            </div>

                            <div class="is-separator"></div>
                         
                            <div class="div-target" style="display: flex;justify-content: flex-end;padding: 5px 0 0;">
                                <button title="${util.out('Desktop')}" class="input-device on" data-value="" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>
                                </button>
                                <!--<button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-device-laptop"></use></svg>
                                </button>-->
                                <button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                                </button>
                                <button title="${util.out('Tablet (Portrait)')}" class="input-device" data-value="sm" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                                </button>
                                <button title="${util.out('Mobile')}" class="input-device" data-value="xs" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:13px;height:13px"><use xlink:href="#icon-device-mobile"></use></svg>
                                </button>
                            </div>

                            <div style="padding-top:0;padding-bottom:3px;">${util.out('Visibility')}:</div>
                            <div class="div-visibility" style="display:flex;">
                                <button title="${util.out('Visible')}" class="input-visible on" data-value="sm" style="width:100px;height:34px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye"></use></svg>
                                    <span>${util.out('Visible')}</span>
                                </button>
                                <button title="${util.out('Hidden')}" class="input-hidden" data-value="xs" style="width:100px;height:34px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye-off"></use></svg>
                                    <span>${util.out('Hidden')}</span>
                                </button>
                            </div>

                            <div class="div-colsperline" style="flex-direction:column">
                                <label style="margin:20px 0 0;display:flex;flex-direction:column">
                                    <span style="margin:0 4px 3px 0">${util.out('Columns per Line')}:</span>
                                    <select class="input-numofcols" id="__input_numofcols" style="width:50%;display:none">
                                        <option value="">Default</option>
                                        <option value="2">2 columns per row</option>
                                        <option value="3">3 columns per row</option>
                                        <option value="4">4 columns per row</option>
                                        <option value="5">5 columns per row</option>
                                        <option value="6">6 columns per row</option>
                                    </select>
                                </label>
                                <div class="flex">
                                    <button title="1" class="input-colsperline on" data-value="1" style="width:40px;height:25px;">1</button>
                                    <button title="2" class="input-colsperline" data-value="2" style="width:40px;height:25px;">2</button>
                                    <button title="3" class="input-colsperline" data-value="3" style="width:40px;height:25px;">3</button>
                                    <button title="4" class="input-colsperline" data-value="4" style="width:40px;height:25px;">4</button>
                                    <button title="5" class="input-colsperline" data-value="5" style="width:40px;height:25px;">5</button>
                                    <button title="6" class="input-colsperline" data-value="6" style="width:40px;height:25px;">6</button>
                                    <button title="${util.out('Default')}" class="input-colsperline" data-value="" style="width:120px;height:25px;">${util.out('Default')}</button>
                                </div>
                            </div>

                            <div id="divReverseColumns" style="diplay:none">
                                <label for="chkReverseColumns" style="margin:20px 0 0;display:flex"><input id="chkReverseColumns" type="checkbox"  style="margin:0 7px 0 0"/><span>${util.out('Reverse Columns')}</span></label>
                            </div>
                        </div>

                        <div id="divRowMore" class="is-tab-content" data-group="rowsettings" tabindex="-1">

                            <label for="inpRowId">${util.out('Add Row ID')}:</label>
                            <div>
                                <input id="inpRowId" class="input-row-id" type="text" onkeypress="return /[0-9a-zA-Z_]/i.test(event.key)" style="height:38px">
                            </div>
        
                            <label for="inpRowCssClasses" style="padding:20px 0 3px;">${util.out('Add Css Classes')}:</label>
                            <div>
                                <input id="inpRowCssClasses" class="input-row-classes" type="text" style="height:38px">
                            </div>

                        </div>
                    
                    </div>
                        
                </div>
            </div>
            
            `;
      dom.appendHtml(builderStuff, html);
      rowSettings = builderStuff.querySelector('.is-modal.rowsettings');
      this.rowSettings = rowSettings;
      const imageSource = document.querySelector('.is-modal.imagesource');
      const imageAdjust = document.querySelector('.is-modal.imageadjust');
      const imageAdjust2 = document.querySelector('.is-modal.imageadjust2');
      this.imageSource = imageSource;
      this.imageAdjust = imageAdjust;
      this.imageAdjust2 = imageAdjust2;
      this.divRowGeneral = rowSettings.querySelector('#divRowGeneral');
      const divColsPerLine = rowSettings.querySelector('.div-colsperline');
      if (!this.builder.enableColumnsPerLine) divColsPerLine.style.display = 'none';

      // Row Background color
      let btnRowBgColor = rowSettings.querySelector('.input-row-bgcolor');
      btnRowBgColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        let elm = e.target;
        this.builder.colorPicker.open(color => {
          const row = this.rowOverlay();
          if (!row) return;
          row.style.backgroundColor = color;
          elm.style.backgroundColor = color; // preview

          this.builder.opts.onChange();
        }, rowSettings.querySelector('.input-row-bgcolor').style.backgroundColor, () => {
          btnRowBgColor.removeAttribute('data-focus');
          btnRowBgColor.focus();
        });
        btnRowBgColor.setAttribute('data-focus', true);
      });

      // Row Background Image
      const btnRowBgImage = rowSettings.querySelector('.input-cell-bgimage');
      if (btnRowBgImage) dom.addEventListener(btnRowBgImage, 'click', () => {
        const row = this.rowOverlay();
        if (!row) return;

        //Get current value
        let imgUrl = '';
        if (row.style.backgroundImage) {
          if (row.style.backgroundImage.indexOf('url(') !== -1) {
            imgUrl = row.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
          }
        }
        this.builder.colTool.openImagePicker(imgUrl, url => {
          const row = this.rowOverlay();
          if (!row) return;
          this.builder.uo.saveForUndo();
          row.style.backgroundImage = `url("${url}")`;
          row.style.backgroundSize = 'cover';
          row.style.backgroundRepeat = 'no-repeat';
          const div = rowSettings.querySelector('.cell-bgimage-preview');
          const btnImageAdjust = this.rowSettings.querySelector('.input-row-bgimageadjust');
          const btnImageRemove = this.rowSettings.querySelector('.input-row-bgremove');
          btnImageAdjust.style.display = 'none';
          btnImageRemove.style.display = 'none';
          if (url !== '') {
            div.innerHTML = `<img src="${url}">`;
            btnImageAdjust.style.display = 'flex';
            btnImageRemove.style.display = 'flex';
          } else {
            div.innerHTML = '';
          }
          this.builder.opts.onChange();
        }, btnRowBgImage);
      });

      // Row Background Image Adjust
      const btnImageAdjust = rowSettings.querySelector('.input-row-bgimageadjust');
      if (btnImageAdjust) dom.addEventListener(btnImageAdjust, 'click', () => {
        const row = this.rowOverlay();
        if (!row) return;
        this.builder.colTool.openImageAdjust(row, btnImageAdjust);
      });
      let elm = rowSettings.querySelector('.input-row-bgremove');
      if (elm) dom.addEventListener(elm, 'click', () => {
        const row = this.rowOverlay();
        if (!row) return;
        this.builder.uo.saveForUndo();
        row.style.backgroundImage = '';
        row.style.backgroundSize = '';
        row.style.backgroundRepeat = '';
        row.style.backgroundPosition = '';
        const div = rowSettings.querySelector('.cell-bgimage-preview');
        const btnImageAdjust = this.rowSettings.querySelector('.input-row-bgimageadjust');
        const btnImageRemove = this.rowSettings.querySelector('.input-row-bgremove');
        btnImageAdjust.style.display = 'none';
        btnImageRemove.style.display = 'none';
        div.innerHTML = '';
        this.builder.opts.onChange();
      });

      // Row Background Image Open Asset

      if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
        this.divRowGeneral.querySelector('.input-select').style.display = 'none';
      }
      const btnRowBgImageOpenAsset = this.divRowGeneral.querySelector('.input-select');
      this.builder.renderSelectAsset(btnRowBgImageOpenAsset, 'image', url => {
        const row = this.rowOverlay();
        if (!row) return;
        this.builder.uo.saveForUndo();
        row.style.backgroundImage = `url("${url}")`;
        row.style.backgroundSize = 'cover';
        row.style.backgroundRepeat = 'no-repeat';
        const div = rowSettings.querySelector('.cell-bgimage-preview');
        const btnImageAdjust = this.rowSettings.querySelector('.input-row-bgimageadjust');
        const btnImageRemove = this.rowSettings.querySelector('.input-row-bgremove');
        btnImageAdjust.style.display = 'none';
        btnImageRemove.style.display = 'none';
        if (url !== '') {
          div.innerHTML = `<img src="${url}">`;
          btnImageAdjust.style.display = 'flex';
          btnImageRemove.style.display = 'flex';
        } else {
          div.innerHTML = '';
        }
        this.builder.opts.onChange();
      });

      // Background gradient
      const gradientPicker = new GradientPicker({
        colors: this.builder.colors,
        gradientcolors: this.builder.opts.gradientcolors,
        lang: this.builder.opts.lang
      });
      let btnRowGradient = rowSettings.querySelector('.input-row-gradient');
      btnRowGradient.addEventListener('click', () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        const row = this.rowOverlay();
        if (!row) return;
        gradientPicker.open(row, () => {
          const btnImageAdjust = this.rowSettings.querySelector('.input-row-bgimageadjust');
          btnImageAdjust.style.display = 'none';
          const btnImageRemove = this.rowSettings.querySelector('.input-row-bgremove');
          btnImageRemove.style.display = 'none';
          const div = this.rowSettings.querySelector('.cell-bgimage-preview');
          div.innerHTML = '';
          const inpSrc = this.imageSource.querySelector('.input-src');
          inpSrc.value = '';

          //Trigger Change event
          this.builder.opts.onChange();
        }, isChanged => {
          btnRowGradient.removeAttribute('data-focus');
          btnRowGradient.focus();
        });
        btnRowGradient.setAttribute('data-focus', true);
      });
      const chkRowGrayscale = rowSettings.querySelector('.chk-row-grayscale');
      chkRowGrayscale.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        const row = this.rowOverlay();
        if (!row) return;
        if (chkRowGrayscale.checked) {
          row.style.filter = 'grayscale(1)';
        } else {
          if (row.style.filter) {
            row.style.filter = row.style.filter.replace('grayscale(1)', '');
          }
        }
        this.builder.opts.onChange();
      });

      // Responsive Visibility

      let btns = rowSettings.querySelectorAll('.input-device');
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let row = util.rowSelected();
          if (!row) return;
          let elms = rowSettings.querySelectorAll('.input-device');
          elms.forEach(elm => {
            elm.classList.remove('on');
          });
          btn.classList.add('on');
          this.realtimeVisibility(row);
        });
      });
      let btnVisible = rowSettings.querySelector('.input-visible');
      let btnHidden = rowSettings.querySelector('.input-hidden');
      btnVisible.addEventListener('click', () => {
        let row = util.rowSelected();
        if (!row) return;
        this.builder.uo.saveForUndo();
        row.classList.remove('hideonmobile');
        let divTarget = rowSettings.querySelector('.div-target');
        let target = this.builder.responsive.readTarget(divTarget);
        if (target === 'xs') {
          row.classList.remove('xs-hidden');
        } else if (target === 'sm') {
          row.classList.remove('sm-hidden');
        } else if (target === 'md') {
          row.classList.remove('md-hidden');
        } else if (target === '') {
          row.classList.remove('desktop-hidden');
        }
        btnVisible.classList.add('on');
        btnHidden.classList.remove('on');
        this.builder.opts.onChange();
      });
      btnHidden.addEventListener('click', () => {
        let row = util.rowSelected();
        if (!row) return;
        this.builder.uo.saveForUndo();
        row.classList.remove('hideonmobile');
        let divTarget = rowSettings.querySelector('.div-target');
        let target = this.builder.responsive.readTarget(divTarget);
        if (target === 'xs') {
          row.classList.add('xs-hidden');
        } else if (target === 'sm') {
          row.classList.add('sm-hidden');
        } else if (target === 'md') {
          row.classList.add('md-hidden');
        } else if (target === '') {
          row.classList.add('desktop-hidden');
        }
        btnVisible.classList.remove('on');
        btnHidden.classList.add('on');
        this.builder.opts.onChange();
      });

      // Cols per line
      btns = rowSettings.querySelectorAll('.input-colsperline');
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let row = util.rowSelected();
          if (!row) return;
          this.builder.uo.saveForUndo();
          let elms = rowSettings.querySelectorAll('.input-colsperline');
          elms.forEach(elm => {
            elm.classList.remove('on');
          });
          btn.classList.add('on');
          let val = btn.getAttribute('data-value');
          let divTarget = rowSettings.querySelector('.div-target');
          let target = this.builder.responsive.readTarget(divTarget);
          if (target === 'xs') {
            row.classList.remove('xs-items-1');
            row.classList.remove('xs-items-2');
            row.classList.remove('xs-items-3');
            row.classList.remove('xs-items-4');
            row.classList.remove('xs-items-5');
            row.classList.remove('xs-items-6');
            if (val !== '') row.classList.add(`xs-items-${val}`);
          } else if (target === 'sm') {
            row.classList.remove('sm-items-1');
            row.classList.remove('sm-items-2');
            row.classList.remove('sm-items-3');
            row.classList.remove('sm-items-4');
            row.classList.remove('sm-items-5');
            row.classList.remove('sm-items-6');
            if (val !== '') row.classList.add(`sm-items-${val}`);
          } else if (target === 'md') {
            row.classList.remove('md-items-1');
            row.classList.remove('md-items-2');
            row.classList.remove('md-items-3');
            row.classList.remove('md-items-4');
            row.classList.remove('md-items-5');
            row.classList.remove('md-items-6');
            if (val !== '') row.classList.add(`md-items-${val}`);
          } else if (target === '') {
            row.classList.remove('desktop-items-1');
            row.classList.remove('desktop-items-2');
            row.classList.remove('desktop-items-3');
            row.classList.remove('desktop-items-4');
            row.classList.remove('desktop-items-5');
            row.classList.remove('desktop-items-6');
            if (val !== '') row.classList.add(`desktop-items-${val}`);
          }
          this.builder.settings.onChange();
        });
      });

      // Reverse
      const chkReverseColumns = rowSettings.querySelector('#chkReverseColumns');
      chkReverseColumns.addEventListener('click', () => {
        let row = util.rowSelected();
        if (!row) return;
        this.builder.uo.saveForUndo();
        let divTarget = rowSettings.querySelector('.div-target');
        let target = this.builder.responsive.readTarget(divTarget);
        if (target === 'xs') {
          if (chkReverseColumns.checked) {
            row.classList.add('xs-column-reverse');
          } else {
            row.classList.remove('xs-column-reverse');
          }
        } else if (target === 'sm') {
          if (chkReverseColumns.checked) {
            row.classList.add('sm-column-reverse');
          } else {
            row.classList.remove('sm-column-reverse');
          }
        } else if (target === 'md') {
          if (chkReverseColumns.checked) {
            row.classList.add('md-column-reverse');
          } else {
            row.classList.remove('md-column-reverse');
          }
        } else if (target === '') {
          if (chkReverseColumns.checked) {
            row.classList.add('desktop-column-reverse');
          } else {
            row.classList.remove('desktop-column-reverse');
          }
        }
        this.builder.settings.onChange();
      });

      //More

      let inpRowId = rowSettings.querySelector('.input-row-id');
      inpRowId.addEventListener('change', () => {
        let row = util.rowSelected();
        if (!row) return;
        this.builder.uo.saveForUndo();
        if (inpRowId.value !== '') {
          row.setAttribute('id', inpRowId.value);
        } else {
          row.removeAttribute('id');
        }

        //Trigger Change event
        this.builder.opts.onChange();
      });
      let inpRowCssClasses = rowSettings.querySelector('.input-row-classes');
      inpRowCssClasses.addEventListener('change', () => {
        let row = util.rowSelected();
        if (!row) return;
        this.builder.uo.saveForUndo();
        let arrCurrentClasses = [];
        let currentClasses = row.getAttribute('data-class');
        if (currentClasses) arrCurrentClasses = currentClasses.split(' ');
        let arrNewClasses = [];
        let newClasses = inpRowCssClasses.value;
        arrNewClasses = newClasses.split(' ');
        arrCurrentClasses.forEach(item => {
          if (!arrNewClasses.includes(item)) {
            row.classList.remove(item);
          }
        });
        arrNewClasses.forEach(item => {
          if (item !== '') row.classList.add(item);
        });

        // save
        row.setAttribute('data-class', newClasses);
        if (row.getAttribute('data-class') === '') row.removeAttribute('data-class');

        //Trigger Change event
        this.builder.opts.onChange();
      });
      new Tabs({
        element: rowSettings
      });
      new Draggable$2({
        selector: '.is-modal.rowsettings .is-draggable'
      });
    }
  }
  realtimeVisibility(row, initialOpen) {
    if (!this.rowSettings) return;
    if (initialOpen) {
      const builderStuff = this.builder.builderStuff;
      const modal = builderStuff.querySelector('.is-modal.content-preview.active');
      if (modal) {
        let elms = this.rowSettings.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        if (modal.classList.contains('is-screen-1920')) {
          this.rowSettings.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1440')) {
          this.rowSettings.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1024')) {
          this.rowSettings.querySelector('.input-device[data-value="md"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-768')) {
          this.rowSettings.querySelector('.input-device[data-value="sm"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-375')) {
          this.rowSettings.querySelector('.input-device[data-value="xs"]').classList.add('on');
        }
      }
    }
    let divTarget = this.rowSettings.querySelector('.div-target');
    let divVisibility = this.rowSettings.querySelector('.div-visibility');
    let target = this.builder.responsive.readTarget(divTarget);
    let valVisibility = this.builder.responsive.getVisibility(row, target);
    this.builder.responsive.showVisibility(divVisibility, valVisibility);

    // const divColsPerLine = this.rowSettings.querySelector('.div-colsperline');
    let btns = this.rowSettings.querySelectorAll('.input-colsperline');
    btns.forEach(btn => {
      btn.classList.remove('on');
    });

    // Column reverse 
    let valReverse = false;
    if (target === 'xs') {
      valReverse = row.classList.contains('xs-column-reverse');
      this.rowSettings.querySelector('.input-colsperline[data-value=""]').style.display = 'none';
      if (row.classList.contains('xs-items-1')) this.rowSettings.querySelector('.input-colsperline[data-value="1"]').classList.add('on');else if (row.classList.contains('xs-items-2')) this.rowSettings.querySelector('.input-colsperline[data-value="2"]').classList.add('on');else if (row.classList.contains('xs-items-3')) this.rowSettings.querySelector('.input-colsperline[data-value="3"]').classList.add('on');else if (row.classList.contains('xs-items-4')) this.rowSettings.querySelector('.input-colsperline[data-value="4"]').classList.add('on');else if (row.classList.contains('xs-items-5')) this.rowSettings.querySelector('.input-colsperline[data-value="5"]').classList.add('on');else if (row.classList.contains('xs-items-6')) this.rowSettings.querySelector('.input-colsperline[data-value="6"]').classList.add('on');else this.rowSettings.querySelector('.input-colsperline[data-value="1"]').classList.add('on');
      if (!initialOpen) this.builder.livePreview.resizePreview(375);
    } else if (target === 'sm') {
      valReverse = row.classList.contains('sm-column-reverse');
      this.rowSettings.querySelector('.input-colsperline[data-value=""]').style.display = 'flex';
      if (row.classList.contains('sm-items-1')) this.rowSettings.querySelector('.input-colsperline[data-value="1"]').classList.add('on');else if (row.classList.contains('sm-items-2')) this.rowSettings.querySelector('.input-colsperline[data-value="2"]').classList.add('on');else if (row.classList.contains('sm-items-3')) this.rowSettings.querySelector('.input-colsperline[data-value="3"]').classList.add('on');else if (row.classList.contains('sm-items-4')) this.rowSettings.querySelector('.input-colsperline[data-value="4"]').classList.add('on');else if (row.classList.contains('sm-items-5')) this.rowSettings.querySelector('.input-colsperline[data-value="5"]').classList.add('on');else if (row.classList.contains('sm-items-6')) this.rowSettings.querySelector('.input-colsperline[data-value="6"]').classList.add('on');else this.rowSettings.querySelector('.input-colsperline[data-value=""]').classList.add('on');
      if (!initialOpen) this.builder.livePreview.resizePreview(768);
    } else if (target === 'md') {
      valReverse = row.classList.contains('md-column-reverse');
      this.rowSettings.querySelector('.input-colsperline[data-value=""]').style.display = 'flex';
      if (row.classList.contains('md-items-1')) this.rowSettings.querySelector('.input-colsperline[data-value="1"]').classList.add('on');else if (row.classList.contains('md-items-2')) this.rowSettings.querySelector('.input-colsperline[data-value="2"]').classList.add('on');else if (row.classList.contains('md-items-3')) this.rowSettings.querySelector('.input-colsperline[data-value="3"]').classList.add('on');else if (row.classList.contains('md-items-4')) this.rowSettings.querySelector('.input-colsperline[data-value="4"]').classList.add('on');else if (row.classList.contains('md-items-5')) this.rowSettings.querySelector('.input-colsperline[data-value="5"]').classList.add('on');else if (row.classList.contains('md-items-6')) this.rowSettings.querySelector('.input-colsperline[data-value="6"]').classList.add('on');else this.rowSettings.querySelector('.input-colsperline[data-value=""]').classList.add('on');
      if (!initialOpen) this.builder.livePreview.resizePreview(1024);
    } else {
      valReverse = row.classList.contains('desktop-column-reverse');
      this.rowSettings.querySelector('.input-colsperline[data-value=""]').style.display = 'flex';
      if (row.classList.contains('desktop-items-1')) this.rowSettings.querySelector('.input-colsperline[data-value="1"]').classList.add('on');else if (row.classList.contains('desktop-items-2')) this.rowSettings.querySelector('.input-colsperline[data-value="2"]').classList.add('on');else if (row.classList.contains('desktop-items-3')) this.rowSettings.querySelector('.input-colsperline[data-value="3"]').classList.add('on');else if (row.classList.contains('desktop-items-4')) this.rowSettings.querySelector('.input-colsperline[data-value="4"]').classList.add('on');else if (row.classList.contains('desktop-items-5')) this.rowSettings.querySelector('.input-colsperline[data-value="5"]').classList.add('on');else if (row.classList.contains('desktop-items-6')) this.rowSettings.querySelector('.input-colsperline[data-value="6"]').classList.add('on');else this.rowSettings.querySelector('.input-colsperline[data-value=""]').classList.add('on');
      if (!initialOpen) this.builder.livePreview.resizePreview(1920);
    }
    const chkReverseColumns = this.rowSettings.querySelector('#chkReverseColumns');
    chkReverseColumns.checked = valReverse;
  }
  moveRowUp() {
    this.grid.moveRowUp();
  }
  moveRowDown() {
    this.grid.moveRowDown();
  }
  duplicateRow() {
    this.grid.duplicateRow();
  }
  removeRow() {
    this.grid.removeRow();
  }
  hideGridEditor() {
    const builderStuff = this.builder.builderStuff;
    const grideditor = builderStuff.querySelector('.grideditor');
    if (!grideditor) return;
    grideditor.classList.remove('active');
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    builders.forEach(builder => {
      builder.removeAttribute('grideditor');
    });
  }
  showGridEditor() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const grideditor = builderStuff.querySelector('.grideditor');
    if (!grideditor) return;
    const handleGridToolClickOut = e => {
      let elm = e.target;
      if (!elm) return;
      if (!elm.closest('.rte-grideditor') && !elm.closest('.grideditor') && !elm.closest('.is-modal') && !elm.closest('.keep-selection') && !elm.closest('.is-sidebar') && !elm.closest('.is-rte-tool') && !elm.closest('.is-rte-pop') && !elm.closest('.is-elementrte-tool') && !elm.closest('.is-builder') && !elm.closest('.is-pop')) {
        // click outside

        // hide
        this.hideGridEditor();

        // clear events
        document.removeEventListener('click', handleGridToolClickOut);
        if (this.builder.iframeDocument) {
          this.builder.doc.removeEventListener('click', handleGridToolClickOut);
        }
        this.builder.handleGridToolClickOut_ = false;
      }
    };
    if (grideditor.classList.contains('active')) {
      // hide
      this.hideGridEditor();

      // clear events
      document.removeEventListener('click', handleGridToolClickOut);
      if (this.builder.iframeDocument) {
        this.builder.doc.removeEventListener('click', handleGridToolClickOut);
      }
      this.builder.handleGridToolClickOut_ = false;
      return;
    }
    util.showModal(grideditor);
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    builders.forEach(builder => {
      builder.setAttribute('grideditor', '');
    });
    if (!this.builder.handleGridToolClickOut_) {
      document.addEventListener('click', handleGridToolClickOut);
      if (this.builder.iframeDocument) {
        this.builder.doc.addEventListener('click', handleGridToolClickOut);
      }
      this.builder.handleGridToolClickOut_ = true;
    }
  }
  readRowStyles(row) {
    const util = this.builder.util;
    if (!this.rowSettings) return;
    util.clearActiveElement();

    // Background color
    let s = row.style.backgroundColor;
    let btn = this.rowSettings.querySelector('.input-row-bgcolor');
    if (s) btn.style.backgroundColor = s;else btn.style.backgroundColor = 'transparent';
    let imgUrl = '';
    const div = this.rowSettings.querySelector('.cell-bgimage-preview');
    const btnImageAdjust = this.rowSettings.querySelector('.input-row-bgimageadjust');
    btnImageAdjust.style.display = 'none';
    const btnImageRemove = this.rowSettings.querySelector('.input-row-bgremove');
    btnImageRemove.style.display = 'none';
    if (row.style.backgroundImage) {
      if (row.style.backgroundImage.indexOf('url(') !== -1) {
        imgUrl = row.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        div.innerHTML = `<img src="${imgUrl}">`;
        btnImageAdjust.style.display = 'flex';
        btnImageRemove.style.display = 'flex';
      } else {
        div.innerHTML = '';
      }
    } else {
      div.innerHTML = '';
    }
    const chkRowGrayscale = this.rowSettings.querySelector('.chk-row-grayscale');
    chkRowGrayscale.checked = false;
    if (row.style.filter) {
      if (row.style.filter.indexOf('grayscale') !== -1) {
        chkRowGrayscale.checked = true;
      }
    }
    let actualRow = row.parentNode; // row is actually row overlay

    this.realtimeVisibility(actualRow, true);
    const divReverseBoxes = this.rowSettings.querySelector('#divReverseColumns');
    let num = 3; //is-row-tool, is-col-tool & is-rowadd-tool
    if (actualRow.querySelector('.is-row-overlay')) {
      num = 4; //is-row-tool, is-col-tool, is-rowadd-tool & is-row-overlay
    }

    if (actualRow.childElementCount - num > 1) {
      divReverseBoxes.style.display = 'flex';
    } else {
      divReverseBoxes.style.display = 'none';
    }

    //More
    let inpRowId = this.rowSettings.querySelector('.input-row-id');
    inpRowId.value = '';
    const rowId = actualRow.getAttribute('id');
    if (rowId) {
      inpRowId.value = rowId;
    }
    let inpRowClasses = this.rowSettings.querySelector('.input-row-classes');
    inpRowClasses.value = '';
    const classes = actualRow.getAttribute('data-class');
    inpRowClasses.value = classes;
  }
  rowOverlay() {
    const util = this.builder.util;
    const dom = this.builder.dom;
    let row = util.rowSelected();
    if (!row) return false;
    let rowOverlay = row.querySelector('.is-row-overlay');
    if (!rowOverlay) {
      dom.appendHtml(row, '<div class="is-row-overlay"></div>');
      rowOverlay = row.querySelector('.is-row-overlay');
    }
    row.classList.add('relative');
    return rowOverlay;
  }
}

class RowAddTool {
  constructor(builder) {
    this.builder = builder;
    const dom = this.builder.dom;
    this.dom = dom;
  }
  render(row) {
    const dom = this.dom;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    let rowaddtool = row.querySelector('.is-rowadd-tool');
    if (!rowaddtool) {
      const html = `<div class="is-rowadd-tool" style="height:0">
                <button type="button" tabindex="-1" title="${util.out('Add')}" title="${util.out('Add')}" style="outline:none;line-height:1;margin:0;padding:0;cursor:pointer;background-color:rgba(255,255,255,0.9);"><svg class="is-icon-flex" style="fill:rgba(0, 0, 0, 0.8);width:17px;height:17px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            </div>`;
      dom.appendHtml(row, html);
      rowaddtool = row.querySelector('.is-rowadd-tool');

      // Prepare for tooltip
      let elms = rowaddtool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
        if (!this.builder.iframe) {
          this.builder.tooltip.set(elm, 5, 3);
        } else {
          this.builder.tooltip.set(elm, 5, 3, true);
        }
      });
    }
    let btnRowAdd = rowaddtool.querySelector('button');
    dom.addEventListener(btnRowAdd, 'click', () => {
      const quickadd = renderQuickAdd(this.builder);
      let tabs = quickadd.querySelector('.is-pop-tabs');
      tabs.style.display = 'none';
      const viewportHeight = window.innerHeight;

      /*
      let top, left;
      if(!this.builder.iframe) {
          top = btnRowAdd.getBoundingClientRect().top;
          left = btnRowAdd.getBoundingClientRect().left;
      } else {
          let adjY = this.builder.iframe.getBoundingClientRect().top;
          let adjX = this.builder.iframe.getBoundingClientRect().left;
           top = btnRowAdd.getBoundingClientRect().top + adjY;
          left = btnRowAdd.getBoundingClientRect().left + adjX;
      }
      */
      const newPos = util.getElementPosition(btnRowAdd);
      let top = newPos.top;
      let left = newPos.left;

      // quickadd.style.display = 'flex';
      util.showPop(quickadd, false, btnRowAdd);
      const w = quickadd.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
      const h = quickadd.offsetHeight;
      if (viewportHeight - top > h) {
        quickadd.style.top = top + window.pageYOffset + 27 + 'px';
        quickadd.style.left = left - w / 2 + 7 + 'px';
        dom.removeClass(quickadd, 'arrow-bottom');
        dom.removeClass(quickadd, 'arrow-right');
        dom.removeClass(quickadd, 'arrow-left');
        dom.removeClass(quickadd, 'center');
        dom.addClass(quickadd, 'arrow-top');
        dom.addClass(quickadd, 'center');
      } else {
        quickadd.style.top = top + window.pageYOffset - h - 8 + 'px';
        quickadd.style.left = left - w / 2 + 7 + 'px';
        dom.removeClass(quickadd, 'arrow-top');
        dom.removeClass(quickadd, 'arrow-right');
        dom.removeClass(quickadd, 'arrow-left');
        dom.removeClass(quickadd, 'center');
        dom.addClass(quickadd, 'arrow-bottom');
        dom.addClass(quickadd, 'center');
      }
      quickadd.setAttribute('data-mode', 'row');

      //handleQuickAddClickOut
      const handleQuickAddClickOut = e => {
        // console.log('handleQuickAddClickOut');
        let elm = e.target;
        if (!elm) return;
        if (!elm.closest('.quickadd') && !elm.closest('.row-add') && !elm.closest('.is-rowadd-tool') && !elm.closest('.cell-add') && !elm.closest('.elm-add') && !elm.closest('.row-add-initial')) {
          // click outside

          // hide
          const quickadd = builderStuff.querySelector('.quickadd');
          util.hidePop(quickadd);
          // console.log('HIDE');

          // clear events
          document.removeEventListener('click', handleQuickAddClickOut);
          if (this.builder.iframeDocument) {
            this.builder.doc.removeEventListener('click', handleQuickAddClickOut);
          }
          this.builder.handleQuickAddClickOut_ = false;
        }
      };
      if (!this.builder.handleQuickAddClickOut_) {
        document.addEventListener('click', handleQuickAddClickOut);
        if (this.builder.iframeDocument) {
          this.builder.doc.addEventListener('click', handleQuickAddClickOut);
        }
        this.builder.handleQuickAddClickOut_ = true;
      }
    });
  }
}

class ColumnTool {
  constructor(builder) {
    this.builder = builder;
    this.grid = new Grid(builder);
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    let modals = builderStuff.querySelector('.is-pop.imageadjust');
    if (!modals) {
      let html = `
            <div class="is-modal imageadjust" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:420px;">
                    <div class="is-modal-bar is-draggable">
                        ${util.out('Background Image Adjustments')}
                        <button class="is-modal-close" title="${util.out('Close')}" tabindex="-1">&#10005;</button>
                    </div>

                    <div style="padding:0;margin-top:25px;">

                        <div class="div-target" style="display: flex;justify-content: flex-end;padding: 5px 0 0;">
                            <button title="${util.out('Desktop')}" class="input-device on" data-value="" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>
                            </button>
                            <button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                            </button>
                            <button title="${util.out('Tablet (Portrait)')}" class="input-device" data-value="sm" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                            </button>
                            <button title="${util.out('Mobile')}" class="input-device" data-value="xs" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:13px;height:13px"><use xlink:href="#icon-device-mobile"></use></svg>
                            </button>
                        </div>

                        <div style="padding-bottom:3px;">${util.out('Scale')}:</div>
                        <div style="padding-top:4px">
                            <input type="range" min="100" max="500" value="0" class="image-scale-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 20px;">${util.out('Horizontal')}:</div>
                        <div style="padding-top:4px">
                            <input type="range" min="0" max="100" value="0" class="image-hor-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 20px;">${util.out('Vertical')}:</div>
                        <div style="padding-top:4px">
                            <input type="range" min="0" max="100" value="0" class="image-vert-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 10px;display:flex;justify-content:right;align-items:center;">
                            <button title="${util.out('Reset')}" class="image-reset" style="display:flex;width:30px;height:30px;"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                        </div>

                    </div>

                </div>
            </div> 

            <div class="is-modal imageadjust2" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:420px;">
                    <div class="is-modal-bar is-draggable">
                        ${util.out('Background Image Adjustments')}
                        <button class="is-modal-close" title="${util.out('Close')}" tabindex="-1">&#10005;</button>
                    </div>

                    <div style="padding:0;margin-top:25px;">

                        <div style="padding-bottom:3px;display:flex;">
                            <span>${util.out('Scale')}:</span>
                        </div>
                        <div style="padding-top:4px">
                            <input type="range" min="100" max="500" value="0" class="image-scale-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 20px;display:flex;">
                            <span>${util.out('Horizontal')}:</span>
                        </div>
                        <div style="padding-top:4px">
                            <input type="range" min="-150" max="150" value="0" class="image-hor-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 20px;display:flex;">
                            <span>${util.out('Vertical')}:</span>
                        </div>
                        <div style="padding-top:4px">
                            <input type="range" min="-150" max="150" value="0" class="image-vert-slider is-rangeslider">
                        </div>

                        <div style="padding-bottom:3px;padding-top: 10px;display:flex;justify-content:right;align-items:center;">
                            <button title="${util.out('Reset')}" class="image-reset" style="display:flex;width:30px;height:30px;"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                        </div>
                    </div>

                </div>
            </div> 

            <div class="is-modal imagesource" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:550px;">

                    <label for="inpCellImageBgSource" style="display:block">${util.out('Source')}:</label>
                    <div class="image-src">
                        <input id="inpCellImageBgSource" class="input-src" type="text">
                        <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                            ${this.builder.opts.selectIcon}
                        </button>
                        <div class="image-larger3 input-upload" style="position: relative; flex: 0 0 auto;box-shadow: rgba(0, 0, 0, 0.32) 0px 3px 6px -6px;">
                            <form class="form-upload-larger" target="frameTargetCellImageUpload" method="post" action="${this.builder.opts.largerImageHandler}" enctype="multipart/form-data" style="position:absolute;display:flex;justify-content: center;align-items: center;top:0;left:0;width:100%;height:100%;">
                                <input id="hidRefId3" name="hidRefId" type="hidden" value="">
                                <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                <input onclick="blur()" title="${util.out('Select')}" id="fileImage3" name="fileImage" type="file" accept="image/*" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                            </form>

                            <iframe tabindex="-1" tabIndex="0" id="frameTargetCellImageUpload" name="frameTargetCellImageUpload" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                        </div>
                    </div>

                    <div style="text-align:right;margin-top:20px;">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>

                </div>
            </div>

            <div class="is-locked-indicator">
                <svg class="is-icon-flex"><use xlink:href="#icon-lock"></use></svg>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        this.lockIndicator = builderStuff.querySelector('.is-locked-indicator');
      } else {
        this.lockIndicator = this.builder.contentStuff.querySelector('.is-locked-indicator');
      }
      const imageSource = document.querySelector('.is-modal.imagesource');
      const imageAdjust = document.querySelector('.is-modal.imageadjust');
      const imageAdjust2 = document.querySelector('.is-modal.imageadjust2');
      this.imageSource = imageSource;
      this.imageAdjust = imageAdjust;
      this.imageAdjust2 = imageAdjust2;

      // Column Background Image Select Dialog (.is-modal.imagesource) 

      if (this.builder.opts.largerImageHandler === '' && !this.builder.opts.onLargerImageUpload) {
        imageSource.querySelector('.image-larger3').style.display = 'none';
      }
      if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
        imageSource.querySelector('.input-select').style.display = 'none';
      }

      // Select image (opens Asset Manager plugin or custom dialog)
      let divImageSrc = imageSource.querySelector('.image-src');
      if (this.builder.opts.onImageSelectClick || this.builder.opts.imageselect) {
        const elm = imageSource.querySelector('.input-select');
        if (elm) dom.addEventListener(elm, 'click', () => {
          if (this.builder.opts.onImageSelectClick) {
            this.builder.opts.onImageSelectClick({
              targetInput: imageSource.querySelector('.input-src'),
              theTrigger: elm
            });
          } else {
            let modalImageSelect = builderStuff.querySelector('.is-modal.imageselect');
            let iframe = modalImageSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.imageselect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.imageselect;
            }
            util.showModal(modalImageSelect, false, () => {
              elm.removeAttribute('data-focus');
              elm.focus();
            }, false, this.builder.assetPanelFullScreen);
            elm.setAttribute('data-focus', true);
          }
          this.builder.targetInput = imageSource.querySelector('.input-src'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          this.builder.targetAssetType = 'image';
        });
      } else {
        dom.removeClass(divImageSrc, 'image-select');
      }
      let fileLargerImage = imageSource.querySelector('#fileImage3');
      dom.addEventListener(fileLargerImage, 'change', e => {
        let element = fileLargerImage;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        imageSource.querySelector('#hidRefId3').value = this.builder.opts.customval;
        if (this.builder.opts.onLargerImageUpload) {
          this.builder.opts.onLargerImageUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerImage.value = ''; // Clear Input
      });

      const btnImageOk = imageSource.querySelector('.input-ok');
      dom.addEventListener(btnImageOk, 'click', () => {
        const inpSrc = this.imageSource.querySelector('.input-src');
        const url = inpSrc.value;
        if (this.builder.imageSelectedCallback) this.builder.imageSelectedCallback(url);
        this.builder.hideModal(imageSource);
      });
      const btnImageCancel = imageSource.querySelector('.input-cancel');
      dom.addEventListener(btnImageCancel, 'click', () => {
        this.builder.hideModal(imageSource);
      });

      // Scale
      const inpImageScaleSlider = imageAdjust.querySelector('.image-scale-slider');
      inpImageScaleSlider.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageScaleSlider.blur();
        // imageAdjust.focus();
      };

      inpImageScaleSlider.oninput = () => {
        //val: 100 - 500
        let val = inpImageScaleSlider.value;
        let cell = this.builder.elementSelected; //util.cellSelected();
        // cell.style.backgroundSize = val + '%';
        if (document.querySelector('.content-preview.is-screen-375.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-xs');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          // div.style.backgroundSize = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-xs', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-768.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-sm');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          // div.style.backgroundSize = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-sm', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-1024.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-md');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          // div.style.backgroundSize = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-md', div.style.cssText);
        } else {
          cell.style.backgroundSize = val + '%';
        }

        // Clean unused
        cell.style.left = '';
        cell.style.top = '';
        cell.style.width = '';
        cell.style.height = '';
        cell.removeAttribute('data-x');
        cell.removeAttribute('data-y');
        cell.removeAttribute('data-scale');
      };
      inpImageScaleSlider.onchange = () => {
        if (document.querySelector('.content-preview.is-screen-375.active')) {
          inpImageScaleSlider.value = 0;
        } else if (document.querySelector('.content-preview.is-screen-768.active')) {
          inpImageScaleSlider.value = 0;
        } else if (document.querySelector('.content-preview.is-screen-1024.active')) {
          inpImageScaleSlider.value = 0;
        }
        this.builder.opts.onChange();
      };

      // Scale 2
      const inpImageScaleSlider2 = imageAdjust2.querySelector('.image-scale-slider');
      inpImageScaleSlider2.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageScaleSlider2.blur();
        // imageAdjust2.focus();
      };

      inpImageScaleSlider2.oninput = () => {
        let cell = this.builder.elementSelected;
        //val: 100 - 500
        let val = inpImageScaleSlider2.value;
        if (this.scaleWidth) {
          cell.style.width = val + '%';
          // cell.style.height = ''; 
          cell.style.height = val * 100 / inpImageScaleSlider2.min + '%';
        } else {
          cell.style.height = val + '%';
          // cell.style.width = '';
          cell.style.width = val * 100 / inpImageScaleSlider2.min + '%';
        }
        cell.setAttribute('data-scale', val);
      };
      inpImageScaleSlider2.onchange = () => {
        this.builder.opts.onChange();
      };

      // Horizontal
      const inpImageHorSlider = imageAdjust.querySelector('.image-hor-slider');
      inpImageHorSlider.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageHorSlider.blur();
        // imageAdjust.focus();
      };

      inpImageHorSlider.oninput = () => {
        //val: 0 - 100
        let val = inpImageHorSlider.value;
        let cell = this.builder.elementSelected; //util.cellSelected();
        // cell.style.backgroundPositionX = val + '%';
        if (document.querySelector('.content-preview.is-screen-375.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-xs');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionX = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-xs', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-768.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-sm');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionX = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-sm', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-1024.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-md');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionX = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-md', div.style.cssText);
        } else {
          cell.style.backgroundPositionX = val + '%';
        }

        // Clean unused
        cell.style.left = '';
        cell.style.top = '';
        cell.style.width = '';
        cell.style.height = '';
        cell.removeAttribute('data-x');
        cell.removeAttribute('data-y');
        cell.removeAttribute('data-scale');
      };
      inpImageHorSlider.onchange = () => {
        if (this.builder.win.adjustBgPos) this.builder.win.adjustBgPos(); // adjustBgPos() from box/flex.js

        this.builder.opts.onChange();
      };

      // Horizontal 2
      const inpImageHorSlider2 = imageAdjust2.querySelector('.image-hor-slider');
      inpImageHorSlider2.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageHorSlider2.blur();
        // imageAdjust2.focus();
      };

      inpImageHorSlider2.oninput = () => {
        let cell = this.builder.elementSelected;

        //val: -100 - 100
        let val = parseFloat(inpImageHorSlider2.value);
        cell.style.left = `${val}%`;
        cell.style.right = '';
        cell.setAttribute('data-x', val);
      };
      inpImageHorSlider2.onchange = () => {
        this.builder.opts.onChange();
      };

      // Vertical
      const inpImageVertSlider = imageAdjust.querySelector('.image-vert-slider');
      inpImageVertSlider.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageVertSlider.blur();
        // imageAdjust.focus();
      };

      inpImageVertSlider.oninput = () => {
        //val: 0 - 100
        let val = inpImageVertSlider.value;
        let cell = this.builder.elementSelected; //util.cellSelected();
        // cell.style.backgroundPositionY = val + '%';
        if (document.querySelector('.content-preview.is-screen-375.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-xs');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionY = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-xs', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-768.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-sm');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionY = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-sm', div.style.cssText);
        } else if (document.querySelector('.content-preview.is-screen-1024.active') && this.useTarget) {
          let dataBg = cell.getAttribute('data-bg-md');
          if (!dataBg) dataBg = '';
          let div = document.createElement('div');
          div.style.cssText = dataBg;
          div.style.backgroundPositionY = val + '%';
          div.style.backgroundSize = 'cover';
          cell.setAttribute('data-bg-md', div.style.cssText);
        } else {
          cell.style.backgroundPositionY = val + '%';
        }

        // Clean unused
        cell.style.left = '';
        cell.style.top = '';
        cell.style.width = '';
        cell.style.height = '';
        cell.removeAttribute('data-x');
        cell.removeAttribute('data-y');
        cell.removeAttribute('data-scale');
      };
      inpImageVertSlider.onchange = () => {
        if (this.builder.win.adjustBgPos) this.builder.win.adjustBgPos(); // adjustBgPos() from box/flex.js

        this.builder.opts.onChange();
      };

      // Vertical 2
      const inpImageVertSlider2 = imageAdjust2.querySelector('.image-vert-slider');
      inpImageVertSlider2.onfocus = () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        // inpImageVertSlider2.blur();
        // imageAdjust2.focus();
      };

      inpImageVertSlider2.oninput = () => {
        let cell = this.builder.elementSelected;

        //val: -100 - 100
        let val = parseFloat(inpImageVertSlider2.value);
        cell.style.top = `${val}%`;
        cell.style.bottom = '';
        cell.setAttribute('data-y', val);
      };
      inpImageVertSlider2.onchange = () => {
        this.builder.opts.onChange();
      };

      //Reset

      const btnImageReset = imageAdjust.querySelector('.image-reset');
      btnImageReset.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        let cell = this.builder.elementSelected;
        this.resetImage(cell);
        this.builder.opts.onChange();
      });
      const btnImageReset2 = imageAdjust2.querySelector('.image-reset');
      btnImageReset2.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
        let cell = this.builder.elementSelected;
        this.resetImage2(cell);
        this.builder.opts.onChange();
      });

      // Responsive Image Adjust

      const btns = this.imageAdjust.querySelectorAll('.input-device');
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let elms = this.imageAdjust.querySelectorAll('.input-device');
          elms.forEach(elm => {
            elm.classList.remove('on');
          });
          btn.classList.add('on');
          const modal = builderStuff.querySelector('.is-modal.content-preview');
          if (!modal.classList.contains('active')) {
            this.builder.openPreview();
          }
          this.realtimeImageAdjust();
          this.readImageAdjust(this.builder.elementSelected, this.useTarget);
        });
      });
    }
  }
  renderColMore() {
    const builder = this.builder;
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    this.grid = new Grid(builder);
    let columnMore = builderStuff.querySelector('.is-pop.columnmore');
    let resizebutton = `
            <button type="button" title="${util.out('Increase')}" class="cell-increase"><span><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-increase"></use></svg></span>${util.out('Increase')}</button>
            <button type="button" title="${util.out('Decrease')}" class="cell-decrease"><span><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-decrease"></use></svg></span>${util.out('Decrease')}</button>      
        `;
    let htmlbutton = '';
    if (builder.opts.columnHtmlEditor) htmlbutton = `<button type="button" title="${util.out('HTML')}" class="cell-html">
                <span><svg class="is-icon-flex" style="margin-right:-3px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:12px;height:12px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></span>${util.out('HTML')}
            </button>`;
    if (!columnMore) {
      // Refer to .is-col-tool in in rowtool.js
      let html = `
            <div class="is-pop columnmore" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="display:flex;flex-flow:wrap;">
                    <button type="button" title="${util.out('Move Left')}" class="cell-prev"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-left"></use></svg></span>${util.out('Move Left')}</button>
                    <button type="button" title="${util.out('Move Right')}" class="cell-next"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-right"></use></svg></span>${util.out('Move Right')}</button>
                    <button type="button" title="${util.out('Move Up')}" class="cell-up"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></span>${util.out('Move Up')}</button>
                    <button type="button" title="${util.out('Move Down')}" class="cell-down"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></span>${util.out('Move Down')}</button>
                    ${resizebutton}
                    <button type="button" title="${util.out('Duplicate')}" class="cell-duplicate"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></span>${util.out('Duplicate')}</button>
                    ${htmlbutton}
                    <div class="is-separator"></div>
                    <button type="button" title="${util.out('Lock')}" class="cell-locking"><span><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#icon-lock"></use></svg></span>${util.out('Lock')}</button>
                    <button type="button" title="${util.out('Settings')}" class="cell-settings"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></span>${util.out('Settings')}</button>
                    
                    <!--
                    <button title="${util.out('Lock')}" class="cell-locking">
                        <svg class="is-icon-flex"><use xlink:href="#icon-lock"></use></svg>
                    </button>
                    <button title="${util.out('Settings')}" class="cell-settings">
                        <svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg>
                        <span>${util.out('Settings')}</span>
                    </button>
                    -->
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      columnMore = builderStuff.querySelector('.columnmore');
      this.columnMore = columnMore;
      let elm;

      // Move Previous
      elm = columnMore.querySelector('.cell-prev');
      dom.addEventListener(elm, 'click', () => {
        this.grid.moveColumnPrevious();

        // util.clearControls();
      });

      // Move Next
      elm = columnMore.querySelector('.cell-next');
      dom.addEventListener(elm, 'click', () => {
        this.grid.moveColumnNext();

        // util.clearControls();
      });

      // Move Up
      elm = columnMore.querySelector('.cell-up');
      dom.addEventListener(elm, 'click', () => {
        this.grid.moveColumnUp();
        util.clearControls();
      });

      // Move Down
      elm = columnMore.querySelector('.cell-down');
      dom.addEventListener(elm, 'click', () => {
        this.grid.moveColumnDown();
        util.clearControls();
      });

      // Increase
      elm = columnMore.querySelector('.cell-increase');
      dom.addEventListener(elm, 'click', () => {
        const cell = util.cellSelected();
        if (!cell) return;
        const row = cell.parentNode;
        if (!this.builder.useDefaultGrid) {
          // Check if reset needed (reset will remove inline width, etc)
          let needed = false;
          Array.from(row.children).map(item => {
            if (item.classList.contains('is-row-tool')) return;
            if (item.classList.contains('is-rowadd-tool')) return;
            if (item.classList.contains('is-col-tool')) return;
            if (item.style.width) needed = true;
          });
          if (needed) {
            Array.from(row.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              item.style.width = '';
              item.style.flex = '';
              item.style.height = '';
              item.style.minHeight = '';
            });
            util.fixLayout(row);
          }

          // fixLayout(row);
        }

        this.grid.increaseColumn();

        // Refresh Module
        Array.from(cell.parentNode.children).map(item => {
          if (item.classList.contains('is-row-tool')) return;
          if (item.classList.contains('is-rowadd-tool')) return;
          if (item.classList.contains('is-col-tool')) return;
          if (item.getAttribute('data-module')) {
            util.refreshModuleLayout(item);
          }
        });
      });

      // Decrease
      elm = columnMore.querySelector('.cell-decrease');
      dom.addEventListener(elm, 'click', () => {
        const cell = util.cellSelected();
        if (!cell) return;
        const row = cell.parentNode;
        if (!this.builder.useDefaultGrid) {
          // Check if reset needed (reset will remove inline width, etc)

          let needed = false;
          Array.from(row.children).map(item => {
            if (item.classList.contains('is-row-tool')) return;
            if (item.classList.contains('is-rowadd-tool')) return;
            if (item.classList.contains('is-col-tool')) return;
            if (item.style.width) needed = true;
          });
          if (needed) {
            Array.from(row.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              item.style.width = '';
              item.style.flex = '';
              item.style.height = '';
              item.style.minHeight = '';
            });
            util.fixLayout(row);
          }

          // fixLayout(row);
        }

        this.grid.decreaseColumn();

        // Refresh Module
        Array.from(cell.parentNode.children).map(item => {
          if (item.classList.contains('is-row-tool')) return;
          if (item.classList.contains('is-rowadd-tool')) return;
          if (item.classList.contains('is-col-tool')) return;
          if (item.getAttribute('data-module')) {
            util.refreshModuleLayout(item);
          }
        });
      });

      // Duplicate
      elm = columnMore.querySelector('.cell-duplicate');
      dom.addEventListener(elm, 'click', () => {
        this.grid.duplicateColumn();
        util.hidePop(this.columnMore);
        util.clearControls();
      });

      // View HTML
      elm = columnMore.querySelector('.cell-html');
      if (elm) dom.addEventListener(elm, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        const htmlutil = new HtmlUtil(this.builder);
        htmlutil.view('cell');
      });

      // Lock/Unlock Column
      const btnCellLocking = columnMore.querySelector('.cell-locking');
      if (btnCellLocking) dom.addEventListener(btnCellLocking, 'click', e => {
        let cell = util.cellSelected();
        if (!cell) return;
        if (!cell.hasAttribute('data-noedit')) {
          cell.setAttribute('data-noedit', '');
          cell.contentEditable = false;
          dom.addClass(btnCellLocking, 'on');
          this.util.clearActiveElement(true);
        } else {
          cell.removeAttribute('data-noedit');
          cell.contentEditable = true;
          dom.removeClass(btnCellLocking, 'on');
        }
        this.showHideLockIndicator(cell);
        this.builder.element.applyBehavior(cell);

        // this.columnMore.style.display = '';
        util.hidePop(this.columnMore);
        e.preventDefault();
      });

      // Open Column Settings
      elm = columnMore.querySelector('.cell-settings');
      if (elm) dom.addEventListener(elm, 'click', () => {
        if (this.builder.controlPanel) {
          this.builder.controlpanel.select('column', true);
          util.hidePop(this.columnMore);
          return;
        }
        this.renderPanel();
        const cellSettings = this.cellSettings;
        let cell = util.cellSelected();
        if (!cell) return;
        this.readCellStyles(cell);

        //save selection
        util.saveSelection();
        util.showModal(cellSettings, false, () => {
          let rtetool = builderStuff.querySelector('.is-rte-tool');
          if (rtetool.style.display === 'flex') {
            // means text selection

            util.restoreSelection();

            // if(this.builder.activeElement) {
            //     dom.addClass(this.builder.activeElement, 'elm-active');
            //     this.builder.elmTool.repositionElementTool();
            // }
          }
        });

        util.hidePop(this.columnMore);
      });
    }
  }
  renderPanel() {
    const builderStuff = this.builder.builderStuff;
    const util = this.builder.util;
    const dom = this.builder.dom;
    const imageSource = builderStuff.querySelector('.is-modal.imagesource');
    const imageAdjust = builderStuff.querySelector('.is-modal.imageadjust');
    const imageAdjust2 = builderStuff.querySelector('.is-modal.imageadjust2');
    this.imageSource = imageSource;
    this.imageAdjust = imageAdjust;
    this.imageAdjust2 = imageAdjust2;
    let cellSettings = builderStuff.querySelector('.is-modal.columnsettings');
    if (!cellSettings) {
      let html = `
            <div class="is-modal columnsettings" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <div class="is-modal-bar is-draggable">
                        ${util.out('Column Settings')}
                        <button class="is-modal-close" title="${util.out('Close')}" tabindex="-1">&#10005;</button>
                    </div>

                    <div style="padding:0;margin-top:35px;">

                        <div class="is-tabs" data-group="cellsettings">
                            <a title="${util.out('General')}" id="tabCellGeneral" href="#" data-content="divCellGeneral" class="active">${util.out('General')}</a>
                            <a title="${util.out('Content')}" id="tabCellContent" href="#" data-content="divCellContent">${util.out('Content')}</a>
                            ${this.builder.useLightbox ? `
                            <a title="${util.out('On Click')}" id="tabCellClick" href="#" data-content="divCellClick">${util.out('On Click')}</a>
                            ` : ''}
                            <a title="${util.out('More')}" id="tabCellMore" href="#" data-content="divCellMore">${util.out('More')}</a>
                        </div>
                        <div id="divCellGeneral" class="is-tab-content active" data-group="cellsettings" style="display:flex" tabindex="-1">
                        
                            <div style="padding-bottom: 3px;">${util.out('Background Color')}:</div>
                            <div style="display:flex;">
                                <button title="${util.out('Background Color')}" class="input-cell-bgcolor is-btn-color" style="margin-right:15px"></button>
                                <button title="${util.out('Gradient')}" class="input-cell-gradient classic" data-value="+"> ${util.out('Gradient')} </button>
                            </div>

                            <div style="padding-top:20px;padding-bottom: 3px;">${util.out('Background Image')}:</div>
                            <div>
                                <div class="cell-bgimage-preview"></div>
                                <div style="display: flex">
                                    <button title="${util.out('Image')}" class="input-cell-bgimage">
                                        <svg class="is-icon-flex"><use xlink:href="#ion-image"></use></svg>
                                        <span>${util.out('Image')}</span>
                                    </button>
                                    <button title="${util.out('Select')}" class="input-select">${this.builder.opts.selectIcon}</button>
                                    <button title="${util.out('Remove')}" class="input-cell-bgremove"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                                    <button title="${util.out('Adjust')}" class="input-cell-bgimageadjust" style="width:40px"><svg class="is-icon-flex"><use xlink:href="#ion-wrench"></use></svg></button>
                                </div>
                            </div>

                            <div style="padding-top:20px;padding-bottom:3px;">${util.out('Text Color')}:</div>
                            <div class="div-content-textcolor">
                                <button title="0" class="input-cell-textcolor" data-command="dark">${util.out('Dark')}</button>
                                <button title="10" class="input-cell-textcolor" data-command="light">${util.out('Light')}</button>
                                
                                <button title="${util.out('Clear')}" class="input-cell-textcolor" data-command=""><svg class="is-icon-flex" style="flex:none;width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                            </div>

                            <div style="padding:30px 0 10px;">
                                <label class="label-cell-grayscale label-checkbox" for="chkCellGrayscale"><input id="chkCellGrayscale" class="chk-cell-grayscale" type="checkbox" /> ${util.out('Grayscale')}</label>
                            </div>

                            <div style="display:none;padding:20px 0 10px;">
                                <label class="label-cell-hideonmobile label-checkbox" for="chkHideColumnOnMobile"><input id="chkHideColumnOnMobile" class="chk-cell-hideonmobile" type="checkbox" /> ${util.out('Hide Column on Mobile')}</label>
                            </div>

                            <div class="is-separator"></div>
                         
                            <div class="div-target" style="display: flex;justify-content: flex-end;padding: 5px 0 0;">
                                <button title="${util.out('Desktop')}" class="input-device on" data-value="" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>
                                </button>
                                <button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                                </button>
                                <button title="${util.out('Tablet (Portrait)')}" class="input-device" data-value="sm" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                                </button>
                                <button title="${util.out('Mobile')}" class="input-device" data-value="xs" style="width:40px;height:25px;">
                                    <svg class="is-icon-flex" style="width:13px;height:13px"><use xlink:href="#icon-device-mobile"></use></svg>
                                </button>
                            </div>

                            <div style="padding-top:0;padding-bottom:3px;">${util.out('Visibility')}:</div>
                            <div class="div-visibility" style="display:flex;">
                                <button title="${util.out('Visible')}" class="input-visible on" style="width:100px;height:34px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye"></use></svg>
                                    <span>${util.out('Visible')}</span>
                                </button>
                                <button title="${util.out('Hidden')}" class="input-hidden" style="width:100px;height:34px;">
                                    <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye-off"></use></svg>
                                    <span>${util.out('Hidden')}</span>
                                </button>
                            </div>
                            
                            <!--
                            <div style="display:none;padding-top:20px;padding-bottom:3px;">${util.out('Enlarge Row')}:</div>
                            <div style="display: none;">
                                <button title="${util.out('Normal')}" class="input-row-enlarge" data-command="0" style="margin-right:1px;">${util.out('Normal')}</button>
                                <button title="+10%" class="input-row-enlarge" data-command="10" style="width:50px;margin-right:1px;">+10%</button>
                                <button title="+20%" class="input-row-enlarge" data-command="20" style="width:50px;margin-right:1px;">+20%</button>
                                <button title="+30%" class="input-row-enlarge" data-command="30" style="width:50px;margin-right:1px;">+30%</button>
                                <button title="+40%" class="input-row-enlarge" data-command="40" style="width:50px;margin-right:1px;">+40%</button>
                                <button title="+50%" class="input-row-enlarge" data-command="50" style="width:50px;margin-right:1px;">+50%</button>
                                <button title="+60%" class="input-row-enlarge" data-command="60" style="width:50px;margin-right:1px;">+60%</button>
                            </div>
                            -->

                        </div>

                        <div id="divCellContent" class="is-tab-content" data-group="cellsettings" tabindex="-1">

                            <div style="padding-bottom:3px;">${util.out('Padding')}:</div>

                            <div class="div-content-padding-pos" style="align-items:center;${this.builder.useCssClasses ? '' : 'display:none'}">
                                <div style="width:130px">
                                    <div style="display: flex;justify-content: center;">
                                        <button title="${util.out('Top')}" class="input-cell-padding-pos on" data-command="top">${util.out('Top')}</button>
                                    </div>
                                    <div style="display: flex;justify-content: center;">
                                        <button title="${util.out('Left')}" class="input-cell-padding-pos on" data-command="left">${util.out('Left')}</button>
                                        <button title="${util.out('Right')}" class="input-cell-padding-pos on" data-command="right">${util.out('Right')}</button>
                                    </div>
                                    <div style="display: flex;justify-content: center;">
                                        <button title="${util.out('Bottom')}" class="input-cell-padding-pos on" data-command="bottom">${util.out('Bottom')}</button>
                                    </div>
                                </div>
                                <button title="${util.out('All')}" class="input-cell-padding-pos" data-command="all">${util.out('All')}</button>
                                <button title="x" class="input-cell-padding-pos" data-command="x" style="width:50px">x</button>
                                <button title="y" class="input-cell-padding-pos" data-command="y" style="width:50px">y</button>
                            </div>

                            <div class="div-content-padding" style="flex-flow:wrap;margin-top:7px">
                                <div style="display:flex;flex-flow:wrap;${this.builder.useCssClasses ? 'display:none' : ''}">
                                    <button title="0" class="input-cell-padding" data-command="0">0</button>
                                    <button title="10" class="input-cell-padding" data-command="10">10</button>
                                    <button title="20" class="input-cell-padding" data-command="20">20</button>
                                    <button title="30" class="input-cell-padding" data-command="30">30</button>
                                    <button title="40" class="input-cell-padding" data-command="40">40</button>
                                    <button title="50" class="input-cell-padding" data-command="50">50</button>
                                    <button title="60" class="input-cell-padding" data-command="60">60</button>
                                </div>

                                <div style="display:flex;flex-flow:wrap;${this.builder.useCssClasses ? '' : 'display:none'}">
                                    <button title="0" class="input-cell-padding" data-command="0">0</button>
                                    <button title="20" class="input-cell-padding" data-command="1">10</button>
                                    <button title="40" class="input-cell-padding" data-command="2">20</button>
                                    <button title="60" class="input-cell-padding" data-command="3">30</button>
                                    <button title="60" class="input-cell-padding" data-command="4">40</button>
                                    <button title="60" class="input-cell-padding" data-command="5">50</button>
                                    <button title="60" class="input-cell-padding" data-command="6">60</button>
                                    <button title="60" class="input-cell-padding" data-command="7">70</button>
                                    <button title="60" class="input-cell-padding" data-command="8">80</button>
                                    <button title="60" class="input-cell-padding" data-command="9">90</button>
                                    <button title="60" class="input-cell-padding" data-command="10">100</button>
                                    <button title="60" class="input-cell-padding" data-command="11">110</button>
                                    <button title="60" class="input-cell-padding" data-command="12">120</button>
                                    <button title="60" class="input-cell-padding" data-command="14">140</button>
                                    <button title="60" class="input-cell-padding" data-command="16">160</button>
                                    <button title="${util.out('Clear')}" class="input-cell-padding" data-command=""><svg class="is-icon-flex" style="flex:none;width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                                </div>
                            </div>

                            <div style="padding-top:20px;padding-bottom:3px;">${util.out('Height')}:</div>
                            <div class="div-content-height">
                                <button title="Decrease" class="input-cell-height" data-command="-">-</button>
                                <button title="Increase" class="input-cell-height" data-command="+">+</button>
                                <button title="300" class="input-cell-height" data-command="300">300</button>
                                <button title="400" class="input-cell-height" data-command="400">400</button>
                                <button title="500" class="input-cell-height" data-command="500">500</button>
                                <button title="600" class="input-cell-height" data-command="600">600</button>
                                <button title="700" class="input-cell-height" data-command="700">700</button>
                                <button title="${util.out('Clear')}" class="input-cell-height" data-command=""><svg class="is-icon-flex" style="flex:none;width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                            </div>

                            <div style="padding-top:20px;padding-bottom:3px;">${util.out('Content Alignment')}:</div>
                            <div style="display:flex;align-items: flex-end;">
                                <div style="width:128px">
                                    <div class="div-content-position">
                                        <button class="cmd-content-pos" data-pos="topleft" title="${util.out('Top Left')}" type="button" style=""><svg class="is-icon-flex" style="transform: rotate(315deg);"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="topcenter" title="${util.out('Top Center')}" type="button"><svg class="is-icon-flex" style=""><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="topright" topright="${util.out('Top Right')}" type="button"><svg class="is-icon-flex" style="transform: rotate(45deg);"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></button>
                                    </div>
                                    <div class="div-content-position">
                                        <button class="cmd-content-pos" data-pos="centerleft" title="${util.out('Center Left')}" type="button"><svg class="is-icon-flex" style=""><use xlink:href="#ion-ios-arrow-thin-left"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="center" title="${util.out('Center')}" type="button"><svg class="is-icon-flex" style="width:6px;height:6px;"><use xlink:href="#ion-android-contract"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="centerright" title="${util.out('Center Right')}" type="button"><svg class="is-icon-flex" style=""><use xlink:href="#ion-ios-arrow-thin-right"></use></svg></button>
                                    </div>
                                    <div class="div-content-position">
                                        <button class="cmd-content-pos" data-pos="bottomleft" title="${util.out('Bottom Left')}" type="button" style=";"><svg class="is-icon-flex" style="transform: rotate(45deg);"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="bottomcenter" title="${util.out('Bottom Center')}" type="button"><svg class="is-icon-flex" style=""><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></button>
                                        <button class="cmd-content-pos" data-pos="bottomright" title="${util.out('Bottom Right')}" type="button"><svg class="is-icon-flex" style="transform: rotate(315deg);"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></button>
                                    </div>
                                </div>
                                <div class="div-content-position">
                                    <button title="${util.out('Clear')}" class="cmd-content-pos" data-pos=""><svg class="is-icon-flex" style="flex:none;width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                                </div>
                            </div>
                        </div>

                        <div id="divCellClick" class="is-tab-content" data-group="cellsettings" tabindex="-1">

                            <label for="inpCellLinkSource" style="display:block">${util.out('Open')}:</label>
                            <div class="image-src">
                                <!--<div class="div-input-text">-->
                                <input id="inpCellLinkSource" class="input-src" type="text" style="height:38px;">
                                <!--<button title="${util.out('Clear')}" class="input-clear"><svg class="is-icon-flex"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                                </div>-->
                                <button title="${util.out('Select')}" class="input-select" style="flex:none;width:40px;height:38px;">${this.builder.opts.selectIcon}</button>

                                <button title="${util.out(this.builder.opts.otherSelectCaption)}" class="input-select-other" style="display:none;width:40px;height:38px;">
                                    ${this.builder.opts.otherSelectIcon}
                                </button>
                                
                                <div class="image-larger4 is-btn classic" style="position: relative; flex: 0 0 auto; width: 40px; height: 38px; box-shadow: rgba(0, 0, 0, 0.32) 0px 3px 6px -6px;">
                                    <form class="form-upload-larger" target="frameTargetLinkUpload" method="post" action="${this.builder.opts.largerImageHandler}" enctype="multipart/form-data" style="position:absolute;top:0;left:0;width:100%;height:100%;border-radius:1px;display:flex;align-items: center;justify-content: center;">
                                        <input id="hidRefId4" name="hidRefId" type="hidden" value="">
                                        <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                                        <input onclick="blur()" title="${util.out('Select')}" id="fileImage4" name="fileImage" type="file" accept="image/*,video/mp4" style="position:absolute;top:-30px;left:0;width:100%;height:68px;opacity: 0;cursor: pointer;">
                                    </form>

                                    <iframe tabindex="-1" id="frameTargetLinkUpload" name="frameTargetLinkUpload" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                                </div>
                            </div>
                            <div style="padding-top:20px">
                                <button class="input-testclick">${util.out('Test')}</button>
                            </div>

                            <p>${util.out('You can test the On-Click action on page if you lock the column by clicking the lock button')} <svg class="is-icon-flex"><use xlink:href="#icon-lock"></use></svg>.</p>

                        </div>

                        <div id="divCellMore" class="is-tab-content" data-group="cellsettings" tabindex="-1">

                            <label for="inpCellId">${util.out('Add Column ID')}:</label>
                            <div>
                                <input id="inpCellId" class="input-cell-id" type="text" onkeypress="return /[0-9a-zA-Z_]/i.test(event.key)" style="height:38px">
                            </div>
        
                            <label for="inpCellCssClasses" style="padding:20px 0 3px;">${util.out('Add Css Classes')}:</label>
                            <div>
                                <input id="inpCellCssClasses" class="input-cell-classes" type="text" style="height:38px">
                            </div>

                        </div>

                    
                    </div>
                        
                </div>
                
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      cellSettings = builderStuff.querySelector('.is-modal.columnsettings');
      this.cellSettings = cellSettings;
      this.divCellClick = cellSettings.querySelector('#divCellClick');
      this.divCellGeneral = cellSettings.querySelector('#divCellGeneral');
      let inpCellId = cellSettings.querySelector('.input-cell-id');
      inpCellId.addEventListener('change', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        if (inpCellId.value !== '') {
          cell.setAttribute('id', inpCellId.value);
        } else {
          cell.removeAttribute('id');
        }
        this.builder.opts.onChange();
      });
      let inpCellCssClasses = cellSettings.querySelector('.input-cell-classes');
      inpCellCssClasses.addEventListener('change', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        let arrCurrentClasses = [];
        let currentClasses = cell.getAttribute('data-class');
        if (currentClasses) arrCurrentClasses = currentClasses.split(' ');
        let arrNewClasses = [];
        let newClasses = inpCellCssClasses.value;
        arrNewClasses = newClasses.split(' ');
        arrCurrentClasses.forEach(item => {
          if (!arrNewClasses.includes(item)) {
            cell.classList.remove(item);
          }
        });
        arrNewClasses.forEach(item => {
          if (item !== '') cell.classList.add(item);
        });

        // save
        cell.setAttribute('data-class', newClasses);
        if (cell.getAttribute('data-class') === '') cell.removeAttribute('data-class');
        this.builder.opts.onChange();
      });

      // Column Background color
      let btnCellBgColor = cellSettings.querySelector('.input-cell-bgcolor');
      btnCellBgColor.addEventListener('click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        let elm = e.target;
        this.builder.colorPicker.open(color => {
          let cell = util.cellSelected();
          cell.style.backgroundColor = color;
          elm.style.backgroundColor = color; // preview

          this.builder.opts.onChange();
        }, cellSettings.querySelector('.input-cell-bgcolor').style.backgroundColor, () => {
          btnCellBgColor.removeAttribute('data-focus');
          btnCellBgColor.focus();
        });
        btnCellBgColor.setAttribute('data-focus', true);
      });

      // Column Background Image
      const btnCellBgImage = cellSettings.querySelector('.input-cell-bgimage');
      if (btnCellBgImage) dom.addEventListener(btnCellBgImage, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;

        //Get current value
        let imgUrl = '';
        if (cell.style.backgroundImage) {
          if (cell.style.backgroundImage.indexOf('url(') !== -1) {
            imgUrl = cell.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
          }
        }
        this.openImagePicker(imgUrl, url => {
          let cell = util.cellSelected();
          if (!cell) return;
          this.builder.uo.saveForUndo();
          cell.style.backgroundImage = `url("${url}")`;
          cell.style.backgroundSize = 'cover';
          cell.style.backgroundRepeat = 'no-repeat';
          const div = cellSettings.querySelector('.cell-bgimage-preview');
          const btnImageAdjust = this.cellSettings.querySelector('.input-cell-bgimageadjust');
          const btnImageRemove = this.cellSettings.querySelector('.input-cell-bgremove');
          btnImageAdjust.style.display = 'none';
          btnImageRemove.style.display = 'none';
          if (url !== '') {
            div.innerHTML = `<img src="${url}">`;
            btnImageAdjust.style.display = 'flex';
            btnImageRemove.style.display = 'flex';
          } else {
            div.innerHTML = '';
          }
          this.builder.opts.onChange();
        }, btnCellBgImage);
      });

      // Column Background Image Adjust
      const btnImageAdjust = cellSettings.querySelector('.input-cell-bgimageadjust');
      if (btnImageAdjust) dom.addEventListener(btnImageAdjust, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        this.openImageAdjust(cell, btnImageAdjust);
      });
      let elm = cellSettings.querySelector('.input-cell-bgremove');
      if (elm) dom.addEventListener(elm, 'click', () => {
        let cell = util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        cell.style.backgroundImage = '';
        cell.style.backgroundSize = '';
        cell.style.backgroundRepeat = '';
        cell.style.backgroundPosition = '';
        const div = cellSettings.querySelector('.cell-bgimage-preview');
        const btnImageAdjust = this.cellSettings.querySelector('.input-cell-bgimageadjust');
        const btnImageRemove = this.cellSettings.querySelector('.input-cell-bgremove');
        btnImageAdjust.style.display = 'none';
        btnImageRemove.style.display = 'none';
        div.innerHTML = '';
        this.builder.opts.onChange();
      });

      // Column Background Image Open Asset

      if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
        this.divCellGeneral.querySelector('.input-select').style.display = 'none';
      }
      const btnCellBgImageOpenAsset = this.divCellGeneral.querySelector('.input-select');
      this.builder.renderSelectAsset(btnCellBgImageOpenAsset, 'image', url => {
        let cell = util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        cell.style.backgroundImage = `url("${url}")`;
        cell.style.backgroundSize = 'cover';
        cell.style.backgroundRepeat = 'no-repeat';
        const div = cellSettings.querySelector('.cell-bgimage-preview');
        const btnImageAdjust = this.cellSettings.querySelector('.input-cell-bgimageadjust');
        const btnImageRemove = this.cellSettings.querySelector('.input-cell-bgremove');
        btnImageAdjust.style.display = 'none';
        btnImageRemove.style.display = 'none';
        if (url !== '') {
          div.innerHTML = `<img src="${url}">`;
          btnImageAdjust.style.display = 'flex';
          btnImageRemove.style.display = 'flex';
        } else {
          div.innerHTML = '';
        }
        this.builder.opts.onChange();
      });

      // Row Enlarge (Currently not used)
      let elms = cellSettings.querySelectorAll('.input-row-enlarge');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          this.builder.uo.saveForUndo();
          let val = elm.getAttribute('data-command');
          let cell = util.cellSelected();
          let row = cell.parentNode;
          dom.removeClass(row, 'expand-10');
          dom.removeClass(row, 'expand-20');
          dom.removeClass(row, 'expand-30');
          dom.removeClass(row, 'expand-40');
          dom.removeClass(row, 'expand-50');
          dom.removeClass(row, 'expand-60');
          dom.addClass(row, 'expand-' + val);
          this.builder.opts.onChange();
        });
      });

      // Background gradient
      const gradientPicker = new GradientPicker({
        colors: this.builder.colors,
        gradientcolors: this.builder.opts.gradientcolors,
        lang: this.builder.opts.lang
      });
      let btnCellGradient = cellSettings.querySelector('.input-cell-gradient');
      btnCellGradient.addEventListener('click', () => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        let cell = util.cellSelected();
        gradientPicker.open(cell, () => {
          const btnImageAdjust = this.cellSettings.querySelector('.input-cell-bgimageadjust');
          btnImageAdjust.style.display = 'none';
          const btnImageRemove = this.cellSettings.querySelector('.input-cell-bgremove');
          btnImageRemove.style.display = 'none';
          const div = this.cellSettings.querySelector('.cell-bgimage-preview');
          div.innerHTML = '';
          const inpSrc = this.imageSource.querySelector('.input-src');
          inpSrc.value = '';
          this.builder.opts.onChange();
        }, isChanged => {
          btnCellGradient.removeAttribute('data-focus');
          btnCellGradient.focus();
        });
        btnCellGradient.setAttribute('data-focus', true);
      });
      elms = cellSettings.querySelectorAll('.input-cell-textcolor');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          this.builder.uo.saveForUndo();
          let val = elm.getAttribute('data-command');
          let cell = util.cellSelected();
          if (val === 'dark') {
            dom.removeClass(cell, 'is-light-text');
            dom.addClass(cell, 'is-dark-text');
          } else if (val === 'light') {
            dom.removeClass(cell, 'is-dark-text');
            dom.addClass(cell, 'is-light-text');
          } else {
            dom.removeClass(cell, 'is-dark-text');
            dom.removeClass(cell, 'is-light-text');
          }
          let ns = cell.querySelectorAll('*');
          Array.prototype.forEach.call(ns, n => {
            if (n.style.color) n.style.color = '';
          });
          this.builder.opts.onChange();
        });
      });
      elms = cellSettings.querySelectorAll('.input-cell-padding-pos');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          let val = elm.getAttribute('data-command');
          let ns = this.cellSettings.querySelectorAll('.input-cell-padding-pos');
          Array.prototype.forEach.call(ns, n => {
            dom.removeClass(n, 'on');
          });
          if (val === 'all') {
            dom.addClass(this.cellSettings.querySelector('button[data-command="top"]'), 'on');
            dom.addClass(this.cellSettings.querySelector('button[data-command="left"]'), 'on');
            dom.addClass(this.cellSettings.querySelector('button[data-command="right"]'), 'on');
            dom.addClass(this.cellSettings.querySelector('button[data-command="bottom"]'), 'on');
          } else if (val === 'x') {
            dom.addClass(this.cellSettings.querySelector('button[data-command="left"]'), 'on');
            dom.addClass(this.cellSettings.querySelector('button[data-command="right"]'), 'on');
          } else if (val === 'y') {
            dom.addClass(this.cellSettings.querySelector('button[data-command="top"]'), 'on');
            dom.addClass(this.cellSettings.querySelector('button[data-command="bottom"]'), 'on');
          } else {
            dom.addClass(elm, 'on');
          }
          let btns = this.cellSettings.querySelectorAll('.input-cell-padding');
          Array.prototype.forEach.call(btns, btn => {
            dom.removeClass(btn, 'on');
          });
        });
      });
      elms = cellSettings.querySelectorAll('.input-cell-padding');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          this.builder.uo.saveForUndo();
          let val = elm.getAttribute('data-command');
          let cell = util.cellSelected();
          let ns = this.cellSettings.querySelectorAll('.input-cell-padding');
          Array.prototype.forEach.call(ns, n => {
            dom.removeClass(n, 'on');
          });
          if (this.builder.useCssClasses) {
            // Clean old classes
            dom.removeClass(cell, 'padding-0');
            dom.removeClass(cell, 'padding-10');
            dom.removeClass(cell, 'padding-20');
            dom.removeClass(cell, 'padding-30');
            dom.removeClass(cell, 'padding-40');
            dom.removeClass(cell, 'padding-50');
            dom.removeClass(cell, 'padding-60');
            let command;
            let btns = this.cellSettings.querySelectorAll('.input-cell-padding-pos.on');
            if (btns.length === 2) {
              // x or y selected
              command = btns[0].getAttribute('data-command');
              if (command === 'left') {
                // x selected

                let classes = this.builder.cssClasses.padding.left;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                classes = this.builder.cssClasses.padding.right;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                classes = this.builder.cssClasses.padding.x;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.x[`px_${val}`]);
              } else {
                // y selected

                let classes = this.builder.cssClasses.padding.top;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                classes = this.builder.cssClasses.padding.bottom;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                classes = this.builder.cssClasses.padding.y;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.y[`py_${val}`]);
              }
            } else if (btns.length === 4) {
              // all selected

              let classes = this.builder.cssClasses.padding.top;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.bottom;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.left;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.right;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.all;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.x;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              classes = this.builder.cssClasses.padding.y;
              for (let i = 0; i < Object.keys(classes).length; i++) {
                let className = Object.values(classes)[i];
                dom.removeClass(cell, className);
              }
              if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.all[`p_${val}`]);
            } else {
              command = btns[0].getAttribute('data-command');
              if (command === 'top') {
                let classes = this.builder.cssClasses.padding.top;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.top[`pt_${val}`]);
              } else if (command === 'bottom') {
                let classes = this.builder.cssClasses.padding.bottom;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.bottom[`pb_${val}`]);
              } else if (command === 'left') {
                let classes = this.builder.cssClasses.padding.left;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.left[`pl_${val}`]);
              } else if (command === 'right') {
                let classes = this.builder.cssClasses.padding.right;
                for (let i = 0; i < Object.keys(classes).length; i++) {
                  let className = Object.values(classes)[i];
                  dom.removeClass(cell, className);
                }
                if (val !== '') dom.addClass(cell, this.builder.cssClasses.padding.right[`pr_${val}`]);
              }
            }
            dom.addClass(elm, 'on');
          } else {
            dom.removeClass(cell, 'padding-0');
            dom.removeClass(cell, 'padding-10');
            dom.removeClass(cell, 'padding-20');
            dom.removeClass(cell, 'padding-30');
            dom.removeClass(cell, 'padding-40');
            dom.removeClass(cell, 'padding-50');
            dom.removeClass(cell, 'padding-60');
            if (val !== '') {
              dom.addClass(cell, 'padding-' + val);
              dom.addClass(elm, 'on');
            }
          }
          this.builder.opts.onChange();
        });
      });
      const chkCellGrayscale = cellSettings.querySelector('.chk-cell-grayscale');
      dom.addEventListener(chkCellGrayscale, 'click', () => {
        this.builder.uo.saveForUndo();
        let cell = util.cellSelected();
        if (chkCellGrayscale.checked) {
          cell.style.filter = 'grayscale(1)';
        } else {
          if (cell.style.filter) {
            cell.style.filter = cell.style.filter.replace('grayscale(1)', '');
          }
        }
        this.builder.opts.onChange();
      });
      const chkHideColumnOnMobile = cellSettings.querySelector('.chk-cell-hideonmobile');
      dom.addEventListener(chkHideColumnOnMobile, 'click', () => {
        this.builder.uo.saveForUndo();
        let cell = util.cellSelected();
        if (chkHideColumnOnMobile.checked) {
          cell.classList.add('hideonmobile');
        } else {
          cell.classList.remove('hideonmobile');
        }
        this.builder.opts.onChange();
      });
      elms = cellSettings.querySelectorAll('.input-cell-height');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          let arrHeight = this.builder.colHeight;
          this.builder.uo.saveForUndo();
          let val = elm.getAttribute('data-command');
          let cell = util.cellSelected();
          let ns = this.cellSettings.querySelectorAll('.input-cell-height');
          Array.prototype.forEach.call(ns, n => {
            dom.removeClass(n, 'on');
          });
          if (val === '') {
            Array.prototype.forEach.call(arrHeight, h => {
              dom.removeClass(cell, 'min-height-' + h);
            });
          } else if (val === '-') {
            let offHeight = cell.offsetHeight;
            Array.prototype.forEach.call(arrHeight, h => {
              if (offHeight - h > 0 && offHeight - h <= 50) {
                Array.prototype.forEach.call(arrHeight, h => {
                  dom.removeClass(cell, 'min-height-' + h);
                });
                dom.addClass(cell, 'min-height-' + h);
                if (h === 300) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="300"');
                  dom.addClass(btn, 'on');
                } else if (h === 400) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="400"');
                  dom.addClass(btn, 'on');
                } else if (h === 500) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="500"');
                  dom.addClass(btn, 'on');
                } else if (h === 600) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="600"');
                  dom.addClass(btn, 'on');
                } else if (h === 700) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="700"');
                  dom.addClass(btn, 'on');
                }
              }
            });
          } else if (val === '+') {
            let offHeight = cell.offsetHeight;
            Array.prototype.forEach.call(arrHeight, h => {
              if (h - offHeight > 0 && h - offHeight <= 50) {
                Array.prototype.forEach.call(arrHeight, h => {
                  dom.removeClass(cell, 'min-height-' + h);
                });
                dom.addClass(cell, 'min-height-' + h);
                if (h === 300) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="300"');
                  dom.addClass(btn, 'on');
                } else if (h === 400) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="400"');
                  dom.addClass(btn, 'on');
                } else if (h === 500) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="500"');
                  dom.addClass(btn, 'on');
                } else if (h === 600) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="600"');
                  dom.addClass(btn, 'on');
                } else if (h === 700) {
                  let btn = this.cellSettings.querySelector('.input-cell-height[data-command="700"');
                  dom.addClass(btn, 'on');
                }
              }
            });
          } else {
            Array.prototype.forEach.call(arrHeight, h => {
              dom.removeClass(cell, 'min-height-' + h);
            });
            dom.addClass(cell, 'min-height-' + val);
            dom.addClass(elm, 'on');
          }
          this.builder.opts.onChange();
        });
      });
      elms = cellSettings.querySelectorAll('.cmd-content-pos');
      Array.prototype.forEach.call(elms, elm => {
        dom.addEventListener(elm, 'click', () => {
          this.builder.uo.saveForUndo();
          let val = elm.getAttribute('data-pos');
          let cell = util.cellSelected();
          const btns = this.cellSettings.querySelectorAll('.cmd-content-pos');
          Array.prototype.forEach.call(btns, n => {
            dom.removeClass(n, 'on');
          });
          if (this.builder.useCssClasses) {
            if (val !== '') {
              let classes = this.builder.cssClasses.display;
              dom.addCssClass(cell, classes.flex, classes);
              classes = this.builder.cssClasses.flexDirection;
              dom.addCssClass(cell, classes.column, classes);
              if (val === 'topleft') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.start, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.start, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'topcenter') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.start, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.center, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'topright') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.start, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.end, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'centerleft') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.center, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.start, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'center') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.center, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.center, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'centerright') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.center, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.end, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'bottomleft') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.end, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.start, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'bottomcenter') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.end, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.center, classes);
                dom.addClass(elm, 'on');
              }
              if (val === 'bottomright') {
                let classes = this.builder.cssClasses.justifyContent;
                dom.addCssClass(cell, classes.end, classes);
                classes = this.builder.cssClasses.alignItems;
                dom.addCssClass(cell, classes.end, classes);
                dom.addClass(elm, 'on');
              }
              cell.style.justifyContent = '';
              cell.style.alignItems = '';
            } else {
              dom.removeCssClasses(cell, this.builder.cssClasses.display);
              dom.removeCssClasses(cell, this.builder.cssClasses.flexDirection);
              dom.removeCssClasses(cell, this.builder.cssClasses.justifyContent);
              dom.removeCssClasses(cell, this.builder.cssClasses.alignItems);
              cell.style.display = '';
              cell.style.flexDirection = '';
              cell.style.justifyContent = '';
              cell.style.alignItems = '';
            }
          } else {
            cell.style.display = 'flex';
            cell.style.flexDirection = 'column';
            if (val === 'topleft') {
              cell.style.justifyContent = 'flex-start';
              cell.style.alignItems = 'flex-start';
              dom.addClass(elm, 'on');
            }
            if (val === 'topcenter') {
              cell.style.justifyContent = 'flex-start';
              cell.style.alignItems = 'center';
              dom.addClass(elm, 'on');
            }
            if (val === 'topright') {
              cell.style.justifyContent = 'flex-start';
              cell.style.alignItems = 'flex-end';
              dom.addClass(elm, 'on');
            }
            if (val === 'centerleft') {
              cell.style.justifyContent = 'center';
              cell.style.alignItems = 'flex-start';
              dom.addClass(elm, 'on');
            }
            if (val === 'center') {
              cell.style.justifyContent = 'center';
              cell.style.alignItems = 'center';
              dom.addClass(elm, 'on');
            }
            if (val === 'centerright') {
              cell.style.justifyContent = 'center';
              cell.style.alignItems = 'flex-end';
              dom.addClass(elm, 'on');
            }
            if (val === 'bottomleft') {
              cell.style.justifyContent = 'flex-end';
              cell.style.alignItems = 'flex-start';
              dom.addClass(elm, 'on');
            }
            if (val === 'bottomcenter') {
              cell.style.justifyContent = 'flex-end';
              cell.style.alignItems = 'center';
              dom.addClass(elm, 'on');
            }
            if (val === 'bottomright') {
              cell.style.justifyContent = 'flex-end';
              cell.style.alignItems = 'flex-end';
              dom.addClass(elm, 'on');
            }
          }
          this.builder.opts.onChange();
        });
      });

      // Click to Open Image Select Dialog (.is-modal.columnsettings)

      if (this.builder.opts.onOtherSelectClick || this.builder.opts.otherSelect !== '') {
        this.cellSettings.querySelector('.input-select-other').style.display = 'flex';
        let inputSelectOther = this.cellSettings.querySelector('.input-select-other');
        dom.addEventListener(inputSelectOther, 'click', e => {
          if (this.builder.opts.onOtherSelectClick) {
            this.builder.opts.onOtherSelectClick({
              targetInput: this.cellSettings.querySelector('.input-src'),
              theTrigger: this.cellSettings.querySelector('.input-select-other')
            });
          } else {
            let modalFileSelect = builderStuff.querySelector('.is-modal.otherselect');
            if (this.builder.opts.assetRefresh) {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
              this.builder.opts.assetRefresh = false;
            }
            if (modalFileSelect.querySelector('iframe').src === 'about:blank') {
              modalFileSelect.querySelector('iframe').src = this.builder.opts.otherSelect;
            }
            util.showModal(modalFileSelect, false, () => {
              inputSelectOther.removeAttribute('data-focus');
              inputSelectOther.focus();
            }, false, this.builder.assetPanelFullScreen);
            inputSelectOther.setAttribute('data-focus', true);
          }
          this.builder.targetInput = this.cellSettings.querySelector('.input-src'); // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = () => {
            this.applyClick();
          };
          this.builder.targetAssetType = 'all';
          e.preventDefault();
          e.stopImmediatePropagation();
        });
      }
      if (this.builder.opts.largerImageHandler === '' && !this.builder.opts.onLargerImageUpload) {
        this.cellSettings.querySelector('.image-larger4').style.display = 'none';
      }
      if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
        this.divCellClick.querySelector('.input-select').style.display = 'none';
      }

      // Select image (opens Asset Manager plugin or custom dialog)
      if (this.builder.opts.onMediaSelectClick || this.builder.opts.mediaSelect || this.builder.opts.onImageSelectClick || this.builder.opts.imageselect) {
        const inpSrc = this.cellSettings.querySelector('.input-src');
        elm = this.divCellClick.querySelector('.input-select');
        if (elm) dom.addEventListener(elm, 'click', () => {
          //TODO: Simplify using openAsset

          //---default
          this.builder.targetInput = inpSrc; // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = () => {
            this.applyClick();
          };
          this.builder.targetAssetType = 'media';
          //---/default

          if (this.builder.opts.onMediaSelectClick) {
            this.builder.opts.onMediaSelectClick({
              targetInput: inpSrc,
              theTrigger: elm
            });

            // dom.observeElement(inpSrc, 'value', () => {
            //     this.applyClick();
            // });
          } else if (this.builder.opts.onImageSelectClick) {
            this.builder.opts.onImageSelectClick({
              targetInput: inpSrc,
              theTrigger: elm
            });

            // dom.observeElement(inpSrc, 'value', () => {
            //     this.applyClick();
            // });
          } else if (this.builder.opts.mediaSelect) {
            let modalMediaSelect = builderStuff.querySelector('.is-modal.mediaselect');
            let iframe = modalMediaSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.mediaSelect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.mediaSelect;
            }
            util.showModal(modalMediaSelect, false, () => {
              elm.removeAttribute('data-focus');
              elm.focus();
            }, false, this.builder.assetPanelFullScreen);
            elm.setAttribute('data-focus', true);
            this.builder.targetInput = inpSrc; // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = () => {
              this.applyClick();
            };
            this.builder.targetAssetType = 'media';
          } else if (this.builder.opts.imageselect) {
            let modalImageSelect = builderStuff.querySelector('.is-modal.imageselect');
            let iframe = modalImageSelect.querySelector('iframe');
            if (this.builder.opts.assetRefresh) {
              iframe.src = this.builder.opts.imageselect;
              this.builder.opts.assetRefresh = false;
            }
            if (iframe.src === 'about:blank') {
              iframe.src = this.builder.opts.imageselect;
            }
            util.showModal(modalImageSelect, false, () => {
              elm.removeAttribute('data-focus');
              elm.focus();
            }, false, this.builder.assetPanelFullScreen);
            elm.setAttribute('data-focus', true);
            this.builder.targetInput = inpSrc; // used by selectAsset() (see contentbuilder.js)
            this.builder.targetCallback = () => {
              this.applyClick();
            };
            this.builder.targetAssetType = 'media';
          }
        });
      }
      const inpSrc = this.cellSettings.querySelector('.input-src');
      dom.observeElement(inpSrc, 'value', () => {
        this.applyClick();
      });
      let fileLargerImage2 = this.cellSettings.querySelector('#fileImage4');
      dom.addEventListener(fileLargerImage2, 'change', e => {
        let element = fileLargerImage2;
        while (element.nodeName.toLowerCase() !== 'form') {
          element = element.parentNode;
        }
        let frmUpload = element;
        dom.addClass(frmUpload, 'please-wait');
        this.cellSettings.querySelector('#hidRefId4').value = this.builder.opts.customval;
        if (this.builder.opts.onMediaUpload) {
          this.builder.opts.onMediaUpload(e);
        } else if (this.builder.opts.onLargerImageUpload) {
          this.builder.opts.onLargerImageUpload(e);
        } else {
          frmUpload.submit();
        }
        fileLargerImage2.value = ''; // Clear Input
      });

      const inpClickSrc = this.cellSettings.querySelector('.input-src');
      inpClickSrc.addEventListener('focus', () => {
        this.builder.uo.saveForUndo(true); // checkLater = true
      });
      // this.util.attachInputTextClear(inpClickSrc);

      inpClickSrc.addEventListener('keyup', () => {
        let cell = this.util.cellSelected();
        if (!cell) return;
        if (inpClickSrc.value === '') {
          // Remove click
          dom.removeClass(cell, 'block-click');
          cell.removeAttribute('data-modal-url');
        } else {
          dom.addClass(cell, 'block-click');
          cell.setAttribute('data-modal-url', inpClickSrc.value);
        }
        this.builder.opts.onChange();
      });
      let btnTestClick = this.cellSettings.querySelector('.input-testclick');
      btnTestClick.addEventListener('click', () => {
        let cell = this.util.cellSelected();
        if (!cell) return;
        if (inpClickSrc.value === '') return;
        this.builder.openMedia(cell);
      });

      // Responsive Visibility

      let btns = this.cellSettings.querySelectorAll('.input-device');
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let cell = this.util.cellSelected();
          if (!cell) return;
          let elms = this.cellSettings.querySelectorAll('.input-device');
          elms.forEach(elm => {
            elm.classList.remove('on');
          });
          btn.classList.add('on');
          this.realtimeVisibility(cell);
        });
      });
      let btnVisible = this.cellSettings.querySelector('.input-visible');
      let btnHidden = this.cellSettings.querySelector('.input-hidden');
      const rowHasHiddenColumns = (row, target) => {
        let cols = row.querySelectorAll(`.${target}-hidden`);
        return cols.length > 0;
      };
      btnVisible.addEventListener('click', () => {
        let cell = this.util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        cell.classList.remove('hideonmobile');
        let divTarget = this.cellSettings.querySelector('.div-target');
        let target = this.builder.responsive.readTarget(divTarget);
        if (target === 'xs') {
          cell.classList.remove('xs-hidden');
        } else if (target === 'sm') {
          cell.classList.remove('sm-hidden');
          if (!rowHasHiddenColumns(cell.parentNode, 'sm')) cell.parentNode.classList.remove('sm-autofit');
        } else if (target === 'md') {
          cell.classList.remove('md-hidden');
          if (!rowHasHiddenColumns(cell.parentNode, 'md')) cell.parentNode.classList.remove('md-autofit');
        } else if (target === '') {
          cell.classList.remove('desktop-hidden');
          if (!rowHasHiddenColumns(cell.parentNode, 'desktop')) cell.parentNode.classList.remove('desktop-autofit');
        }
        btnVisible.classList.add('on');
        btnHidden.classList.remove('on');
        this.builder.opts.onChange();
      });
      btnHidden.addEventListener('click', () => {
        let cell = this.util.cellSelected();
        if (!cell) return;
        this.builder.uo.saveForUndo();
        cell.classList.remove('hideonmobile');
        let divTarget = this.cellSettings.querySelector('.div-target');
        let target = this.builder.responsive.readTarget(divTarget);
        if (target === 'xs') {
          cell.classList.add('xs-hidden');
        } else if (target === 'sm') {
          cell.classList.add('sm-hidden');
          cell.parentNode.classList.add('sm-autofit');
        } else if (target === 'md') {
          cell.classList.add('md-hidden');
          cell.parentNode.classList.add('md-autofit');
        } else if (target === '') {
          cell.classList.add('desktop-hidden');
          cell.parentNode.classList.add('desktop-autofit');
        }
        btnVisible.classList.remove('on');
        btnHidden.classList.add('on');
        this.builder.opts.onChange();
      });
      new Tabs({
        element: cellSettings
      });
      new Draggable$2({
        selector: '.is-modal.columnsettings .is-draggable'
      });
    }
  }
  moveColumnLeft() {
    this.grid.moveColumnPrevious();
  }
  moveColumnRight() {
    this.grid.moveColumnNext();
  }
  duplicateColumn() {
    this.grid.duplicateColumn();
  }
  removeColumn() {
    this.grid.removeColumn();
  }
  moveColumnUp() {
    this.grid.moveColumnUp();
  }
  moveColumnDown() {
    this.grid.moveColumnDown();
  }
  applyClick() {
    const dom = this.dom;
    let cell = this.util.cellSelected();
    if (!cell) return;
    const inpSrc = this.cellSettings.querySelector('.input-src');
    let currValue = cell.getAttribute('data-modal-url');
    if (!currValue) currValue = '';
    let newValue = inpSrc.value;
    if (currValue === newValue) return;
    this.builder.uo.saveForUndo();
    dom.addClass(cell, 'block-click');
    cell.setAttribute('data-modal-url', inpSrc.value);
    this.builder.opts.onChange();
  }
  readCellStyles(cell) {
    const dom = this.dom;
    this.util.clearActiveElement();

    // Background color
    let s = cell.style.backgroundColor;
    let btn = this.cellSettings.querySelector('.input-cell-bgcolor');
    if (s) btn.style.backgroundColor = s;else btn.style.backgroundColor = 'transparent';
    let imgUrl = '';
    const div = this.cellSettings.querySelector('.cell-bgimage-preview');
    const btnImageAdjust = this.cellSettings.querySelector('.input-cell-bgimageadjust');
    btnImageAdjust.style.display = 'none';
    const btnImageRemove = this.cellSettings.querySelector('.input-cell-bgremove');
    btnImageRemove.style.display = 'none';
    if (cell.style.backgroundImage) {
      if (cell.style.backgroundImage.indexOf('url(') !== -1) {
        imgUrl = cell.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        div.innerHTML = `<img src="${imgUrl}">`;
        btnImageAdjust.style.display = 'flex';
        btnImageRemove.style.display = 'flex';
      } else {
        div.innerHTML = '';
      }
    } else {
      div.innerHTML = '';
    }
    const inpClickSrc = this.cellSettings.querySelector('.input-src');
    inpClickSrc.value = '';
    let clickUrl = cell.getAttribute('data-modal-url');
    if (clickUrl) {
      inpClickSrc.value = clickUrl;
    }
    let elms = this.cellSettings.querySelectorAll('.input-cell-padding');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'on');
    });
    if (dom.hasClass(cell, 'padding-0')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="0"');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(cell, 'padding-10')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="10"');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(cell, 'padding-20')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="20"');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(cell, 'padding-30')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="30"');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(cell, 'padding-40')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="40"');
      dom.addClass(btn, 'on');
    } else if (dom.hasClass(cell, 'padding-50')) {
      let btn = this.cellSettings.querySelector('.input-cell-padding[data-command="50"');
      dom.addClass(btn, 'on');
    }
    const chkCellGrayscale = this.cellSettings.querySelector('.chk-cell-grayscale');
    chkCellGrayscale.checked = false;
    if (cell.style.filter) {
      if (cell.style.filter.indexOf('grayscale') !== -1) {
        chkCellGrayscale.checked = true;
      }
    }
    const chkHideColumnOnMobile = this.cellSettings.querySelector('.chk-cell-hideonmobile');
    chkHideColumnOnMobile.checked = false;
    if (cell.classList.contains('hideonmobile')) {
      chkHideColumnOnMobile.checked = true;
    }
    elms = this.cellSettings.querySelectorAll('.input-cell-height');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'on');
    });
    let minHeight = 0;
    let arrHeight = this.builder.colHeight;
    Array.prototype.forEach.call(arrHeight, h => {
      if (dom.hasClass(cell, 'min-height-' + h)) minHeight = h;
    });
    if (minHeight === 300) {
      let btn = this.cellSettings.querySelector('.input-cell-height[data-command="300"');
      dom.addClass(btn, 'on');
    } else if (minHeight === 400) {
      let btn = this.cellSettings.querySelector('.input-cell-height[data-command="400"');
      dom.addClass(btn, 'on');
    } else if (minHeight === 500) {
      let btn = this.cellSettings.querySelector('.input-cell-height[data-command="500"');
      dom.addClass(btn, 'on');
    } else if (minHeight === 600) {
      let btn = this.cellSettings.querySelector('.input-cell-height[data-command="600"');
      dom.addClass(btn, 'on');
    } else if (minHeight === 700) {
      let btn = this.cellSettings.querySelector('.input-cell-height[data-command="700"');
      dom.addClass(btn, 'on');
    }
    elms = this.cellSettings.querySelectorAll('.cmd-content-pos');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'on');
    });
    let alignItems = cell.style.alignItems;
    let justifyContent = cell.style.justifyContent;
    let pos = '';
    if (justifyContent === 'flex-start') {
      //top
      if (alignItems === 'flex-start') {
        pos = 'topleft';
      } else if (alignItems === 'center') {
        pos = 'topcenter';
      } else if (alignItems === 'flex-end') {
        pos = 'topright';
      }
    } else if (justifyContent === 'center') {
      //top
      if (alignItems === 'flex-start') {
        pos = 'centerleft';
      } else if (alignItems === 'center') {
        pos = 'center';
      } else if (alignItems === 'flex-end') {
        pos = 'centerright';
      }
    } else if (justifyContent === 'flex-end') {
      //top
      if (alignItems === 'flex-start') {
        pos = 'bottomleft';
      } else if (alignItems === 'center') {
        pos = 'bottomcenter';
      } else if (alignItems === 'flex-end') {
        pos = 'bottomright';
      }
    }
    if (pos === 'topleft') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="topleft"');
      dom.addClass(btn, 'on');
    } else if (pos === 'topcenter') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="topcenter"');
      dom.addClass(btn, 'on');
    } else if (pos === 'topright') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="topright"');
      dom.addClass(btn, 'on');
    } else if (pos === 'centerleft') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="centerleft"');
      dom.addClass(btn, 'on');
    } else if (pos === 'center') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="center"');
      dom.addClass(btn, 'on');
    } else if (pos === 'centerright') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="centerright"');
      dom.addClass(btn, 'on');
    } else if (pos === 'bottomleft') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="bottomleft"');
      dom.addClass(btn, 'on');
    } else if (pos === 'bottomcenter') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="bottomcenter"');
      dom.addClass(btn, 'on');
    } else if (pos === 'bottomright') {
      let btn = this.cellSettings.querySelector('.cmd-content-pos[data-pos="bottomright"');
      dom.addClass(btn, 'on');
    }
    this.realtimeVisibility(cell, true);

    //More
    let inpCellId = this.cellSettings.querySelector('.input-cell-id');
    inpCellId.value = '';
    const rowId = cell.getAttribute('id');
    if (rowId) {
      inpCellId.value = rowId;
    }
    let inpCellClasses = this.cellSettings.querySelector('.input-cell-classes');
    inpCellClasses.value = '';
    const classes = cell.getAttribute('data-class');
    inpCellClasses.value = classes;
  }
  realtimeVisibility(cell, initialOpen) {
    if (initialOpen) {
      const builderStuff = this.builder.builderStuff;
      const modal = builderStuff.querySelector('.is-modal.content-preview.active');
      if (modal) {
        let elms = this.cellSettings.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        if (modal.classList.contains('is-screen-1920')) {
          this.cellSettings.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1440')) {
          this.cellSettings.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1024')) {
          this.cellSettings.querySelector('.input-device[data-value="md"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-768')) {
          this.cellSettings.querySelector('.input-device[data-value="sm"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-375')) {
          this.cellSettings.querySelector('.input-device[data-value="xs"]').classList.add('on');
        }
      }
    }
    let divTarget = this.cellSettings.querySelector('.div-target');
    let divVisibility = this.cellSettings.querySelector('.div-visibility');
    let target = this.builder.responsive.readTarget(divTarget);
    let valVisibility = this.builder.responsive.getVisibility(cell, target);
    this.builder.responsive.showVisibility(divVisibility, valVisibility);

    // Live Preview Sync
    if (target === 'xs') {
      if (!initialOpen) this.builder.livePreview.resizePreview(375);
    } else if (target === 'sm') {
      if (!initialOpen) this.builder.livePreview.resizePreview(768);
    } else if (target === 'md') {
      if (!initialOpen) this.builder.livePreview.resizePreview(1024);
    } else {
      if (!initialOpen) this.builder.livePreview.resizePreview(1920);
    }
  }
  openImagePicker(currentUrl, callback, btn) {
    //Current value
    const imageSource = this.imageSource;
    const inpSrc = imageSource.querySelector('.input-src');
    inpSrc.value = currentUrl;

    //imageSelectedCallback
    this.builder.imageSelectedCallback = callback;

    //Show modal
    imageSource.style.zIndex = '10005';
    this.util.showModal(imageSource, false, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    }, false, this.builder.assetPanelFullScreen);
    if (btn) btn.setAttribute('data-focus', true);
  }
  readImageAdjust(elm, useTarget) {
    //Current value
    const imageAdjust = this.imageAdjust;
    const inpImageScaleSlider = imageAdjust.querySelector('.image-scale-slider');
    const inpImageHorSlider = imageAdjust.querySelector('.image-hor-slider');
    const inpImageVertSlider = imageAdjust.querySelector('.image-vert-slider');
    inpImageScaleSlider.value = 100;
    inpImageHorSlider.value = 0;
    inpImageVertSlider.value = 0;
    inpImageScaleSlider.disabled = false;
    if (useTarget) {
      inpImageHorSlider.value = 50;
      inpImageVertSlider.value = 60;
    }
    let div = document.createElement('div');
    if (document.querySelector('.content-preview.is-screen-375.active') && useTarget) {
      let dataBg = elm.getAttribute('data-bg-xs');
      if (!dataBg) dataBg = '';
      div.style.cssText = dataBg;
      inpImageScaleSlider.disabled = true;
      inpImageScaleSlider.style.opacity = 0.6;
    } else if (document.querySelector('.content-preview.is-screen-768.active') && useTarget) {
      let dataBg = elm.getAttribute('data-bg-sm');
      if (!dataBg) dataBg = '';
      div.style.cssText = dataBg;
      inpImageScaleSlider.disabled = true;
      inpImageScaleSlider.style.opacity = 0.6;
    } else if (document.querySelector('.content-preview.is-screen-1024.active') && useTarget) {
      let dataBg = elm.getAttribute('data-bg-md');
      if (!dataBg) dataBg = '';
      div.style.cssText = dataBg;
      inpImageScaleSlider.disabled = true;
      inpImageScaleSlider.style.opacity = 0.6;
    } else {
      div.style.cssText = elm.style.cssText;
      inpImageScaleSlider.disabled = false;
      inpImageScaleSlider.style.opacity = '';
    }
    if (div.style.backgroundSize) {
      let val;
      let bgSize = div.style.backgroundSize;
      if (isNaN(parseInt(bgSize))) {
        val = 100;
      } else {
        val = parseInt(bgSize);
      }
      if (bgSize.indexOf('%') !== -1) {
        inpImageScaleSlider.value = val;
      }
    }
    if (div.style.backgroundPositionX) {
      let val;
      let bgPosX = div.style.backgroundPositionX;
      if (isNaN(parseInt(bgPosX))) {
        val = 0;
      } else {
        val = parseInt(bgPosX);
      }
      if (bgPosX.indexOf('%') !== -1) {
        inpImageHorSlider.value = val;
      }
    }
    if (div.style.backgroundPositionY) {
      let val;
      let bgPosY = div.style.backgroundPositionY;
      if (isNaN(parseInt(bgPosY))) {
        val = 0;
      } else {
        val = parseInt(bgPosY);
      }
      if (bgPosY.indexOf('%') !== -1) {
        inpImageVertSlider.value = val;
      }
    }

    //elementSelected
    this.builder.elementSelected = elm;
  }
  openImageAdjust(elm, btn, useTarget) {
    if (useTarget) this.useTarget = true;else this.useTarget = false;
    const divTarget = this.imageAdjust.querySelector('.div-target');
    if (useTarget) {
      divTarget.style.display = 'flex';
    } else {
      divTarget.style.display = 'none';
    }
    const modal = this.builderStuff.querySelector('.is-modal.content-preview');
    let elms = this.imageAdjust.querySelectorAll('.input-device');
    elms.forEach(elm => {
      elm.classList.remove('on');
    });
    if (!modal.classList.contains('active')) {
      this.imageAdjust.querySelector('.input-device[data-value=""]').classList.add('on');
    }
    this.readImageAdjust(elm, useTarget);

    //Show modal
    this.imageAdjust.style.zIndex = '10005';
    this.util.showModal(this.imageAdjust, false, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    });
    if (btn) btn.setAttribute('data-focus', true);
    this.realtimeImageAdjust(true);
  }
  realtimeImageAdjust(initialOpen) {
    if (initialOpen) {
      const builderStuff = this.builder.builderStuff;
      const modal = builderStuff.querySelector('.is-modal.content-preview.active');
      if (modal) {
        let elms = this.imageAdjust.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        if (modal.classList.contains('is-screen-1920')) {
          this.imageAdjust.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1440')) {
          this.imageAdjust.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1024')) {
          this.imageAdjust.querySelector('.input-device[data-value="md"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-768')) {
          this.imageAdjust.querySelector('.input-device[data-value="sm"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-375')) {
          this.imageAdjust.querySelector('.input-device[data-value="xs"]').classList.add('on');
        }
      }
    }
    let divTarget = this.imageAdjust.querySelector('.div-target');
    let target = this.builder.responsive.readTarget(divTarget);

    // Live Preview Sync
    if (target === 'xs') {
      if (!initialOpen) this.builder.livePreview.resizePreview(375);
    } else if (target === 'sm') {
      if (!initialOpen) this.builder.livePreview.resizePreview(768);
    } else if (target === 'md') {
      if (!initialOpen) this.builder.livePreview.resizePreview(1024);
    } else {
      if (!initialOpen) this.builder.livePreview.resizePreview(1920);
    }
  }
  resetImage(elm) {
    //Current value
    const imageAdjust = this.imageAdjust;
    const inpImageScaleSlider = imageAdjust.querySelector('.image-scale-slider');
    const inpImageHorSlider = imageAdjust.querySelector('.image-hor-slider');
    const inpImageVertSlider = imageAdjust.querySelector('.image-vert-slider');
    inpImageHorSlider.value = 50;
    inpImageVertSlider.value = 60;
    inpImageScaleSlider.value = 0;
    if (elm.classList.contains('cell-active') || elm.classList.contains('is-row-overlay')) {
      inpImageHorSlider.value = 0;
      inpImageVertSlider.value = 0;
    }
    elm.style.backgroundPositionX = '';
    elm.style.backgroundPositionY = '';
    elm.style.backgroundSize = 'cover';

    // Clean unused
    elm.style.left = '';
    elm.style.top = '';
    elm.style.width = '';
    elm.style.height = '';
    elm.removeAttribute('data-x');
    elm.removeAttribute('data-y');
    elm.removeAttribute('data-scale');
    elm.removeAttribute('data-bg-xs');
    elm.removeAttribute('data-bg-sm');
    elm.removeAttribute('data-bg-md');
  }
  resetImage2(elm) {
    //Current value
    const imageAdjust2 = this.imageAdjust2;
    const inpImageScaleSlider = imageAdjust2.querySelector('.image-scale-slider');
    const inpImageHorSlider = imageAdjust2.querySelector('.image-hor-slider');
    const inpImageVertSlider = imageAdjust2.querySelector('.image-vert-slider');
    let overlayDimension = {
      width: elm.parentNode.offsetWidth,
      height: elm.parentNode.offsetHeight
    };
    let dimension, image;
    image = new Image();
    image.src = elm.style.backgroundImage.replace(/"/g, '').replace(/url\(|\)$/ig, '');
    image.onload = () => {
      dimension = {
        width: image.naturalWidth,
        height: image.naturalHeight
      };
      this.dimension = dimension;
      if (overlayDimension.width / overlayDimension.height <= dimension.width / dimension.height) {
        this.scaleWidth = true;
        this.scaleHeight = false;

        // let h = overlayDimension.height; //px
        let w = overlayDimension.height * (dimension.width / dimension.height);
        w = w / overlayDimension.width * 100; //%

        if (!elm.style.width) {
          elm.style.width = w + '%';
          elm.style.height = '';
        }
        inpImageScaleSlider.min = w;
        let val = -(w - 100) * 0.5;
        inpImageHorSlider.value = val; //50%
        elm.style.left = val + '%';
        elm.setAttribute('data-x', val);
        inpImageVertSlider.value = 0;
        elm.style.top = '0%';
        elm.setAttribute('data-y', 0);
        inpImageScaleSlider.value = w;
        elm.style.width = w + '%';
        elm.setAttribute('data-scale', w);
        elm.style.height = '100%'; //((w*this.dimension.height)/this.dimension.width) + '%';
      } else {
        this.scaleHeight = true;
        this.scaleWidth = false;

        // let w = overlayDimension.width;
        let h = overlayDimension.width * (dimension.height / dimension.width);
        h = h / overlayDimension.height * 100; //%

        if (!elm.style.height) {
          elm.style.height = h + '%';
          elm.style.width = '';
        }
        inpImageScaleSlider.min = h;
        let val = -(h - 100) * 0.6;
        inpImageVertSlider.value = val; //60%
        elm.style.top = val + '%';
        elm.setAttribute('data-y', val);
        inpImageHorSlider.value = 0;
        elm.style.left = '0%';
        elm.setAttribute('data-x', 0);
        inpImageScaleSlider.value = h;
        elm.style.height = h + '%';
        elm.setAttribute('data-scale', h);
        elm.style.width = '100%'; //((h*this.dimension.width)/this.dimension.height) + '%';
      }
    };
  }

  openImageAdjust2(elm, btn) {
    //Current value
    const imageAdjust2 = this.imageAdjust2;
    const inpImageScaleSlider = imageAdjust2.querySelector('.image-scale-slider');
    const inpImageHorSlider = imageAdjust2.querySelector('.image-hor-slider');
    const inpImageVertSlider = imageAdjust2.querySelector('.image-vert-slider');
    inpImageScaleSlider.value = 0;
    inpImageHorSlider.value = 0;
    inpImageVertSlider.value = 15;
    const scale = elm.getAttribute('data-scale');
    if (scale) {
      inpImageScaleSlider.value = scale;
    }
    const posX = elm.getAttribute('data-x');
    if (posX) {
      inpImageHorSlider.value = posX;
    }
    const posY = elm.getAttribute('data-y');
    if (posY) {
      inpImageVertSlider.value = posY;
    }
    let overlayDimension = {
      width: elm.parentNode.offsetWidth,
      height: elm.parentNode.offsetHeight
    };
    // console.log(overlayDimension);
    let dimension, image;
    image = new Image();
    image.src = elm.style.backgroundImage.replace(/"/g, '').replace(/url\(|\)$/ig, '');
    image.onload = () => {
      dimension = {
        width: image.naturalWidth,
        height: image.naturalHeight
      };
      this.dimension = dimension;
      // console.log(dimension)
      if (overlayDimension.width / overlayDimension.height <= dimension.width / dimension.height) {
        this.scaleWidth = true;
        this.scaleHeight = false;

        // let h = overlayDimension.height; //px
        let w = overlayDimension.height * (dimension.width / dimension.height);
        w = w / overlayDimension.width * 100; //%

        if (!elm.style.width) {
          elm.style.width = w + '%';
          elm.style.height = '';
        }
        inpImageScaleSlider.min = w;
        if (!posX) {
          inpImageHorSlider.value = -(w - 100) * 0.5; //50%
          elm.style.left = -(w - 100) * 0.5 + '%';
          inpImageVertSlider.value = 0;
        }
        const scale = elm.getAttribute('data-scale');
        if (!scale) {
          inpImageScaleSlider.value = w;
        }
      } else {
        this.scaleHeight = true;
        this.scaleWidth = false;

        // let w = overlayDimension.width;
        let h = overlayDimension.width * (dimension.height / dimension.width);
        h = h / overlayDimension.height * 100; //%

        if (!elm.style.height) {
          elm.style.height = h + '%';
          elm.style.width = '';
        }
        inpImageScaleSlider.min = h;
        if (!posY) {
          inpImageVertSlider.value = -(h - 100) * 0.6; //60%
          elm.style.top = -(h - 100) * 0.6 + '%';
          inpImageHorSlider.value = 0;
        }
        const scale = elm.getAttribute('data-scale');
        if (!scale) {
          inpImageScaleSlider.value = h;
        }
      }
    };

    // const imageAdjust2 = this.imageAdjust2;
    // const inpImageScaleSlider = imageAdjust2.querySelector('.image-scale-slider');
    // const inpImageHorSlider = imageAdjust2.querySelector('.image-hor-slider');
    // const inpImageVertSlider = imageAdjust2.querySelector('.image-vert-slider');
    // inpImageScaleSlider.value = 100;
    // inpImageHorSlider.value = 0;
    // inpImageVertSlider.value = 0;

    // if(elm.style.backgroundSize) {
    //     let val;
    //     let bgSize = elm.style.backgroundSize;
    //     if(isNaN(parseInt(bgSize))) {
    //         val = 100;
    //     } else {
    //         val = parseInt(bgSize);
    //     }
    //     if(bgSize.indexOf('%')!==-1) {
    //         inpImageScaleSlider.value = val;
    //     }
    // }

    // if(elm.style.backgroundPositionX) {
    //     let val;
    //     let bgPosX = elm.style.backgroundPositionX;
    //     if(isNaN(parseInt(bgPosX))) {
    //         val = 0;
    //     } else {
    //         val = parseInt(bgPosX);
    //     }
    //     if(bgPosX.indexOf('%')!==-1) {
    //         inpImageHorSlider.value = val;
    //     }
    // }

    // if(elm.style.backgroundPositionY) {
    //     let val;
    //     let bgPosY = elm.style.backgroundPositionY;
    //     if(isNaN(parseInt(bgPosY))) {
    //         val = 0;
    //     } else {
    //         val = parseInt(bgPosY);
    //     }
    //     if(bgPosY.indexOf('%')!==-1) {
    //         inpImageVertSlider.value = val;
    //     }
    // }

    // let img = elm.querySelector('img');
    // if(!img) {

    //     let oFitPosX = 0;
    //     let oFitPosY = 0;
    //     if(elm.style.backgroundPositionX) {
    //         let val;
    //         let bgPosX = elm.style.backgroundPositionX;
    //         if(isNaN(parseInt(bgPosX))) {
    //             val = 0;
    //         } else {
    //             val = parseInt(bgPosX);
    //         }
    //         if(bgPosX.indexOf('%')!==-1) {
    //             inpImageHorSlider.value = val;
    //             oFitPosX = val;
    //         }
    //     }

    //     if(elm.style.backgroundPositionY) {
    //         let val;
    //         let bgPosY = elm.style.backgroundPositionY;
    //         if(isNaN(parseInt(bgPosY))) {
    //             val = 0;
    //         } else {
    //             val = parseInt(bgPosY);
    //         }
    //         if(bgPosY.indexOf('%')!==-1) {
    //             inpImageVertSlider.value = val;
    //             oFitPosY = val;
    //         }
    //     }

    //     const src = elm.style.backgroundImage.replace(/"/g,"").replace(/url\(|\)$/ig, "");
    //     elm.innerHTML = '';
    //     img = document.createElement('img');
    //     img.setAttribute('src', src);
    //     elm.appendChild(img);
    //     img.style.opacity = 0.0001;
    //     img.style.width = '100%';
    //     img.style.height = '100%';
    //     img.style.objectFit = 'cover';
    //     img.style.objectPosition = `${oFitPosX}% ${oFitPosY}%`
    // } else {
    //     let x = img.style.objectPosition.split(' ')[0].replace('%','');
    //     let y = img.style.objectPosition.split(' ')[1].replace('%','');

    //     inpImageHorSlider.value = x;
    //     inpImageVertSlider.value = y;
    // }

    //elementSelected
    this.builder.elementSelected = elm;

    //Show modal
    imageAdjust2.style.zIndex = '10005';
    this.util.showModal(imageAdjust2, false, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    });
    if (btn) btn.setAttribute('data-focus', true);
  }
  showHideLockIndicator(col) {
    const lockIndicator = this.lockIndicator;
    if (col.hasAttribute('data-noedit')) {
      // const top = col.getBoundingClientRect().top + window.pageYOffset;
      // const left = col.getBoundingClientRect().left + window.pageXOffset;

      let top, left;
      if (!this.builder.iframe) {
        top = col.getBoundingClientRect().top + window.pageYOffset;
        left = col.getBoundingClientRect().left + window.pageXOffset;
      } else {
        top = col.getBoundingClientRect().top + this.builder.win.pageYOffset;
        left = col.getBoundingClientRect().left + this.builder.win.pageXOffset;
      }
      const w = col.offsetWidth * this.builder.zoom;
      // const h = col.offsetHeight * this.builder.zoom;
      lockIndicator.style.display = 'flex';
      lockIndicator.style.top = top + 4 + 'px';
      lockIndicator.style.left = left + w - 33 + 'px';
    } else {
      lockIndicator.style.display = '';
    }
  }
  click(col) {
    this.columnTool = col.parentNode.querySelector('.is-col-tool');
    this.columnTool.style.left = col.offsetLeft + 'px';
    this.columnTool.style.top = col.offsetTop + 'px';
    const btnAdd = this.columnTool.querySelector('.cell-add');
    const btnRemove = this.columnTool.querySelector('.cell-remove');
    const btnMore = this.columnTool.querySelector('.cell-more');
    let nogrid = col.closest('[nogrid]');
    if (nogrid) {
      btnAdd.style.display = 'none';
      btnRemove.style.display = 'none';
      btnAdd.setAttribute('disabled', 'disabled');
      btnRemove.setAttribute('disabled', 'disabled');
      if (col.getAttribute('data-html')) {
        btnMore.style.display = 'none';
        btnMore.setAttribute('disabled', 'disabled');
      }
    } else {
      btnAdd.style.display = '';
      btnRemove.style.display = '';
      btnAdd.removeAttribute('disabled');
      btnRemove.removeAttribute('disabled');
    }
    let row = col.parentNode;

    //data-protected
    if (row.hasAttribute('data-protected')) {
      row.querySelector('.is-row-tool').style.display = 'none';
      this.columnTool.style.display = 'none'; // if row protected, then all column protected

      let rowaddtool = row.querySelector('.is-rowadd-tool');
      if (rowaddtool) {
        rowaddtool.style.display = 'none';
      }
    } else {
      this.columnTool.style.display = '';
      //check columnTool buttons if need to show or hide
      let _protected = col.closest('[data-protected]');
      if (_protected) {
        btnAdd.style.display = 'none';
        btnRemove.style.display = 'none';
        btnMore.style.display = 'none';
      } else {
        btnAdd.style.display = '';
        btnRemove.style.display = '';
        btnMore.style.display = '';
      }
    }
    if (col.classList.contains('column-lock')) {
      btnAdd.style.display = 'none';
      btnRemove.style.display = 'none';
    }
  }
}

const dom$g = new Dom();
class ELementStyleEditor {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    let modalStyles = builderStuff.querySelector('.editstyles');
    if (!modalStyles) {
      let html = `
            <div class="is-modal is-modal-content editstyles">
                <div class="is-modal-bar is-draggable">
                    <div class="is-modal-close" role="button" tabindex="0" title="${util.out('Close')}">&#10005;</div>
                </div>
                <div style="padding:12px">
                    <div class="is-settings" style="display:inline-block;width:100%;margin-bottom:0;">
                        <div>${util.out('Style')}:</div>
                        <div>
                            <textarea id="inpElmInlineStyle" style="width:100%;height:256px;margin:0px;border:none;font-size: 14px;line-height: 1.5;letter-spacing: 0;"></textarea>
                        </div>
                    </div>
                    <div class="is-settings" style="display:inline-block;width:100%;margin-bottom:0;">
                        <div>${util.out('Class')}:</div>
                        <div>
                            <input type="text" id="inpElmClassName" value="" style="width:100%;padding-left: 16px;font-family: courier, monospace;font-size: 14px;line-height: 2;letter-spacing: 1px;border:none;"/>
                        </div>
                    </div>
                </div>
            </div>           
            `;
      dom$g.appendHtml(builderStuff, html);
      modalStyles = builderStuff.querySelector('.editstyles');
      let btn = modalStyles.querySelector('.is-modal-close');
      dom$g.addEventListener(btn, 'click', () => {
        dom$g.removeClass(modalStyles, 'active');
        var panel = this.builderStuff.querySelector('.is-side.elementstyles'); // if all close
        if (!dom$g.hasClass(panel, 'active')) {
          let elms = document.querySelectorAll('[data-saveforundo]');
          Array.prototype.forEach.call(elms, elm => {
            elm.removeAttribute('data-saveforundo');
          });
          elms = document.querySelectorAll('.elm-inspected');
          Array.prototype.forEach.call(elms, elm => {
            dom$g.removeClass(elm, 'elm-inspected');
          });
        }
      });
      let inp = modalStyles.querySelector('#inpElmClassName');
      inp.addEventListener('keyup', () => {
        let elm = this.builder.inspectedElement;
        let val = modalStyles.querySelector('#inpElmClassName').value;

        //builder classes
        let bElmActive = false;
        if (dom$g.hasClass(elm, 'elm-active')) {
          bElmActive = true;
        }
        let bCellActive = false;
        if (dom$g.hasClass(elm, 'elm-active')) {
          bCellActive = true;
        }
        let bRowActive = false;
        if (dom$g.hasClass(elm, 'row-active')) {
          bRowActive = true;
        }
        elm.setAttribute('class', val); //update

        //builder classes
        if (bElmActive) dom$g.addClass(elm, 'elm-active');
        if (bCellActive) dom$g.addClass(elm, 'cell-active');
        if (bRowActive) dom$g.addClass(elm, 'row-active');
        dom$g.addClass(elm, 'elm-inspected');

        //Trigger Change event
        this.builder.opts.onChange();
      });
      inp = modalStyles.querySelector('#inpElmInlineStyle');
      inp.addEventListener('keyup', () => {
        this.builder.inspectedElement.style.cssText = modalStyles.querySelector('#inpElmInlineStyle').value;

        //Trigger Change event
        this.builder.opts.onChange();
      });
    }
    this.modalStyles = modalStyles;
  }
  toggleStyleEditor() {
    if (!dom$g.hasClass(this.modalStyles, 'active')) {
      dom$g.addClass(this.modalStyles, 'active');
    } else {
      dom$g.removeClass(this.modalStyles, 'active');
    }
  }
  refresh() {
    this.modalStyles.querySelector('#inpElmInlineStyle').value = this.builder.inspectedElement.style.cssText;
    let s = this.builder.inspectedElement.getAttribute('class');
    if (s) {
      s = s.replace('elm-active', '');
      s = s.replace('cell-active', '');
      s = s.replace('row-active', '');
      s = s.replace('elm-inspected', '');
      s = s.replace('  ', ' ').trim();
    }
    this.modalStyles.querySelector('#inpElmClassName').value = s;
  }
}

const dom$f = new Dom();
class ElementGeneralStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementGeneral');
    this.panelStuff = panelStuff;
    const html = `
                <div class="is-settings" style="width: 100%">
                    <div class="is-label" style="margin:0 0 3px">${util.out('Background Color')}:</div>
                    <div>
                        <button title="${util.out('Background Color')}" class="input-elm-bgcolor is-btn-color" style="margin-right:15px"></button>
                        <button title="${util.out('Gradient')}" class="input-elm-gradient classic" data-value="+"> ${util.out('Gradient')} </button>
                    </div>
                </div>

                <div style="padding-top:20px;padding-bottom: 3px;">${util.out('Background Image')}:</div>
                <div class="is-settings" style="width: 100%">
                    <div class="elm-bgimage-preview"></div>
                    <div style="display: flex">
                        <button title="${util.out('Image')}" class="input-elm-bgimage">
                            <svg class="is-icon-flex"><use xlink:href="#ion-image"></use></svg>
                            <span style="margin-left: 5px;">${util.out('Image')}</span>
                        </button>
                        <button title="${util.out('Select')}" class="input-select">
                            ${this.builder.opts.selectIcon}
                        </button>
                        <button title="${util.out('Remove')}" class="input-elm-bgremove"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                        <button title="${util.out('Adjust')}" class="input-elm-bgimageadjust" style="width:40px"><svg class="is-icon-flex" style="width:13px;height:13px;flex:none"><use xlink:href="#ion-wrench"></use></svg></button>
                    </div>
                </div>

                <div class="is-settings" style="padding-top:20px;width: 100%">
                    <label class="label-elm-grayscale label-checkbox" for="chkElmGrayscale"><input id="chkElmGrayscale" class="chk-elm-grayscale" type="checkbox" /> ${util.out('Grayscale')}</label>
                </div>

                <div class="is-separator" style="margin-top:28px;margin-bottom:5px;"></div>
                         
                <div class="is-settings" style="padding-top:0;margin-top:0;width: 100%">
                    <div class="div-target" style="display: flex;justify-content: flex-end;padding: 5px 0 0;">
                        <button title="${util.out('Desktop')}" class="input-device on" data-value="" style="width:40px;height:25px;">
                            <svg class="is-icon-flex" style="width:16px;height:16px;flex:none"><use xlink:href="#icon-device-desktop"></use></svg>
                        </button>
                        <!--<button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                            <svg class="is-icon-flex" style="width:19px;height:19px;flex:none"><use xlink:href="#icon-device-laptop"></use></svg>
                        </button>-->
                        <button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                            <svg class="is-icon-flex" style="width:16px;height:16px;flex:none;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                        </button>
                        <button title="${util.out('Tablet (Portrait)')}" class="input-device" data-value="sm" style="width:40px;height:25px;">
                            <svg class="is-icon-flex" style="width:16px;height:16px;flex:none"><use xlink:href="#icon-device-tablet"></use></svg>
                        </button>
                        <button title="${util.out('Mobile')}" class="input-device" data-value="xs" style="width:40px;height:25px;">
                            <svg class="is-icon-flex" style="width:13px;height:13px;flex:none"><use xlink:href="#icon-device-mobile"></use></svg>
                        </button>
                    </div>

                    <div style="padding-top:0;padding-bottom:3px;">${util.out('Visibility')}:</div>
                    <div class="div-visibility" style="display:flex;">
                        <button title="${util.out('Visible')}" class="input-visible on" data-value="sm" style="width:100px;height:34px;">
                            <svg class="is-icon-flex" style="width:16px;height:16px;flex:none"><use xlink:href="#icon-eye"></use></svg>
                            <span>${util.out('Visible')}</span>
                        </button>
                        <button title="${util.out('Hidden')}" class="input-hidden" data-value="xs" style="width:100px;height:34px;">
                            <svg class="is-icon-flex" style="width:16px;height:16px;flex:none"><use xlink:href="#icon-eye-off"></use></svg>
                            <span>${util.out('Hidden')}</span>
                        </button>
                    </div>
                </div>


        `;
    dom$f.appendHtml(panelStuff, html);

    // Background color
    let btnElmBgColor = panelStuff.querySelector('.input-elm-bgcolor');
    btnElmBgColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.backgroundColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, panelStuff.querySelector('.input-elm-bgcolor').style.backgroundColor, () => {
        btnElmBgColor.removeAttribute('data-focus');
        btnElmBgColor.focus();
      });
      btnElmBgColor.setAttribute('data-focus', true);
    });

    // Background gradient
    const gradientPicker = new GradientPicker({
      colors: this.builder.colors,
      gradientcolors: this.builder.opts.gradientcolors,
      lang: this.builder.opts.lang
    });
    let btnElmGradient = panelStuff.querySelector('.input-elm-gradient');
    btnElmGradient.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      gradientPicker.open(this.builder.inspectedElement, () => {
        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, isChanged => {
        if (isChanged) {
          elementStyleEditor.refresh();
        }
        btnElmGradient.removeAttribute('data-focus');
        btnElmGradient.focus();
      });
      btnElmGradient.setAttribute('data-focus', true);
    });

    // Elm Background Image
    const btnElmBgImage = panelStuff.querySelector('.input-elm-bgimage');
    if (btnElmBgImage) dom$f.addEventListener(btnElmBgImage, 'click', () => {
      const elm = this.builder.inspectedElement;

      //Get current value
      let imgUrl = '';
      if (elm.style.backgroundImage) {
        if (elm.style.backgroundImage.indexOf('url(') !== -1) {
          imgUrl = elm.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      }
      this.builder.colTool.openImagePicker(imgUrl, url => {
        this.builder.uo.saveForUndo();
        const elm = this.builder.inspectedElement;
        this.builder.uo.saveForUndo();
        elm.style.backgroundImage = `url("${url}")`;
        elm.style.backgroundSize = 'cover';
        elm.style.backgroundRepeat = 'no-repeat';
        const div = panelStuff.querySelector('.elm-bgimage-preview');
        const btnImageAdjust = this.panelStuff.querySelector('.input-elm-bgimageadjust');
        const btnImageRemove = this.panelStuff.querySelector('.input-elm-bgremove');
        btnImageAdjust.style.display = 'none';
        btnImageRemove.style.display = 'none';
        if (url !== '') {
          div.innerHTML = `<img src="${url}">`;
          btnImageAdjust.style.display = 'flex';
          btnImageRemove.style.display = 'flex';
        } else {
          div.innerHTML = '';
        }
        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBgImage);
    });

    // Elm Background Image Adjust
    const btnImageAdjust = panelStuff.querySelector('.input-elm-bgimageadjust');
    if (btnImageAdjust) dom$f.addEventListener(btnImageAdjust, 'click', () => {
      const elm = this.builder.inspectedElement;
      this.builder.colTool.openImageAdjust(elm, btnImageAdjust);
    });
    const btnImageRemove = panelStuff.querySelector('.input-elm-bgremove');
    if (btnImageRemove) dom$f.addEventListener(btnImageRemove, 'click', () => {
      const elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      elm.style.backgroundImage = '';
      elm.style.backgroundSize = '';
      elm.style.backgroundRepeat = '';
      elm.style.backgroundPosition = '';
      const div = panelStuff.querySelector('.elm-bgimage-preview');
      const btnImageAdjust = this.panelStuff.querySelector('.input-elm-bgimageadjust');
      const btnImageRemove = this.panelStuff.querySelector('.input-elm-bgremove');
      btnImageAdjust.style.display = 'none';
      btnImageRemove.style.display = 'none';
      div.innerHTML = '';
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Elm Background Image Open Asset

    if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
      panelStuff.querySelector('.input-select').style.display = 'none';
    }
    const btnElmBgImageOpenAsset = panelStuff.querySelector('.input-select');
    this.builder.renderSelectAsset(btnElmBgImageOpenAsset, 'image', url => {
      const elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      elm.style.backgroundImage = `url("${url}")`;
      elm.style.backgroundSize = 'cover';
      elm.style.backgroundRepeat = 'no-repeat';
      const div = panelStuff.querySelector('.elm-bgimage-preview');
      const btnImageAdjust = this.panelStuff.querySelector('.input-elm-bgimageadjust');
      const btnImageRemove = this.panelStuff.querySelector('.input-elm-bgremove');
      btnImageAdjust.style.display = 'none';
      btnImageRemove.style.display = 'none';
      if (url !== '') {
        div.innerHTML = `<img src="${url}">`;
        btnImageAdjust.style.display = 'flex';
        btnImageRemove.style.display = 'flex';
      } else {
        div.innerHTML = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const chkElmGrayscale = panelStuff.querySelector('.chk-elm-grayscale');
    chkElmGrayscale.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      const elm = this.builder.inspectedElement;
      if (chkElmGrayscale.checked) {
        elm.style.filter = 'grayscale(1)';
      } else {
        if (elm.style.filter) {
          elm.style.filter = elm.style.filter.replace('grayscale(1)', '');
        }
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Responsive Visibility

    let btns = panelStuff.querySelectorAll('.input-device');
    btns.forEach(btn => {
      btn.addEventListener('click', () => {
        const elm = this.builder.inspectedElement;
        let elms = panelStuff.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        btn.classList.add('on');
        this.realtimeVisibility(elm);
      });
    });
    let btnVisible = panelStuff.querySelector('.input-visible');
    let btnHidden = panelStuff.querySelector('.input-hidden');
    btnVisible.addEventListener('click', () => {
      const elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      elm.classList.remove('hideonmobile');
      let divTarget = panelStuff.querySelector('.div-target');
      let target = this.builder.responsive.readTarget(divTarget);
      if (target === 'xs') {
        elm.classList.remove('xs-hidden');
      } else if (target === 'sm') {
        elm.classList.remove('sm-hidden');
      } else if (target === 'md') {
        elm.classList.remove('md-hidden');
      } else if (target === '') {
        elm.classList.remove('desktop-hidden');
      }
      btnVisible.classList.add('on');
      btnHidden.classList.remove('on');

      //Trigger Change event
      this.builder.opts.onChange();
    });
    btnHidden.addEventListener('click', () => {
      const elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      elm.classList.remove('hideonmobile');
      let divTarget = panelStuff.querySelector('.div-target');
      let target = this.builder.responsive.readTarget(divTarget);
      if (target === 'xs') {
        elm.classList.add('xs-hidden');
      } else if (target === 'sm') {
        elm.classList.add('sm-hidden');
      } else if (target === 'md') {
        elm.classList.add('md-hidden');
      } else if (target === '') {
        elm.classList.add('desktop-hidden');
      }
      btnVisible.classList.remove('on');
      btnHidden.classList.add('on');

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;

    // Background color
    let s = elm.style.backgroundColor;
    let btn = panelStuff.querySelector('.input-elm-bgcolor');
    if (s) btn.style.backgroundColor = s;else btn.style.backgroundColor = 'transparent';

    // Background image
    let imgUrl = '';
    const div = panelStuff.querySelector('.elm-bgimage-preview');
    const btnImageAdjust = panelStuff.querySelector('.input-elm-bgimageadjust');
    btnImageAdjust.style.display = 'none';
    const btnImageRemove = panelStuff.querySelector('.input-elm-bgremove');
    btnImageRemove.style.display = 'none';
    if (elm.style.backgroundImage) {
      if (elm.style.backgroundImage.indexOf('url(') !== -1) {
        imgUrl = elm.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        div.innerHTML = `<img src="${imgUrl}">`;
        btnImageAdjust.style.display = 'flex';
        btnImageRemove.style.display = 'flex';
      } else {
        div.innerHTML = '';
      }
    } else {
      div.innerHTML = '';
    }
    const chkRowGrayscale = panelStuff.querySelector('.chk-elm-grayscale');
    chkRowGrayscale.checked = false;
    if (elm.style.filter) {
      if (elm.style.filter.indexOf('grayscale') !== -1) {
        chkRowGrayscale.checked = true;
      }
    }
    this.realtimeVisibility(elm, true);
  }
  realtimeVisibility(row, initialOpen) {
    if (initialOpen) {
      const builderStuff = this.builder.builderStuff;
      const modal = builderStuff.querySelector('.is-modal.content-preview.active');
      if (modal) {
        let elms = this.panelStuff.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        if (modal.classList.contains('is-screen-1920')) {
          this.panelStuff.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1440')) {
          this.panelStuff.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1024')) {
          this.panelStuff.querySelector('.input-device[data-value="md"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-768')) {
          this.panelStuff.querySelector('.input-device[data-value="sm"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-375')) {
          this.panelStuff.querySelector('.input-device[data-value="xs"]').classList.add('on');
        }
      }
    }
    let divTarget = this.panelStuff.querySelector('.div-target');
    let divVisibility = this.panelStuff.querySelector('.div-visibility');
    let target = this.builder.responsive.readTarget(divTarget);
    let valVisibility = this.builder.responsive.getVisibility(row, target);
    this.builder.responsive.showVisibility(divVisibility, valVisibility);

    // Live Preview Sync
    if (target === 'xs') {
      if (!initialOpen) this.builder.livePreview.resizePreview(375);
    } else if (target === 'sm') {
      if (!initialOpen) this.builder.livePreview.resizePreview(768);
    } else if (target === 'md') {
      if (!initialOpen) this.builder.livePreview.resizePreview(1024);
    } else {
      if (!initialOpen) this.builder.livePreview.resizePreview(1920);
    }
  }
}

const dom$e = new Dom();
class ElementBoxStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementBox');
    this.panelStuff = panelStuff;
    const html = `
                <div class="is-settings" style="width:110px">
                    <div><label for="inpElmWidth">${util.out('Width')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmWidth" value="" style="width:45px"/>
                        <select id="inpElmWidthUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div><label for="inpElmHeight">${util.out('Height')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmHeight" value="" style="width:45px"/>
                        <select id="inpElmHeightUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div><label for="inpElmMaxWidth">${util.out('Max Width')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmMaxWidth" value="" style="width:45px"/>
                        <select id="inpElmMaxWidthUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div><label for="inpElmMaxHeight">${util.out('Max Height')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmMaxHeight" value="" style="width:45px"/>
                        <select id="inpElmMaxHeightUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div><label for="inpElmMinWidth">${util.out('Min Width')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmMinWidth" value="" style="width:45px"/>
                        <select id="inpElmMinWidthUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div><label for="inpElmMinHeight">${util.out('Min Height')}:</label></div>
                    <div style="display:flex">
                        <input type="text" id="inpElmMinHeight" value="" style="width:45px"/>
                        <select id="inpElmMinHeightUnit"">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                
                <div class="is-settings" style="width:110px;">
                    <div>${util.out('Overflow x')}:</div>
                    <div>
                        <select id="inpElmOverflowX"">
                            <option value=""></option>
                            <option value="auto">Auto</option>
                            <option value="hidden">Hidden</option>
                        </select>
                    </div>
                </div>
                <div class="is-settings" style="width:110px;">
                    <div>${util.out('Overflow y')}:</div>
                    <div>
                        <select id="inpElmOverflowY"">
                            <option value=""></option>
                            <option value="auto">Auto</option>
                            <option value="hidden">Hidden</option>
                        </select>
                    </div>
                </div>
        `;
    dom$e.appendHtml(panelStuff, html);

    // Others
    let inpElmMaxWidth = panelStuff.querySelector('#inpElmMaxWidth');
    inpElmMaxWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmMaxWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMaxWidth').value;
      let unit = panelStuff.querySelector('#inpElmMaxWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.maxWidth = val + unit;
      } else {
        elm.style.maxWidth = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMaxWidthUnit = panelStuff.querySelector('#inpElmMaxWidthUnit');
    inpElmMaxWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMaxWidth').value;
      let unit = panelStuff.querySelector('#inpElmMaxWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.maxWidth = val + unit;
      } else {
        elm.style.maxWidth = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMaxHeight = panelStuff.querySelector('#inpElmMaxHeight');
    inpElmMaxHeight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmMaxHeight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMaxHeight').value;
      let unit = panelStuff.querySelector('#inpElmMaxHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.maxHeight = val + unit;
      } else {
        elm.style.maxHeight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMaxHeightUnit = panelStuff.querySelector('#inpElmMaxHeightUnit');
    inpElmMaxHeightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMaxHeight').value;
      let unit = panelStuff.querySelector('#inpElmMaxHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.maxHeight = val + unit;
      } else {
        elm.style.maxHeight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMinWidth = panelStuff.querySelector('#inpElmMinWidth');
    inpElmMinWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmMinWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMinWidth').value;
      let unit = panelStuff.querySelector('#inpElmMinWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.minWidth = val + unit;
      } else {
        elm.style.minWidth = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMinWidthUnit = panelStuff.querySelector('#inpElmMinWidthUnit');
    inpElmMinWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMinWidth').value;
      let unit = panelStuff.querySelector('#inpElmMinWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.minWidth = val + unit;
      } else {
        elm.style.minWidth = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMinHeight = panelStuff.querySelector('#inpElmMinHeight');
    inpElmMinHeight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmMinHeight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMinHeight').value;
      let unit = panelStuff.querySelector('#inpElmMinHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.minHeight = val + unit;
      } else {
        elm.style.minHeight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMinHeightUnit = panelStuff.querySelector('#inpElmMinHeightUnit');
    inpElmMinHeightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmMinHeight').value;
      let unit = panelStuff.querySelector('#inpElmMinHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.minHeight = val + unit;
      } else {
        elm.style.minHeight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmWidth = panelStuff.querySelector('#inpElmWidth');
    inpElmWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmWidth').value;
      let unit = panelStuff.querySelector('#inpElmWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.width = val + unit;
      } else {
        elm.style.width = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmWidthUnit = panelStuff.querySelector('#inpElmWidthUnit');
    inpElmWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmWidth').value;
      let unit = panelStuff.querySelector('#inpElmWidthUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.width = val + unit;
      } else {
        elm.style.width = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmHeight = panelStuff.querySelector('#inpElmHeight');
    inpElmHeight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmHeight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmHeight').value;
      let unit = panelStuff.querySelector('#inpElmHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.height = val + unit;
      } else {
        elm.style.height = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmHeightUnit = panelStuff.querySelector('#inpElmHeightUnit');
    inpElmHeightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmHeight').value;
      let unit = panelStuff.querySelector('#inpElmHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.height = val + unit;
      } else {
        elm.style.height = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmOverflowX = panelStuff.querySelector('#inpElmOverflowX');
    inpElmOverflowX.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmOverflowX').value;
      elm.style.overflowX = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmOverflowY = panelStuff.querySelector('#inpElmOverflowY');
    inpElmOverflowY.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmOverflowY').value;
      elm.style.overflowY = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;

    // Max Width
    const inpElmMaxWidth = panelStuff.querySelector('#inpElmMaxWidth');
    const inpElmMaxWidthUnit = panelStuff.querySelector('#inpElmMaxWidthUnit');
    inpElmMaxWidth.value = '';
    inpElmMaxWidthUnit.value = 'px';
    let s = elm.style.maxWidth;
    let nMaxWidth = parseInt(s);
    if (!isNaN(nMaxWidth)) {
      if (s.indexOf('%') !== -1) inpElmMaxWidthUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMaxWidthUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMaxWidthUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMaxWidthUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMaxWidthUnit.value = 'em';
      inpElmMaxWidth.value = nMaxWidth;
    }

    // Max Height
    const inpElmMaxHeight = panelStuff.querySelector('#inpElmMaxHeight');
    const inpElmMaxHeightUnit = panelStuff.querySelector('#inpElmMaxHeightUnit');
    inpElmMaxHeight.value = '';
    inpElmMaxHeightUnit.value = 'px';
    s = elm.style.maxHeight;
    let nMaxHeight = parseInt(s);
    if (!isNaN(nMaxHeight)) {
      if (s.indexOf('%') !== -1) inpElmMaxHeightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMaxHeightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMaxHeightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMaxHeightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMaxHeightUnit.value = 'em';
      inpElmMaxHeight.value = nMaxHeight;
    }

    // Min Width
    const inpElmMinWidth = panelStuff.querySelector('#inpElmMinWidth');
    const inpElmMinWidthUnit = panelStuff.querySelector('#inpElmMinWidthUnit');
    inpElmMinWidth.value = '';
    inpElmMinWidthUnit.value = 'px';
    s = elm.style.minWidth;
    let nMinWidth = parseInt(s);
    if (!isNaN(nMinWidth)) {
      if (s.indexOf('%') !== -1) inpElmMinWidthUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMinWidthUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMinWidthUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMinWidthUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMinWidthUnit.value = 'em';
      inpElmMinWidth.value = nMinWidth;
    }

    // Min Height
    const inpElmMinHeight = panelStuff.querySelector('#inpElmMinHeight');
    const inpElmMinHeightUnit = panelStuff.querySelector('#inpElmMinHeightUnit');
    inpElmMinHeight.value = '';
    inpElmMinHeightUnit.value = 'px';
    s = elm.style.minHeight;
    let nMinHeight = parseInt(s);
    if (!isNaN(nMinHeight)) {
      if (s.indexOf('%') !== -1) inpElmMinHeightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMinHeightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMinHeightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMinHeightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMinHeightUnit.value = 'em';
      inpElmMinHeight.value = nMinHeight;
    }

    // Width
    const inpElmWidth = panelStuff.querySelector('#inpElmWidth');
    const inpElmWidthUnit = panelStuff.querySelector('#inpElmWidthUnit');
    inpElmWidth.value = '';
    inpElmWidthUnit.value = 'px';
    s = elm.style.width;
    let nWidth = parseInt(s);
    if (!isNaN(nWidth)) {
      if (s.indexOf('%') !== -1) inpElmWidthUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmWidthUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmWidthUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmWidthUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmWidthUnit.value = 'em';
      inpElmWidth.value = nWidth;
    }

    // Height
    const inpElmHeight = panelStuff.querySelector('#inpElmHeight');
    const inpElmHeightUnit = panelStuff.querySelector('#inpElmHeightUnit');
    inpElmHeight.value = '';
    inpElmHeightUnit.value = 'px';
    s = elm.style.height;
    let nHeight = parseInt(s);
    if (!isNaN(nHeight)) {
      if (s.indexOf('%') !== -1) inpElmHeightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmHeightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmHeightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmHeightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmHeightUnit.value = 'em';
      inpElmHeight.value = nHeight;
    }

    // Overflow X
    const inpElmOverflowX = panelStuff.querySelector('#inpElmOverflowX');
    s = elm.style.overflowX;
    inpElmOverflowX.value = s;

    // Overflow Y
    const inpElmOverflowY = panelStuff.querySelector('#inpElmOverflowY');
    s = elm.style.overflowY;
    inpElmOverflowY.value = s;
  }
}

const dom$d = new Dom();
class ElementSpacingStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementSpacing');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top: 13px;font-weight: bold;width:100%">${util.out('Padding')}</div>
            
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Top')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmPaddingTop" value="" style="width:45px"/>
                    <select id="inpElmPaddingTopUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Bottom')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmPaddingBottom" value="" style="width:45px"/>
                    <select id="inpElmPaddingBottomUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Left')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmPaddingLeft" value="" style="width:45px"/>
                    <select id="inpElmPaddingLeftUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Right')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmPaddingRight" value="" style="width:45px"/>
                    <select id="inpElmPaddingRightUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>
            
            <div style="margin-top: 25px;font-weight: bold;width:100%">${util.out('Margin')}</div>
            
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Top')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmMarginTop" value="" style="width:45px"/>
                    <select id="inpElmMarginTopUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                        <option value="auto">auto</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Bottom')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmMarginBottom" value="" style="width:45px"/>
                    <select id="inpElmMarginBottomUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                        <option value="auto">auto</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Left')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmMarginLeft" value="" style="width:45px"/>
                    <select id="inpElmMarginLeftUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                        <option value="auto">auto</option>
                    </select>
                </div>
            </div>
            <div class="is-settings" style="width:110px;">
                <div>${util.out('Right')}:</div>
                <div style="display:flex;">
                    <input type="text" id="inpElmMarginRight" value="" style="width:45px"/>
                    <select id="inpElmMarginRightUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                        <option value="auto">auto</option>
                    </select>
                </div>
            </div>

            <div style="display:none">
                <div style="margin-top: 25px;font-weight: bold;width:100%">${util.out('Responsive Positioning')}:</div>
                
                <div class="is-settings" style="width:100%;">
                    <div>
                        <label for="chkResetMarginLeft" style="letter-spacing: 0.5px;"><input type="checkbox" id="chkResetMarginLeft" value="" /> ${util.out('Reset margin left on small screen')} </label>
                    </div>
                </div>
                <div class="is-settings" style="margin-top:0;width:100%;">
                    <div>
                        <label for="chkResetMarginRight" style="letter-spacing: 0.5px;"><input type="checkbox" id="chkResetMarginRight" value="" /> ${util.out('Reset margin right on small screen')} </label>
                    </div>
                </div>
            </div>
        `;
    dom$d.appendHtml(panelStuff, html);

    // Margin
    let inpElmMarginLeft = panelStuff.querySelector('#inpElmMarginLeft');
    inpElmMarginLeft.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmMarginLeftUnit = panelStuff.querySelector('#inpElmMarginLeftUnit');
    inpElmMarginLeft.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginLeft.value;
      let unit = inpElmMarginLeftUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.marginLeft = val + unit;
      } else {
        elm.style.marginLeft = '';
      }
      if (unit === 'auto') {
        elm.style.marginLeft = 'auto';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmMarginLeftUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginLeft.value;
      let unit = inpElmMarginLeftUnit.value;
      if (unit === 'auto') {
        elm.style.marginLeft = 'auto';
        inpElmMarginLeft.value = '';
      } else {
        elm.style.marginLeft = val + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMarginRight = panelStuff.querySelector('#inpElmMarginRight');
    inpElmMarginRight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmMarginRightUnit = panelStuff.querySelector('#inpElmMarginRightUnit');
    inpElmMarginRight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginRight.value;
      let unit = inpElmMarginRightUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.marginRight = val + unit;
      } else {
        elm.style.marginRight = '';
      }
      if (unit === 'auto') {
        elm.style.marginRight = 'auto';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmMarginRightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginRight.value;
      let unit = inpElmMarginRightUnit.value;
      if (unit === 'auto') {
        elm.style.marginRight = 'auto';
        inpElmMarginRight.value = '';
      } else {
        elm.style.marginRight = val + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMarginTop = panelStuff.querySelector('#inpElmMarginTop');
    inpElmMarginTop.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmMarginTopUnit = panelStuff.querySelector('#inpElmMarginTopUnit');
    inpElmMarginTop.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginTop.value;
      let unit = inpElmMarginTopUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.marginTop = val + unit;
      } else {
        elm.style.marginTop = '';
      }
      if (unit === 'auto') {
        elm.style.marginTop = 'auto';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmMarginTopUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginTop.value;
      let unit = inpElmMarginTopUnit.value;
      if (unit === 'auto') {
        elm.style.marginTop = 'auto';
        inpElmMarginTop.value = '';
      } else {
        elm.style.marginTop = val + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmMarginBottom = panelStuff.querySelector('#inpElmMarginBottom');
    inpElmMarginBottom.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmMarginBottomUnit = panelStuff.querySelector('#inpElmMarginBottomUnit');
    inpElmMarginBottom.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginBottom.value;
      let unit = inpElmMarginBottomUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.marginBottom = val + unit;
      } else {
        elm.style.marginBottom = '';
      }
      if (unit === 'auto') {
        elm.style.marginBottom = 'auto';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmMarginBottomUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmMarginBottom.value;
      let unit = inpElmMarginBottomUnit.value;
      if (unit === 'auto') {
        elm.style.marginBottom = 'auto';
        inpElmMarginBottom.value = '';
      } else {
        elm.style.marginBottom = val + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Padding
    let inpElmPaddingLeft = panelStuff.querySelector('#inpElmPaddingLeft');
    inpElmPaddingLeft.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmPaddingLeftUnit = panelStuff.querySelector('#inpElmPaddingLeftUnit');
    inpElmPaddingLeft.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingLeft.value;
      let unit = inpElmPaddingLeftUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingLeft = val + unit;
      } else {
        elm.style.paddingLeft = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmPaddingLeftUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingLeft.value;
      let unit = inpElmPaddingLeftUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingLeft = val + unit;
      } else {
        elm.style.paddingLeft = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmPaddingRight = panelStuff.querySelector('#inpElmPaddingRight');
    inpElmPaddingRight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmPaddingRightUnit = panelStuff.querySelector('#inpElmPaddingRightUnit');
    inpElmPaddingRight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingRight.value;
      let unit = inpElmPaddingRightUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingRight = val + unit;
      } else {
        elm.style.paddingRight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmPaddingRightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingRight.value;
      let unit = inpElmPaddingRightUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingRight = val + unit;
      } else {
        elm.style.paddingRight = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmPaddingTop = panelStuff.querySelector('#inpElmPaddingTop');
    inpElmPaddingTop.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmPaddingTopUnit = panelStuff.querySelector('#inpElmPaddingTopUnit');
    inpElmPaddingTop.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingTop.value;
      let unit = inpElmPaddingTopUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingTop = val + unit;
      } else {
        elm.style.paddingTop = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmPaddingTopUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingTop.value;
      let unit = inpElmPaddingTopUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingTop = val + unit;
      } else {
        elm.style.paddingTop = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let inpElmPaddingBottom = panelStuff.querySelector('#inpElmPaddingBottom');
    inpElmPaddingBottom.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    let inpElmPaddingBottomUnit = panelStuff.querySelector('#inpElmPaddingBottomUnit');
    inpElmPaddingBottom.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingBottom.value;
      let unit = inpElmPaddingBottomUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingBottom = val + unit;
      } else {
        elm.style.paddingBottom = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmPaddingBottomUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmPaddingBottom.value;
      let unit = inpElmPaddingBottomUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.paddingBottom = val + unit;
      } else {
        elm.style.paddingBottom = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Responsive positioning
    let chkResetMarginLeft = panelStuff.querySelector('#chkResetMarginLeft');
    chkResetMarginLeft.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      if (chkResetMarginLeft.checked) {
        dom$d.addClass(elm, 'margin-left-1024-reset');
      } else {
        dom$d.removeClass(elm, 'margin-left-1024-reset');
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let chkResetMarginRight = panelStuff.querySelector('#chkResetMarginRight');
    chkResetMarginRight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      if (chkResetMarginRight.checked) {
        dom$d.addClass(elm, 'margin-right-1024-reset');
      } else {
        dom$d.removeClass(elm, 'margin-right-1024-reset');
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    let s;

    // Margin
    const inpElmMarginTop = panelStuff.querySelector('#inpElmMarginTop');
    const inpElmMarginTopUnit = panelStuff.querySelector('#inpElmMarginTopUnit');
    inpElmMarginTop.value = '';
    inpElmMarginTopUnit.value = 'px';
    s = elm.style.marginTop;
    let nMarginTop = parseInt(s);
    if (!isNaN(nMarginTop)) {
      if (s.indexOf('%') !== -1) inpElmMarginTopUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMarginTopUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMarginTopUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMarginTopUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMarginTopUnit.value = 'em';
      inpElmMarginTop.value = nMarginTop;
    } else {
      if (s) if (s.indexOf('auto') !== -1) {
        inpElmMarginTopUnit.value = 'auto';
        inpElmMarginTop.value = '';
      }
    }
    const inpElmMarginBottom = panelStuff.querySelector('#inpElmMarginBottom');
    const inpElmMarginBottomUnit = panelStuff.querySelector('#inpElmMarginBottomUnit');
    inpElmMarginBottom.value = '';
    inpElmMarginBottomUnit.value = 'px';
    s = elm.style.marginBottom;
    let nMarginBottom = parseInt(s);
    if (!isNaN(nMarginBottom)) {
      if (s.indexOf('%') !== -1) inpElmMarginBottomUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMarginBottomUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMarginBottomUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMarginBottomUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMarginBottomUnit.value = 'em';
      inpElmMarginBottom.value = nMarginBottom;
    } else {
      if (s) if (s.indexOf('auto') !== -1) {
        inpElmMarginBottomUnit.value = 'auto';
        inpElmMarginBottom.value = '';
      }
    }
    const inpElmMarginLeft = panelStuff.querySelector('#inpElmMarginLeft');
    const inpElmMarginLeftUnit = panelStuff.querySelector('#inpElmMarginLeftUnit');
    inpElmMarginLeft.value = '';
    inpElmMarginLeftUnit.value = 'px';
    s = elm.style.marginLeft;
    let nMarginLeft = parseInt(s);
    if (!isNaN(nMarginLeft)) {
      if (s.indexOf('%') !== -1) inpElmMarginLeftUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMarginLeftUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMarginLeftUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMarginLeftUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMarginLeftUnit.value = 'em';
      inpElmMarginLeft.value = nMarginLeft;
    } else {
      if (s) if (s.indexOf('auto') !== -1) {
        inpElmMarginLeftUnit.value = 'auto';
        inpElmMarginLeft.value = '';
      }
    }
    const inpElmMarginRight = panelStuff.querySelector('#inpElmMarginRight');
    const inpElmMarginRightUnit = panelStuff.querySelector('#inpElmMarginRightUnit');
    inpElmMarginRight.value = '';
    inpElmMarginRightUnit.value = 'px';
    s = elm.style.marginRight;
    let nMarginRight = parseInt(s);
    if (!isNaN(nMarginRight)) {
      if (s.indexOf('%') !== -1) inpElmMarginRightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmMarginRightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmMarginRightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmMarginRightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmMarginRightUnit.value = 'em';
      inpElmMarginRight.value = nMarginRight;
    } else {
      if (s) if (s.indexOf('auto') !== -1) {
        inpElmMarginRightUnit.value = 'auto';
        inpElmMarginRight.value = '';
      }
    }

    // Padding
    const inpElmPaddingTop = panelStuff.querySelector('#inpElmPaddingTop');
    const inpElmPaddingTopUnit = panelStuff.querySelector('#inpElmPaddingTopUnit');
    inpElmPaddingTop.value = '';
    inpElmPaddingTopUnit.value = 'px';
    s = elm.style.paddingTop;
    let nPaddingTop = parseInt(s);
    if (!isNaN(nPaddingTop)) {
      if (s.indexOf('%') !== -1) inpElmPaddingTopUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmPaddingTopUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmPaddingTopUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmPaddingTopUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmPaddingTopUnit.value = 'em';
      inpElmPaddingTop.value = nPaddingTop;
    }
    const inpElmPaddingBottom = panelStuff.querySelector('#inpElmPaddingBottom');
    const inpElmPaddingBottomUnit = panelStuff.querySelector('#inpElmPaddingBottomUnit');
    inpElmPaddingBottom.value = '';
    inpElmPaddingBottomUnit.value = 'px';
    s = elm.style.paddingBottom;
    let nPaddingBottom = parseInt(s);
    if (!isNaN(nPaddingBottom)) {
      if (s.indexOf('%') !== -1) inpElmPaddingBottomUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmPaddingBottomUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmPaddingBottomUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmPaddingBottomUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmPaddingBottomUnit.value = 'em';
      inpElmPaddingBottom.value = nPaddingBottom;
    }
    const inpElmPaddingLeft = panelStuff.querySelector('#inpElmPaddingLeft');
    const inpElmPaddingLeftUnit = panelStuff.querySelector('#inpElmPaddingLeftUnit');
    inpElmPaddingLeft.value = '';
    inpElmPaddingLeftUnit.value = 'px';
    s = elm.style.paddingLeft;
    let nPaddingLeft = parseInt(s);
    if (!isNaN(nPaddingLeft)) {
      if (s.indexOf('%') !== -1) inpElmPaddingLeftUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmPaddingLeftUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmPaddingLeftUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmPaddingLeftUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmPaddingLeftUnit.value = 'em';
      inpElmPaddingLeft.value = nPaddingLeft;
    }
    const inpElmPaddingRight = panelStuff.querySelector('#inpElmPaddingRight');
    const inpElmPaddingRightUnit = panelStuff.querySelector('#inpElmPaddingRightUnit');
    inpElmPaddingRight.value = '';
    inpElmPaddingRightUnit.value = 'px';
    s = elm.style.paddingRight;
    let nPaddingRight = parseInt(s);
    if (!isNaN(nPaddingRight)) {
      if (s.indexOf('%') !== -1) inpElmPaddingRightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmPaddingRightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmPaddingRightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmPaddingRightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmPaddingRightUnit.value = 'em';
      inpElmPaddingRight.value = nPaddingRight;
    }

    // Responsive Positioning
    if (dom$d.hasClass(elm, 'margin-left-1024-reset')) {
      panelStuff.querySelector('#chkResetMarginLeft').checked = true;
    } else {
      panelStuff.querySelector('#chkResetMarginLeft').checked = false;
    }
    if (dom$d.hasClass(elm, 'margin-right-1024-reset')) {
      panelStuff.querySelector('#chkResetMarginRight').checked = true;
    } else {
      panelStuff.querySelector('#chkResetMarginRight').checked = false;
    }
  }
}

const dom$c = new Dom();
class ElementBorderStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementBorder');
    this.panelStuff = panelStuff;
    const html = `
                <div style="margin-top: 13px;font-weight: bold;line-height: 1.7;">${util.out('Border')}</div>
                
                <div class="is-settings">
                    <div style="display:flex;">
                        <input type="text" id="inpElmBorderWidth" value="" style="width:45px"/>
                        <select id="inpElmBorderWidthUnit" style="margin-right:15px;">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="none">none</option>
                        </select>
                        <select id="inpElmBorderStyle" style="margin-right:15px;">
                            <option value=""></option>
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                        <button title="${util.out('Border Color')}" class="input-elm-bordercolor is-btn-color"></button>                             
                    </div>
                </div>
                
                <div style="margin-top: 25px;font-weight: bold;line-height: 1.7;">${util.out('Individual Sides')}</div>
                
                <div class="is-settings">
                    <div>${util.out('Border Top')}:</div>
                    <div style="display:flex;">
                        <input type="text" id="inpElmBorderTopWidth" value="" style="width:45px"/>
                        <select id="inpElmBorderTopWidthUnit" style="margin-right:15px;">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="none">none</option>
                        </select>
                        <select id="inpElmBorderTopStyle" style="margin-right:15px;">
                            <option value=""></option>
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                        <button title="${util.out('Border Top Color')}" class="input-elm-bordertopcolor is-btn-color"></button>
                    </div>
                </div>
                
                <div class="is-settings">
                    <div>${util.out('Border Bottom')}:</div>
                    <div style="display:flex;">
                        <input type="text" id="inpElmBorderBottomWidth" value="" style="width:45px"/>
                        <select id="inpElmBorderBottomWidthUnit" style="margin-right:15px;">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="none">none</option>
                        </select>
                        <select id="inpElmBorderBottomStyle" style="margin-right:15px;">
                            <option value=""></option>
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                        <button title="${util.out('Border Bottom Color')}" class="input-elm-borderbottomcolor is-btn-color"></button>
                    </div>
                </div>
                
                <div class="is-settings">
                    <div>${util.out('Border Left')}:</div>
                    <div style="display:flex;">
                        <input type="text" id="inpElmBorderLeftWidth" value="" style="width:45px"/>
                        <select id="inpElmBorderLeftWidthUnit" style="margin-right:15px;">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="none">none</option>
                        </select>
                        <select id="inpElmBorderLeftStyle" style="margin-right:15px;">
                            <option value=""></option>
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                        <button title="${util.out('Border Left Color')}" class="input-elm-borderleftcolor is-btn-color"></button>
                    </div>
                </div>
                
                <div class="is-settings">
                    <div>${util.out('Border Right')}:</div>
                    <div style="display:flex;">
                        <input type="text" id="inpElmBorderRightWidth" value="" style="width:45px"/>
                        <select id="inpElmBorderRightWidthUnit" style="margin-right:15px;">
                            <option value="px">px</option>
                            <option value="em">em</option>
                            <option value="vw">vw</option>
                            <option value="vh">vh</option>
                            <option value="none">none</option>
                        </select>
                        <select id="inpElmBorderRightStyle" style="margin-right:15px;">
                            <option value=""></option>
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                        <button title="${util.out('Border Right Color')}" class="input-elm-borderrightcolor is-btn-color"></button> 
                    </div>
                </div>                
        `;
    dom$c.appendHtml(panelStuff, html);

    // Border color
    let btnElmBorderColor = panelStuff.querySelector('.input-elm-bordercolor');
    btnElmBorderColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.borderColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBorderColor.style.backgroundColor, () => {
        btnElmBorderColor.removeAttribute('data-focus');
        btnElmBorderColor.focus();
      });
      btnElmBorderColor.setAttribute('data-focus', true);
    });

    // Border top color
    let btnElmBorderTopColor = panelStuff.querySelector('.input-elm-bordertopcolor');
    btnElmBorderTopColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.borderTopColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBorderTopColor.style.backgroundColor, () => {
        btnElmBorderTopColor.removeAttribute('data-focus');
        btnElmBorderTopColor.focus();
      });
      btnElmBorderTopColor.setAttribute('data-focus', true);
    });

    // Border bottom color
    let btnElmBorderBottomColor = panelStuff.querySelector('.input-elm-borderbottomcolor');
    btnElmBorderBottomColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.borderBottomColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBorderBottomColor.style.backgroundColor, () => {
        btnElmBorderBottomColor.removeAttribute('data-focus');
        btnElmBorderBottomColor.focus();
      });
      btnElmBorderBottomColor.setAttribute('data-focus', true);
    });

    // Border left color
    let btnElmBorderLeftColor = panelStuff.querySelector('.input-elm-borderleftcolor');
    btnElmBorderLeftColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.borderLeftColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBorderLeftColor.style.backgroundColor, () => {
        btnElmBorderLeftColor.removeAttribute('data-focus');
        btnElmBorderLeftColor.focus();
      });
      btnElmBorderLeftColor.setAttribute('data-focus', true);
    });

    // Border right color
    let btnElmBorderRightColor = panelStuff.querySelector('.input-elm-borderrightcolor');
    btnElmBorderRightColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.borderRightColor = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmBorderRightColor.style.backgroundColor, () => {
        btnElmBorderRightColor.removeAttribute('data-focus');
        btnElmBorderRightColor.focus();
      });
      btnElmBorderRightColor.setAttribute('data-focus', true);
    });

    // Border width
    let inpElmBorderWidth = panelStuff.querySelector('#inpElmBorderWidth');
    inpElmBorderWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderWidth').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderStyle = 'solid'; //refresh
        elm.style.borderWidth = val + panelStuff.querySelector('#inpElmBorderWidthUnit').value;
        elm.style.borderStyle = panelStuff.querySelector('#inpElmBorderStyle').value;
      } else {
        elm.style.borderStyle = 'solid'; //refresh
        elm.style.borderWidth = '';
        elm.style.borderStyle = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border width unit
    let inpElmBorderWidthUnit = panelStuff.querySelector('#inpElmBorderWidthUnit');
    inpElmBorderWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var unit = panelStuff.querySelector('#inpElmBorderWidthUnit').value;
      if (unit === 'none') {
        elm.style.border = 'none';
        elm.style.borderWidth = '';
        elm.style.borderStyle = '';
      } else {
        elm.style.borderWidth = panelStuff.querySelector('#inpElmBorderWidth').value + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border style
    let inpElmBorderStyle = panelStuff.querySelector('#inpElmBorderStyle');
    inpElmBorderStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderStyle').value;
      elm.style.borderStyle = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border top width
    let inpElmBorderTopWidth = panelStuff.querySelector('#inpElmBorderTopWidth');
    inpElmBorderTopWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderTopWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderTopWidth').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderTopStyle = 'solid'; //refresh
        elm.style.borderTopWidth = val + panelStuff.querySelector('#inpElmBorderTopWidthUnit').value;
        elm.style.borderTopStyle = panelStuff.querySelector('#inpElmBorderTopStyle').value;
      } else {
        elm.style.borderTopStyle = 'solid'; //refresh
        elm.style.borderTopWidth = '';
        elm.style.borderTopStyle = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border top width unit
    let inpElmBorderTopWidthUnit = panelStuff.querySelector('#inpElmBorderTopWidthUnit');
    inpElmBorderTopWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var unit = panelStuff.querySelector('#inpElmBorderTopWidthUnit').value;
      if (unit === 'none') {
        elm.style.borderTop = 'none';
        elm.style.borderTopWidth = '';
        elm.style.borderTopStyle = '';
        this.panelStuff.querySelector('#inpElmBorderTopWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderTopStyle').value = '';
      } else {
        elm.style.borderTopWidth = panelStuff.querySelector('#inpElmBorderTopWidth').value + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border top style
    let inpElmBorderTopStyle = panelStuff.querySelector('#inpElmBorderTopStyle');
    inpElmBorderTopStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderTopStyle').value;
      elm.style.borderTopStyle = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border bottom width
    let inpElmBorderBottomWidth = panelStuff.querySelector('#inpElmBorderBottomWidth');
    inpElmBorderBottomWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderBottomWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderBottomWidth').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderBottomStyle = 'solid'; //refresh
        elm.style.borderBottomWidth = val + panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value;
        elm.style.borderBottomStyle = panelStuff.querySelector('#inpElmBorderBottomStyle').value;
      } else {
        elm.style.borderBottomStyle = 'solid'; //refresh
        elm.style.borderBottomWidth = '';
        elm.style.borderBottomStyle = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border bottom width unit
    let inpElmBorderBottomWidthUnit = panelStuff.querySelector('#inpElmBorderBottomWidthUnit');
    inpElmBorderBottomWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var unit = panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value;
      if (unit === 'none') {
        elm.style.borderBottom = 'none';
        elm.style.borderBottomWidth = '';
        elm.style.borderBottomStyle = '';
        this.panelStuff.querySelector('#inpElmBorderBottomWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = '';
      } else {
        elm.style.borderBottomWidth = panelStuff.querySelector('#inpElmBorderBottomWidth').value + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border bottom style
    let inpElmBorderBottomStyle = panelStuff.querySelector('#inpElmBorderBottomStyle');
    inpElmBorderBottomStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderBottomStyle').value;
      elm.style.borderBottomStyle = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border left width
    let inpElmBorderLeftWidth = panelStuff.querySelector('#inpElmBorderLeftWidth');
    inpElmBorderLeftWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderLeftWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderLeftWidth').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderLeftStyle = 'solid'; //refresh
        elm.style.borderLeftWidth = val + panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value;
        elm.style.borderLeftStyle = panelStuff.querySelector('#inpElmBorderLeftStyle').value;
      } else {
        elm.style.borderLeftStyle = 'solid'; //refresh
        elm.style.borderLeftWidth = '';
        elm.style.borderLeftStyle = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border left width unit
    let inpElmBorderLeftWidthUnit = panelStuff.querySelector('#inpElmBorderLeftWidthUnit');
    inpElmBorderLeftWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var unit = panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value;
      if (unit === 'none') {
        elm.style.borderLeft = 'none';
        elm.style.borderLeftWidth = '';
        elm.style.borderLeftStyle = '';
        this.panelStuff.querySelector('#inpElmBorderLeftWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = '';
      } else {
        elm.style.borderLeftWidth = panelStuff.querySelector('#inpElmBorderLeftWidth').value + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border left style
    let inpElmBorderLeftStyle = panelStuff.querySelector('#inpElmBorderLeftStyle');
    inpElmBorderLeftStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderLeftStyle').value;
      elm.style.borderLeftStyle = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border right width
    let inpElmBorderRightWidth = panelStuff.querySelector('#inpElmBorderRightWidth');
    inpElmBorderRightWidth.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderRightWidth.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderRightWidth').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderRightStyle = 'solid'; //refresh
        elm.style.borderRightWidth = val + panelStuff.querySelector('#inpElmBorderRightWidthUnit').value;
        elm.style.borderRightStyle = panelStuff.querySelector('#inpElmBorderRightStyle').value;
      } else {
        elm.style.borderRightStyle = 'solid'; //refresh
        elm.style.borderRightWidth = '';
        elm.style.borderRightStyle = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border right width unit
    let inpElmBorderRightWidthUnit = panelStuff.querySelector('#inpElmBorderRightWidthUnit');
    inpElmBorderRightWidthUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var unit = panelStuff.querySelector('#inpElmBorderRightWidthUnit').value;
      if (unit === 'none') {
        elm.style.borderRight = 'none';
        elm.style.borderRightWidth = '';
        elm.style.borderRightStyle = '';
        this.panelStuff.querySelector('#inpElmBorderRightWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderRightStyle').value = '';
      } else {
        elm.style.borderRightWidth = panelStuff.querySelector('#inpElmBorderRightWidth').value + unit;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });

    // Border right style
    let inpElmBorderRightStyle = panelStuff.querySelector('#inpElmBorderRightStyle');
    inpElmBorderRightStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      var val = panelStuff.querySelector('#inpElmBorderRightStyle').value;
      elm.style.borderRightStyle = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    this.panelStuff.querySelector('.input-elm-bordercolor').style.backgroundColor = elm.style.borderColor;
    this.panelStuff.querySelector('.input-elm-bordertopcolor').style.backgroundColor = elm.style.borderTopColor;
    this.panelStuff.querySelector('.input-elm-borderbottomcolor').style.backgroundColor = elm.style.borderBottomColor;
    this.panelStuff.querySelector('.input-elm-borderleftcolor').style.backgroundColor = elm.style.borderLeftColor;
    this.panelStuff.querySelector('.input-elm-borderrightcolor').style.backgroundColor = elm.style.borderRightColor;
    this.panelStuff.querySelector('#inpElmBorderWidth').value = '';
    this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = '';
    this.panelStuff.querySelector('#inpElmBorderStyle').value = '';
    var s = elm.style.borderWidth;
    var nBorderWidth = parseInt(s);
    if (!isNaN(nBorderWidth)) {
      if (s.indexOf('px') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = 'px';
      }
      if (s.indexOf('vw') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = 'vw';
      }
      if (s.indexOf('vh') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = 'vh';
      }
      if (s.indexOf('em') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = 'em';
      }
      this.panelStuff.querySelector('#inpElmBorderWidth').value = nBorderWidth;
      s = elm.style.borderStyle;
      if (s.indexOf('solid') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderStyle').value = 'solid';
      }
      if (s.indexOf('dashed') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderStyle').value = 'dashed';
      }
      if (s.indexOf('dotted') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderStyle').value = 'dotted';
      }
    } else {
      s = elm.style.border;
      if (s.indexOf('none') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderWidthUnit').value = 'none';
        this.panelStuff.querySelector('#inpElmBorderWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderStyle').value = '';
      }
    }
    this.panelStuff.querySelector('#inpElmBorderTopWidth').value = '';
    this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = '';
    this.panelStuff.querySelector('#inpElmBorderTopStyle').value = '';
    s = elm.style.borderTopWidth;
    var nBorderTopWidth = parseInt(s);
    if (!isNaN(nBorderTopWidth)) {
      if (s.indexOf('px') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = 'px';
      }
      if (s.indexOf('vw') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = 'vw';
      }
      if (s.indexOf('vh') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = 'vh';
      }
      if (s.indexOf('em') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = 'em';
      }
      this.panelStuff.querySelector('#inpElmBorderTopWidth').value = nBorderTopWidth;
      if (s.indexOf('solid') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopStyle').value = 'solid';
      }
      if (s.indexOf('dashed') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopStyle').value = 'dashed';
      }
      if (s.indexOf('dotted') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopStyle').value = 'dotted';
      }
    } else {
      s = elm.style.borderTop;
      if (s.indexOf('none') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderTopWidthUnit').value = 'none';
        this.panelStuff.querySelector('#inpElmBorderTopWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderTopStyle').value = '';
      }
    }
    this.panelStuff.querySelector('#inpElmBorderBottomWidth').value = '';
    this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = '';
    this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = '';
    s = elm.style.borderBottomWidth;
    var nBorderBottomWidth = parseInt(s);
    if (!isNaN(nBorderBottomWidth)) {
      if (s.indexOf('px') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = 'px';
      }
      if (s.indexOf('vw') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = 'vw';
      }
      if (s.indexOf('vh') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = 'vh';
      }
      if (s.indexOf('em') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = 'em';
      }
      this.panelStuff.querySelector('#inpElmBorderBottomWidth').value = nBorderBottomWidth;
      if (s.indexOf('solid') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = 'solid';
      }
      if (s.indexOf('dashed') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = 'dashed';
      }
      if (s.indexOf('dotted') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = 'dotted';
      }
    } else {
      s = elm.style.borderBottom;
      if (s.indexOf('none') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderBottomWidthUnit').value = 'none';
        this.panelStuff.querySelector('#inpElmBorderBottomWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderBottomStyle').value = '';
      }
    }
    this.panelStuff.querySelector('#inpElmBorderLeftWidth').value = '';
    this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = '';
    this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = '';
    s = elm.style.borderLeftWidth;
    var nBorderLeftWidth = parseInt(s);
    if (!isNaN(nBorderLeftWidth)) {
      if (s.indexOf('px') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = 'px';
      }
      if (s.indexOf('vw') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = 'vw';
      }
      if (s.indexOf('vh') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = 'vh';
      }
      if (s.indexOf('em') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = 'em';
      }
      this.panelStuff.querySelector('#inpElmBorderLeftWidth').value = nBorderLeftWidth;
      if (s.indexOf('solid') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = 'solid';
      }
      if (s.indexOf('dashed') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = 'dashed';
      }
      if (s.indexOf('dotted') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = 'dotted';
      }
    } else {
      s = elm.style.borderLeft;
      if (s.indexOf('none') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderLeftWidthUnit').value = 'none';
        this.panelStuff.querySelector('#inpElmBorderLeftWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderLeftStyle').value = '';
      }
    }
    this.panelStuff.querySelector('#inpElmBorderRightWidth').value = '';
    this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = '';
    this.panelStuff.querySelector('#inpElmBorderRightStyle').value = '';
    s = elm.style.borderRightWidth;
    var nBorderRightWidth = parseInt(s);
    if (!isNaN(nBorderRightWidth)) {
      if (s.indexOf('px') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = 'px';
      }
      if (s.indexOf('vw') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = 'vw';
      }
      if (s.indexOf('vh') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = 'vh';
      }
      if (s.indexOf('em') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = 'em';
      }
      this.panelStuff.querySelector('#inpElmBorderRightWidth').value = nBorderRightWidth;
      if (s.indexOf('solid') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightStyle').value = 'solid';
      }
      if (s.indexOf('dashed') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightStyle').value = 'dashed';
      }
      if (s.indexOf('dotted') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightStyle').value = 'dotted';
      }
    } else {
      s = elm.style.borderRight;
      if (s.indexOf('none') !== -1) {
        this.panelStuff.querySelector('#inpElmBorderRightWidthUnit').value = 'none';
        this.panelStuff.querySelector('#inpElmBorderRightWidth').value = '';
        this.panelStuff.querySelector('#inpElmBorderRightStyle').value = '';
      }
    }
  }
}

const dom$b = new Dom();
class ElementTextStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementText');
    this.panelStuff = panelStuff;
    const html = `
            <div class="is-settings" style="width:115px;">
                <div>Text Color:</div>
                <div>
                    <button title="${util.out('Text Color')}" class="input-elm-color is-btn-color"></button>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Font Size')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmFontSize" value="" style="width:45px"/>
                    <select id="inpElmFontSizeUnit">
                        <option value=""></option>
                        <option value="px">px</option>
                        <option value="pt">pt</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="vmin">vmin</option>
                        <option value="vmax">vmax</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Text Align')}:</div>
                <div>
                    <select id="inpElmTextAlign">
                        <option value=""></option>
                        <option value="left">${util.out('Left')}</option>
                        <option value="center">${util.out('Center')}</option>
                        <option value="right">${util.out('Right')}</option>
                        <option value="justify">${util.out('Full')}</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Line Height')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmLineHeight" value="" style="width:45px"/>
                    <select id="inpElmLineHeightUnit">
                        <option value=""></option>
                        <option value="px">px</option>
                        <option value="pt">pt</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Font Weight')}:</div>
                <div>
                    <select id="inpElmFontWeight">
                        <option value=""></option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                        <option value="700">700</option>
                        <option value="800">800</option>
                        <option value="900">900</option>
                        <option value="bold">${util.out('Bold')}</option>
                        <option value="normal">${util.out('Normal')}</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Font Style')}:</div>
                <div>
                    <select id="inpElmFontStyle">
                        <option value=""></option>
                        <option value="italic">${util.out('Italic')}</option>
                        <option value="normal">${util.out('Normal')}</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Text Transform')}:</div>
                <div>
                    <select id="inpElmTextTransform">
                        <option value=""></option>
                        <option value="uppercase">${util.out('Uppercase')}</option>
                        <option value="lowercase">${util.out('Lowercase')}</option>
                        <option value="capitalize">${util.out('Capitalize')}</option>
                        <option value="none">${util.out('None')}</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Text Decoration')}:</div>
                <div>
                    <select id="inpElmTextDecoration">
                        <option value=""></option>
                        <option value="underline">${util.out('Underline')}</option>
                        <option value="line-through">${util.out('Line Through')}</option>
                        <option value="overline">${util.out('Overline')}</option>
                        <option value="none">${util.out('None')}</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Letter Spacing')}:</div>
                <div>
                    <input type="text" id="inpElmLetterSpacing" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div class="is-settings" style="width:115px;">
                <div>${util.out('Word Spacing')}:</div>
                <div>
                    <input type="text" id="inpElmWordSpacing" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>
        `;
    dom$b.appendHtml(panelStuff, html);

    // Text color
    let btnElmTextColor = panelStuff.querySelector('.input-elm-color');
    btnElmTextColor.addEventListener('click', e => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let elm = e.target;
      this.builder.colorPicker.open(color => {
        this.builder.inspectedElement.style.color = color;
        elm.style.backgroundColor = color; // preview

        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmTextColor.style.backgroundColor, () => {
        btnElmTextColor.removeAttribute('data-focus');
        btnElmTextColor.focus();
      });
      btnElmTextColor.setAttribute('data-focus', true);
    });

    /*
        Text Style
        by Tinara
    */

    let inpElmTextAlign = panelStuff.querySelector('#inpElmTextAlign');
    inpElmTextAlign.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmTextAlign').value;
      elm.style.textAlign = val;
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmFontWeight = panelStuff.querySelector('#inpElmFontWeight');
    inpElmFontWeight.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFontWeight').value;
      elm.style.fontWeight = val;
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmFontStyle = panelStuff.querySelector('#inpElmFontStyle');
    inpElmFontStyle.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFontStyle').value;
      elm.style.fontStyle = val;
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmTextTransform = panelStuff.querySelector('#inpElmTextTransform');
    inpElmTextTransform.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmTextTransform').value;
      elm.style.textTransform = val;
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmTextDecoration = panelStuff.querySelector('#inpElmTextDecoration');
    inpElmTextDecoration.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmTextDecoration').value;
      elm.style.textDecoration = val;
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmFontSize = panelStuff.querySelector('#inpElmFontSize');
    inpElmFontSize.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmFontSize.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFontSize').value;
      if (val === '') {
        elm.style.fontSize = '';
        return;
      }
      let unit = panelStuff.querySelector('#inpElmFontSizeUnit').value;
      if (unit === '') {
        panelStuff.querySelector('#inpElmFontSizeUnit').value = 'px';
        unit = 'px';
      }
      if (!isNaN(val) && val !== '') {
        elm.style.fontSize = val + unit;
      } else {
        elm.style.fontSize = '';
      }

      // Get current class size & remove all class size from the element
      const arrSizes = this.builder.opts.fontSizeClassValues;
      for (var i = 0; i <= arrSizes.length - 1; i++) {
        if (dom$b.hasClass(elm, 'size-' + arrSizes[i])) {
          dom$b.removeClass(elm, 'size-' + arrSizes[i]);
        }
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmFontSizeUnit = panelStuff.querySelector('#inpElmFontSizeUnit');
    inpElmFontSizeUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFontSize').value;
      let unit = panelStuff.querySelector('#inpElmFontSizeUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.fontSize = val + unit;
      } else {
        elm.style.fontSize = '';
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmLineHeight = panelStuff.querySelector('#inpElmLineHeight');
    inpElmLineHeight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmLineHeight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmLineHeight').value;
      let unit = panelStuff.querySelector('#inpElmLineHeightUnit').value;
      if (!isNaN(val) && val !== '') {
        elm.style.lineHeight = val + unit;
      } else {
        elm.style.lineHeight = '';
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmLineHeightUnit = panelStuff.querySelector('#inpElmLineHeightUnit');
    inpElmLineHeightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let unit = panelStuff.querySelector('#inpElmLineHeightUnit').value;
      let val = panelStuff.querySelector('#inpElmLineHeight').value;
      if (!isNaN(val) && val !== '') {
        elm.style.lineHeight = val + unit;
      } else {
        elm.style.lineHeight = '';
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmLetterSpacing = panelStuff.querySelector('#inpElmLetterSpacing');
    inpElmLetterSpacing.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmLetterSpacing.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmLetterSpacing').value;
      if (!isNaN(val) && val !== '') {
        elm.style.letterSpacing = val + 'px';
      } else {
        elm.style.letterSpacing = '';
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
    let inpElmWordSpacing = panelStuff.querySelector('#inpElmWordSpacing');
    inpElmWordSpacing.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmWordSpacing.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmWordSpacing').value;
      if (!isNaN(val) && val !== '') {
        elm.style.wordSpacing = val + 'px';
      } else {
        elm.style.wordSpacing = '';
      }
      elementStyleEditor.refresh();
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    this.panelStuff.querySelector('.input-elm-color').style.backgroundColor = elm.style.color;

    /*
        Text Style
        by Tinara
    */

    this.panelStuff.querySelector('#inpElmTextAlign').value = '';
    var sTextAlign = elm.style.textAlign;
    this.panelStuff.querySelector('#inpElmTextAlign').value = sTextAlign;
    this.panelStuff.querySelector('#inpElmFontSize').value = '';
    var nFontSize = parseFloat(elm.style.fontSize);
    if (!isNaN(nFontSize)) {
      this.panelStuff.querySelector('#inpElmFontSize').value = nFontSize;
    }
    let sFontSizeUnit;
    this.panelStuff.querySelector('#inpElmFontSizeUnit').value = 'px';
    var s = elm.style.fontSize;
    if (s.indexOf('px') !== -1) {
      sFontSizeUnit = 'px';
    }
    if (s.indexOf('pt') !== -1) {
      sFontSizeUnit = 'pt';
    }
    if (s.indexOf('em') !== -1) {
      sFontSizeUnit = 'em';
    }
    if (s.indexOf('vw') !== -1) {
      sFontSizeUnit = 'vw';
    }
    if (s.indexOf('vh') !== -1) {
      sFontSizeUnit = 'vh';
    }
    if (s.indexOf('vmin') !== -1) {
      sFontSizeUnit = 'vmin';
    }
    if (s.indexOf('vmax') !== -1) {
      sFontSizeUnit = 'vmax';
    }
    if (s.indexOf('%') !== -1) {
      sFontSizeUnit = '%';
    }
    this.panelStuff.querySelector('#inpElmFontSizeUnit').value = sFontSizeUnit;
    this.panelStuff.querySelector('#inpElmFontWeight').value = '';
    var sFontWeight = elm.style.fontWeight;
    this.panelStuff.querySelector('#inpElmFontWeight').value = sFontWeight;
    this.panelStuff.querySelector('#inpElmFontStyle').value = '';
    var sFontStyle = elm.style.fontStyle;
    this.panelStuff.querySelector('#inpElmFontStyle').value = sFontStyle;
    this.panelStuff.querySelector('#inpElmTextTransform').value = '';
    var sTextTransform = elm.style.textTransform;
    this.panelStuff.querySelector('#inpElmTextTransform').value = sTextTransform;
    this.panelStuff.querySelector('#inpElmTextDecoration').value = '';
    var sTextDecoration = elm.style.textDecoration;
    this.panelStuff.querySelector('#inpElmTextDecoration').value = sTextDecoration;
    this.panelStuff.querySelector('#inpElmLineHeight').value = '';
    if (!isNaN(elm.style.lineHeight)) {
      this.panelStuff.querySelector('#inpElmLineHeight').value = elm.style.lineHeight;
    } else {
      var nLineHeight = parseFloat(elm.style.lineHeight);
      if (!isNaN(nLineHeight)) {
        this.panelStuff.querySelector('#inpElmLineHeight').value = nLineHeight;
      }
    }
    let sLineHeightUnit;
    this.panelStuff.querySelector('#inpElmLineHeightUnit').value = '';
    s = elm.style.lineHeight;
    if (s.indexOf('px') !== -1) {
      sLineHeightUnit = 'px';
    }
    if (s.indexOf('pt') !== -1) {
      sLineHeightUnit = 'pt';
    }
    this.panelStuff.querySelector('#inpElmLineHeightUnit').value = sLineHeightUnit;
    this.panelStuff.querySelector('#inpElmLetterSpacing').value = '';
    var nLetterSpacing = parseFloat(elm.style.letterSpacing);
    if (!isNaN(nLetterSpacing)) {
      this.panelStuff.querySelector('#inpElmLetterSpacing').value = nLetterSpacing;
    }
    this.panelStuff.querySelector('#inpElmWordSpacing').value = '';
    var nWordSpacing = parseFloat(elm.style.wordSpacing);
    if (!isNaN(nWordSpacing)) {
      this.panelStuff.querySelector('#inpElmWordSpacing').value = nWordSpacing;
    }
  }
}

const dom$a = new Dom();
class ElementCornerStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementCorner');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top: 13px;font-weight: bold;width:100%;">${util.out('Corners')}</div>

            <div class="is-settings" style="width:100%;margin-bottom:9px;">
                <div>${util.out('Border Radius')}:</div>
                <div>
                    <input type="text" id="inpElmBorderRadius" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div style="margin-top: 25px;font-weight: bold;width:100%;">${util.out('Individual Corners')}</div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Top Left')}:</div>
                <div>
                    <input type="text" id="inpElmBorderTopLeftRadius" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Top Right')}:</div>
                <div>
                    <input type="text" id="inpElmBorderTopRightRadius" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Bottom Left')}:</div>
                <div>
                    <input type="text" id="inpElmBorderBottomLeftRadius" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Bottom Right')}:</div>
                <div>
                    <input type="text" id="inpElmBorderBottomRightRadius" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>
        `;
    dom$a.appendHtml(panelStuff, html);
    const inpElmBorderRadius = panelStuff.querySelector('#inpElmBorderRadius');
    inpElmBorderRadius.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderRadius.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBorderRadius').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderRadius = val + 'px';
      } else {
        elm.style.borderRadius = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBorderTopLeftRadius = panelStuff.querySelector('#inpElmBorderTopLeftRadius');
    inpElmBorderTopLeftRadius.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderTopLeftRadius.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBorderTopLeftRadius').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderTopLeftRadius = val + 'px';
      } else {
        elm.style.borderTopLeftRadius = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBorderTopRightRadius = panelStuff.querySelector('#inpElmBorderTopRightRadius');
    inpElmBorderTopRightRadius.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderTopRightRadius.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBorderTopRightRadius').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderTopRightRadius = val + 'px';
      } else {
        elm.style.borderTopRightRadius = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBorderBottomLeftRadius = panelStuff.querySelector('#inpElmBorderBottomLeftRadius');
    inpElmBorderBottomLeftRadius.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderBottomLeftRadius.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBorderBottomLeftRadius').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderBottomLeftRadius = val + 'px';
      } else {
        elm.style.borderBottomLeftRadius = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBorderBottomRightRadius = panelStuff.querySelector('#inpElmBorderBottomRightRadius');
    inpElmBorderBottomRightRadius.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBorderBottomRightRadius.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBorderBottomRightRadius').value;
      if (!isNaN(val) && val !== '') {
        elm.style.borderBottomRightRadius = val + 'px';
      } else {
        elm.style.borderBottomRightRadius = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    const inpElmBorderRadius = panelStuff.querySelector('#inpElmBorderRadius');
    inpElmBorderRadius.value = '';
    let s = elm.style.borderRadius;
    let nBorderRadius = parseInt(s);
    if (!isNaN(nBorderRadius)) {
      inpElmBorderRadius.value = nBorderRadius;
    }
    const inpElmBorderTopLeftRadius = panelStuff.querySelector('#inpElmBorderTopLeftRadius');
    inpElmBorderTopLeftRadius.value = '';
    s = elm.style.borderTopLeftRadius;
    let nBorderTopLeftRadius = parseInt(s);
    if (!isNaN(nBorderTopLeftRadius)) {
      inpElmBorderTopLeftRadius.value = nBorderTopLeftRadius;
    }
    const inpElmBorderTopRightRadius = panelStuff.querySelector('#inpElmBorderTopRightRadius');
    inpElmBorderTopRightRadius.value = '';
    s = elm.style.borderTopRightRadius;
    let nBorderTopRightRadius = parseInt(s);
    if (!isNaN(nBorderTopRightRadius)) {
      inpElmBorderTopRightRadius.value = nBorderTopRightRadius;
    }
    const inpElmBorderBottomLeftRadius = panelStuff.querySelector('#inpElmBorderBottomLeftRadius');
    inpElmBorderBottomLeftRadius.value = '';
    s = elm.style.borderBottomLeftRadius;
    let nBorderBottomLeftRadius = parseInt(s);
    if (!isNaN(nBorderBottomLeftRadius)) {
      inpElmBorderBottomLeftRadius.value = nBorderBottomLeftRadius;
    }
    const inpElmBorderBottomRightRadius = panelStuff.querySelector('#inpElmBorderBottomRightRadius');
    inpElmBorderBottomRightRadius.value = '';
    s = elm.style.borderBottomRightRadius;
    let nBorderBottomRightRadius = parseInt(s);
    if (!isNaN(nBorderBottomRightRadius)) {
      inpElmBorderBottomRightRadius.value = nBorderBottomRightRadius;
    }
  }
}

const dom$9 = new Dom();
class ElementShadowStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementShadow');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;width:100%;">${util.out('Shadow')}</div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('x Offset')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmBoxShadowX" value="" style="width:45px"/>
                    <select id="inpElmBoxShadowXUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('y Offset')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmBoxShadowY" value="" style="width:45px"/>
                    <select id="inpElmBoxShadowYUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Blur')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmBoxShadowBlur" value="" style="width:45px"/>
                    <select id="inpElmBoxShadowBlurUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Spread')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmBoxShadowSpread" value="" style="width:45px"/>
                    <select id="inpElmBoxShadowSpreadUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:100%;">
                <div>${util.out('Shadow Color')}:</div>
                <div>
                <button title="${util.out('Shadow Color')}" class="input-elm-shadowcolor is-btn-color"></button>
                </div>
            </div>

            <div class="is-settings" style="width:100%;">
                <div>${util.out('Outer/Inner Shadow')}:</div>
                <div>
                    <select id="inpElmBoxShadowInset">
                        <option value="">Outset</option>
                        <option value="inset">Inset</option>
                    </select>
                </div>
            </div>
        `;
    dom$9.appendHtml(panelStuff, html);

    // Shadow color
    let btnElmShadowColor = panelStuff.querySelector('.input-elm-shadowcolor');
    btnElmShadowColor.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      this.builder.colorPicker.open(color => {
        btnElmShadowColor.style.backgroundColor = color; // preview

        this.updateShadow(this.builder.inspectedElement);
        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      }, btnElmShadowColor.style.backgroundColor, () => {
        btnElmShadowColor.removeAttribute('data-focus');
        btnElmShadowColor.focus();
      });
      btnElmShadowColor.setAttribute('data-focus', true);
    });
    let inps = panelStuff.querySelectorAll('#inpElmBoxShadowX,#inpElmBoxShadowY,#inpElmBoxShadowBlur,#inpElmBoxShadowSpread');
    Array.prototype.forEach.call(inps, inp => {
      inp.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
      });
      inp.addEventListener('keyup', () => {
        let elm = this.builder.inspectedElement;
        this.updateShadow(elm);
        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      });
    });
    inps = panelStuff.querySelectorAll('#inpElmBoxShadowXUnit,#inpElmBoxShadowYUnit,#inpElmBoxShadowBlurUnit,#inpElmBoxShadowSpreadUnit');
    Array.prototype.forEach.call(inps, inp => {
      inp.addEventListener('change', () => {
        this.builder.uo.saveForUndo();
        let elm = this.builder.inspectedElement;
        this.updateShadow(elm);
        elementStyleEditor.refresh();

        //Trigger Change event
        this.builder.opts.onChange();
      });
    });
    const inpElmBoxShadowInset = panelStuff.querySelector('#inpElmBoxShadowInset');
    inpElmBoxShadowInset.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      this.updateShadow(elm);
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  updateShadow(elm) {
    let panelStuff = this.panelStuff;
    var shadowColor = panelStuff.querySelector('.input-elm-shadowcolor').style.backgroundColor;
    var shadowInset = panelStuff.querySelector('#inpElmBoxShadowInset').value;
    var val = panelStuff.querySelector('#inpElmBoxShadowX').value;
    var unit = panelStuff.querySelector('#inpElmBoxShadowXUnit').value;
    var offX = '';
    if (!isNaN(val) && val !== '') {
      offX = val + unit;
    }
    val = panelStuff.querySelector('#inpElmBoxShadowY').value;
    unit = panelStuff.querySelector('#inpElmBoxShadowYUnit').value;
    var offY = '';
    if (!isNaN(val) && val !== '') {
      offY = val + unit;
    }
    val = panelStuff.querySelector('#inpElmBoxShadowBlur').value;
    unit = panelStuff.querySelector('#inpElmBoxShadowBlurUnit').value;
    var blur = '';
    if (!isNaN(val) && val !== '') {
      blur = val + unit;
    }
    val = panelStuff.querySelector('#inpElmBoxShadowSpread').value;
    unit = panelStuff.querySelector('#inpElmBoxShadowSpreadUnit').value;
    var spread = '';
    if (!isNaN(val) && val !== '') {
      spread = val + unit;
    }
    elm.style.boxShadow = (offX + ' ' + offY + ' ' + blur + ' ' + spread + ' ' + shadowColor + ' ' + shadowInset).trim();
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    let color, n;
    let sBoxShadow = elm.style.boxShadow;
    let inps = panelStuff.querySelectorAll('#inpElmBoxShadowX,#inpElmBoxShadowY,#inpElmBoxShadowBlur,#inpElmBoxShadowSpread');
    Array.prototype.forEach.call(inps, inp => {
      inp.value = '';
    });
    inps = panelStuff.querySelectorAll('#inpElmBoxShadowXUnit,#inpElmBoxShadowYUnit,#inpElmBoxShadowBlurUnit,#inpElmBoxShadowSpreadUnit');
    Array.prototype.forEach.call(inps, inp => {
      inp.value = 'px';
    });
    panelStuff.querySelector('#inpElmBoxShadowInset').value = '';
    if (sBoxShadow.indexOf('inset') !== -1) {
      panelStuff.querySelector('#inpElmBoxShadowInset').value = 'inset';
      sBoxShadow = sBoxShadow.replace('inset', '');
    }
    if (sBoxShadow !== '') {
      if (sBoxShadow.indexOf('rgb') !== -1) {
        //always get rgb value, not hex
        color = sBoxShadow.substr(sBoxShadow.indexOf('rgb'));
        color = color.substr(0, color.indexOf(')') + 1);
        panelStuff.querySelector('.input-elm-shadowcolor').style.backgroundColor = color;
        n = sBoxShadow.split('rgb')[1].indexOf(')');
        sBoxShadow = sBoxShadow.split('rgb')[0] + sBoxShadow.split('rgb')[1].substr(n + 2);
      }
      if (sBoxShadow.indexOf('#') !== -1) {
        //never executed
        color = sBoxShadow.substr(sBoxShadow.indexOf('#'));
        color = color.substr(0, color.indexOf(' '));
        panelStuff.querySelector('.input-elm-shadowcolor').style.backgroundColor = color;
        n = sBoxShadow.split('#')[1].indexOf(' ');
        sBoxShadow = sBoxShadow.split('#')[0] + sBoxShadow.split('#')[1].substr(n + 2);
      }
      let array = sBoxShadow.split(' ');
      let length = array.length;
      n = 1;
      for (let i = 0; i < length; i++) {
        if (n === 1) {
          panelStuff.querySelector('#inpElmBoxShadowX').value = parseInt(array[i]);
          if (array[i].indexOf('px') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowXUnit').value = 'px';
          } else if (array[i].indexOf('em') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowXUnit').value = 'em';
          } else {
            panelStuff.querySelector('#inpElmBoxShadowX').value = '';
          }
        }
        if (n === 2) {
          panelStuff.querySelector('#inpElmBoxShadowY').value = parseInt(array[i]);
          if (array[i].indexOf('px') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowYUnit').value = 'px';
          } else if (array[i].indexOf('em') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowYUnit').value = 'em';
          } else {
            panelStuff.querySelector('#inpElmBoxShadowY').value = '';
          }
        }
        if (n === 3) {
          panelStuff.querySelector('#inpElmBoxShadowBlur').value = parseInt(array[i]);
          if (array[i].indexOf('px') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowBlurUnit').value = 'px';
          } else if (array[i].indexOf('em') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowBlurUnit').value = 'em';
          } else {
            panelStuff.querySelector('#inpElmBoxShadowBlur').value = '';
          }
        }
        if (n === 4) {
          panelStuff.querySelector('#inpElmBoxShadowSpread').value = parseInt(array[i]);
          if (array[i].indexOf('px') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowSpreadUnit').value = 'px';
          } else if (array[i].indexOf('em') !== -1) {
            panelStuff.querySelector('#inpElmBoxShadowSpreadUnit').value = 'em';
          } else {
            panelStuff.querySelector('#inpElmBoxShadowSpread').value = '';
          }
        }
        n++;
      }
    }
  }
}

const dom$8 = new Dom();
class ElementDisplayStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementDisplay');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;">${util.out('Display')}</div>

            <div class="is-settings" style="width:100%;">
                <div style="display:flex">
                    <select id="inpElmDisplay" style="width:110px;">
                        <option value=""></option>
                        <option value="block">Block</option>
                        <option value="inline-block">Inline Block</option>
                        <option value="inline">Inline</option>
                        <option value="flex">Flex</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>

            <div style="margin-top:25px;font-weight:bold;width:100%;">${util.out('Flex')}</div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Direction')}:</div>
                <div style="display:flex">
                    <select id="inpElmFlexDirection" style="width:110px;">
                        <option value=""></option>
                        <option value="row">Row</option>
                        <option value="row-reverse">Row Reverse</option>
                        <option value="column">Column</option>
                        <option value="column-reverse">Column Reverse</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Wrap')}:</div>
                <div style="display:flex">
                    <select id="inpElmFlexWrap" style="width:110px;">
                        <option value=""></option>
                        <option value="no-wrap">No Wrap</option>
                        <option value="wrap">Wrap</option>
                        <option value="wrap-reverse">Wrap Reverse</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:100%;">
                <div>${util.out('Justify Content')}:</div>
                <div style="display:flex">
                    <select id="inpElmJustifyContent" style="width:110px;">
                        <option value=""></option>
                        <option value="center">Center</option>
                        <option value="flex-start">Flex Start</option>
                        <option value="flex-end">Flex End</option>
                        <option value="space-around">Space Around</option>
                        <option value="space-between">Space Between</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Align Items')}:</div>
                <div style="display:flex">
                    <select id="inpElmAlignItems" style="width:110px;">
                        <option value=""></option>
                        <option value="center">Center</option>
                        <option value="flex-start">Flex Start</option>
                        <option value="flex-end">Flex End</option>
                        <option value="stretch">Stretch</option>
                        <option value="baseline">Baseline</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Align Content')}:</div>
                <div style="display:flex">
                    <select id="inpElmAlignContent" style="width:110px;">
                        <option value=""></option>
                        <option value="center">Center</option>
                        <option value="flex-start">Flex Start</option>
                        <option value="flex-end">Flex End</option>
                        <option value="stretch">Stretch</option>
                        <option value="space-around">Space Around</option>
                        <option value="space-between">Space Between</option>
                    </select>
                </div>
            </div>
        `;
    dom$8.appendHtml(panelStuff, html);
    const inpElmDisplay = panelStuff.querySelector('#inpElmDisplay');
    inpElmDisplay.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmDisplay').value;
      elm.style.display = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmFlexDirection = panelStuff.querySelector('#inpElmFlexDirection');
    inpElmFlexDirection.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFlexDirection').value;
      elm.style.flexDirection = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmFlexWrap = panelStuff.querySelector('#inpElmFlexWrap');
    inpElmFlexWrap.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFlexWrap').value;
      elm.style.flexWrap = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmJustifyContent = panelStuff.querySelector('#inpElmJustifyContent');
    inpElmJustifyContent.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmJustifyContent').value;
      elm.style.justifyContent = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmAlignItems = panelStuff.querySelector('#inpElmAlignItems');
    inpElmAlignItems.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmAlignItems').value;
      elm.style.alignItems = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmAlignContent = panelStuff.querySelector('#inpElmAlignContent');
    inpElmAlignContent.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmAlignContent').value;
      elm.style.alignContent = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    const inpElmDisplay = panelStuff.querySelector('#inpElmDisplay');
    inpElmDisplay.value = '';
    let s = elm.style.display;
    if (s) inpElmDisplay.value = s;
    const inpElmFlexDirection = panelStuff.querySelector('#inpElmFlexDirection');
    inpElmFlexDirection.value = '';
    s = elm.style.flexDirection;
    if (s) inpElmFlexDirection.value = s;
    const inpElmFlexWrap = panelStuff.querySelector('#inpElmFlexWrap');
    inpElmFlexWrap.value = '';
    s = elm.style.flexWrap;
    if (s) inpElmFlexWrap.value = s;
    const inpElmJustifyContent = panelStuff.querySelector('#inpElmJustifyContent');
    inpElmJustifyContent.value = '';
    s = elm.style.justifyContent;
    if (s) inpElmJustifyContent.value = s;
    const inpElmAlignItems = panelStuff.querySelector('#inpElmAlignItems');
    inpElmAlignItems.value = '';
    s = elm.style.alignItems;
    if (s) inpElmAlignItems.value = s;
    const inpElmAlignContent = panelStuff.querySelector('#inpElmAlignContent');
    inpElmAlignContent.value = '';
    s = elm.style.alignContent;
    if (s) inpElmAlignContent.value = s;
  }
}

const dom$7 = new Dom();
class ElementPositionStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementPosition');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;width:100%;">${util.out('Position')}</div>

            <div class="is-settings" style="width:100%;">
                <div style="display:flex">
                    <select id="inpElmPosition">
                        <option value=""></option>
                        <option value="relative">Relative</option>
                        <option value="absolute">Absolute</option>
                        <option value="fixed">Fixed</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Top')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmTop" value="" style="width:45px"/>
                    <select id="inpElmTopUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Left')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmLeft" value="" style="width:45px"/>
                    <select id="inpElmLeftUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Bottom')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmBottom" value="" style="width:45px"/>
                    <select id="inpElmBottomUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div>${util.out('Right')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmRight" value="" style="width:45px"/>
                    <select id="inpElmRightUnit">
                        <option value="px">px</option>
                        <option value="em">em</option>
                        <option value="vw">vw</option>
                        <option value="vh">vh</option>
                        <option value="%">%</option>
                    </select>
                </div>
            </div>

            <div style="margin-top: 25px;font-weight: bold;width:100%;">${util.out('Float')}</div>

            <div class="is-settings" style="width:100%;">
                <div style="display:flex">
                    <select id="inpElmFloat">
                        <option value=""></option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
        `;
    dom$7.appendHtml(panelStuff, html);
    const inpElmPosition = panelStuff.querySelector('#inpElmPosition');
    inpElmPosition.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmPosition').value;
      elm.style.position = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmFloat = panelStuff.querySelector('#inpElmFloat');
    inpElmFloat.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmFloat').value;
      elm.style.float = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmTop = panelStuff.querySelector('#inpElmTop');
    inpElmTop.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    const inpElmTopUnit = panelStuff.querySelector('#inpElmTopUnit');
    inpElmTop.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmTop.value;
      let unit = inpElmTopUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.top = val + unit;
      } else {
        elm.style.top = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmTopUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmTop.value;
      let unit = inpElmTopUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.top = val + unit;
      } else {
        elm.style.top = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBottom = panelStuff.querySelector('#inpElmBottom');
    inpElmBottom.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    const inpElmBottomUnit = panelStuff.querySelector('#inpElmBottomUnit');
    inpElmBottom.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmBottom.value;
      let unit = inpElmBottomUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.bottom = val + unit;
      } else {
        elm.style.bottom = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmBottomUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmBottom.value;
      let unit = inpElmBottomUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.bottom = val + unit;
      } else {
        elm.style.bottom = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmLeft = panelStuff.querySelector('#inpElmLeft');
    inpElmLeft.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    const inpElmLeftUnit = panelStuff.querySelector('#inpElmLeftUnit');
    inpElmLeft.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmLeft.value;
      let unit = inpElmLeftUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.left = val + unit;
      } else {
        elm.style.left = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmLeftUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmLeft.value;
      let unit = inpElmLeftUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.left = val + unit;
      } else {
        elm.style.left = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmRight = panelStuff.querySelector('#inpElmRight');
    inpElmRight.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    const inpElmRightUnit = panelStuff.querySelector('#inpElmRightUnit');
    inpElmRight.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = inpElmRight.value;
      let unit = inpElmRightUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.right = val + unit;
      } else {
        elm.style.right = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inpElmRightUnit.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = inpElmRight.value;
      let unit = inpElmRightUnit.value;
      if (!isNaN(val) && val !== '') {
        elm.style.right = val + unit;
      } else {
        elm.style.right = '';
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    const inpElmPosition = panelStuff.querySelector('#inpElmPosition');
    inpElmPosition.value = '';
    let s = elm.style.position;
    inpElmPosition.value = s;
    const inpElmFloat = panelStuff.querySelector('#inpElmFloat');
    inpElmFloat.value = '';
    s = elm.style.float;
    inpElmFloat.value = s;
    const inpElmTop = panelStuff.querySelector('#inpElmTop');
    const inpElmTopUnit = panelStuff.querySelector('#inpElmTopUnit');
    inpElmTop.value = '';
    inpElmTopUnit.value = 'px';
    s = elm.style.top;
    let nTop = parseInt(s);
    if (!isNaN(nTop)) {
      if (s.indexOf('%') !== -1) inpElmTopUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmTopUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmTopUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmTopUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmTopUnit.value = 'em';
      inpElmTop.value = nTop;
    }
    const inpElmBottom = panelStuff.querySelector('#inpElmBottom');
    const inpElmBottomUnit = panelStuff.querySelector('#inpElmBottomUnit');
    inpElmBottom.value = '';
    inpElmBottomUnit.value = 'px';
    s = elm.style.bottom;
    let nBottom = parseInt(s);
    if (!isNaN(nBottom)) {
      if (s.indexOf('%') !== -1) inpElmBottomUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmBottomUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmBottomUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmBottomUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmBottomUnit.value = 'em';
      inpElmBottom.value = nBottom;
    }
    const inpElmLeft = panelStuff.querySelector('#inpElmLeft');
    const inpElmLeftUnit = panelStuff.querySelector('#inpElmLeftUnit');
    inpElmLeft.value = '';
    inpElmLeftUnit.value = 'px';
    s = elm.style.left;
    let nLeft = parseInt(s);
    if (!isNaN(nLeft)) {
      if (s.indexOf('%') !== -1) inpElmLeftUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmLeftUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmLeftUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmLeftUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmLeftUnit.value = 'em';
      inpElmLeft.value = nLeft;
    }
    const inpElmRight = panelStuff.querySelector('#inpElmRight');
    const inpElmRightUnit = panelStuff.querySelector('#inpElmRightUnit');
    inpElmRight.value = '';
    inpElmRightUnit.value = 'px';
    s = elm.style.right;
    let nRight = parseInt(s);
    if (!isNaN(nRight)) {
      if (s.indexOf('%') !== -1) inpElmRightUnit.value = '%';
      if (s.indexOf('px') !== -1) inpElmRightUnit.value = 'px';
      if (s.indexOf('vw') !== -1) inpElmRightUnit.value = 'vw';
      if (s.indexOf('vh') !== -1) inpElmRightUnit.value = 'vh';
      if (s.indexOf('em') !== -1) inpElmRightUnit.value = 'em';
      inpElmRight.value = nRight;
    }
  }
}

const dom$6 = new Dom();
class ElementEffectStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const elementStyleEditor = new ELementStyleEditor(builder);
    let panelStuff = builderStuff.querySelector('#divElementEffect');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;">${util.out('Effects')}</div>

            <div class="is-settings" style="width:100%;">
                <div>${util.out('Opacity')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmOpacity" value="" style="width:45px"/>
                </div>
            </div>

            <div style="margin-top:25px;font-weight:bold;width:100%;">${util.out('Filters')}</div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Blur')}:</div>
                <div>
                    <input type="text" id="inpElmBlur" value="" style="width:45px"/> &nbsp;px
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Brightness')}:</div>
                <div>
                    <input type="text" id="inpElmBrightness" value="" style="width:45px"/>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Contrast')}:</div>
                <div>
                    <input type="text" id="inpElmContrast" value="" style="width:45px"/> &nbsp;%
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Grayscale')}:</div>
                <div>
                    <input type="text" id="inpElmGrayscale" value="" style="width:45px"/> &nbsp;%
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Hue Rotate')}:</div>
                <div>
                    <input type="text" id="inpElmHueRotate" value="" style="width:45px"/> &nbsp;<span style="font-size:12px">deg</span>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Invert')}:</div>
                <div>
                    <input type="text" id="inpElmInvert" value="" style="width:45px"/> &nbsp;%
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Saturate')}:</div>
                <div>
                    <input type="text" id="inpElmSaturate" value="" style="width:45px"/>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div>${util.out('Sepia')}:</div>
                <div>
                    <input type="text" id="inpElmSepia" value="" style="width:45px"/> &nbsp;%
                </div>
            </div>
        `;
    dom$6.appendHtml(panelStuff, html);
    const inpElmOpacity = panelStuff.querySelector('#inpElmOpacity');
    inpElmOpacity.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmOpacity.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmOpacity').value;
      elm.style.opacity = val;
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let i;
    const inpElmBlur = panelStuff.querySelector('#inpElmBlur');
    inpElmBlur.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBlur.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBlur').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('blur') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'blur(' + val + 'px)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' blur(' + val + 'px)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmBrightness = panelStuff.querySelector('#inpElmBrightness');
    inpElmBrightness.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmBrightness.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmBrightness').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('brightness') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'brightness(' + val + ')';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' brightness(' + val + ')';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmContrast = panelStuff.querySelector('#inpElmContrast');
    inpElmContrast.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmContrast.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmContrast').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('contrast') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'contrast(' + val + '%)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' contrast(' + val + '%)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmGrayscale = panelStuff.querySelector('#inpElmGrayscale');
    inpElmGrayscale.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmGrayscale.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmGrayscale').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('grayscale') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'grayscale(' + val + '%)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' grayscale(' + val + '%)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmHueRotate = panelStuff.querySelector('#inpElmHueRotate');
    inpElmHueRotate.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmHueRotate.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmHueRotate').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('hue-rotate') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'hue-rotate(' + val + 'deg)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' hue-rotate(' + val + 'deg)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmInvert = panelStuff.querySelector('#inpElmInvert');
    inpElmInvert.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmInvert.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmInvert').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('invert') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'invert(' + val + '%)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' invert(' + val + '%)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmSaturate = panelStuff.querySelector('#inpElmSaturate');
    inpElmSaturate.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmSaturate.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmSaturate').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('saturate') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'saturate(' + val + ')';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' saturate(' + val + ')';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmSepia = panelStuff.querySelector('#inpElmSepia');
    inpElmSepia.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
    });
    inpElmSepia.addEventListener('keyup', () => {
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#inpElmSepia').value;
      let sFilter = elm.style.filter;
      sFilter = sFilter.replace('none', '');
      let arr = sFilter.split(' ');
      let exist = false;
      for (i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (s.indexOf('sepia') !== -1) {
          if (!isNaN(val) && val !== '') {
            arr[i] = 'sepia(' + val + '%)';
          } else {
            arr[i] = '';
          }
          exist = true;
        }
      }
      if (!exist) {
        sFilter = sFilter + ' sepia(' + val + '%)';
      } else {
        sFilter = '';
        for (i = 0; i < arr.length; i++) {
          sFilter += ' ' + arr[i];
        }
      }
      if (sFilter.trim() === '') {
        elm.style.filter = 'none';
      } else {
        elm.style.filter = sFilter;
      }
      elementStyleEditor.refresh();

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    const inpElmOpacity = panelStuff.querySelector('#inpElmOpacity');
    inpElmOpacity.value = '';
    let s = elm.style.opacity;
    if (s) inpElmOpacity.value = s;

    //filter
    let sFilter = elm.style.filter; // brightness(2) blur(1px) contrast(100%)'

    let arr = sFilter.split(' ');
    const inpElmBlur = panelStuff.querySelector('#inpElmBlur');
    inpElmBlur.value = '';
    const inpElmBrightness = panelStuff.querySelector('#inpElmBrightness');
    inpElmBrightness.value = '';
    const inpElmGrayscale = panelStuff.querySelector('#inpElmGrayscale');
    inpElmGrayscale.value = '';
    const inpElmContrast = panelStuff.querySelector('#inpElmContrast');
    inpElmContrast.value = '';
    const inpElmHueRotate = panelStuff.querySelector('#inpElmHueRotate');
    inpElmHueRotate.value = '';
    const inpElmInvert = panelStuff.querySelector('#inpElmInvert');
    inpElmInvert.value = '';
    const inpElmSaturate = panelStuff.querySelector('#inpElmSaturate');
    inpElmSaturate.value = '';
    const inpElmSepia = panelStuff.querySelector('#inpElmSepia');
    inpElmSepia.value = '';
    let val;
    for (let i = 0; i < arr.length; i++) {
      s = arr[i];
      if (s.indexOf('blur') !== -1) {
        //blur exists
        val = s.replace('blur(', '').replace(')', '');
        val = parseInt(val);
        inpElmBlur.value = val;
      }
      if (s.indexOf('brightness') !== -1) {
        //brightness exists
        val = s.replace('brightness(', '').replace(')', '');
        val = parseInt(val);
        inpElmBrightness.value = val;
      }
      if (s.indexOf('grayscale') !== -1) {
        //grayscale exists
        val = s.replace('grayscale(', '').replace(')', '');
        val = parseInt(val);
        inpElmGrayscale.value = val;
      }
      if (s.indexOf('contrast') !== -1) {
        //contrast exists
        val = s.replace('contrast(', '').replace(')', '');
        val = parseInt(val);
        inpElmContrast.value = val;
      }
      if (s.indexOf('hue-rotate') !== -1) {
        //hue-rotate exists
        val = s.replace('hue-rotate(', '').replace(')', '');
        val = parseInt(val);
        inpElmHueRotate.value = val;
      }
      if (s.indexOf('invert') !== -1) {
        //invert exists
        val = s.replace('invert(', '').replace(')', '');
        val = parseInt(val);
        inpElmInvert.value = val;
      }
      if (s.indexOf('saturate') !== -1) {
        //saturate exists
        val = s.replace('saturate(', '').replace(')', '');
        val = parseInt(val);
        inpElmSaturate.value = val;
      }
      if (s.indexOf('sepia') !== -1) {
        //sepia exists
        val = s.replace('sepia(', '').replace(')', '');
        val = parseInt(val);
        inpElmSepia.value = val;
      }
    }
  }
}

const dom$5 = new Dom();
class ElementAttributeStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    let panelStuff = builderStuff.querySelector('#divElementAttribute');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;width:100%;">${util.out('Attributes')}</div>

            <div class="is-settings" style="width:120px;">
                <div style="width:100%">${util.out('Names')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmAttr1" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="width:100%">${util.out('Values')}:</div>
                <div style="display:flex">
                    <input type="text" id="inpElmAttrVal1" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttr2" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttrVal2" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttr3" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttrVal3" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttr4" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttrVal4" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttr5" value="" style="width:90%"/>
                </div>
            </div>

            <div class="is-settings" style="width:120px;float:left;">
                <div style="display:flex">
                    <input type="text" id="inpElmAttrVal5" value="" style="width:90%"/>
                </div>
            </div>
        `;
    dom$5.appendHtml(panelStuff, html);
    let inps = panelStuff.querySelectorAll('#inpElmAttr1,#inpElmAttr2,#inpElmAttr3,#inpElmAttr4,#inpElmAttr5,#inpElmAttrVal1,#inpElmAttrVal2,#inpElmAttrVal3,#inpElmAttrVal4,#inpElmAttrVal5');
    Array.prototype.forEach.call(inps, inp => {
      inp.addEventListener('click', () => {
        this.builder.uo.saveForUndo();
      });
      inp.addEventListener('keyup', () => {
        let elm = this.builder.inspectedElement;
        this.updateAttributes(elm);

        //Trigger Change event
        this.builder.opts.onChange();
      });
    });
  }
  updateAttributes(elm) {
    // Remove all attributes
    let attrs = {};
    Array.prototype.forEach.call(elm.attributes, attribute => {
      attrs[attribute.name] = attribute.value;
    });
    for (let k in attrs) {
      if (Object.prototype.hasOwnProperty.call(attrs, k)) {
        if (k !== 'id' && k !== 'style' && k !== 'class' && k !== 'href' && k !== 'src' && k !== 'contenteditable' && k !== 'data-filename') {
          elm.removeAttribute(k);
        }
      }
    }

    // Update
    const panelStuff = this.panelStuff;
    let attrname, val;
    attrname = panelStuff.querySelector('#inpElmAttr1').value;
    val = panelStuff.querySelector('#inpElmAttrVal1').value;
    if (attrname !== '') elm.setAttribute(attrname, val);
    attrname = panelStuff.querySelector('#inpElmAttr2').value;
    val = panelStuff.querySelector('#inpElmAttrVal2').value;
    if (attrname !== '') elm.setAttribute(attrname, val);
    attrname = panelStuff.querySelector('#inpElmAttr3').value;
    val = panelStuff.querySelector('#inpElmAttrVal3').value;
    if (attrname !== '') elm.setAttribute(attrname, val);
    attrname = panelStuff.querySelector('#inpElmAttr4').value;
    val = panelStuff.querySelector('#inpElmAttrVal4').value;
    if (attrname !== '') elm.setAttribute(attrname, val);
    attrname = panelStuff.querySelector('#inpElmAttr5').value;
    val = panelStuff.querySelector('#inpElmAttrVal5').value;
    if (attrname !== '') elm.setAttribute(attrname, val);
  }
  readElementStyles(elm) {
    const panelStuff = this.panelStuff;
    let inps = panelStuff.querySelectorAll('#inpElmAttr1,#inpElmAttr2,#inpElmAttr3,#inpElmAttr4,#inpElmAttr5,#inpElmAttrVal1,#inpElmAttrVal2,#inpElmAttrVal3,#inpElmAttrVal4,#inpElmAttrVal5');
    Array.prototype.forEach.call(inps, inp => {
      inp.value = '';
    });
    var indx = 1;
    Array.prototype.forEach.call(elm.attributes, attribute => {
      if (attribute.name !== 'id' && attribute.name !== 'style' && attribute.name !== 'class' && attribute.name !== 'href' && attribute.name !== 'src' && attribute.name !== 'contenteditable' && attribute.name !== 'data-filename' && attribute.name !== 'data-saveforundo') {
        panelStuff.querySelector('#inpElmAttr' + indx).value = attribute.name;
        panelStuff.querySelector('#inpElmAttrVal' + indx).value = attribute.value;
        indx = indx + 1;
      }
    });
  }
}

const dom$4 = new Dom();
class ElementMoreStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    let panelStuff = builderStuff.querySelector('#divElementMore');
    this.panelStuff = panelStuff;
    const html = `

            <div class="is-settings" style="width:100%;margin-bottom:9px;">
                <div>${util.out('Add Element ID')}:</div>
                <div>
                    <input type="text" id="inpElmId" value="" style="width:100%"/>
                </div>
            </div>

            <div class="is-settings" style="width:100%;margin-bottom:9px;">
                <div>${util.out('Add Css Classes')}:</div>
                <div>
                    <input type="text" id="inpElmCssClasses" value="" style="width:100%"/>
                </div>
            </div>

        `;
    dom$4.appendHtml(panelStuff, html);
    const inpElmId = panelStuff.querySelector('#inpElmId');
    inpElmId.addEventListener('change', () => {
      let elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      if (inpElmId.value !== '') {
        elm.setAttribute('id', inpElmId.value);
      } else {
        elm.removeAttribute('id');
      }

      //Trigger Change event
      this.builder.opts.onChange();
    });
    const inpElmCssClasses = panelStuff.querySelector('#inpElmCssClasses');
    inpElmCssClasses.addEventListener('change', () => {
      let elm = this.builder.inspectedElement;
      this.builder.uo.saveForUndo();
      let arrCurrentClasses = [];
      let currentClasses = elm.getAttribute('data-class');
      if (currentClasses) arrCurrentClasses = currentClasses.split(' ');
      let arrNewClasses = [];
      let newClasses = inpElmCssClasses.value;
      arrNewClasses = newClasses.split(' ');
      arrCurrentClasses.forEach(item => {
        if (!arrNewClasses.includes(item)) {
          elm.classList.remove(item);
        }
      });
      arrNewClasses.forEach(item => {
        if (item !== '') elm.classList.add(item);
      });

      // save
      elm.setAttribute('data-class', newClasses);
      if (elm.getAttribute('data-class') === '') elm.removeAttribute('data-class');

      //Trigger Change event
      this.builder.opts.onChange();
    });
  }
  readElementStyles(elm) {
    let panelStuff = this.panelStuff;
    const inpElmId = panelStuff.querySelector('#inpElmId');
    inpElmId.value = '';
    const rowId = elm.getAttribute('id');
    if (rowId) {
      inpElmId.value = rowId;
    }
    const inpElmCssClasses = panelStuff.querySelector('#inpElmCssClasses');
    inpElmCssClasses.value = '';
    const classes = elm.getAttribute('data-class');
    inpElmCssClasses.value = classes;
  }
}

const dom$3 = new Dom();
class ElementAnimationStyles {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    let panelStuff = builderStuff.querySelector('#divElementAnimation');
    this.panelStuff = panelStuff;
    const html = `
            <div style="margin-top:13px;font-weight:bold;">${util.out('Animate')}</div>

            <div class="is-settings" style="width:100%;">
                <div style="display:flex">
                    <select id="selElmAnim">
                        <option value=""></option>
                        <option value="fade">fade</option>
                        <option value="fade-up">fade-up</option>
                        <option value="fade-down">fade-down</option>
                        <option value="fade-left">fade-left</option>
                        <option value="fade-right">fade-right</option>
                        <option value="fade-up-right">fade-up-right</option>
                        <option value="fade-up-left">fade-up-left</option>
                        <option value="fade-down-right">fade-down-right</option>
                        <option value="fade-down-left">fade-down-left</option>
                        <option value="flip-up">flip-up</option>
                        <option value="flip-down">flip-down</option>
                        <option value="flip-left">flip-left</option>
                        <option value="flip-right">flip-right</option>
                        <option value="slide-up">slide-up</option>
                        <option value="slide-down">slide-down</option>
                        <option value="slide-left">slide-left</option>
                        <option value="slide-right">slide-right</option>
                        <option value="zoom-in">zoom-in</option>
                        <option value="zoom-in-up">zoom-in-up</option>
                        <option value="zoom-in-down">zoom-in-down</option>
                        <option value="zoom-in-left">zoom-in-left</option>
                        <option value="zoom-in-right">zoom-in-right</option>
                        <option value="zoom-out">zoom-out</option>
                        <option value="zoom-out-up">zoom-out-up</option>
                        <option value="zoom-out-down">zoom-out-down</option>
                        <option value="zoom-out-left">zoom-out-left</option>
                        <option value="zoom-out-right">zoom-out-right</option>
                    </select>
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div> ${util.out('Delay')}:</div>
                <div>
                    <select id="selElmAnimDelay">
                        <option value=""></option>
                        <option value="0">0</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                        <option value="700">700</option>
                        <option value="800">800</option>
                        <option value="900">900</option>
                        <option value="1000">1000</option>
                        <option value="1100">1100</option>
                        <option value="1200">1200</option>
                        <option value="1300">1300</option>
                        <option value="1400">1400</option>
                        <option value="1500">1500</option>
                        <option value="1600">1600</option>
                        <option value="1700">1700</option>
                        <option value="1800">1800</option>
                        <option value="1900">1900</option>
                        <option value="2000">2000</option>
                        <option value="2100">2100</option>
                        <option value="2200">2200</option>
                        <option value="2300">2300</option>
                        <option value="2400">2400</option>
                        <option value="2500">2500</option>
                        <option value="2600">2600</option>
                        <option value="2700">2700</option>
                        <option value="2800">2800</option>
                        <option value="2900">2900</option>
                        <option value="3000">3000</option>
                    </select> &nbsp;ms
                </div>
            </div>

            <div class="is-settings" style="width:110px;">
                <div> ${util.out('Duration')}:</div>
                <div>
                    <select id="selElmAnimDuration">
                        <option value=""></option>
                        <option value="0">0</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                        <option value="700">700</option>
                        <option value="800">800</option>
                        <option value="900">900</option>
                        <option value="1000">1000</option>
                        <option value="1100">1100</option>
                        <option value="1200">1200</option>
                        <option value="1300">1300</option>
                        <option value="1400">1400</option>
                        <option value="1500">1500</option>
                        <option value="1600">1600</option>
                        <option value="1700">1700</option>
                        <option value="1800">1800</option>
                        <option value="1900">1900</option>
                        <option value="2000">2000</option>
                        <option value="2100">2100</option>
                        <option value="2200">2200</option>
                        <option value="2300">2300</option>
                        <option value="2400">2400</option>
                        <option value="2500">2500</option>
                        <option value="2600">2600</option>
                        <option value="2700">2700</option>
                        <option value="2800">2800</option>
                        <option value="2900">2900</option>
                        <option value="3000">3000</option>
                    </select> &nbsp;ms
                </div>
            </div>

            <div class="is-settings" style="width:100%;">
                <div style="margin-top:15px">
                    <label for="chkAnimateOnce"><input type="checkbox" id="chkAnimateOnce" value=""> ${util.out('Animate Once')} </label>
                </div>
            </div>

            <div class="is-settings" style="width:100%;">
                <div style="display:flex">
                    <button title="${util.out('Test')}" id="btnPreviewAnim" class="classic" value=""> ${util.out('TEST')} </button>
                </div>
            </div>
        `;
    dom$3.appendHtml(panelStuff, html);
    let inp = panelStuff.querySelector('#selElmAnim');
    inp.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#selElmAnim').value;
      if (val === '') {
        elm.removeAttribute('data-aos');
      } else {
        elm.setAttribute('data-aos', val);
        panelStuff.querySelector('#btnPreviewAnim').click();
      }

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inp = panelStuff.querySelector('#selElmAnimDelay');
    inp.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#selElmAnimDelay').value;
      if (val === '') {
        elm.removeAttribute('data-aos-delay');
      } else {
        elm.setAttribute('data-aos-delay', val);
      }

      //Trigger Change event
      this.builder.opts.onChange();
    });
    inp = panelStuff.querySelector('#selElmAnimDuration');
    inp.addEventListener('change', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      let val = panelStuff.querySelector('#selElmAnimDuration').value;
      if (val === '') {
        elm.removeAttribute('data-aos-duration');
      } else {
        elm.setAttribute('data-aos-duration', val);
      }

      //Trigger Change event
      this.builder.opts.onChange();
    });
    let btn = panelStuff.querySelector('#chkAnimateOnce');
    btn.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.inspectedElement;
      if (panelStuff.querySelector('#chkAnimateOnce').checked) {
        elm.setAttribute('data-aos-once', 'true');
      } else {
        elm.removeAttribute('data-aos-once');
      }

      //Trigger Change event
      this.builder.opts.onChange();
    });
    btn = panelStuff.querySelector('#btnPreviewAnim');
    btn.addEventListener('click', () => {
      let elm = this.builder.inspectedElement;
      let animduration = elm.getAttribute('data-aos-duration');
      elm.removeAttribute('data-aos-duration'); //can cause preview problem

      elm.style.visibility = 'hidden';
      if (window.AOS) window.AOS.init({
        duration: 1
      });
      dom$3.removeClass(elm, 'aos-init');
      dom$3.removeClass(elm, 'aos-animate');
      setTimeout(function () {
        elm.style.visibility = '';
        if (window.AOS) window.AOS.init({
          duration: 1200
        });
        if (animduration) {
          elm.setAttribute('data-aos-duration', animduration);
        }
      }, 10);
    });
  }
  readElementStyles(elm) {
    this.panelStuff.querySelector('#selElmAnimDelay').value = '';
    let animname = elm.getAttribute('data-aos-delay');
    this.panelStuff.querySelector('#selElmAnimDelay').value = animname;
    this.panelStuff.querySelector('#selElmAnimDuration').value = '';
    animname = elm.getAttribute('data-aos-duration');
    this.panelStuff.querySelector('#selElmAnimDuration').value = animname;
    this.panelStuff.querySelector('#chkAnimateOnce').checked = false;
    let animateonce = elm.getAttribute('data-aos-once');
    if (animateonce) {
      if (animateonce === 'true') {
        this.panelStuff.querySelector('#chkAnimateOnce').checked = true;
      }
    }
    this.panelStuff.querySelector('#selElmAnim').value = '';
    animname = elm.getAttribute('data-aos');
    this.panelStuff.querySelector('#selElmAnim').value = animname;
  }
}

const dom$2 = new Dom();
let arrElms = [];
class ElementPanel {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
  }
  renderPanel() {
    const util = this.util;
    const builderStuff = this.builderStuff;
    const builder = this.builder;
    let panel = builderStuff.querySelector('.elementstyles');
    if (!panel) {
      let html = `
            <div class="is-side${this.builder.opts.sidePanel === 'right' ? '' : ' fromleft'} elementstyles" style="display:none;" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                    <div class="elm-list" style="z-index:1;width:100%;height:100px;position:absolute;top:0px;left:0px;box-sizing:border-box;display:flex;align-items:center;flex-wrap: wrap;padding:10px 23px 10px 18px;"></div>
                    
                    <button tabindex="-1" title="${util.out('Close')}" class="is-side-close" style="z-index:1;background:transparent;width:25px;height:25px;position:absolute;top:10px;right:13px;box-sizing:border-box;padding:0;line-height:25px;font-size: 12px;text-align:center;cursor:pointer;"><svg class="is-icon-flex" style="width:25px;height:25px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                    
                    <div style="position: absolute;bottom:7px;right:7px;width:40px;height:25px;z-index:1;display:flex">
                        <button title="${util.out('css')}" class="elm-editstyle classic" style="width: 40px;height: 25px;font-family: sans-serif;font-size: 10px;padding: 0px;font-weight: bold;">${util.out('css')}</button>
                    </div>
                        
                    <div style="width:100%;height:100%;overflow-y:auto;overflow-x:hidden;position:absolute;top:0px;left:0px;box-sizing:border-box;border-top:100px solid transparent;padding:0px;">
                            
                        <div class="is-tabs" data-group="element" style="padding-right:0;padding-bottom:0;">
                            <a title="${util.out('General')}" id="tabElementGeneral" href="" data-content="divElementGeneral" class="active">${util.out('General')}</a>
                            <a title="${util.out('Box')}" id="tabElementBox" href="" data-content="divElementBox">${util.out('Box')}</a>
                            <a title="${util.out('Spacing')}" id="tabElementSpacing" href="" data-content="divElementSpacing">${util.out('Spacing')}</a>
                            <a title="${util.out('Text')}" id="tabElementText" href="" data-content="divElementText">${util.out('Text')}</a>
                            <a title="${util.out('More')}" id="tabElementMore" data-menu="divElementMoreItems" href=""><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-more"></use></svg></a>
                        </div>
                        
                        <ul id="divElementMoreItems" style="top: 50px;left: 140px;" class="is-tabs-more" data-group="element" tabindex="-1" aria-modal="true" aria-hidden="true">
                            <li title="${util.out('Border')}" id="tabElementBorder" data-content="divElementBorder" tabindex="0">${util.out('Border')}</li>
                            <li title="${util.out('Corners')}" id="tabElementCorner" data-content="divElementCorner" tabindex="0">${util.out('Corners')}</li>
                            <li title="${util.out('Shadow')}" id="tabElementShadow" data-content="divElementShadow" tabindex="0">${util.out('Shadow')}</li>
                            <li title="${util.out('Display')}" id="tabElementDisplay" data-content="divElementDisplay" tabindex="0">${util.out('Display')}</li>
                            <li title="${util.out('Position')}" id="tabElementPosition" data-content="divElementPosition" tabindex="0">${util.out('Position')}</li>
                            <li title="${util.out('Effects')}" id="tabElementEffect" data-content="divElementEffect" tabindex="0">${util.out('Effects')}</li>
                            <li style="display:none" title="${util.out('Attributes')}" id="tabElementAttribute" data-content="divElementAttribute" tabindex="0">${util.out('Attributes')}</li>
                            ${this.builder.opts.elementAnimate === true ? `<li title="${util.out('Animation')}" id="tabElementAnimation" data-content="divElementAnimation" tabindex="0">${util.out('Animation')}</li>` : ''}
                            <li title="${util.out('More')}" id="tabElementMore" data-content="divElementMore" tabindex="0">${util.out('More')}</li>
                        </ul>
                        
                        <div id="divElementGeneral" class="is-tab-content active" tabindex="-1" data-group="element" style="display:flex;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementBox" class="is-tab-content active" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementSpacing" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementBorder" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementText" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementCorner" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementShadow" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementDisplay" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementPosition" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementEffect" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementAttribute" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                        
                        <div id="divElementAnimation" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>

                        <div id="divElementMore" class="is-tab-content" tabindex="-1" data-group="element" style="display:none;flex-flow:wrap;padding:12px 20px;">
                        </div>
                    </div>
            </div>              
            `;
      dom$2.appendHtml(builderStuff, html);
      this.elementStyleEditor = new ELementStyleEditor(builder);
      panel = builderStuff.querySelector('.elementstyles');
      let btn = panel.querySelector('.is-side-close');
      dom$2.addEventListener(btn, 'click', () => {
        this.hidePanel();
      });
      btn = panel.querySelector('.elm-editstyle');
      dom$2.addEventListener(btn, 'click', () => {
        this.elementStyleEditor.toggleStyleEditor();
      });
      this.panel = panel;
      const elementBoxStyles = new ElementBoxStyles(builder);
      this.elementBoxStyles = elementBoxStyles;
      const elementGeneralStyles = new ElementGeneralStyles(builder);
      this.elementGeneralStyles = elementGeneralStyles;
      const elementSpacingStyles = new ElementSpacingStyles(builder);
      this.elementSpacingStyles = elementSpacingStyles;
      const elementBorderStyles = new ElementBorderStyles(builder);
      this.elementBorderStyles = elementBorderStyles;
      const elementTextStyles = new ElementTextStyles(builder);
      this.elementTextStyles = elementTextStyles;
      const elementCornerStyles = new ElementCornerStyles(builder);
      this.elementCornerStyles = elementCornerStyles;
      const elementShadowStyles = new ElementShadowStyles(builder);
      this.elementShadowStyles = elementShadowStyles;
      const elementDisplayStyles = new ElementDisplayStyles(builder);
      this.elementDisplayStyles = elementDisplayStyles;
      const elementPositionStyles = new ElementPositionStyles(builder);
      this.elementPositionStyles = elementPositionStyles;
      const elementEffectStyles = new ElementEffectStyles(builder);
      this.elementEffectStyles = elementEffectStyles;
      const elementAttributeStyles = new ElementAttributeStyles(builder);
      this.elementAttributeStyles = elementAttributeStyles;
      const elementMoreStyles = new ElementMoreStyles(builder);
      this.elementMoreStyles = elementMoreStyles;
      const elementAnimationStyles = new ElementAnimationStyles(builder);
      this.elementAnimationStyles = elementAnimationStyles;
      this.tabs = new Tabs({
        element: this.panel
      });
    }
  }
  click() {
    if (!this.panel) return;
    if (dom$2.hasClass(this.panel, 'active') || dom$2.hasClass(this.elementStyleEditor.modalStyles, 'active')) {
      this.inspect(this.builder.inspectedElement);
    }
  }
  inspect(elm) {
    this.elementGeneralStyles.readElementStyles(elm);
    this.elementBoxStyles.readElementStyles(elm);
    this.elementSpacingStyles.readElementStyles(elm);
    this.elementBorderStyles.readElementStyles(elm);
    this.elementTextStyles.readElementStyles(elm);
    this.elementCornerStyles.readElementStyles(elm);
    this.elementShadowStyles.readElementStyles(elm);
    this.elementDisplayStyles.readElementStyles(elm);
    this.elementPositionStyles.readElementStyles(elm);
    this.elementEffectStyles.readElementStyles(elm);
    this.elementAttributeStyles.readElementStyles(elm);
    this.elementMoreStyles.readElementStyles(elm);
    this.elementAnimationStyles.readElementStyles(elm);
    let panel = this.panel;
    let elms = this.builder.doc.querySelectorAll('[data-saveforundo]');
    Array.prototype.forEach.call(elms, elm => {
      elm.removeAttribute('data-saveforundo');
    });
    elm.setAttribute('data-saveforundo', '');
    elms = this.builder.doc.querySelectorAll('.elm-inspected');
    Array.prototype.forEach.call(elms, elm => {
      dom$2.removeClass(elm, 'elm-inspected');
    });
    setTimeout(() => {
      dom$2.addClass(elm, 'elm-inspected');
    }, 10);
    panel.querySelector('.elm-list').innerHTML = '';
    let element = elm;
    let i = 0;
    arrElms = [];
    while (!dom$2.hasClass(element, 'is-builder')) {
      arrElms.push(element);
      if (!element) {
        // This should not happen. But on quick user click (ex. undo then redo quickly), an element can lost, so checking is needed
        break;
      }
      if (!element.tagName) {
        break;
      }
      var tagName = element.tagName.toLowerCase();
      var a = dom$2.createElement('a');
      a.setAttribute('data-index', i);
      i++;
      a.setAttribute('href', '#');
      a.innerHTML = tagName;
      if (panel.querySelector('.elm-list').innerHTML === '') {
        dom$2.addClass(a, 'active');
        panel.querySelector('.elm-list').insertAdjacentHTML('afterbegin', a.outerHTML);
      } else {
        panel.querySelector('.elm-list').insertAdjacentHTML('afterbegin', '&nbsp;>&nbsp; ');
        panel.querySelector('.elm-list').insertAdjacentHTML('afterbegin', a.outerHTML);
      }
      element = element.parentNode;
    }
    const links = panel.querySelectorAll('.elm-list a');
    Array.prototype.forEach.call(links, link => {
      dom$2.addEventListener(link, 'click', e => {
        let index = link.getAttribute('data-index');
        this.builder.inspectedElement = arrElms[index];
        this.inspect(arrElms[index]);
        if (!this.builder.doc.querySelector('.elm-inspected.elm-active')) {
          // hide element tool if inspected element is not active element
          this.builderStuff.querySelector('.is-element-tool').style.display = 'none';
        }
        e.preventDefault();
        e.stopImmediatePropagation(); // a must
      });
    });

    this.elementStyleEditor.refresh();
  }
  showPanel() {
    this.renderPanel();
    var panel = this.builderStuff.querySelector('.is-side.elementstyles');
    panel.style.display = 'block'; // this is needed because the elementstyles panel's display is set 'none' (to prevent warning as the panel is actually not visible at first)

    let panels = this.builderStuff.querySelectorAll('.is-side');
    Array.prototype.forEach.call(panels, panel => {
      dom$2.removeClass(panel, 'active');
    });
    setTimeout(() => {
      dom$2.addClass(panel, 'active'); // add 10ms delay after display is set 'block' for visible animation

      // Focus
      let content = panel.querySelector('.is-tab-content.active');
      content.focus();
      this.builder.tabs.setupTabKey(content);
      const handleKeyDown = e => {
        if (e.keyCode === 27) {
          // escape key
          this.hidePanel();
        }
      };
      panel.addEventListener('keydown', handleKeyDown);
    }, 10);
    this.inspect(this.builder.inspectedElement);
  }
  hidePanel() {
    var panel = this.builderStuff.querySelector('.is-side.elementstyles');
    dom$2.removeClass(panel, 'active');
    let elms = this.builder.doc.querySelectorAll('[data-saveforundo]');
    Array.prototype.forEach.call(elms, elm => {
      elm.removeAttribute('data-saveforundo');
    });
    elms = this.builder.doc.querySelectorAll('.elm-inspected');
    Array.prototype.forEach.call(elms, elm => {
      dom$2.removeClass(elm, 'elm-inspected');
    });
  }
}

class ElementTool {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    if (!this.builder.controlPanel) {
      const elementPanel = new ElementPanel(builder);
      this.elementPanel = elementPanel;
    }
    let elementTool = builderStuff.querySelector('.is-element-tool');
    let elementMore = builderStuff.querySelector('.elmmore');
    if (!elementTool) {
      let html = `<div class="is-tool is-element-tool">
                <button type="button" tabindex="-1" title="${util.out('Add')}" class="elm-add"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('More')}" class="elm-more"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('Delete')}" class="elm-remove"><svg class="is-icon-flex" style="margin-left:-1px"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                <button type="button" tabindex="-1" title="${util.out('Settings')}" class="elm-settings"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
            </div>
            <div class="is-pop elmmore" style="z-index:10002;" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="display:flex;flex-flow:wrap;">
                    <button type="button" title="${util.out('Move Up')}" class="elm-up"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-up"></use></svg></span>${util.out('Move Up')}</button>
                    <button type="button" title="${util.out('Move Down')}" class="elm-down"><span><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#ion-ios-arrow-thin-down"></use></svg></span>${util.out('Move Down')}</button>
                    <button type="button" title="${util.out('Duplicate')}" class="elm-duplicate"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></span>${util.out('Duplicate')}</button>
                    ${this.builder.opts.elementEditor ? `
                    <button type="button" title="${util.out('Settings')}" class="elm-settings"><span><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-ios-gear"></use></svg></span>${util.out('Settings')}</button>
                    ` : ''} 
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      if (!this.builder.iframe) {
        elementTool = builderStuff.querySelector('.is-element-tool');
      } else {
        elementTool = this.builder.contentStuff.querySelector('.is-element-tool');
      }
      elementMore = builderStuff.querySelector('.elmmore');

      // Prepare for tooltip
      let elms = elementTool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
    }
    this.elementTool = elementTool;
    this.elementMore = elementMore;

    // Add element
    const elmAdd = elementTool.querySelector('.elm-add');
    dom.addEventListener(elmAdd, 'click', () => {
      const quickadd = renderQuickAdd(builder);
      let tabs = quickadd.querySelector('.is-pop-tabs');
      tabs.style.display = 'none';
      const viewportHeight = window.innerHeight;

      /*
      let top, left;
      if(!this.builder.iframe) {
          top = elmAdd.getBoundingClientRect().top;
          left = elmAdd.getBoundingClientRect().left;
      } else {
          let adjY = this.builder.iframe.getBoundingClientRect().top;// + window.pageYOffset;
          let adjX = this.builder.iframe.getBoundingClientRect().left;// + window.pageXOffset;
           top = elmAdd.getBoundingClientRect().top + adjY ;
          left = elmAdd.getBoundingClientRect().left + adjX;
      }
      */
      const newPos = this.builder.util.getElementPosition(elmAdd);
      let top = newPos.top;
      let left = newPos.left;

      // quickadd.style.display = 'flex';
      util.showPop(quickadd, false, elmAdd);
      const w = quickadd.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
      const h = quickadd.offsetHeight;
      if (viewportHeight - top > h) {
        quickadd.style.top = top + window.pageYOffset + 27 + 'px';
        quickadd.style.left = left - w / 2 + 10 + 'px';
        dom.removeClass(quickadd, 'arrow-bottom');
        dom.removeClass(quickadd, 'arrow-right');
        dom.removeClass(quickadd, 'arrow-left');
        dom.removeClass(quickadd, 'center');
        dom.addClass(quickadd, 'arrow-top');
        dom.addClass(quickadd, 'center');
      } else {
        quickadd.style.top = top + window.pageYOffset - h - 8 + 'px';
        quickadd.style.left = left - w / 2 + 10 + 'px';
        dom.removeClass(quickadd, 'arrow-top');
        dom.removeClass(quickadd, 'arrow-right');
        dom.removeClass(quickadd, 'arrow-left');
        dom.removeClass(quickadd, 'center');
        dom.addClass(quickadd, 'arrow-bottom');
        dom.addClass(quickadd, 'center');
      }
      quickadd.setAttribute('data-mode', 'elm');

      //handleQuickAddClickOut
      const handleQuickAddClickOut = e => {
        // console.log('handleQuickAddClickOut');
        let elm = e.target;
        if (!elm) return;
        if (!elm.closest('.quickadd') && !elm.closest('.row-add') && !elm.closest('.is-rowadd-tool') && !elm.closest('.cell-add') && !elm.closest('.elm-add') && !elm.closest('.row-add-initial')) {
          // click outside

          // hide
          const quickadd = builderStuff.querySelector('.quickadd');
          util.hidePop(quickadd);
          // console.log('HIDE');

          // clear events
          document.removeEventListener('click', handleQuickAddClickOut);
          if (this.builder.iframeDocument) {
            this.builder.doc.removeEventListener('click', handleQuickAddClickOut);
          }
          this.builder.handleQuickAddClickOut_ = false;
        }
      };
      if (!this.builder.handleQuickAddClickOut_) {
        document.addEventListener('click', handleQuickAddClickOut);
        if (this.builder.iframeDocument) {
          this.builder.doc.addEventListener('click', handleQuickAddClickOut);
        }
        this.builder.handleQuickAddClickOut_ = true;
      }
    });
    const elmRemove = elementTool.querySelector('.elm-remove');
    dom.addEventListener(elmRemove, 'click', () => {
      util.confirm(util.out('Are you sure you want to delete this element?'), ok => {
        if (ok) {
          this.builder.uo.saveForUndo();
          let elm = this.builder.activeElement;
          let subblock = false;
          if (elm.closest('.is-subblock')) {
            subblock = true;
          }

          /*
          if(dom.hasClass(elm.parentNode, 'cell-active') || elm.parentNode.hasAttribute('data-subblock')) {
              // Level 1
              elm.parentNode.removeChild(elm);
          } else {
              // Deeper
              if(elm.parentNode.childElementCount > 1) {
                  elm.parentNode.removeChild(elm);
              } else {
                  let element = elm;
                  if(!dom.parentsHasAttribute(element, 'data-subblock')) {
                      
                      while(!dom.hasClass(element.parentNode, 'cell-active') && elm.parentNode.childElementCount === 1) {
                          element = element.parentNode;
                      }
                   } else {
                       while(!element.parentNode.hasAttribute('data-subblock') && elm.parentNode.childElementCount === 1) {
                          element = element.parentNode;
                      }
                   }
                  element.parentNode.removeChild(element);
              }
          }
          */

          // elm.parentNode.removeChild(elm);
          let elmParent = elm.parentNode;
          elm.remove();
          let childs = dom.elementChildren(elmParent);
          if (!elmParent.classList.contains('cell-active') && childs.length === 0) {
            elmParent.remove(); // remove empty div.display
          }

          this.elementTool.style.display = 'none';
          let cell = this.builder.activeCol;
          if (cell) {
            let row = cell.parentNode;
            if (cell.childElementCount === 0 && row.childElementCount === 4) {
              // 4 => col + tools

              row.parentNode.removeChild(row);
              util.checkEmpty();
            } else if (cell.childElementCount === 0) {
              row.removeChild(cell);
              util.fixLayout(row);
            }
          }

          // Add spacer to empty subblock
          const subblocks = this.builder.doc.querySelectorAll('.is-subblock');
          Array.prototype.forEach.call(subblocks, subblock => {
            const rows = dom.elementChildren(subblock);
            let empty = true;
            rows.forEach(() => {
              empty = false;
            });
            if (empty) {
              subblock.innerHTML = '<div class="spacer height-40" contentEditable="false"></div>';
            }
          });
          util.clearControls();
          if (subblock) {
            let block = this.builder.activeCol;
            let subblocks = block.querySelectorAll('[data-subblock]');
            var index = 1;
            Array.prototype.forEach.call(subblocks, subblock => {
              if (subblock.closest('.glide__slide--clone')) return;
              let html = subblock.innerHTML;
              block.setAttribute('data-html-' + index, encodeURIComponent(html));
              index++;
            });
            util.refreshModuleLayout(block);
          }

          //Trigger Change event
          this.builder.opts.onChange();
          if (this.builder.onSelectChange) this.builder.onSelectChange();
        }
      });
    });
    const btnMore = elementTool.querySelector('.elm-more');
    dom.addEventListener(btnMore, 'click', () => {
      const viewportHeight = window.innerHeight;

      /*
      let top, left;
      if(!this.builder.iframe) {
          top = btnMore.getBoundingClientRect().top;
          left = btnMore.getBoundingClientRect().left;
      } else {
          let adjY = this.builder.iframe.getBoundingClientRect().top;// + window.pageYOffset;
          let adjX = this.builder.iframe.getBoundingClientRect().left;// + window.pageXOffset;
           top = btnMore.getBoundingClientRect().top + adjY;
          left = btnMore.getBoundingClientRect().left + adjX;
      }
      */
      const newPos = this.builder.util.getElementPosition(btnMore);
      let top = newPos.top;
      let left = newPos.left;

      // elementMore.style.display = 'flex';
      util.showPop(elementMore, false, btnMore);
      const w = elementMore.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
      const h = elementMore.offsetHeight;
      if (viewportHeight - top > h) {
        elementMore.style.top = top + window.pageYOffset + 27 + 'px';
        elementMore.style.left = left - w / 2 + 10 + 'px';
        dom.removeClass(elementMore, 'arrow-bottom');
        dom.removeClass(elementMore, 'arrow-right');
        dom.removeClass(elementMore, 'arrow-left');
        dom.removeClass(elementMore, 'center');
        dom.addClass(elementMore, 'arrow-top');
        dom.addClass(elementMore, 'center');
      } else {
        elementMore.style.top = top + window.pageYOffset - h - 8 + 'px';
        elementMore.style.left = left - w / 2 + 10 + 'px';
        dom.removeClass(elementMore, 'arrow-top');
        dom.removeClass(elementMore, 'arrow-right');
        dom.removeClass(elementMore, 'arrow-left');
        dom.removeClass(elementMore, 'center');
        dom.addClass(elementMore, 'arrow-bottom');
        dom.addClass(elementMore, 'center');
      }
    });
    const elmUp = elementMore.querySelector('.elm-up');
    dom.addEventListener(elmUp, 'click', () => {
      let elm = this.builder.activeElement;
      if (elm.previousElementSibling) {
        this.builder.uo.saveForUndo();
        elm.parentNode.insertBefore(elm, elm.previousElementSibling);

        // elm.click();
        // this.position(elm);
        setTimeout(() => {
          this.position();
        }, 30);

        //Trigger Change event
        this.builder.opts.onChange();
      } else {
        // Try move the parent
        let element = elm;
        while (!dom.hasClass(element.parentNode, 'cell-active') && !element.parentNode.hasAttribute('data-subblock')) {
          element = element.parentNode;
        }
        if (element.previousElementSibling && element !== elm) {
          this.builder.uo.saveForUndo();
          element.parentNode.insertBefore(element, element.previousElementSibling);

          // elm.click();
          // this.position(elm);
          setTimeout(() => {
            this.position();
          }, 30);

          //Trigger Change event
          this.builder.opts.onChange();
        }
      }
      // elm.click();
      // elementTool.querySelector('.elm-more').click();
    });

    const elmDown = elementMore.querySelector('.elm-down');
    dom.addEventListener(elmDown, 'click', () => {
      let elm = this.builder.activeElement;
      if (elm.nextElementSibling) {
        this.builder.uo.saveForUndo();
        elm.parentNode.insertBefore(elm.nextElementSibling, elm);

        // elm.click();
        // this.position(elm);
        setTimeout(() => {
          this.position();
        }, 30);

        //Trigger Change event
        this.builder.opts.onChange();
      } else {
        // Try move the parent
        let element = elm;
        while (!dom.hasClass(element.parentNode, 'cell-active') && !element.parentNode.hasAttribute('data-subblock')) {
          element = element.parentNode;
        }
        if (element.nextElementSibling && element !== elm) {
          this.builder.uo.saveForUndo();
          element.parentNode.insertBefore(element.nextElementSibling, element);

          // elm.click();
          // this.position(elm);
          setTimeout(() => {
            this.position();
          }, 30);

          //Trigger Change event
          this.builder.opts.onChange();
        }
      }
    });
    const elmDuplicate = elementMore.querySelector('.elm-duplicate');
    dom.addEventListener(elmDuplicate, 'click', () => {
      this.builder.uo.saveForUndo();
      let elm = this.builder.activeElement;

      //Clone row & cleanup attached tool & event
      const newelm = elm.cloneNode(true);
      dom.moveAfter(newelm, elm);
      setTimeout(() => {
        newelm.click();
        this.position(newelm);
        let builderActive = this.builder.doc.querySelector('.builder-active');
        if (builderActive) this.builder.applyBehaviorOn(builderActive);

        //Trigger Change event
        this.builder.opts.onChange();
      }, 100); //Timeout needed by Safari
    });

    const elmSettings = elementTool.querySelector('.elm-settings');
    if (elmSettings) dom.addEventListener(elmSettings, 'click', () => {
      util.hidePop(elementMore);
      if (this.builder.controlPanel) {
        this.builder.controlpanel.objDialogElement.open();
      } else {
        this.elementPanel.showPanel();
      }
    });
    const elmSettings2 = elementMore.querySelector('.elm-settings');
    if (elmSettings2) dom.addEventListener(elmSettings2, 'click', () => {
      util.hidePop(elementMore);
      if (this.builder.controlPanel) {
        this.builder.controlpanel.objDialogElement.open();
      } else {
        this.elementPanel.showPanel();
      }
    });

    // document.addEventListener('mousedown', (e) => {
    //     e = e || window.event;
    //     var target = e.target || e.srcElement;  

    //     if(elementMore.style.display === 'flex') {
    //         let a = dom.parentsHasClass(target, 'elmmore');
    //         let b = dom.parentsHasClass(target, 'elm-more');
    //         if(a||b) {
    //             return;
    //         }
    //         else {
    //             // elementMore.style.display = '';
    //             util.hidePop(elementMore);
    //         }
    //     }
    // });
  }

  hide() {
    const dom = this.dom;
    this.elementTool.style.display = '';
    let elms = this.builder.doc.querySelectorAll('.elm-active');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-active');
    });
  }
  position() {
    const dom = this.dom;
    let elementTool = this.elementTool;
    let elementMore = this.elementMore;
    dom.addClass(elementMore, 'transition1');
    let elmMore = elementTool.querySelector('.elm-more');
    const viewportHeight = window.innerHeight;

    /*
    let top, left;
    if(!this.builder.iframe) {
        top = elmMore.getBoundingClientRect().top;
        left = elmMore.getBoundingClientRect().left;
    } else {
        let adjY = this.builder.iframe.getBoundingClientRect().top;
        let adjX = this.builder.iframe.getBoundingClientRect().left;
         top = elmMore.getBoundingClientRect().top;
        left = elmMore.getBoundingClientRect().left;
        top = top + adjY;
        left = left + adjX;
    }
    */
    const newPos = this.builder.util.getElementPosition(elmMore);
    let top = newPos.top;
    let left = newPos.left;

    // elementMore.style.display = 'flex';
    const btnMore = elementTool.querySelector('.elm-more');
    this.util.showPop(elementMore, false, btnMore);
    const w = elementMore.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = elementMore.offsetHeight;
    if (viewportHeight - top > h) {
      elementMore.style.top = top + window.pageYOffset + 27 + 'px';
      elementMore.style.left = left - w / 2 + 10 + 'px';
      dom.removeClass(elementMore, 'arrow-bottom');
      dom.removeClass(elementMore, 'arrow-right');
      dom.removeClass(elementMore, 'arrow-left');
      dom.removeClass(elementMore, 'center');
      dom.addClass(elementMore, 'arrow-top');
      dom.addClass(elementMore, 'center');
    } else {
      elementMore.style.top = top + window.pageYOffset - h - 8 + 'px';
      elementMore.style.left = left - w / 2 + 10 + 'px';
      dom.removeClass(elementMore, 'arrow-top');
      dom.removeClass(elementMore, 'arrow-right');
      dom.removeClass(elementMore, 'arrow-left');
      dom.removeClass(elementMore, 'center');
      dom.addClass(elementMore, 'arrow-bottom');
      dom.addClass(elementMore, 'center');
    }
    setTimeout(() => {
      dom.removeClass(elementMore, 'transition1');
    }, 300);
  }
  click(col, e) {
    // old: 12808
    const dom = this.dom;
    const elm = e.target;
    let elementTool = this.elementTool;
    elementTool.style.display = 'none';
    let elms = this.builder.doc.querySelectorAll('.elm-active');
    Array.prototype.forEach.call(elms, elm => {
      dom.removeClass(elm, 'elm-active');
    });
    let activeElement = null;
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    let customcode = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
    }
    let subblock = false;
    //if(dom.parentsHasAttribute(elm, 'data-subblock')) {
    if (dom.parentsHasClass(elm, 'is-subblock')) {
      subblock = true;
    }
    if ((customcode || noedit || _protected) && !subblock) ; else {
      const tagName = elm.tagName.toLowerCase();
      // LATER: label, code, figcaption ?
      if (!elm.classList.contains('cell-active') && (tagName === 'h1' || tagName === 'h2' || tagName === 'h3' || tagName === 'h4' || tagName === 'h5' || tagName === 'h6' || tagName === 'p' || tagName === 'div' || tagName === 'pre' || tagName === 'blockquote' || tagName === 'li' || tagName === 'img' || tagName === 'iframe')) {
        activeElement = elm; //set active element

        if (tagName === 'img') {
          if (dom.hasClass(elm.parentNode, 'img-circular')) {
            activeElement = elm.parentNode;
          }
          let link = dom.getParentByTag(elm, 'a');
          if (link) {
            activeElement = elm.parentNode;
          }
        }
      } else {
        /*
        <div class="cell-active">
             ..level 0
            <p>
                ..level 1
                <b>..deeper level..</b>
            </p>
             <div class="display">
                ..level 1
                <h1>..<b>..deeper level..</b>..</h1>
                <p>..<b>..deeper level..</b>..</p>
            </div>
        </div>                            
        */
        if (dom.hasClass(elm, 'cell-active') || elm.hasAttribute('data-subblock')) ; else if (dom.hasClass(elm, 'cell-active') || elm.parentNode.hasAttribute('data-subblock')) {
          // Level 1
          activeElement = elm;
        } else {
          // Deeper level
          let element = elm;
          while (element.tagName !== 'BODY' && element.tagName !== 'HTML') {
            let s = element.tagName.toLowerCase();
            if (dom.hasClass(element, 'spacer') || s === 'h1' || s === 'h2' || s === 'h3' || s === 'h4' || s === 'h5' || s === 'h6' || s === 'p' || s === 'pre' || s === 'blockquote' || s === 'li' || s === 'img' || s === 'iframe') {
              activeElement = element; //set active element

              break;
            } else {
              if (dom.hasClass(element.parentNode, 'cell-active') || element.parentNode.hasAttribute('data-subblock')) {
                activeElement = element; //set active element
                break;
              }
            }
            element = element.parentNode;
          }
        }
      }
    }
    this.builder.activeElement = activeElement;
    if (activeElement) {
      let elm = activeElement;

      // const top = elm.getBoundingClientRect().top + window.pageYOffset;
      // const left = elm.getBoundingClientRect().left + window.pageXOffset;
      // const w = elm.offsetWidth;
      // const h = elm.offsetHeight;
      // elementTool.style.display = 'flex';
      // elementTool.style.top = (top + h) + 'px';
      // elementTool.style.left = (left + w - elementTool.offsetWidth) + 'px';

      // const viewportWidth = window.innerWidth;
      // if((left + w)>viewportWidth) {
      //     elementTool.style.left = (viewportWidth - elementTool.offsetWidth) + 'px';
      // }
      this.pos();
      dom.addClass(elm, 'elm-active');
    }
    this.builder.inspectedElement = e.target;

    // console.log(this.builder.inspectedElement);
    // console.log(this.builder.activeElement);

    if (!this.builder.controlPanel) {
      this.elementPanel.click(e);
    }
  }
  refresh() {
    if (this.builder.activeElement) {
      let elementTool = this.elementTool;
      elementTool.style.display = '';
      setTimeout(() => {
        // let elm = this.builder.activeElement;
        // const top = elm.getBoundingClientRect().top + window.pageYOffset;
        // const left = elm.getBoundingClientRect().left + window.pageXOffset;
        // const w = elm.offsetWidth;
        // const h = elm.offsetHeight;
        // elementTool.style.display = 'flex';
        // elementTool.style.top = (top + h) + 'px';
        // elementTool.style.left = (left + w - elementTool.offsetWidth) + 'px';

        // const viewportWidth = window.innerWidth;
        // if((left + w)>viewportWidth) {
        //     elementTool.style.left = (viewportWidth - elementTool.offsetWidth) + 'px';
        // }
        this.pos();
      }, 300);
    }
  }
  repositionElementTool(check) {
    // = refresh(), but without delay
    if (this.builder.activeElement) {
      try {
        // use try to prevent unspecified error in IE

        // let elementTool = this.elementTool;

        // let elm = this.builder.activeElement;
        // const top = elm.getBoundingClientRect().top + window.pageYOffset;
        // const left = elm.getBoundingClientRect().left + window.pageXOffset;
        // const w = elm.offsetWidth;
        // const h = elm.offsetHeight;
        // elementTool.style.display = 'flex';
        // elementTool.style.top = (top + h) + 'px';
        // elementTool.style.left = (left + w - elementTool.offsetWidth) + 'px';

        // const viewportWidth = window.innerWidth;
        // if((left + w)>viewportWidth) {
        //     elementTool.style.left = (viewportWidth - elementTool.offsetWidth) + 'px';
        // }
        if (check) {
          // Check tool visibility (flex or none). Only run pos() if the tool is visible.
          let elementTool = this.elementTool;
          if (elementTool.style.display === 'flex') {
            this.pos();
          } else {
            // Do Nothingr
          }
        } else {
          this.pos();
        }
      } catch (e) {
        // Do Nothing
      }
    }
  }
  pos() {
    let elementTool = this.elementTool;
    let elm = this.builder.activeElement;
    if (!elm) return;
    if (elm.closest('.is-dock')) return;
    let top, left;
    if (!this.builder.iframe) {
      top = elm.getBoundingClientRect().top + window.pageYOffset;
      left = elm.getBoundingClientRect().left + window.pageXOffset;
    } else {
      top = elm.getBoundingClientRect().top + this.builder.win.pageYOffset;
      left = elm.getBoundingClientRect().left + this.builder.win.pageXOffset;
    }
    const w = elm.offsetWidth * this.builder.opts.zoom;
    const h = elm.offsetHeight * this.builder.opts.zoom;
    elementTool.style.display = 'flex';
    elementTool.style.top = top + h + 'px';
    elementTool.style.left = left + w - elementTool.offsetWidth + 'px';
    const viewportWidth = window.innerWidth;
    if (left + w > viewportWidth) {
      elementTool.style.left = viewportWidth - elementTool.offsetWidth + 'px';
    }
  }
}

class Preferences {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    let htmlThemes = '';
    if (this.builder.themes) {
      htmlThemes = '<div class="div-themes" style="margin-top:3px">';
      let n = 0;
      this.builder.themes.forEach(item => {
        if (item[1] === '') {
          htmlThemes += `<button type="button" title="${util.out('Set theme')}" class="input-setcolor" data-index="${n}" style="background:${item[0]};border:rgba(0,0,0,0.15) 1px solid;"></button>`;
        } else if (item[1] === 'light') {
          htmlThemes += `<button type="button" title="${util.out('Set theme')}" class="input-setcolor" data-index="${n}" style="background:${item[0]};border:rgb(132 132 132 / 16%) 1px solid;"></button>`;
        } else {
          htmlThemes += `<button type="button" title="${util.out('Set theme')}" class="input-setcolor" data-index="${n}" style="background:${item[0]};"></button>`;
        }
        n++;
      });
      htmlThemes += '</div>';
    }
    let config = builderStuff.querySelector('.viewconfig');
    if (!config) {
      let html = `<div class="is-modal viewconfig" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
                    <div class="is-modal-bar is-draggable">${util.out('Preferences')}</div>
                
                    <div style="display:flex;flex-wrap:wrap;width:100%;padding-top:32px;">
                        <div style="width:50%">
                            <label id="divBuilderMode" style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Builder Mode')}:&nbsp;
                                <select class="select-buildermode" id="__select_builderode">
                                    <option value="">${util.out('Default')}</option>
                                    <option value="minimal">${util.out('Minimal')}</option>
                                    <option value="clean">${util.out('Clean')}</option>
                                </select>
                            </label>
                            
                            <label id="divOutlineMode" style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Outline Mode')}:&nbsp;
                                <select class="select-outlinemode" id="__select_outlinemode">
                                    <option value="">${util.out('Row & column')}</option>
                                    <option value="row">${util.out('Row only')}</option>
                                </select>
                            </label>

                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Outline Style')}:&nbsp;
                                <select class="select-outlinestyle" id="__select_outlinestyle">>
                                    <option value="">${util.out('Colored')}</option>
                                    <option value="grayoutline">${util.out('Gray')}</option>
                                </select>
                            </label>
                            
                            <label style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-hiderowcoloutline" id="__input_hiderowcoloutline" type="checkbox" /> ${util.out('Hide Outline')}&nbsp;
                            </label>  

                            <label id="divHideCellTool" style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-hidecelltool" id="__input_hidecelltool" type="checkbox" />  ${util.out('Hide Column Tool')}&nbsp;
                            </label>


                            <label style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-hidesnippetaddtool" id="__input_hidesnippetaddtool" type="checkbox" />  ${util.out('Hide Snippet (+) Tool')}&nbsp;
                            </label>

                            <label style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-hideelementtool" id="__input_hideelementtool" type="checkbox" /> ${util.out('Hide element tool')}&nbsp;
                            </label>  

                            <label style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-hideelementhighlight" id="__input_hideelementhighlight" type="checkbox" /> ${util.out('Hide element highlight')}&nbsp;
                            </label>  
                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Row Tool Position')}:&nbsp;
                                <select class="select-rowtool" id="__select_rowtool">
                                    <option value="right">${util.out('Right')}</option>
                                    <option value="left">${util.out('Left')}</option>
                                </select>
                            </label>   

                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Tool Style')}:&nbsp;
                                <select class="select-toolstyle" id="__select_toolstyle">
                                    <option value="">${util.out('Colored')}</option>
                                    <option value="gray">${util.out('Mono')}</option>
                                </select>
                            </label>  

                        </div>
                        <div style="width:50%">

                            <label class="option-opensnippets" style="display:block;margin-top:10px;margin-bottom:10px;">
                                <input class="input-opensnippets" id="__input_opensnippets" type="checkbox" />  ${util.out('Open snippets sidebar on start')}&nbsp;
                            </label>

                            <label style="display:${builder.opts.snippetList === '#divSnippetList' ? 'block' : 'none'};margin-top:10px;margin-bottom:5px;">
                               ${util.out('Snippets sidebar visibility')}:&nbsp;
                                <select class="select-snippetssidebardisplay" id="__select_snippetssidebardisplay">
                                    <option value="auto">${util.out('Auto')}</option>
                                    <option value="always">${util.out('Always Visible')}</option>
                                </select>
                            </label>

                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Toolbar visibility')}:&nbsp;
                                <select class="select-editingtoolbardisplay" id="__select_editingtoolbardisplay">
                                    <option value="auto">${util.out('Auto')}</option>
                                    <option value="always">${util.out('Always Visible')}</option>
                                </select>
                            </label>

                            <label style="${this.builder.isTouchSupport ? 'display:none;' : 'display:block;'}margin-top:10px;margin-bottom:5px;">
                                ${util.out('Toolbar position')}:&nbsp;
                                <select class="select-editingtoolbar" id="__select_editingtoolbar">
                                    <option value="topfull">${util.out('Top (Full Width)')}</option>
                                    <option value="top">${util.out('Top')}</option>
                                    <option value="left">${util.out('Left')}</option>
                                    <option value="right">${util.out('Right')}</option>
                                </select>
                            </label> 

                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('Paste result')}:&nbsp;
                                <select class="select-pasteresult" id="__select_pasteresult">
                                    <option value="html-without-styles">${util.out('HTML (without styles)')}</option>
                                    <option value="html">${util.out('HTML (with styles)')}</option>
                                    <option value="text">${util.out('Text only')}</option>
                                </select>
                            </label>  

                            <label style="display:block;margin-top:10px;margin-bottom:5px;">
                                ${util.out('HTML View')}:&nbsp;
                                <select class="select-htmlview" id="__select_htmlview">
                                    <option value="shorten">${util.out('Shorten HTML')}</option>
                                    <option value="actual">${util.out('Actual')}</option>
                                </select>
                            </label>  

                            ${this.builder.themes ? `
                                <label style="${this.builder.isTouchSupport ? 'display:none;' : 'display:block;'}margin-top:10px;margin-bottom:5px;">
                                    ${util.out('Theme')}:&nbsp;
                                    ${htmlThemes}
                                </label> 
                            ` : ''}

                        </div>
                    </div>
                    <div style="text-align:right;margin-top:30px">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>`;
      dom.appendHtml(builderStuff, html);
      config = builderStuff.querySelector('.viewconfig');
      if (!(builder.opts.snippetList === '#divSnippetList' && builder.opts.snippetJSON.snippets.length > 0)) {
        config.querySelector('.option-opensnippets').style.display = 'none';
      }
      let elm = config.querySelector('.input-cancel');
      dom.addEventListener(elm, 'click', () => {
        util.hideModal(config);
      });
      elm = config.querySelector('.input-ok');
      dom.addEventListener(elm, 'click', () => {
        this.update();
        util.hideModal(config);
      });

      // On first load, apply preferences (check if there are stored values)
      if (localStorage.getItem('_hiderowcoloutline') !== null) {
        if (localStorage.getItem('_hiderowcoloutline') === '1') {
          this.builder.opts.rowcolOutline = false;
        } else {
          this.builder.opts.rowcolOutline = true;
        }
      }
      this.setOutline(!this.builder.opts.rowcolOutline);
      if (localStorage.getItem('_outlinemode') !== null) {
        this.builder.opts.outlineMode = localStorage.getItem('_outlinemode');
      }
      this.setOutlineMode(this.builder.opts.outlineMode);
      if (localStorage.getItem('_outlinestyle') !== null) {
        this.builder.opts.outlineStyle = localStorage.getItem('_outlinestyle');
      }
      this.setOutlineStyle(this.builder.opts.outlineStyle);
      if (localStorage.getItem('_pasteresult') !== null) {
        this.builder.opts.paste = localStorage.getItem('_pasteresult');
      }
      if (localStorage.getItem('_htmlview') !== null) {
        let htmlView = localStorage.getItem('_htmlview');
        if (htmlView === 'shorten') {
          this.builder.opts.shortenHTML = true;
        } else {
          this.builder.opts.shortenHTML = false;
        }
      }
      if (localStorage.getItem('_hidecelltool') !== null) {
        if (localStorage.getItem('_hidecelltool') === '1') {
          this.builder.opts.columnTool = false;
        } else {
          this.builder.opts.columnTool = true;
        }
      }
      this.setColumnTool(!this.builder.opts.columnTool);
      if (localStorage.getItem('_hidesnippetaddtool') !== null) {
        if (localStorage.getItem('_hidesnippetaddtool') === '1') {
          this.builder.opts.snippetAddTool = false;
        } else {
          this.builder.opts.snippetAddTool = true;
        }
      }
      this.setSnippetAddTool(!this.builder.opts.snippetAddTool);
      if (localStorage.getItem('_hideelementtool') !== null) {
        if (localStorage.getItem('_hideelementtool') === '1') {
          this.builder.opts.elementTool = false;
        } else {
          this.builder.opts.elementTool = true;
        }
      }
      this.setElementTool(!this.builder.opts.elementTool);
      if (localStorage.getItem('_hideelementhighlight') !== null) {
        if (localStorage.getItem('_hideelementhighlight') === '1') {
          this.builder.opts.elementHighlight = false;
        } else {
          this.builder.opts.elementHighlight = true;
        }
      }
      this.setElementHighlight(!this.builder.opts.elementHighlight);
      if (localStorage.getItem('_opensnippets') !== null) {
        if (localStorage.getItem('_opensnippets') === '1') {
          this.builder.opts.snippetOpen = true;
        } else {
          this.builder.opts.snippetOpen = false;
        }
      }
      if (localStorage.getItem('_buildermode') !== null) {
        this.builder.opts.builderMode = localStorage.getItem('_buildermode');
      }
      this.setBuilderMode(this.builder.opts.builderMode);
      if (localStorage.getItem('_rowtool') !== null) {
        this.builder.opts.rowTool = localStorage.getItem('_rowtool');
      }
      this.setRowToolPosition(this.builder.opts.rowTool);
      if (localStorage.getItem('_toolstyle') !== null) {
        this.builder.opts.toolStyle = localStorage.getItem('_toolstyle');
      }
      this.setToolStyle(this.builder.opts.toolStyle);

      // Always Auto
      if (localStorage.getItem('_editingtoolbardisplay') !== null) {
        this.builder.opts.toolbarDisplay = localStorage.getItem('_editingtoolbardisplay');
      }
      // this.builder.opts.toolbarDisplay = 'auto';
      // this.setToolbarDisplay(this.builder.opts.toolbarDisplay);

      if (localStorage.getItem('_snippetssidebardisplay') !== null) {
        this.builder.opts.snippetsSidebarDisplay = localStorage.getItem('_snippetssidebardisplay');
      }
      if (localStorage.getItem('_editingtoolbar') != null) {
        this.builder.opts.toolbar = localStorage.getItem('_editingtoolbar');
      }
      this.setToolbar(this.builder.opts.toolbar);
      if (localStorage.getItem('_theme') != null) {
        const n = localStorage.getItem('_theme');
        this.builder.themeIndex = n;
        if (this.builder.themes) {
          if (this.builder.themes.length > 0) {
            const item = this.builder.themes[n];
            if (item) {
              this.builder.setUIColor(item[1], item[2]);
              this.builder.renderIframeLater = true;
            }
          }
        }
      } else {
        this.builder.setUIColor('', '');
        this.builder.renderIframeLater = true;
      }
      if (!this.builder.renderIframeLater) {
        // means setUIColor() not called, so we need to call getUIStyles() manually
        util.getUIStyles();
      }

      // Email Mode
      if (this.builder.opts.emailMode) {
        this.builder.opts.outlineMode = 'row';
        this.builder.opts.columnTool = false;
        this.builder.opts.builderMode = '';
        if (localStorage.getItem('_outlinemode') != null) {
          localStorage.setItem('_outlinemode', 'row');
        }
        if (localStorage.getItem('_hidecelltool') !== null) {
          localStorage.setItem('_hidecelltool', '1');
        }
        if (localStorage.getItem('_buildermode') !== null) {
          localStorage.setItem('_buildermode', '');
        }
        this.setColumnTool(true);
        this.setBuilderMode('');
        this.setEmailMode();
        builderStuff.querySelector('#divHideCellTool').style.display = 'none';
        builderStuff.querySelector('#divOutlineMode').style.display = 'none';
        builderStuff.querySelector('#divBuilderMode').style.display = 'none';
      }
    }
    this.config = config;
    const btns = document.querySelectorAll('.input-setcolor');
    btns.forEach(btn => {
      btn.addEventListener('click', e => {
        const n = btn.getAttribute('data-index');
        const item = this.builder.themes[n];
        this.builder.setUIColor(item[1], item[2]);
        this.builder.themeIndex = n;
        e.preventDefault();
        e.stopImmediatePropagation();
      });
    });
  }
  view() {
    const util = new Util(this.builder);
    let modal = this.config;
    util.showModal(modal, false, null, false);

    // Display values
    if (this.builder.opts.rowcolOutline) {
      modal.querySelector('.input-hiderowcoloutline').checked = false;
    } else {
      modal.querySelector('.input-hiderowcoloutline').checked = true;
    }
    if (this.builder.opts.columnTool) {
      modal.querySelector('.input-hidecelltool').checked = false;
    } else {
      modal.querySelector('.input-hidecelltool').checked = true;
    }
    if (this.builder.opts.snippetAddTool) {
      modal.querySelector('.input-hidesnippetaddtool').checked = false;
    } else {
      modal.querySelector('.input-hidesnippetaddtool').checked = true;
    }
    if (this.builder.opts.elementTool) {
      modal.querySelector('.input-hideelementtool').checked = false;
    } else {
      modal.querySelector('.input-hideelementtool').checked = true;
    }
    if (this.builder.opts.elementHighlight) {
      modal.querySelector('.input-hideelementhighlight').checked = false;
    } else {
      modal.querySelector('.input-hideelementhighlight').checked = true;
    }
    if (this.builder.opts.snippetOpen) {
      modal.querySelector('.input-opensnippets').checked = true;
    } else {
      modal.querySelector('.input-opensnippets').checked = false;
    }
    this.config.querySelector('.select-buildermode').value = this.builder.opts.builderMode;
    this.config.querySelector('.select-rowtool').value = this.builder.opts.rowTool;
    this.config.querySelector('.select-outlinemode').value = this.builder.opts.outlineMode;
    this.config.querySelector('.select-outlinestyle').value = this.builder.opts.outlineStyle;
    this.config.querySelector('.select-toolstyle').value = this.builder.opts.toolStyle;
    this.config.querySelector('.select-pasteresult').value = this.builder.opts.paste;
    this.config.querySelector('.select-editingtoolbardisplay').value = this.builder.opts.toolbarDisplay;
    this.config.querySelector('.select-editingtoolbar').value = this.builder.opts.toolbar;
    this.config.querySelector('.select-snippetssidebardisplay').value = this.builder.opts.snippetsSidebarDisplay;
    if (this.builder.opts.shortenHTML) {
      this.config.querySelector('.select-htmlview').value = 'shorten';
    } else {
      this.config.querySelector('.select-htmlview').value = 'actual';
    }
  }
  update() {
    // Update values
    let hideoutline = this.config.querySelector('.input-hiderowcoloutline').checked;
    if (hideoutline) {
      this.builder.opts.rowcolOutline = false;
      localStorage.setItem('_hiderowcoloutline', '1');
    } else {
      this.builder.opts.rowcolOutline = true;
      localStorage.setItem('_hiderowcoloutline', '0');
    }
    this.setOutline(hideoutline);
    let hidecolumntool = this.config.querySelector('.input-hidecelltool').checked;
    if (hidecolumntool) {
      this.builder.opts.columnTool = false;
      localStorage.setItem('_hidecelltool', '1');
      this.setColumnTool(true);
    } else {
      this.builder.opts.columnTool = true;
      localStorage.setItem('_hidecelltool', '0');
      this.setColumnTool(false);
    }
    let hidesnippetaddtool = this.config.querySelector('.input-hidesnippetaddtool').checked;
    if (hidesnippetaddtool) {
      this.builder.opts.snippetAddTool = false;
      localStorage.setItem('_hidesnippetaddtool', '1');
      this.setSnippetAddTool(true);
    } else {
      this.builder.opts.snippetAddTool = true;
      localStorage.setItem('_hidesnippetaddtool', '0');
      this.setSnippetAddTool(false);
    }
    let hideelementtool = this.config.querySelector('.input-hideelementtool').checked;
    if (hideelementtool) {
      this.builder.opts.elementTool = false;
      localStorage.setItem('_hideelementtool', '1');
      this.setElementTool(true);
    } else {
      this.builder.opts.elementTool = true;
      localStorage.setItem('_hideelementtool', '0');
      this.setElementTool(false);
    }
    let hideelementhighlight = this.config.querySelector('.input-hideelementhighlight').checked;
    if (hideelementhighlight) {
      this.builder.opts.elementHighlight = false;
      localStorage.setItem('_hideelementhighlight', '1');
      this.setElementHighlight(true);
    } else {
      this.builder.opts.elementHighlight = true;
      localStorage.setItem('_hideelementhighlight', '0');
      this.setElementHighlight(false);
    }
    let snippetopen = this.config.querySelector('.input-opensnippets').checked;
    if (snippetopen) {
      this.builder.opts.snippetOpen = true;
      localStorage.setItem('_opensnippets', '1');
    } else {
      this.builder.opts.snippetOpen = false;
      localStorage.setItem('_opensnippets', '0');
    }
    let builderMode = this.config.querySelector('.select-buildermode').value;
    this.builder.opts.builderMode = builderMode;
    localStorage.setItem('_buildermode', builderMode);
    this.setBuilderMode(builderMode);
    let rowTool = this.config.querySelector('.select-rowtool').value;
    this.builder.opts.rowTool = rowTool;
    localStorage.setItem('_rowtool', rowTool);
    this.setRowToolPosition(rowTool);
    let outlineMode = this.config.querySelector('.select-outlinemode').value;
    this.builder.opts.outlineMode = outlineMode;
    localStorage.setItem('_outlinemode', outlineMode);
    this.setOutlineMode(outlineMode);
    let outlineStyle = this.config.querySelector('.select-outlinestyle').value;
    this.builder.opts.outlineStyle = outlineStyle;
    localStorage.setItem('_outlinestyle', outlineStyle);
    this.setOutlineStyle(outlineStyle);
    let toolStyle = this.config.querySelector('.select-toolstyle').value;
    this.builder.opts.toolStyle = toolStyle;
    localStorage.setItem('_toolstyle', toolStyle);
    this.setToolStyle(toolStyle);
    let pasteResult = this.config.querySelector('.select-pasteresult').value;
    this.builder.opts.paste = pasteResult;
    localStorage.setItem('_pasteresult', pasteResult);
    let toolbarDisplay = this.config.querySelector('.select-editingtoolbardisplay').value;
    this.builder.opts.toolbarDisplay = toolbarDisplay;
    localStorage.setItem('_editingtoolbardisplay', toolbarDisplay);
    // this.setToolbarDisplay(toolbarDisplay);

    let snippetsSidebarDisplay = this.config.querySelector('.select-snippetssidebardisplay').value;
    this.builder.opts.snippetsSidebarDisplay = snippetsSidebarDisplay;
    localStorage.setItem('_snippetssidebardisplay', snippetsSidebarDisplay);
    let toolbar = this.config.querySelector('.select-editingtoolbar').value;
    this.builder.opts.toolbar = toolbar;
    localStorage.setItem('_editingtoolbar', toolbar);
    this.setToolbar(toolbar);
    let htmlView = this.config.querySelector('.select-htmlview').value;
    if (htmlView === 'shorten') {
      this.builder.opts.shortenHTML = true;
    } else {
      this.builder.opts.shortenHTML = false;
    }
    localStorage.setItem('_htmlview', htmlView);
    if (this.builder.themes) {
      const n = this.builder.themeIndex;
      if (this.builder.themeIndex) localStorage.setItem('_theme', n);
    }

    // clear/hide rte pops
    const builderStuff = this.builder.builderStuff;
    let rtepops = builderStuff.querySelectorAll('.is-rte-pop');
    Array.prototype.forEach.call(rtepops, rtepop => {
      rtepop.style.display = '';
    });
  }
  setToolbar(toolbar) {
    const dom = this.dom;
    const builderStuff = this.builder.builderStuff;
    const contentStuff = this.builder.contentStuff;
    if (toolbar === 'topfull') {
      builderStuff.setAttribute('toolbarfull', '');
      builderStuff.removeAttribute('toolbarleft', '');
      builderStuff.removeAttribute('toolbarright', '');
      if (this.builder.iframe) {
        contentStuff.removeAttribute('toolbarleft', '');
        contentStuff.removeAttribute('toolbarright', '');
      }
    } else if (toolbar === 'top') {
      builderStuff.removeAttribute('toolbarleft', '');
      builderStuff.removeAttribute('toolbarright', '');
      builderStuff.removeAttribute('toolbarfull', '');
      if (this.builder.iframe) {
        contentStuff.removeAttribute('toolbarleft', '');
        contentStuff.removeAttribute('toolbarright', '');
      }
    } else if (toolbar === 'left') {
      builderStuff.setAttribute('toolbarleft', '');
      builderStuff.removeAttribute('toolbarright', '');
      builderStuff.removeAttribute('toolbarfull', '');
      if (this.builder.iframe) {
        contentStuff.setAttribute('toolbarleft', '');
        contentStuff.removeAttribute('toolbarright', '');
      }
    } else if (toolbar === 'right') {
      builderStuff.setAttribute('toolbarright', '');
      builderStuff.removeAttribute('toolbarleft', '');
      builderStuff.removeAttribute('toolbarfull', '');
      if (this.builder.iframe) {
        contentStuff.setAttribute('toolbarright', '');
        contentStuff.removeAttribute('toolbarleft', '');
      }
    }

    // this.positionToolbar();
    const rteTool = builderStuff.querySelector('.is-rte-tool');
    const rteMoreOptions = builderStuff.querySelector('.rte-more-options');
    const elementRteMoreOptions = builderStuff.querySelector('.elementrte-more-options');
    if (rteTool) this.builder.rte.positionToolbar();
    if (rteMoreOptions) {
      dom.removeClass(rteMoreOptions, 'active');
      dom.addClass(rteMoreOptions, 'deactive');
      dom.removeClass(elementRteMoreOptions, 'active');
      dom.addClass(elementRteMoreOptions, 'deactive');
    }
  }
  setEmailMode() {
    const builderStuff = this.builder.builderStuff;
    builderStuff.setAttribute('emailmode', '');
    if (this.builder.iframe) {
      const contentStuff = this.builder.contentStuff;
      contentStuff.setAttribute('emailmode', '');
    }
  }

  /*
  positionToolbar() { // direct
      let builderStuff = document.querySelector('#_cbhtml');
      const rteTool = builderStuff.querySelector('.is-rte-tool');
      const rteMoreOptions = builderStuff.querySelector('.rte-more-options');
      if(rteTool){ // check in case rte stuff hasn't rendered yet
           const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
           if(this.builder.opts.toolbar === 'left' || this.builder.opts.toolbar === 'right') {
  
              let h = rteTool.offsetHeight;
  
              let top = (viewportHeight/2) - (h/2);
  
              rteTool.style.left = '';
              rteTool.style.top = top + 'px';
              
          } else {
  
              let w = rteTool.offsetWidth;
      
              let left = (viewportWidth/2) - (w/2);
      
              rteTool.style.top = '';
              rteTool.style.left = left + 'px';
  
          }
      }
      if(rteMoreOptions) {
          //rteMoreOptions.style.display = '';
          dom.removeClass(rteMoreOptions,'active');
          dom.addClass(rteMoreOptions, 'deactive');
      }
  }
   setToolbarDisplay(toolbardisplay) {
      let builderStuff = document.querySelector('#_cbhtml');
      if(toolbardisplay==='auto'){
           builderStuff.removeAttribute('toolbarstay','');
           // direct
          const rteTool = builderStuff.querySelector('.is-rte-tool');
          if(rteTool) { // check in case rte stuff hasn't rendered yet
              rteTool.style.display = '';
          }
       } else {
           builderStuff.setAttribute('toolbarstay','');
           // direct
          const viewportWidth = window.innerWidth;
          const rteTool = builderStuff.querySelector('.is-rte-tool');
          if(rteTool) { // check in case rte stuff hasn't rendered yet
              let w = rteTool.offsetWidth;
              let left = (viewportWidth/2) - (w/2);
              rteTool.style.left = left + 'px';
          }
       }
  }
  */

  setElementTool(hideelementtool) {
    const builderStuff = this.builder.builderStuff;
    if (hideelementtool) {
      builderStuff.setAttribute('hideelementtool', '');
    } else {
      builderStuff.removeAttribute('hideelementtool', '');
    }
    if (this.builder.iframe) {
      const contentStuff = this.builder.contentStuff;
      if (hideelementtool) {
        contentStuff.setAttribute('hideelementtool', '');
      } else {
        contentStuff.removeAttribute('hideelementtool', '');
      }
    }
  }
  setElementHighlight(hideelementhighlight) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (hideelementhighlight) {
        builder.setAttribute('hideelementhighlight', '');
      } else {
        builder.removeAttribute('hideelementhighlight', '');
      }
    });
  }
  setOutlineStyle(outlineStyle) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (outlineStyle === 'grayoutline') {
        builder.setAttribute('grayoutline', '');
      } else {
        builder.removeAttribute('grayoutline');
      }
    });
  }
  setColumnTool(hidecolumntool) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    if (hidecolumntool) {
      Array.prototype.forEach.call(builders, builder => {
        builder.setAttribute('hidecolumntool', '');
      });
    } else {
      Array.prototype.forEach.call(builders, builder => {
        builder.removeAttribute('hidecolumntool');
      });
    }
  }
  setSnippetAddTool(hidesnippetaddtool) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (hidesnippetaddtool) {
        builder.setAttribute('hidesnippetaddtool', '');
      } else {
        builder.removeAttribute('hidesnippetaddtool', '');
      }
    });
  }
  setToolStyle(toolStyle) {
    const builderStuff = this.builder.builderStuff;
    if (toolStyle === 'gray') {
      builderStuff.setAttribute('gray', '');
    } else {
      builderStuff.removeAttribute('gray', '');
    }
    if (this.builder.iframe) {
      const contentStuff = this.builder.contentStuff;
      if (toolStyle === 'gray') {
        contentStuff.setAttribute('gray', '');
      } else {
        contentStuff.removeAttribute('gray', '');
      }
    }
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (toolStyle === 'gray') {
        builder.setAttribute('gray', '');
      } else {
        builder.removeAttribute('gray');
      }
    });
  }
  setOutlineMode(outlineMode) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (outlineMode === 'row') {
        builder.setAttribute('rowoutline', '');
      } else {
        builder.removeAttribute('rowoutline');
      }
    });
  }
  setOutline(hideoutline) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (hideoutline) {
        builder.setAttribute('hideoutline', '');
      } else {
        builder.removeAttribute('hideoutline');
      }
    });
  }
  setRowToolPosition(rowTool) {
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (rowTool === 'right') {
        builder.removeAttribute('leftrowtool');
      } else {
        builder.setAttribute('leftrowtool', '');
      }
    });
  }
  setBuilderMode(builderMode) {
    const builderStuff = this.builder.builderStuff;
    if (builderMode === '') {
      builderStuff.removeAttribute('minimal');
      builderStuff.removeAttribute('clean');
    } else if (builderMode === 'minimal') {
      builderStuff.setAttribute('minimal', '');
      builderStuff.removeAttribute('clean');
    } else if (builderMode === 'clean') {
      builderStuff.setAttribute('clean', '');
      builderStuff.removeAttribute('minimal');
    }
    if (this.builder.iframe) {
      const contentStuff = this.builder.contentStuff;
      if (builderMode === '') {
        contentStuff.removeAttribute('minimal');
        contentStuff.removeAttribute('clean');
      } else if (builderMode === 'minimal') {
        contentStuff.setAttribute('minimal', '');
        contentStuff.removeAttribute('clean');
      } else if (builderMode === 'clean') {
        contentStuff.setAttribute('clean', '');
        contentStuff.removeAttribute('minimal');
      }
    }
    const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      if (builderMode === '') {
        builder.removeAttribute('minimal');
        builder.removeAttribute('clean');
      } else if (builderMode === 'minimal') {
        builder.setAttribute('minimal', '');
        builder.removeAttribute('clean');
      } else if (builderMode === 'clean') {
        builder.setAttribute('clean', '');
        builder.removeAttribute('minimal');
      }
    });
  }
  initBuilder(builder) {
    const builderMode = this.builder.opts.builderMode;
    if (builderMode === '') {
      builder.removeAttribute('minimal');
      builder.removeAttribute('clean');
    } else if (builderMode === 'minimal') {
      builder.setAttribute('minimal', '');
      builder.removeAttribute('clean');
    } else if (builderMode === 'clean') {
      builder.setAttribute('clean', '');
      builder.removeAttribute('minimal');
    }
    const rowTool = this.builder.opts.rowTool;
    if (rowTool === 'right') {
      builder.removeAttribute('leftrowtool');
    } else {
      builder.setAttribute('leftrowtool', '');
    }
    const hideoutline = !this.builder.opts.rowcolOutline;
    if (hideoutline) {
      builder.setAttribute('hideoutline', '');
    } else {
      builder.removeAttribute('hideoutline');
    }
    const outlineMode = this.builder.opts.outlineMode;
    if (outlineMode === 'row') {
      builder.setAttribute('rowoutline', '');
    } else {
      builder.removeAttribute('rowoutline');
    }
    const toolStyle = this.builder.opts.toolStyle;
    if (toolStyle === 'gray') {
      builder.setAttribute('gray', '');
    } else {
      builder.removeAttribute('gray');
    }
    const hidesnippetaddtool = !this.builder.opts.snippetAddTool;
    if (hidesnippetaddtool) {
      builder.setAttribute('hidesnippetaddtool', '');
    } else {
      builder.removeAttribute('hidesnippetaddtool', '');
    }
    const outlineStyle = this.builder.opts.outlineStyle;
    if (outlineStyle === 'grayoutline') {
      builder.setAttribute('grayoutline', '');
    } else {
      builder.removeAttribute('grayoutline');
    }
    const hideelementhighlight = !this.builder.opts.elementHighlight;
    if (hideelementhighlight) {
      builder.setAttribute('hideelementhighlight', '');
    } else {
      builder.removeAttribute('hideelementhighlight', '');
    }
  }
}

const fontList = [{
  value: '',
  label: '',
  fontFamily: '',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'helvetica neue',
  // Arial
  label: '<img src="%path%arial.png">',
  fontFamily: '\'Helvetica Neue\', \'Arial Nova\', \'Nimbus Sans\', Arial, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'nimbus mono ps',
  // Courier
  label: '<img src="%path%courier.png">',
  fontFamily: '\'Nimbus Mono PS\', \'Courier New\', monospace',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'superclarendon',
  // Georgia
  label: '<img src="%path%georgia.png">',
  fontFamily: 'Superclarendon, \'Bookman Old Style\', \'URW Bookman\', \'URW Bookman L\', \'Georgia Pro\', Georgia, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'ui-monospace',
  // monospace
  label: '<img src="%path%monospace.png">',
  fontFamily: 'ui-monospace, \'Cascadia Code\', \'Source Code Pro\', Menlo, Consolas, \'DejaVu Sans Mono\', monospace',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'system-ui',
  // sans-serif
  label: '<img src="%path%sans_serif.png">',
  fontFamily: 'system-ui, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'charter',
  // serif
  label: '<img src="%path%serif.png">',
  fontFamily: 'Charter, \'Bitstream Charter\', \'Sitka Text\', Cambria, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: ''
}, {
  value: 'abel',
  label: '<img src="%path%abel.png">',
  fontFamily: 'Abel, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'abril fatface',
  label: '<img src="%path%abril_fatface.png">',
  fontFamily: 'Abril Fatface',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'advent pro',
  label: '<img src="%path%advent_pro.png">',
  fontFamily: 'Advent Pro, sans-serif',
  fontStyle: 'wght@100;200;300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'aladin',
  label: '<img src="%path%aladin.png">',
  fontFamily: 'Aladin, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'alegreya',
  label: '<img src="%path%alegreya.png">',
  fontFamily: 'Alegreya, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'alegreya sc',
  label: '<img src="%path%alegreya_sc.png">',
  fontFamily: 'Alegreya SC, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,700;0,800;0,900;1,400;1,500;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'alice',
  label: '<img src="%path%alice.png">',
  fontFamily: 'Alice, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'allerta stencil',
  label: '<img src="%path%allerta_stencil.png">',
  fontFamily: 'Allerta Stencil, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'allura',
  label: '<img src="%path%allura.png">',
  fontFamily: 'Allura, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'almendra display',
  label: '<img src="%path%almendra_display.png">',
  fontFamily: 'Almendra Display, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'amatic sc',
  label: '<img src="%path%amatic_sc.png">',
  fontFamily: 'Amatic SC, cursive',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'andika',
  label: '<img src="%path%andika.png">',
  fontFamily: 'Andika, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'anonymous pro',
  label: '<img src="%path%anonymous_pro.png">',
  fontFamily: 'Anonymous Pro, monospace',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'architects daughter',
  label: '<img src="%path%architects_daughter.png">',
  fontFamily: 'Architects Daughter, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'arimo',
  label: '<img src="%path%arimo.png">',
  fontFamily: 'Arimo, sans-serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'arsenal',
  label: '<img src="%path%arsenal.png">',
  fontFamily: 'Arsenal, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'assistant',
  label: '<img src="%path%assistant.png">',
  fontFamily: 'Assistant',
  fontStyle: 'wght@200;300;400;500;600;700;800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'aubrey',
  label: '<img src="%path%aubrey.png">',
  fontFamily: 'Aubrey, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'anton',
  label: '<img src="%path%anton.png">',
  fontFamily: 'Anton, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'archivo narrow',
  label: '<img src="%path%archivo_narrow.png">',
  fontFamily: 'Archivo Narrow, sans-serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bad script',
  label: '<img src="%path%bad_script.png">',
  fontFamily: 'Bad Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'benchNine',
  label: '<img src="%path%benchNine.png">',
  fontFamily: 'BenchNine, sans-serif',
  fontStyle: 'wght@300;400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bevan',
  label: '<img src="%path%bevan.png">',
  fontFamily: 'Bevan, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bigelow rules',
  label: '<img src="%path%bigelow_rules.png">',
  fontFamily: 'Bigelow Rules, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bilbo',
  label: '<img src="%path%bilbo.png">',
  fontFamily: 'Bilbo, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bonbon',
  label: '<img src="%path%bonbon.png">',
  fontFamily: 'Bonbon, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'bowlby one sc',
  label: '<img src="%path%bowlby_one_sc.png">',
  fontFamily: 'Bowlby One SC, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cabin condensed',
  label: '<img src="%path%cabin_condensed.png">',
  fontFamily: 'Cabin Condensed, sans-serif',
  fontStyle: 'wght@400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'carrois gothic sc',
  label: '<img src="%path%carrois_gothic_sc.png">',
  fontFamily: 'Carrois Gothic SC, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'caveat',
  label: '<img src="%path%caveat.png">',
  fontFamily: 'Caveat, cursive',
  fontStyle: 'wght@400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'chewy',
  label: '<img src="%path%chewy.png">',
  fontFamily: 'Chewy, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cinzel',
  label: '<img src="%path%cinzel.png">',
  fontFamily: 'Cinzel, serif',
  fontStyle: 'wght@400;500;600;700;800;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'comfortaa',
  label: '<img src="%path%comfortaa.png">',
  fontFamily: 'Comfortaa, cursive',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'concert one',
  label: '<img src="%path%concert_one.png">',
  fontFamily: 'Concert One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cormorant',
  label: '<img src="%path%cormorant.png">',
  fontFamily: 'Cormorant, serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cormorant garamond',
  label: '<img src="%path%cormorant_garamond.png">',
  fontFamily: 'Cormorant Garamond, serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cormorant infant',
  label: '<img src="%path%cormorant_infant.png">',
  fontFamily: 'Cormorant Infant, serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cormorant sc',
  label: '<img src="%path%cormorant_sc.png">',
  fontFamily: 'Cormorant SC, serif',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cormorant unicase',
  label: '<img src="%path%cormorant_unicase.png">',
  fontFamily: 'Cormorant Unicase, serif',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cousine',
  label: '<img src="%path%cousine.png">',
  fontFamily: 'Cousine',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'crafty girls',
  label: '<img src="%path%crafty_girls.png">',
  fontFamily: 'Crafty Girls, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cuprum',
  label: '<img src="%path%cuprum.png">',
  fontFamily: 'Cuprum, sans-serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'cutive mono',
  label: '<img src="%path%cutive_mono.png">',
  fontFamily: 'Cutive Mono, monospace',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'devonshire',
  label: '<img src="%path%devonshire.png">',
  fontFamily: 'Devonshire, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'didact gothic',
  label: '<img src="%path%didact_gothic.png">',
  fontFamily: 'Didact Gothic, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'diplomata sc',
  label: '<img src="%path%diplomata_sc.png">',
  fontFamily: 'Diplomata SC, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'dosis',
  label: '<img src="%path%dosis.png">',
  fontFamily: 'Dosis, sans-serif',
  fontStyle: 'wght@200;300;400;500;600;700;800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'eb garamond',
  label: '<img src="%path%eb_garamond.png">',
  fontFamily: 'EB Garamond, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'el messiri',
  label: '<img src="%path%el_messiri.png">',
  fontFamily: 'El Messiri, sans-serif',
  fontStyle: 'wght@400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'elsie',
  label: '<img src="%path%elsie.png">',
  fontFamily: 'Elsie, cursive',
  fontStyle: 'wght@400;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'encode sans',
  label: '<img src="%path%encode_sans.png">',
  fontFamily: 'Encode Sans, sans-serif',
  fontStyle: 'wght@100;200;300;400;500;600;700;800;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'exo',
  label: '<img src="%path%exo.png">',
  fontFamily: 'Exo, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'exo 2',
  label: '<img src="%path%exo_2.png">',
  fontFamily: '\'Exo 2\', sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'felipa',
  label: '<img src="%path%felipa.png">',
  fontFamily: 'Felipa, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fira code',
  label: '<img src="%path%fira_code.png">',
  fontFamily: 'Fira Code, monospace',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fira mono',
  label: '<img src="%path%fira_mono.png">',
  fontFamily: 'Fira Mono, monospace',
  fontStyle: 'wght@400;500;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fira sans',
  label: '<img src="%path%fira_sans.png">',
  fontFamily: 'Fira Sans, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fira sans condensed',
  label: '<img src="%path%fira_sans_condensed.png">',
  fontFamily: 'Fira Sans Condensed, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fira sans extra condensed',
  label: '<img src="%path%fira_sans_extra_condensed.png">',
  fontFamily: 'Fira Sans Extra Condensed, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fjalla one',
  label: '<img src="%path%fjalla_one.png">',
  fontFamily: 'Fjalla One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'forum',
  label: '<img src="%path%forum.png">',
  fontFamily: 'Forum, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'frank ruhl libre',
  label: '<img src="%path%frank_ruhl_libre.png">',
  fontFamily: 'Frank Ruhl Libre',
  fontStyle: 'wght@300;400;500;700;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'fredericka the great',
  label: '<img src="%path%fredericka_the_great.png">',
  fontFamily: 'Fredericka the Great, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'gabriela',
  label: '<img src="%path%gabriela.png">',
  fontFamily: 'Gabriela, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'gilda display',
  label: '<img src="%path%gilda_display.png">',
  fontFamily: 'Gilda Display, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'give you glory',
  label: '<img src="%path%give_you_glory.png">',
  fontFamily: 'Give You Glory, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'handlee',
  label: '<img src="%path%handlee.png">',
  fontFamily: 'Handlee, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'happy monkey',
  label: '<img src="%path%happy_monkey.png">',
  fontFamily: 'Happy Monkey, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'hind',
  label: '<img src="%path%hind.png">',
  fontFamily: 'Hind',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ibm plex mono',
  label: '<img src="%path%ibm_plex_mono.png">',
  fontFamily: 'IBM Plex Mono, monospace',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ibm plex sans',
  label: '<img src="%path%ibm_plex_sans.png">',
  fontFamily: 'IBM Plex Sans, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ibm plex serif',
  label: '<img src="%path%ibm_plex_serif.png">',
  fontFamily: 'IBM Plex Serif, serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'iceland',
  label: '<img src="%path%iceland.png">',
  fontFamily: 'Iceland, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'inconsolata',
  label: '<img src="%path%inconsolata.png">',
  fontFamily: 'Inconsolata, monospace',
  fontStyle: 'wght@200;300;400;500;600;700;800;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'istok web',
  label: '<img src="%path%istok_web.png">',
  fontFamily: 'Istok Web, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'josefin sans',
  label: '<img src="%path%josefin_sans.png">',
  fontFamily: 'Josefin Sans, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'julee',
  label: '<img src="%path%julee.png">',
  fontFamily: 'Julee, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'julius sans one',
  label: '<img src="%path%julius_sans_one.png">',
  fontFamily: 'Julius Sans One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'junge',
  label: '<img src="%path%junge.png">',
  fontFamily: 'Junge, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'jura',
  label: '<img src="%path%jura.png">',
  fontFamily: 'Jura, sans-serif',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'just me again down here',
  label: '<img src="%path%just_me_again_down_here.png">',
  fontFamily: 'Just Me Again Down Here, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kaushan script',
  label: '<img src="%path%kaushan_script.png">',
  fontFamily: 'Kaushan Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kelly slab',
  label: '<img src="%path%kelly_slab.png">',
  fontFamily: 'Kelly Slab, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kite one',
  label: '<img src="%path%kite_one.png">',
  fontFamily: 'Kite One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kosugi',
  label: '<img src="%path%kosugi.png">',
  fontFamily: 'Kosugi, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kosugi maru',
  label: '<img src="%path%kosugi_maru.png">',
  fontFamily: 'Kosugi Maru, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'kurale',
  label: '<img src="%path%kurale.png">',
  fontFamily: 'Kurale, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'lato',
  label: '<img src="%path%lato.png">',
  fontFamily: 'Lato, sans-serif',
  fontStyle: 'ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ledger',
  label: '<img src="%path%ledger.png">',
  fontFamily: 'Ledger, serif',
  fontStyle: '',
  fontDisplay: 'swap',
  provider: 'google'
}, {
  value: 'lekton',
  label: '<img src="%path%lekton.png">',
  fontFamily: 'Lekton, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'life savers',
  label: '<img src="%path%life_savers.png">',
  fontFamily: 'Life Savers, cursive',
  fontStyle: 'wght@400;700;800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'literata',
  label: '<img src="%path%literata.png">',
  fontFamily: 'Literata, serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'lobster',
  label: '<img src="%path%lobster.png">',
  fontFamily: 'Lobster, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'lobster two',
  label: '<img src="%path%lobster_two.png">',
  fontFamily: 'Lobster Two, cursive',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'londrina shadow',
  label: '<img src="%path%londrina_shadow.png">',
  fontFamily: 'Londrina Shadow, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'lora',
  label: '<img src="%path%lora.png">',
  fontFamily: 'Lora, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'lovers quarrel',
  label: '<img src="%path%lovers_quarrel.png">',
  fontFamily: 'Lovers Quarrel, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'm plus 1p',
  label: '<img src="%path%m_plus_1p.png">',
  fontFamily: '\'M PLUS 1p\', sans-serif',
  fontStyle: 'wght@100;300;400;500;700;800;900',
  fontDisplay: 'swap',
  provider: 'google'
}, {
  value: 'm plus rounded 1c',
  label: '<img src="%path%m_plus_rounded_1c.png">',
  fontFamily: '\'M PLUS Rounded 1c\', sans-serif',
  fontStyle: 'wght@100;300;400;500;700;800;900',
  fontDisplay: 'swap',
  provider: 'google'
}, {
  value: 'macondo',
  label: '<img src="%path%macondo.png">',
  fontFamily: 'Macondo, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'marcellus sc',
  label: '<img src="%path%marcellus_sc.png">',
  fontFamily: 'Marcellus SC, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'marck script',
  label: '<img src="%path%marck_script.png">',
  fontFamily: 'Marck Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'martel',
  label: '<img src="%path%martel.png">',
  fontFamily: 'Martel, serif',
  fontStyle: 'wght@200;300;400;600;700;800;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'maven pro',
  label: '<img src="%path%maven_pro.png">',
  fontFamily: 'Maven Pro, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'merriweather',
  label: '<img src="%path%merriweather.png">',
  fontFamily: 'Merriweather, serif',
  fontStyle: 'ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'merriweather sans',
  label: '<img src="%path%merriweather_sans.png">',
  fontFamily: 'Merriweather Sans',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'mogra',
  label: '<img src="%path%mogra.png">',
  fontFamily: 'Mogra, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'monoton',
  label: '<img src="%path%monoton.png">',
  fontFamily: 'Monoton, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'montez',
  label: '<img src="%path%montez.png">',
  fontFamily: 'Montez, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'montserrat',
  label: '<img src="%path%montserrat.png">',
  fontFamily: 'Montserrat, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'montserrat alternates',
  label: '<img src="%path%montserrat_alternates.png">',
  fontFamily: 'Montserrat Alternates, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'montserrat subrayada',
  label: '<img src="%path%montserrat_subrayada.png">',
  fontFamily: 'Montserrat Subrayada, sans-serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'neucha',
  label: '<img src="%path%neucha.png">',
  fontFamily: 'Neucha, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'neuton',
  label: '<img src="%path%neuton.png">',
  fontFamily: 'Neuton, serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,700;0,800;1,400',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'nixie one',
  label: '<img src="%path%nixie_one.png">',
  fontFamily: 'Nixie One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'nothing you could do',
  label: '<img src="%path%nothing_you_could_do.png">',
  fontFamily: 'Nothing You Could Do, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'noto sans',
  label: '<img src="%path%noto_sans.png">',
  fontFamily: 'Noto Sans, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'noto sans sc',
  label: '<img src="%path%noto_sans_sc.png">',
  fontFamily: 'Noto Sans SC, sans-serif',
  fontStyle: 'wght@100;300;400;500;700;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'noto serif',
  label: '<img src="%path%noto_serif.png">',
  fontFamily: 'Noto Serif, serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'noto serif tc',
  label: '<img src="%path%noto_serif_tc.png">',
  fontFamily: 'Noto Serif TC, serif',
  fontStyle: 'wght@200;300;400;500;600;700;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'nunito',
  label: '<img src="%path%nunito.png">',
  fontFamily: 'Nunito, sans-serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;0,1000;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900;1,1000',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'old standard tt',
  label: '<img src="%path%old_standard_tt.png">',
  fontFamily: 'Old Standard TT, serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'open sans',
  label: '<img src="%path%open_sans.png">',
  fontFamily: 'Open Sans, sans-serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'oranienbaum',
  label: '<img src="%path%oranienbaum.png">',
  fontFamily: 'Oranienbaum, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'oswald',
  label: '<img src="%path%oswald.png">',
  fontFamily: 'Oswald, sans-serif',
  fontStyle: 'wght@200;300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'oxygen',
  label: '<img src="%path%oxygen.png">',
  fontFamily: 'Oxygen, sans-serif',
  fontStyle: 'wght@300;400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pacifico',
  label: '<img src="%path%pacifico.png">',
  fontFamily: 'Pacifico, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pangolin',
  label: '<img src="%path%pangolin.png">',
  fontFamily: 'Pangolin, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'passion one',
  label: '<img src="%path%passion_one.png">',
  fontFamily: 'Passion One, cursive',
  fontStyle: 'wght@400;700;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pathway gothic one',
  label: '<img src="%path%pathway_gothic_one.png">',
  fontFamily: 'Pathway Gothic One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pattaya',
  label: '<img src="%path%pattaya.png">',
  fontFamily: 'Pattaya, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'petit formal script',
  label: '<img src="%path%petit_formal_script.png">',
  fontFamily: 'Petit Formal Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'philosopher',
  label: '<img src="%path%philosopher.png">',
  fontFamily: 'Philosopher, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'play',
  label: '<img src="%path%play.png">',
  fontFamily: 'Play, sans-serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'playfair display',
  label: '<img src="%path%playfair_display.png">',
  fontFamily: 'Playfair Display, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'playfair display sc',
  label: '<img src="%path%playfair_display_sc.png">',
  fontFamily: 'Playfair Display SC, serif',
  fontStyle: 'ital,wght@0,400;0,700;0,900;1,400;1,700;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'podkova',
  label: '<img src="%path%podkova.png">',
  fontFamily: 'Podkova, serif',
  fontStyle: 'wght@400;500;600;700;800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'poiret one',
  label: '<img src="%path%poiret_one.png">',
  fontFamily: 'Poiret One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pompiere',
  label: '<img src="%path%pompiere.png">',
  fontFamily: 'Pompiere, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'poppins',
  label: '<img src="%path%poppins.png">',
  fontFamily: 'Poppins, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'prata',
  label: '<img src="%path%prata.png">',
  fontFamily: 'Prata, serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'press start 2p',
  label: '<img src="%path%press_start_2p.png">',
  fontFamily: '\'Press Start 2P\', cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'prosto one',
  label: '<img src="%path%prosto_one.png">',
  fontFamily: 'Prosto One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt mono',
  label: '<img src="%path%pt_mono.png">',
  fontFamily: 'PT Mono, monospace',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt sans',
  label: '<img src="%path%pt_sans.png">',
  fontFamily: 'PT Sans, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt sans caption',
  label: '<img src="%path%pt_sans_caption.png">',
  fontFamily: 'PT Sans Caption, sans-serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt sans narrow',
  label: '<img src="%path%pt_sans_narrow.png">',
  fontFamily: 'PT Sans Narrow, sans-serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt serif',
  label: '<img src="%path%pt_serif.png">',
  fontFamily: 'PT Serif, serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'pt serif caption',
  label: '<img src="%path%pt_serif_caption.png">',
  fontFamily: 'PT Serif Caption, serif',
  fontStyle: 'ital@0;1',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'quattrocento sans',
  label: '<img src="%path%quattrocento_sans.png">',
  fontFamily: 'Quattrocento Sans, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'quattrocento',
  label: '<img src="%path%quattrocento.png">',
  fontFamily: 'Quattrocento, serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'quicksand',
  label: '<img src="%path%quicksand.png">',
  fontFamily: 'Quicksand, sans-serif',
  fontStyle: 'wght@300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'qwigley',
  label: '<img src="%path%qwigley.png">',
  fontFamily: 'Qwigley, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'raleway',
  label: '<img src="%path%raleway.png">',
  fontFamily: 'Raleway, sans-serif',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'raleway dots',
  label: '<img src="%path%raleway_dots.png">',
  fontFamily: 'Raleway Dots, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'redressed',
  label: '<img src="%path%redressed.png">',
  fontFamily: 'Redressed, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ribeye marrow',
  label: '<img src="%path%ribeye_marrow.png">',
  fontFamily: 'Ribeye Marrow, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'righteous',
  label: '<img src="%path%righteous.png">',
  fontFamily: 'Righteous, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'roboto',
  label: '<img src="%path%roboto.png">',
  fontFamily: 'Roboto, sans-serif',
  fontStyle: 'ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'roboto condensed',
  label: '<img src="%path%roboto_condensed.png">',
  fontFamily: 'Roboto Condensed, sans-serif',
  fontStyle: 'ital,wght@0,300;0,400;0,700;1,300;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'roboto mono',
  label: '<img src="%path%roboto_mono.png">',
  fontFamily: 'Roboto Mono, monospace',
  fontStyle: 'ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'roboto slab',
  label: '<img src="%path%roboto_slab.png">',
  fontFamily: 'Roboto Slab, serif',
  fontStyle: 'wght@100;200;300;400;500;600;700;800;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'rochester',
  label: '<img src="%path%rochester.png">',
  fontFamily: 'Rochester, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'rouge script',
  label: '<img src="%path%rouge_script.png">',
  fontFamily: 'Rouge Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'rubik',
  label: '<img src="%path%rubik.png">',
  fontFamily: 'Rubik, sans-serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'rubik mono one',
  label: '<img src="%path%rubik_mono_one.png">',
  fontFamily: 'Rubik Mono One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ruslan display',
  label: '<img src="%path%ruslan_display.png">',
  fontFamily: 'Ruslan Display, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'russo one',
  label: '<img src="%path%russo_one.png">',
  fontFamily: 'Russo One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'sacramento',
  label: '<img src="%path%sacramento.png">',
  fontFamily: 'Sacramento, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'sanchez',
  label: '<img src="%path%sanchez.png">',
  fontFamily: 'Sanchez, serif',
  fontStyle: 'ital@0;1',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'satisfy',
  label: '<img src="%path%satisfy.png">',
  fontFamily: 'Satisfy, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'sawarabi gothic',
  label: '<img src="%path%sawarabi_gothic.png">',
  fontFamily: 'Sawarabi Gothic, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'scada',
  label: '<img src="%path%scada.png">',
  fontFamily: 'Scada, sans-serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'seaweed script',
  label: '<img src="%path%seaweed_script.png">',
  fontFamily: 'Seaweed Script, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'seymour one',
  label: '<img src="%path%seymour_one.png">',
  fontFamily: 'Seymour One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'shadows into light two',
  label: '<img src="%path%shadows_into_light_two.png">',
  fontFamily: 'Shadows Into Light Two, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'six caps',
  label: '<img src="%path%six_caps.png">',
  fontFamily: 'Six Caps, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'snowburst one',
  label: '<img src="%path%snowburst_one.png">',
  fontFamily: 'Snowburst One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'source code pro',
  label: '<img src="%path%source_code_pro.png">',
  fontFamily: 'Source Code Pro, monospace',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'source sans pro',
  label: '<img src="%path%source_sans_pro.png">',
  fontFamily: 'Source Sans Pro, sans-serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'special elite',
  label: '<img src="%path%special_elite.png">',
  fontFamily: 'Special Elite, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'spectral',
  label: '<img src="%path%spectral.png">',
  fontFamily: 'Spectral, serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'spectral_sc',
  label: '<img src="%path%spectral_sc.png">',
  fontFamily: 'Spectral SC, serif',
  fontStyle: 'ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'squada one',
  label: '<img src="%path%squada_one.png">',
  fontFamily: 'Squada One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'stalinist one',
  label: '<img src="%path%stalinist_one.png">',
  fontFamily: 'Stalinist One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'stint ultra expanded',
  label: '<img src="%path%stint_ultra_expanded.png">',
  fontFamily: 'Stint Ultra Expanded, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'syncopate',
  label: '<img src="%path%syncopate.png">',
  fontFamily: 'Syncopate, sans-serif',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'tangerine',
  label: '<img src="%path%tangerine.png">',
  fontFamily: 'Tangerine, cursive',
  fontStyle: 'wght@400;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'tenor sans',
  label: '<img src="%path%tenor_sans.png">',
  fontFamily: 'Tenor Sans, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'tinos',
  label: '<img src="%path%tinos.png">',
  fontFamily: 'Tinos, serif',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ubuntu',
  label: '<img src="%path%ubuntu.png">',
  fontFamily: 'Ubuntu, sans-serif',
  fontStyle: 'ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ubuntu condensed',
  label: '<img src="%path%ubuntu_condensed.png">',
  fontFamily: 'Ubuntu Condensed, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'ubuntu mono',
  label: '<img src="%path%ubuntu_mono.png">',
  fontFamily: 'Ubuntu Mono, monospace',
  fontStyle: 'ital,wght@0,400;0,700;1,400;1,700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'underdog',
  label: '<img src="%path%underdog.png">',
  fontFamily: 'Underdog, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'unifrakturmaguntia',
  label: '<img src="%path%unifrakturmaguntia.png">',
  fontFamily: 'UnifrakturMaguntia, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'vast shadow',
  label: '<img src="%path%vast_shadow.png">',
  fontFamily: 'Vast Shadow, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'viga',
  label: '<img src="%path%viga.png">',
  fontFamily: 'Viga, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'vollkorn',
  label: '<img src="%path%vollkorn.png">',
  fontFamily: 'Vollkorn, serif',
  fontStyle: 'ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'vollkorn sc',
  label: '<img src="%path%vollkorn_sc.png">',
  fontFamily: 'Vollkorn SC, serif',
  fontStyle: 'wght@400;600;700;900',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'voltaire',
  label: '<img src="%path%voltaire.png">',
  fontFamily: 'Voltaire, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'wire one',
  label: '<img src="%path%wire_one.png">',
  fontFamily: 'Wire One, sans-serif',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'yanone kaffeesatz',
  label: '<img src="%path%yanone_kaffeesatz.png">',
  fontFamily: 'Yanone Kaffeesatz, sans-serif',
  fontStyle: 'wght@200;300;400;500;600;700',
  fontDisplay: '',
  provider: 'google'
}, {
  value: 'yeseva one',
  label: '<img src="%path%yeseva_one.png">',
  fontFamily: 'Yeseva One, cursive',
  fontStyle: '',
  fontDisplay: '',
  provider: 'google'
}];

class Rte {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    this.dom = this.builder.dom;
    const dom = this.dom;
    this.elementStyleEditor = new ELementStyleEditor(builder);
    this.hyperlink = new Hyperlink(builder);
    let rteTool = builderStuff.querySelector('#divRteTool');
    let elementRteTool;
    let rteAlignOptions;
    let rteFormattingOptions;
    let rteColorPicker;
    let rteListOptions;
    let rteFontFamilyOptions;
    let rteParagraphOptions;
    let rteMoreOptions;
    let elementRteMoreOptions;
    let rteTextSettingOptions;
    let rteZoomOptions;
    let rteIconOptions;
    let rteCustomTagOptions;
    let rteZoomSlider;
    let inpZoomSlider;
    if (!rteTool) {
      let zoomMax = 100;
      if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer && !this.builder.iframe) {
        // freeform
        zoomMax = 200;
      }

      // if(builder.plugins.length>0) {
      let allButtons = ['|', 'addsnippet', 'bold', 'italic', 'underline', 'formatting', 'color', 'removeformat', 'align', 'textsettings', 'createlink', 'tags', 'undo', 'redo', 'zoom', 'livepreview', 'icon', 'image', 'list', 'font', 'formatpara', 'gridtool', 'html', 'preferences', 'more', 'left', 'center', 'right', 'full', 'group', 'ungroup', 'duplicate', 'addblock', 'front', 'backward', 'moveup', 'movedown', 'delete', 'blocksettings', 'aiassistant', 'snippets', 'svg', 'pageoptions', 'print'];
      const filterButtons = myArray => {
        let newArray = myArray;
        myArray.forEach(item => {
          item = item.toLowerCase();
          let result = allButtons.filter(btnName => {
            return btnName === item;
          });
          if (result.length === 0) {
            // a plugin
            result = builder.plugins.filter(plugin => {
              // check if plugin registered.
              return plugin.name === item;
            });
            if (result.length === 0) {
              // plugin not registered
              newArray = newArray.filter(e => e !== item);
            }
          }
        });

        // if(!this.builder.previewURL && newArray.indexOf('livepreview')!==-1) {
        //     newArray = newArray.filter((item)=>{
        //         return item !== 'livepreview';
        //     });
        // }

        if (!this.builder.sendCommandUrl && newArray.indexOf('aiassistant') !== -1) {
          newArray = newArray.filter(item => {
            return item !== 'aiassistant';
          });
        }
        if (!this.builder.snippetModal && newArray.indexOf('snippets') !== -1) {
          newArray = newArray.filter(item => {
            return item !== 'snippets';
          });
        }
        return newArray;
      };
      builder.opts.buttons = filterButtons(builder.opts.buttons);
      builder.opts.buttonsMore = filterButtons(builder.opts.buttonsMore);
      builder.opts.elementButtons = filterButtons(builder.opts.elementButtons);
      builder.opts.elementButtonsMore = filterButtons(builder.opts.elementButtonsMore);
      builder.opts.iconButtons = filterButtons(builder.opts.iconButtons);
      builder.opts.iconButtonsMore = filterButtons(builder.opts.iconButtonsMore);
      // }

      let customtag_button = '';
      var customTagsHtml = '';
      if (builder.opts.customTags.length > 0) {
        customtag_button = `<button tabindex="-1" title="${util.out('Tags')}" class="rte-tags"><svg class="is-icon-flex" style="width:14px;height:14px"><use xlink:href="#ion-code-working"></use></svg></button>`;
        for (let j = 0; j < builder.opts.customTags.length; j++) {
          customTagsHtml += `<button data-value="${builder.opts.customTags[j][1]}"> ${builder.opts.customTags[j][0]} </button>`;
        }
      }
      let html_rtemore = '';
      for (var j = 0; j < builder.opts.buttonsMore.length; j++) {
        var btn = builder.opts.buttonsMore[j].toLowerCase();
        if (btn === 'createlink') html_rtemore += `<button tabindex="-1" title="${util.out('Hyperlink')}" class="rte-link"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-link"></use></svg></button>`;else if (btn === 'icon' && !this.builder.opts.emailMode) html_rtemore += `<button tabindex="-1" title="${util.out('Icon')}" class="rte-icon"><svg class="is-icon-flex" style="width:14px;height:14px;margin-top:2px;"><use xlink:href="#ion-android-happy"></use></svg></button>`;else if (btn === 'svg' && !this.builder.opts.emailMode) html_rtemore += `<button tabindex="-1" title="${util.out('SVG')}" class="rte-svg"><svg class="is-icon-flex" style="width:19px;height:19px;margin-top:2px;"><use xlink:href="#icon-svg"></use></svg></button>`;else if (btn === 'removeformat') html_rtemore += `<button tabindex="-1" title="${util.out('Clean')}" class="rte-clean"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>`;else if (btn === 'bold') html_rtemore += `<button tabindex="-1" title="${util.out('Bold')}" class="rte-format" data-command="bold"><span style="font-family:serif;font-size:14px;">B</span></button>`;else if (btn === 'italic') html_rtemore += `<button tabindex="-1" title="${util.out('Italic')}" class="rte-format" data-command="italic"><span style="font-family:serif;font-size:16px;font-style:italic;">i</span></button>`;else if (btn === 'underline') html_rtemore += `<button tabindex="-1" title="${util.out('Underline')}" class="rte-format" data-command="underline"><span style="font-family:serif;font-size:14px;text-decoration:underline;">U</span></button>`;
        // else if(btn==='createlink') html_rtemore += `<button tabindex="-1" title="${util.out('Hyperlink')}" class="rte-link"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-link"></use></svg></button>`; 
        else if (btn === 'align') html_rtemore += `<button tabindex="-1" title="${util.out('Align')}" class="rte-align"><svg class="is-icon-flex" style="width:12px;height:12px;margin-top:-2px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'list') html_rtemore += `<button tabindex="-1" title="${util.out('List')}" class="rte-list"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#icon-list-bullet"></use></svg></button>`;else if (btn === 'color') html_rtemore += `<button tabindex="-1" title="${util.out('Color')}" class="rte-color"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-contrast"></use></svg></button>`;else if (btn === 'formatting') html_rtemore += `<button tabindex="-1" title="${util.out('Formatting')}" class="rte-formatting"><span style="font-family:serif;font-size:15px;display:inline-block;">A</span></button>`;else if (btn === 'tags') html_rtemore += customtag_button;else if (btn === 'image') html_rtemore += `<button tabindex="-1" title="${util.out('Image')}" class="rte-image"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-image"></use></svg></button>`;else if (btn === 'gridtool') html_rtemore += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_rtemore += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_rtemore += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_rtemore += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'formatpara') html_rtemore += `<button tabindex="-1" title="${util.out('Paragraph')}" class="rte-paragraph"><span style="font-family:serif;font-size:14px;display:inline-block;margin-top:2px;">H</span></button>`;else if (btn === 'font') html_rtemore += `<button tabindex="-1" title="${util.out('Font')}" class="rte-fontfamily"><span style="font-family:serif;font-size:18px;text-transform:none;display:inline-block;margin-top: -3px;">a</span></button>`;else if (btn === 'textsettings') html_rtemore += `<button tabindex="-1" title="${util.out('Text Settings')}" class="rte-textsettings"><svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#ion-ios-settings"></use></svg></button>`;else if (btn === 'undo') html_rtemore += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_rtemore += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_rtemore += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_rtemore += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'pageoptions') html_rtemore += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_rtemore += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_rtemore += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_rtemore += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === '|') {
          html_rtemore += '<div class="rte-separator"></div>';
        } else {
          html_rtemore += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      let html_rte = '';
      for (j = 0; j < builder.opts.buttons.length; j++) {
        btn = builder.opts.buttons[j].toLowerCase();
        if (btn === 'bold') html_rte += `<button tabindex="-1" title="${util.out('Bold')}" class="rte-format" data-command="bold"><span style="font-family:serif;font-size:14px;">B</span></button>`;else if (btn === 'italic') html_rte += `<button tabindex="-1" title="${util.out('Italic')}" class="rte-format" data-command="italic"><span style="font-family:serif;font-size:16px;font-style:italic;">i</span></button>`;else if (btn === 'underline') html_rte += `<button tabindex="-1" title="${util.out('Underline')}" class="rte-format" data-command="underline"><span style="font-family:serif;font-size:14px;text-decoration:underline;">U</span></button>`;else if (btn === 'createlink') html_rte += `<button tabindex="-1" title="${util.out('Hyperlink')}" class="rte-link"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-link"></use></svg></button>`;else if (btn === 'align') html_rte += `<button tabindex="-1" title="${util.out('Align')}" class="rte-align"><svg class="is-icon-flex" style="width:12px;height:12px;margin-top:-2px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'formatpara') html_rte += `<button tabindex="-1" title="${util.out('Paragraph')}" class="rte-paragraph"><span style="font-family:serif;font-size:14px;display:inline-block;margin-top:2px;">H</span></button>`;else if (btn === 'color') html_rte += `<button tabindex="-1" title="${util.out('Color')}" class="rte-color"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-contrast"></use></svg></button>`;else if (btn === 'formatting') html_rte += `<button tabindex="-1" title="${util.out('Formatting')}" class="rte-formatting"><span style="font-family:serif;font-size:15px;display:inline-block;">A</span></button>`;else if (btn === 'list') html_rte += `<button tabindex="-1" title="${util.out('List')}" class="rte-list"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#icon-list-bullet"></use></svg></button>`;else if (btn === 'textsettings') html_rte += `<button tabindex="-1" title="${util.out('Text Settings')}" class="rte-textsettings"><svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#ion-ios-settings"></use></svg></button>`;else if (btn === 'icon' && !this.builder.opts.emailMode) html_rte += `<button tabindex="-1" title="${util.out('Icon')}" class="rte-icon"><svg class="is-icon-flex" style="width:14px;height:14px;margin-top:2px"><use xlink:href="#ion-android-happy"></use></svg></button>`;else if (btn === 'svg' && !this.builder.opts.emailMode) html_rte += `<button tabindex="-1" title="${util.out('SVG')}" class="rte-svg"><svg class="is-icon-flex" style="width:19px;height:19px;margin-top:2px"><use xlink:href="#icon-svg"></use></svg></button>`;else if (btn === 'tags') html_rte += customtag_button;else if (btn === 'removeformat') html_rte += `<button tabindex="-1" title="${util.out('Clean')}" class="rte-format" data-command="clean"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>`;else if (btn === 'font') html_rte += `<button tabindex="-1" title="${util.out('Font')}" class="rte-fontfamily"><span style="font-family:serif;font-size:18px;text-transform:none;display:inline-block;margin-top: -3px;">a</span></button>`;else if (btn === 'image') html_rte += `<button tabindex="-1" title="${util.out('Image')}" class="rte-image"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-image"></use></svg></button>`;else if (btn === 'gridtool') html_rte += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;width:17px;height:17px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_rte += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_rte += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_rte += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'undo') html_rte += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_rte += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_rte += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_rte += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'more' && html_rtemore !== '') html_rte += `<button tabindex="-1" title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;else if (btn === 'pageoptions') html_rte += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_rte += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_rte += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_rte += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === '|') {
          html_rte += '<div class="rte-separator"></div>';
        } else {
          html_rte += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      if (this.builder.opts.toolbarAddSnippetButton && html_rte.indexOf('rte-addsnippet') === -1 && html_rtemore.indexOf('rte-addsnippet') === -1) {
        html_rte = `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>` + html_rte;
      }
      if (html_rtemore !== '' && html_rte.indexOf('rte-more') === -1) {
        html_rte = html_rte + `<button tabindex="-1" title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;
      }

      // Element Toolbar
      let html_elementrtemore = '';
      for (j = 0; j < builder.opts.elementButtonsMore.length; j++) {
        btn = builder.opts.elementButtonsMore[j].toLowerCase();
        if (btn === 'left') html_elementrtemore += `<button tabindex="-1" title="${util.out('Align Left')}" data-align="left"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-left"></use></svg></button>`;else if (btn === 'center') html_elementrtemore += `<button tabindex="-1" title="${util.out('Align Center')}" data-align="center"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-center"></use></svg></button>`;else if (btn === 'right') html_elementrtemore += `<button tabindex="-1" title="${util.out('Align Right')}" data-align="right"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-right"></use></svg></button>`;else if (btn === 'full') html_elementrtemore += `<button tabindex="-1" title="${util.out('Align Full')}" data-align="justify"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'gridtool') html_elementrtemore += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_elementrtemore += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_elementrtemore += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_elementrtemore += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'undo') html_elementrtemore += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_elementrtemore += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_elementrtemore += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_elementrtemore += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'pageoptions') html_elementrtemore += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_elementrtemore += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_elementrtemore += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_elementrtemore += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === '|') {
          html_elementrtemore += '<div class="rte-separator"></div>';
        } else {
          html_elementrtemore += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      let html_elementrte = '';
      for (j = 0; j < builder.opts.elementButtons.length; j++) {
        btn = builder.opts.elementButtons[j].toLowerCase();
        if (btn === 'left') html_elementrte += `<button tabindex="-1" title="${util.out('Align Left')}" data-align="left"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-left"></use></svg></button>`;else if (btn === 'center') html_elementrte += `<button tabindex="-1" title="${util.out('Align Center')}" data-align="center"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-center"></use></svg></button>`;else if (btn === 'right') html_elementrte += `<button tabindex="-1" title="${util.out('Align Right')}" data-align="right"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-right"></use></svg></button>`;else if (btn === 'full') html_elementrte += `<button tabindex="-1" title="${util.out('Align Full')}" data-align="justify"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'gridtool') html_elementrte += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;width:17px;height:17px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_elementrte += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_elementrte += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_elementrte += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'group') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Group')}" class="rte-group"><svg class="is-icon-flex" style="width:20px;height:20px;margin-top:-1px;"><use xlink:href="#icon-group"></use></svg></button>`;else if (btn === 'ungroup') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Ungroup')}" class="rte-ungroup"><svg class="is-icon-flex" style="width:20px;height:20px;margin-top:-1px;"><use xlink:href="#icon-ungroup"></use></svg></button>`;else if (btn === 'duplicate') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Duplicate')}" class="rte-duplicate"><svg class="is-icon-flex" style="width:16px;height:16px;margin-top:-1px;"><use xlink:href="#icon-duplicate"></use></svg></button>`;else if (btn === 'front') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Bring to Front')}" class="rte-front"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#icon-stack-forward"></use></svg></button>`;else if (btn === 'backward') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Send to Back')}" class="rte-backward"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#icon-stack-backward"></use></svg></button>`;else if (btn === 'moveup') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Move Up')}" class="rte-moveup"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#icon-arrow-up"></use></svg></button>`;else if (btn === 'movedown') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Move Down')}" class="rte-movedown"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#icon-arrow-down"></use></svg></button>`;else if (btn === 'delete') html_elementrte += `<button style="display:none" tabindex="-1" title="${util.out('Delete')}" class="rte-delete"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#icon-trash"></use></svg></button>`;else if (btn === 'blocksettings' && this.builder.canvas) html_elementrte += `<button tabindex="-1" title="${util.out('Block Settings')}" class="rte-blocksettings"><svg class="is-icon-flex"><use xlink:href="#icon-settings"></use></svg></button>`;else if (btn === 'undo') html_elementrte += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_elementrte += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_elementrte += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_elementrte += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'more' && html_elementrtemore !== '') html_elementrte += `<button tabindex="-1" title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;else if (btn === 'pageoptions') html_elementrte += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_elementrte += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_elementrte += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_elementrte += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === '|') {
          html_elementrte += '<div class="rte-separator"></div>';
        } else {
          html_elementrte += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      if (this.builder.opts.toolbarAddSnippetButton && html_elementrte.indexOf('rte-addsnippet') === -1 && html_elementrtemore.indexOf('rte-addsnippet') === -1) {
        html_elementrte = `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>` + html_elementrte; //html_rte;
      }

      if (html_elementrtemore !== '' && html_elementrte.indexOf('rte-more') === -1) {
        html_elementrte = html_elementrte + `<button title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;
      }

      /* Icon Buttons */
      let html_iconrtemore = '';
      let html_iconrte = '';
      for (j = 0; j < builder.opts.iconButtonsMore.length; j++) {
        btn = builder.opts.iconButtonsMore[j].toLowerCase();
        if (btn === 'createlink') html_iconrtemore += `<button tabindex="-1" title="${util.out('Hyperlink')}" class="rte-link"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-link"></use></svg></button>`;else if (btn === 'icon' && !this.builder.opts.emailMode) html_iconrtemore += `<button tabindex="-1" title="${util.out('Icon')}" class="rte-icon"><svg class="is-icon-flex" style="width:14px;height:14px;margin-top:2px;"><use xlink:href="#ion-android-happy"></use></svg></button>`;else if (btn === 'svg' && !this.builder.opts.emailMode) html_iconrtemore += `<button tabindex="-1" title="${util.out('SVG')}" class="rte-svg"><svg class="is-icon-flex" style="width:19px;height:19px;margin-top:2px;"><use xlink:href="#icon-svg"></use></svg></button>`;else if (btn === 'align') html_iconrtemore += `<button tabindex="-1" title="${util.out('Align')}" class="rte-align"><svg class="is-icon-flex" style="width:12px;height:12px;margin-top:-2px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'color') html_iconrtemore += `<button tabindex="-1" title="${util.out('Color')}" class="rte-color"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-contrast"></use></svg></button>`;else if (btn === 'gridtool') html_iconrtemore += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_iconrtemore += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_iconrtemore += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_iconrtemore += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'textsettings') html_iconrtemore += `<button tabindex="-1" title="${util.out('Text Settings')}" class="rte-textsettings"><svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#ion-ios-settings"></use></svg></button>`;else if (btn === 'undo') html_iconrtemore += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_iconrtemore += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_iconrtemore += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_iconrtemore += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'pageoptions') html_iconrtemore += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_iconrtemore += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_iconrtemore += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_iconrtemore += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === '|') {
          html_iconrtemore += '<div class="rte-separator"></div>';
        } else {
          html_iconrtemore += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      for (j = 0; j < builder.opts.iconButtons.length; j++) {
        btn = builder.opts.iconButtons[j].toLowerCase();
        if (btn === 'createlink') html_iconrte += `<button tabindex="-1" title="${util.out('Hyperlink')}" class="rte-link"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#ion-link"></use></svg></button>`;else if (btn === 'icon' && !this.builder.opts.emailMode) html_iconrte += `<button tabindex="-1" title="${util.out('Icon')}" class="rte-icon"><svg class="is-icon-flex" style="width:14px;height:14px;margin-top:2px;"><use xlink:href="#ion-android-happy"></use></svg></button>`;else if (btn === 'svg' && !this.builder.opts.emailMode) html_iconrte += `<button tabindex="-1" title="${util.out('SVG')}" class="rte-svg"><svg class="is-icon-flex" style="width:19px;height:19px;margin-top:2px;"><use xlink:href="#icon-svg"></use></svg></button>`;else if (btn === 'align') html_iconrte += `<button tabindex="-1" title="${util.out('Align')}" class="rte-align"><svg class="is-icon-flex" style="width:12px;height:12px;margin-top:-2px;"><use xlink:href="#icon-align-full"></use></svg></button>`;else if (btn === 'color') html_iconrte += `<button tabindex="-1" title="${util.out('Color')}" class="rte-color"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-contrast"></use></svg></button>`;else if (btn === 'gridtool') html_iconrte += `<button tabindex="-1" title="${util.out('Grid Tool')}" class="rte-grideditor"><svg class="is-icon-flex" style="margin-right:-3px;"><use xlink:href="#ion-grid"></use></svg></button>`;else if (btn === 'html') html_iconrte += `<button tabindex="-1" title="${util.out('HTML')}" class="rte-html"><svg class="is-icon-flex" style="margin-right:-3px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-left"></use></svg><svg class="is-icon-flex" style="margin-left:-2px;width:14px;height:14px;"><use xlink:href="#ion-ios-arrow-right"></use></svg></button>`;else if (btn === 'preferences') html_iconrte += `<button tabindex="-1" title="${util.out('Preferences')}" class="rte-preferences"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-wrench"></use></svg></button>`;else if (btn === 'addsnippet') html_iconrte += `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>`;else if (btn === 'textsettings') html_iconrte += `<button tabindex="-1" title="${util.out('Text Settings')}" class="rte-textsettings"><svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#ion-ios-settings"></use></svg></button>`;else if (btn === 'undo') html_iconrte += `<button tabindex="-1" title="${util.out('Undo')}" class="rte-undo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-undo"></use></svg></button>`;else if (btn === 'redo') html_iconrte += `<button tabindex="-1" title="${util.out('Redo')}" class="rte-redo"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#ion-ios-redo"></use></svg></button>`;else if (btn === 'aiassistant') html_iconrte += `<button tabindex="-1" title="${util.out('AI Assistant')}" class="rte-ai"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-message"></use></svg></button>`;else if (btn === 'snippets') html_iconrte += `<button tabindex="-1" title="${util.out('Snippets')}" class="rte-snippets"><svg class="is-icon-flex" style="width:19px;height:19px;"><use xlink:href="#icon-snippets"></use></svg></button>`;else if (btn === 'pageoptions') html_iconrte += `<button tabindex="-1" title="${util.out('Page Options')}" class="rte-pageoptions"><svg class="is-icon-flex"><use xlink:href="#icon-pagesize"></use></svg></button>`;else if (btn === 'print') html_iconrte += `<button tabindex="-1" title="${util.out('Print')}" class="rte-print"><svg class="is-icon-flex" style="width:15px;height:15px;"><use xlink:href="#icon-print"></use></svg></button>`;else if (btn === 'zoom') html_iconrte += `<button tabindex="-1" title="${util.out('Zoom')}" class="rte-zoom"><svg class="is-icon-flex" style="margin-top:1px;width:15px;height:15px;"><use xlink:href="#icon-zoom-in"></use></svg></button>`;else if (btn === 'livepreview') html_iconrte += `<button tabindex="-1" title="${util.out('Live Preview')}" class="rte-livepreview"><svg class="is-icon-flex" style="margin-top:2px;width:15px;height:15px;"><use xlink:href="#icon-device-desktop"></use></svg></button>`;else if (btn === 'more' && html_rtemore !== '') html_iconrte += `<button tabindex="-1" title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;else if (btn === '|') {
          html_iconrte += '<div class="rte-separator"></div>';
        } else {
          html_iconrte += `<button tabindex="-1" title="button not found" data-plugin="${btn}"></button>`; //temporary (later will be replaced with plugin button)
        }
      }

      if (this.builder.opts.toolbarAddSnippetButton && html_iconrte.indexOf('rte-addsnippet') === -1 && html_iconrtemore.indexOf('rte-addsnippet') === -1) {
        html_iconrte = `<button tabindex="-1" title="${util.out('Add Snippet')}" class="rte-addsnippet"><svg class="is-icon-flex" style="width:18px;height:18px;margin-top:-1px;"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>` + html_iconrte; //html_rte;
      }

      if (html_iconrtemore !== '' && html_iconrte.indexOf('rte-more') === -1) {
        html_iconrte = html_iconrte + `<button tabindex="-1" title="${util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`;
      }
      /* /Icon Buttons */

      let html_fontsizes = '';
      for (j = 0; j < builder.opts.defaultFontSizes.length; j++) {
        html_fontsizes += `<button title="${builder.opts.defaultFontSizes[j]}px" data-value="${builder.opts.defaultFontSizes[j]}">${builder.opts.defaultFontSizes[j]}</button>`;
      }
      let html_leading = '';
      this.builder.leadingPreset.forEach(val => {
        html_leading += `<button title="${val}" data-value="${val}">${val}</button>`;
      });

      // <div class="is-draggable" style="width: 5px;height: 45pxpx;background:#fff;cursor: move;"></div>
      // <div style="height:55px;background:#fff;border-top:#f5f5f5 1px solid;">
      // </div>
      let html = `<div class="is-rte-tool" style="position:fixed;flex-direction:column;display:none;">
                <div class="rte-for-text" style="display:flex">
                    ${html_rte}
                </div>
                <div class="rte-for-icon" class="" style="display:flex">
                    ${html_iconrte}
                </div>
            </div>

            <div class="is-elementrte-tool" style="position:fixed;flex-direction:column;display:none;">
                <div style="display:flex">
                    ${html_elementrte}
                </div>
            </div>

            <div class="rte-formatting-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                    <button tabindex="-1" title="${util.out('Strikethrough')}" class="rte-format" data-command="strikethrough" style="float:left"><svg class="is-icon-flex" style="width:17px;height:17px;"><use xlink:href="#icon-strike"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Superscript')}" class="rte-format" data-command="superscript" style="float:left"><span style="font-family:serif;font-size:13px;">x</span><sup style="font-size:10px">2</sup></button>
                    <button tabindex="-1" title="${util.out('Subscript')}" class="rte-format" data-command="subscript" style="float:left"><span style="font-family:serif;font-size:13px;">x</span><sub style="font-size:10px">2</sub></button>
                    <button tabindex="-1" title="${util.out('Uppercase')}" class="rte-format" data-command="uppercase" style="float:left"><span style="font-family:serif;font-size:14px;display:inline-block;text-transform: none;">Aa</span></button>
                    <button tabindex="-1" title="${util.out('Clean')}" class="rte-format" data-command="clean"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                </div>
            </div>

            <div class="rte-align-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                    <button tabindex="-1" title="${util.out('Align Left')}" data-align="left"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-left"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Align Center')}" data-align="center"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-center"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Align Right')}" data-align="right"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-right"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Align Full')}" data-align="justify"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-align-full"></use></svg></button>
                </div>
            </div>

            <div class="rte-list-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                    <button tabindex="-1" title="${util.out('Bullets')}" data-action="insertUnorderedList"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-list-bullet"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Numbering')}" data-action="insertOrderedList"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-list-number"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Indent')}" data-action="indent"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-indent"></use></svg></button>
                    <button tabindex="-1" title="${util.out('Outdent')}" data-action="outdent"><svg class="is-icon-flex" style="width:14px;height:14px;"><use xlink:href="#icon-outdent"></use></svg></use></svg></svg></button>
                </div>
            </div>

            <div class="rte-paragraph-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <ul>
                    <li style="height:58px" title="${util.out('Heading 1')}" data-block="h1" tabindex="0"><h1>Heading 1</h1></li>
                    <li style="height:50px" title="${util.out('Heading 2')}" data-block="h2" tabindex="0"><h2>Heading 2</h2></li>
                    <li style="height:45px" title="${util.out('Heading 3')}" data-block="h3" tabindex="0"><h3>Heading 3</h3></li>
                    <li style="height:40px" title="${util.out('Heading 4')}" data-block="h4" tabindex="0"><h4>Heading 4</h4></li>
                    <li style="height:28px" title="${util.out('Paragraph')}" data-block="p" tabindex="0"><p>Paragraph</p></li>
                    <li style="height:28px" title="${util.out('DIV')}" data-block="div" tabindex="0"><p>div</p></li>
                    <li style="height:28px" title="${util.out('Preformatted')}" data-block="pre" tabindex="0"><p style="font-family:courier, monospace;">Preformatted</p></li>
                </ul>
            </div>

            <div class="rte-fontfamily-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="scroll">
                    <input id="inpRteFontSearch" type="text" placeholder="${util.out('Type to search...')}">
                    <div class="div-font-list"></div>
                </div>
            </div>

            <div class="rte-color-picker is-rte-pop" data-command="forecolor" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-pop-tabs">
                    <div class="is-pop-tab-item active" data-value="forecolor">${util.out('Forecolor')}</div>
                    <div class="is-pop-tab-item" data-value="backcolor">${util.out('Backcolor')}</div>
                </div>
                <div class="rte-color-picker-area"></div>
            </div>
            
            <div class="rte-textsetting-options ${this.builder.simpleTextSettings ? 'simple' : ''} is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                    <div class="is-label">${util.out('Font Size')}</div>
                    <div class="rte-fontsize-options" style="display: flex;flex-flow: wrap;">
                        ${html_fontsizes}

                        <button title="${util.out('Decrease')}" data-value="-" style="font-size:13px">-</button>
                        <button title="${util.out('Increase')}" data-value="+" style="font-size:13px">+</button>
                        <button title="${util.out('Clear')}" data-value=""><svg class="is-icon-flex" style="width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                    </div>
                    <div class="is-label separator label-fontweight">${util.out('Font Weight')}</div>
                    <div class="rte-fontweight-options" style="display: flex;flex-flow: wrap;">
                        <button title="100" data-value="100">100</button>
                        <button title="200" data-value="200">200</button>
                        <button title="300" data-value="300">300</button>
                        <button title="400" data-value="400">400</button>
                        <button title="500" data-value="500">500</button>
                        <button title="600" data-value="600">600</button>
                        <button title="700" data-value="700">700</button>
                        <button title="800" data-value="800">800</button>
                        <button title="900" data-value="900">900</button>
                        <button title="${util.out('Clear')}" data-value=""><svg class="is-icon-flex" style="width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                    </div>
                    <div class="is-label separator">${util.out('Line Spacing')}</div>
                    <div class="rte-lineheight-options" style="display: flex;flex-flow: wrap;">
                        
                        ${html_leading}

                        <button title="${util.out('Decrease')}" data-value="-" style="font-size:13px">-</button>
                        <button title="${util.out('Increase')}" data-value="+" style="font-size:13px">+</button>
                        <button title="${util.out('Clear')}" data-value=""><svg class="is-icon-flex" style="width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                    </div>
                    <div class="is-label separator">${util.out('Letter Spacing')}</div>
                    <div class="rte-letterspacing-options" style="display: flex;flex-flow: wrap;">
                        <button title="1" data-value="1">1</button>
                        <button title="2" data-value="2">2</button>
                        <button title="${util.out('Decrease')}" data-value="-" style="font-size:13px">-</button>
                        <button title="${util.out('Increase')}" data-value="+" style="font-size:13px">+</button>
                        <button title="${util.out('Clear')}" data-value=""><svg class="is-icon-flex" style="width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                    </div>
                </div>
            </div>

            <div class="rte-zoom-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                    <div class="is-label">${util.out('Zoom')}</div>
                    <div style="padding-top:4px">
                        <input type="range" min="50" max="${zoomMax}" value="1" class="rte-zoom-slider is-rangeslider">
                    </div>
                    <div style="display:flex;justify-content:flex-end">
                        <button title="${util.out('Reset')}" class="reset-zoom" style="background:transparent;padding:0;height:27px;text-decoration:underline">${util.out('Reset')}</button>
                    </div>
                </div>
            </div>

            <div class="is-modal viewzoom" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:250px;height:150px;display:flex;flex-flow:column;justify-content:center;">
                    <div class="is-modal-bar is-draggable">${util.out('Zoom')}</div>
                
                    <div style="display:flex;flex-wrap:wrap;width:100%;padding-top:32px;">
                        <input type="range" min="50" max="100" value="1" class="inp-zoom-slider is-rangeslider">
                    </div>
                </div>
            </div>

            <div class="is-modal insertimage" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:560px;">
                    <div class="is-browse-area">
                        <div class="is-drop-area">
                            <input id="fileInsertImage" type="file" accept="image/*" />
                            <div class="drag-text">
                                <p style="display:flex;justify-content:center;align-items:center;"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-camera"></use></svg> <span style="margin-left:5px;margin-top:3px;"> ${util.out('Drag and drop an image or click to browse.')} </span></p>
                            </div>
                        </div>
                        <div class="is-preview-area">
                            <div><img id="imgInsertImagePreview" alt="" /><button><i class="ion-ios-close-empty"></i></button></div>
                        </div>
                    </div>    
                    <label for="inpInsertImageSrc" style="margin:10px 0 5px;display:block;">${util.out('Or Specify Image Source')}:</label>
                    ${(this.builder.opts.onImageSelectClick + '').replace(/\s/g, '') !== 'function(){}' || this.builder.opts.imageselect !== '' ? `<div class="image-src" style="margin-bottom: 12px;"><input id="inpInsertImageSrc" class="input-src" type="text" placeholder="${util.out('Source')}">
                    <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                        ${this.builder.opts.selectIcon}
                    </button></div>` : `<div class="image-src" style="margin-bottom: 12px;"><input id="inpInsertImageSrc" class="input-src" type="text" placeholder="${util.out('Source')}"></div>`}
                    <div style="text-align:right">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
                </div>
            </div>

            <div class="rte-icon-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="scroll">
                    <input id="inpRteIconSearch" type="text" placeholder="${util.out('Type to search...')}">
                    <div class="div-icon-list"></div>
                </div>
            </div>

            <div class="rte-customtag-options is-rte-pop scroll" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>${customTagsHtml}</div>
            </div>

            <div class="rte-more-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="rte-for-text">
                ${html_rtemore}
                </div>
                <div class="rte-for-icon">
                ${html_iconrtemore}
                </div>
            </div>

            <div class="elementrte-more-options is-rte-pop" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div>
                ${html_elementrtemore}
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      rteTool = builderStuff.querySelector('.is-rte-tool');
      elementRteTool = builderStuff.querySelector('.is-elementrte-tool');
      rteMoreOptions = builderStuff.querySelector('.rte-more-options');
      elementRteMoreOptions = builderStuff.querySelector('.elementrte-more-options');
      rteAlignOptions = builderStuff.querySelector('.rte-align-options');
      rteFormattingOptions = builderStuff.querySelector('.rte-formatting-options');
      rteColorPicker = builderStuff.querySelector('.rte-color-picker');
      rteListOptions = builderStuff.querySelector('.rte-list-options');
      rteFontFamilyOptions = builderStuff.querySelector('.rte-fontfamily-options');
      rteParagraphOptions = builderStuff.querySelector('.rte-paragraph-options');
      rteTextSettingOptions = builderStuff.querySelector('.rte-textsetting-options');
      rteZoomOptions = builderStuff.querySelector('.rte-zoom-options');
      rteIconOptions = builderStuff.querySelector('.rte-icon-options');
      rteCustomTagOptions = builderStuff.querySelector('.rte-customtag-options');
      rteZoomSlider = builderStuff.querySelector('.rte-zoom-slider');
      inpZoomSlider = builderStuff.querySelector('.inp-zoom-slider');

      // Prepare for tooltip
      let elms = rteTool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = elementRteTool.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = rteAlignOptions.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = rteFormattingOptions.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = rteListOptions.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = rteMoreOptions.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      elms = elementRteMoreOptions.querySelectorAll('[title]');
      Array.prototype.forEach.call(elms, elm => {
        elm.setAttribute('data-title', elm.getAttribute('title'));
      });
      if (this.builder.isTouchSupport) {
        // On iPad, on double click text to select word, getSelected() won't return the word, instead it returns empty
        // So this is needed to call getSelected() after 'selectionchange' that is triggered after double click a text.
        this.builder.doc.addEventListener('selectionchange', function () {
          if (dom.checkEditable()) {
            var text = dom.getSelected();
            if (text.trim() !== '') {
              //save selection
              util.saveSelection();
            }
          }
        }, false);
      }
    }
    this.rteTool = rteTool;
    this.elementRteTool = elementRteTool;
    this.rteAlignOptions = rteAlignOptions;
    this.rteFormattingOptions = rteFormattingOptions;
    this.rteColorPicker = rteColorPicker;
    this.rteListOptions = rteListOptions;
    this.rteFontFamilyOptions = rteFontFamilyOptions;
    this.rteParagraphOptions = rteParagraphOptions;
    this.rteMoreOptions = rteMoreOptions;
    this.elementRteMoreOptions = elementRteMoreOptions;
    this.rteTextSettingOptions = rteTextSettingOptions;
    this.rteZoomOptions = rteZoomOptions;
    this.rteIconOptions = rteIconOptions;
    this.rteCustomTagOptions = rteCustomTagOptions;
    this.rteZoomSlider = rteZoomSlider;
    this.inpZoomSlider = inpZoomSlider;
    this.positionToolbar();
    const inpIconSearch = this.rteIconOptions.querySelector('#inpRteIconSearch');
    inpIconSearch.addEventListener('input', () => {
      const searchInput = inpIconSearch.value.toLowerCase();
      const buttons = this.rteIconOptions.querySelectorAll('.div-icon-list button');
      buttons.forEach(button => {
        const iconName = button.querySelector('i').className;
        if (iconName.toLowerCase().includes(searchInput)) {
          button.style.display = '';
        } else {
          button.style.display = 'none';
        }
      });
    });
    const inpFontSearch = this.rteFontFamilyOptions.querySelector('#inpRteFontSearch');
    inpFontSearch.addEventListener('input', () => {
      const searchInput = inpFontSearch.value.toLowerCase();
      const buttons = this.rteFontFamilyOptions.querySelectorAll('.div-font-list button');
      buttons.forEach(button => {
        const fontName = button.getAttribute('data-font-family');
        if (fontName.toLowerCase().includes(searchInput)) {
          button.classList.remove('hidden');
          button.classList.add('flex');
        } else {
          button.classList.add('hidden');
          button.classList.remove('flex');
        }
      });
    });
    const handleSearchKeyDown = e => {
      let btnActive = this.rteFontFamilyOptions.querySelector('.div-font-list button.on');
      if (!btnActive) btnActive = this.rteFontFamilyOptions.querySelector('.div-font-list button.flex');
      if (e.keyCode === 40) {
        // down
        btnActive.focus();
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    };
    inpFontSearch.addEventListener('keydown', handleSearchKeyDown);

    // Formatting
    let btnRteFormatting = builderStuff.querySelectorAll('button.rte-formatting');
    btnRteFormatting.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteFormattingOptions;
        const top = btn.getBoundingClientRect().top;
        const left = btn.getBoundingClientRect().left;
        pop.style.display = 'flex';
        const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        const h = pop.offsetHeight;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            pop.focus();
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // Align
    let btnRteAlign = builderStuff.querySelectorAll('button.rte-align');
    btnRteAlign.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteAlignOptions;
        const top = btn.getBoundingClientRect().top;
        const left = btn.getBoundingClientRect().left;
        pop.style.display = 'flex';
        const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        const h = pop.offsetHeight;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            pop.focus();
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // List
    let btnRteList = builderStuff.querySelectorAll('button.rte-list');
    btnRteList.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteListOptions;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            const top = btn.getBoundingClientRect().top;
            const left = btn.getBoundingClientRect().left;
            const w = pop.offsetWidth;
            const h = pop.offsetHeight;
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            pop.focus();
          }, btn);
        } else {
          dom.removeClass(pop, 'active');
          dom.addClass(pop, 'deactive');
        }
      });
    });

    // Custom Tags

    const setTagValue = btn => {
      this.builder.uo.saveForUndo();

      //restore selection
      util.restoreSelection(); //a must

      const tag = btn.getAttribute('data-value');
      util.pasteHtmlAtCaret(tag, true);
      this.util.hideRtePop(this.rteCustomTagOptions);
      if (this.builder.onTextChange) this.builder.onTextChange();
    };
    const handleTagItemClick = e => {
      e.preventDefault();
      setTagValue(e.target);
    };
    const handleTagItemKeyDown = e => {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (e.keyCode === 38 && e.target.previousElementSibling) {
        // up
        e.target.previousElementSibling.focus();
      } else if (e.keyCode === 40 && e.target.nextElementSibling) {
        // down
        e.target.nextElementSibling.focus();
      } else if (e.keyCode === 27) {
        // esc
        this.util.hideRtePop(this.rteCustomTagOptions);
      } else if (e.keyCode === 13 || e.keyCode === 32) {
        // enter or spacebar key
        setTagValue(e.target);
      }
    };
    let tagItems = builderStuff.querySelectorAll('.rte-customtag-options button');
    tagItems.forEach(elm => {
      elm.addEventListener('keydown', handleTagItemKeyDown);
      elm.addEventListener('click', handleTagItemClick);
    });
    this.rteCustomTagOptions.addEventListener('keydown', e => {
      if (e.keyCode === 40 && e.target.nextElementSibling) {
        // down
        const firstButton = this.rteCustomTagOptions.querySelector('button');
        firstButton.focus();
      }
    });
    const btnTags = this.rteCustomTagOptions.querySelectorAll('[data-value]');
    Array.prototype.forEach.call(btnTags, btn => {
      dom.addEventListener(btn, 'click', e => {
        setTagValue(e.target);
      });
    });
    let btnRteTags = builderStuff.querySelectorAll('button.rte-tags');
    btnRteTags.forEach(btn => {
      btn.addEventListener('click', () => {
        //save selection
        util.saveSelection();
        const pop = this.rteCustomTagOptions;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            const top = btn.getBoundingClientRect().top;
            const left = btn.getBoundingClientRect().left;
            const w = pop.offsetWidth;
            const h = pop.offsetHeight;
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            if (dom.parentsHasClass(btn, 'rte-more-options')) {
              // Adjustment if button is placed on 2nd bar (div.rte-more-options)
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                if (btn.getBoundingClientRect().left + 45 - parseInt(this.rteMoreOptions.style.left) < pop.offsetWidth) {
                  pop.style.left = parseInt(this.rteMoreOptions.style.left) + 'px';
                } else if (parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - btn.getBoundingClientRect().left + 45 < pop.offsetWidth) {
                  pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
                } else ;
                pop.style.right = 'auto';
              }
            }
            pop.focus();
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // Paragraph

    const setParagraphValue = item => {
      this.builder.uo.saveForUndo();
      util.restoreSelection(); //a must

      const command = item.getAttribute('data-block'); //h1, h2, h3, h4, p, pre  

      /*
      let block = this.builder.doc.queryCommandValue('FormatBlock');
      block = block.toLowerCase();
      if (block === 'pre') {
          let elm = dom.textSelection();
          if(elm) {
              let pre = elm.closest('pre');
              if(pre) {
                  let newnode = pre.cloneNode(true);
                  let s = newnode.outerHTML.replace('<pre', '<' + command);
                  s = s.replace('</pre>', '</' + command + '>');
                  pre.outerHTML = s;
              }
              pre.focus();
          }
      } else {
          this.builder.doc.execCommand('formatBlock', false, '<' + command + '>'); //Needs contenteditable.         
      }
      */

      const selection = dom.getSelection();
      if (!selection) return;
      const anchorNode = selection.anchorNode;
      let container;
      if (anchorNode) {
        container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
      }
      if (!container) return;
      let element = container.closest('h1') || container.closest('h2') || container.closest('h3') || container.closest('h4') || container.closest('h5') || container.closest('h6') || container.closest('pre') || container.closest('p') || container.closest('div');
      if (element) {
        // const tagName = element.tagName.toLowerCase();

        element.setAttribute('data-replacetagname', '1');
        const newElement = this.builder.doc.createElement(command);

        // Copy the attributes
        for (var i = 0, l = element.attributes.length; i < l; ++i) {
          var nodeName = element.attributes.item(i).nodeName;
          var nodeValue = element.attributes.item(i).nodeValue;
          newElement.setAttribute(nodeName, nodeValue);
        }

        // move all elements in the other container.
        while (element.firstChild) {
          newElement.appendChild(element.firstChild);
        }
        element.parentNode.replaceChild(newElement, element);
        const result = this.builder.doc.querySelector('[data-replacetagname="1"]');
        if (result) {
          result.removeAttribute('data-replacetagname');
          dom.selectElementContents(result);
        }
      }

      //save selection
      util.saveSelection();

      //Trigger Change event
      this.builder.opts.onChange();

      // Focus
      let elms = builderStuff.querySelectorAll('.rte-paragraph-options li');
      elms.forEach(elm => {
        elm.classList.remove('on');
      });
      item.classList.add('on');
      item.focus();
      if (this.builder.onTextChange) this.builder.onTextChange();
    };
    const handleParagraphItemClick = e => {
      e.preventDefault();
      let item = e.target;
      setParagraphValue(item);
    };
    const handleParagraphItemKeyDown = e => {
      e.preventDefault();
      if (e.keyCode === 38 && e.target.previousElementSibling) {
        // up
        e.target.previousElementSibling.focus();
      } else if (e.keyCode === 40 && e.target.nextElementSibling) {
        // down
        e.target.nextElementSibling.focus();
      } else if (e.keyCode === 13 || e.keyCode === 32) {
        // enter or spacebar key
        setParagraphValue(e.target);
      }
    };
    let paragraphItems = builderStuff.querySelectorAll('.rte-paragraph-options li');
    paragraphItems.forEach(elm => {
      elm.addEventListener('keydown', handleParagraphItemKeyDown);
      elm.addEventListener('click', handleParagraphItemClick);
    });
    let btnRteParagraph = builderStuff.querySelectorAll('button.rte-paragraph');
    btnRteParagraph.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteParagraphOptions;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            const top = btn.getBoundingClientRect().top;
            const left = btn.getBoundingClientRect().left;
            const w = pop.offsetWidth;
            const h = pop.offsetHeight;
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            if (dom.parentsHasClass(btn, 'rte-more-options')) {
              // Adjustment if button is placed on 2nd bar (div.rte-more-options)
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
                pop.style.right = 'auto';
              }
            }
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
        this.getState();

        //Focus
        var target = pop.querySelector('.on');
        if (target) {
          target.focus();
        }
      });
    });

    // Font Family

    let btnRteFontFamily = builderStuff.querySelectorAll('button.rte-fontfamily');
    btnRteFontFamily.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteFontFamilyOptions;
        const divFontList = pop.querySelector('.div-font-list');
        if (divFontList.innerHTML.trim() === '') {
          let path = this.builder.fontAssetPath;
          let s = '';
          fontList.forEach(choice => {
            choice.label = choice.label.replace('%path%', path);
            if (choice.label === '') choice.label = this.util.out('None');
            s += `<button class="flex" data-provider="${choice.provider}" data-font-family="${choice.fontFamily}" 
                        data-font-style="${choice.fontStyle}"
                        data-font-display="${choice.fontDisplay}">
                        ${choice.label}
                        </button>`;
          });
          divFontList.innerHTML = s;
          const setValue = item => {
            let provider = item.getAttribute('data-provider');
            let fontfamily = item.getAttribute('data-font-family');
            let fontstyle = item.getAttribute('data-font-style');
            let fontdisplay = item.getAttribute('data-font-display');
            this.setFont(fontfamily, fontstyle, fontdisplay, provider);
            let elms = pop.querySelectorAll('.div-font-list > button');
            elms.forEach(elm => {
              elm.classList.remove('on');
            });
            item.classList.add('on');
          };
          const handleItemClick = e => {
            e.preventDefault();
            let item = e.target;
            setValue(item);
            item.focus();
          };
          const handleItemKeyDown = e => {
            let prevElm, nextElm;
            let elms = this.rteFontFamilyOptions.querySelectorAll('.div-font-list button.flex');
            for (let i = 0; i < elms.length; i++) {
              if (elms[i] === e.target) {
                if (i === 0) {
                  prevElm = null;
                } else {
                  prevElm = elms[i - 1];
                }
                if (i === elms.length - 1) {
                  nextElm = null;
                } else {
                  nextElm = elms[i + 1];
                }
              }
            }
            if (e.keyCode === 38) {
              // up
              e.preventDefault();
              if (prevElm) {
                prevElm.focus();
              } else {
                const inpFontSearch = this.rteFontFamilyOptions.querySelector('#inpRteFontSearch');
                inpFontSearch.focus();
              }
            } else if (e.keyCode === 40) {
              // down
              e.preventDefault();
              if (nextElm) nextElm.focus();
            }
          };
          let elms = pop.querySelectorAll('.div-font-list > button');
          elms.forEach(elm => {
            elm.addEventListener('keydown', handleItemKeyDown);
            elm.addEventListener('click', handleItemClick);
          });
        }
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            const top = btn.getBoundingClientRect().top;
            const left = btn.getBoundingClientRect().left;
            const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
            const h = pop.offsetHeight;
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            if (dom.parentsHasClass(btn, 'rte-more-options')) {
              // Adjustment if button is placed on 2nd bar (div.rte-more-options)
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
                pop.style.right = 'auto';
              }
            }
          }, btn);
          this.getState();
          const inpFontSearch = this.rteFontFamilyOptions.querySelector('#inpRteFontSearch');
          inpFontSearch.focus();
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // Icons

    let btnRteIcons = builderStuff.querySelectorAll('button.rte-icon');
    btnRteIcons.forEach(btn => {
      btn.addEventListener('click', e => {
        //save selection
        util.saveSelection();
        Promise.resolve().then(() => {
          this.openIcon(e);
        });
      });
    });
    let btnRteSvgs = builderStuff.querySelectorAll('button.rte-svg');
    btnRteSvgs.forEach(btn => {
      btn.addEventListener('click', () => {
        //save selection
        util.saveSelection();
        this.builder.element.svg.edit();
      });
    });

    // Color
    let btnRteColor = builderStuff.querySelectorAll('button.rte-color');
    btnRteColor.forEach(btn => {
      btn.addEventListener('click', () => {
        const pop = this.rteColorPicker;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            const top = btn.getBoundingClientRect().top;
            const left = btn.getBoundingClientRect().left;
            const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = this.rteTool.style.top; //(top - (h/2) + 20) + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = this.rteTool.style.top; //(top - (h/2) + 20) + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
          }, btn);
          this.builder.uo.saveForUndo(true); // checkLater = true

          //Focus
          let input = pop.querySelector('.input-text');
          input.focus();
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // Preferences
    let btnRtePreferences = builderStuff.querySelectorAll('button.rte-preferences');
    btnRtePreferences.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.viewPreferences();
      });
    });

    // View HTML
    let btnRteHtml = builderStuff.querySelectorAll('button.rte-html');
    btnRteHtml.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.viewHtml();
      });
    });

    // Grid Editor
    let btnRteGridEditor = builderStuff.querySelectorAll('button.rte-grideditor');
    btnRteGridEditor.forEach(btn => {
      btn.addEventListener('click', () => {
        // direct
        const grideditor = this.builderStuff.querySelector('.grideditor');
        dom.addClass(grideditor, 'active');
        const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
        Array.prototype.forEach.call(builders, builder => {
          builder.setAttribute('grideditor', '');
        });
      });
    });

    // Undo
    let btnRteUndo = builderStuff.querySelectorAll('button.rte-undo');
    btnRteUndo.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.uo.doUndo();
      });
    });

    // Redo
    let btnRteRedo = builderStuff.querySelectorAll('button.rte-redo');
    btnRteRedo.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.uo.doRedo();
      });
    });

    // Add Snippet
    let btnRteAddSnippet = builderStuff.querySelectorAll('button.rte-addsnippet');
    btnRteAddSnippet.forEach(btn => {
      btn.addEventListener('click', () => {
        this.viewSnippets();
      });
    });

    // AI Assistant
    let btnRteAI = builderStuff.querySelectorAll('button.rte-ai');
    btnRteAI.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.toggleAIAssistant();
      });
    });

    // Snippets Modal
    let btnSnippets = builderStuff.querySelectorAll('button.rte-snippets');
    btnSnippets.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.toggleSnippetModal();
      });
    });

    // Link
    let btnRteLink = builderStuff.querySelectorAll('button.rte-link');
    btnRteLink.forEach(btn => {
      btn.addEventListener('click', () => {
        // const util = new Util(this.builder);
        // util.clearActiveCell();
        this.hyperlink.createLink();
      });
    });

    // Image
    let btnRteImage = builderStuff.querySelectorAll('button.rte-image');
    btnRteImage.forEach(btn => {
      btn.addEventListener('click', () => {
        this.insertImage();
      });
    });
    const modalInsertImage = this.builderStuff.querySelector('.insertimage');
    const fileInsertImage = modalInsertImage.querySelector('#fileInsertImage');
    dom.addEventListener(fileInsertImage, 'change', e => {
      var input = e.target;
      if (input.files && input.files[0]) {
        var reader = new FileReader();
        reader.onload = function (e) {
          modalInsertImage.querySelector('.is-drop-area').style.display = 'none';
          modalInsertImage.querySelector('#imgInsertImagePreview').src = e.target.result;
          modalInsertImage.querySelector('.is-preview-area').style.display = 'block';
          fileInsertImage.setAttribute('disabled', 'disabled');
          let fileToInsert = input.files[0].name;
          modalInsertImage.querySelector('#imgInsertImagePreview').setAttribute('data-filename', fileToInsert);

          //modalInsertImage.querySelector('.image-title').innerHTML = input.files[0].name;
        };

        reader.readAsDataURL(input.files[0]);
        modalInsertImage.querySelector('.input-src').value = ''; //Clear manually specified image soure
      }
    });

    const btnInsertImageOk = modalInsertImage.querySelector('.input-ok');
    dom.addEventListener(btnInsertImageOk, 'click', () => {
      if (!this.builder.activeCol) {
        util.hideModal(modalInsertImage);
        return;
      }
      this.builder.uo.saveForUndo();
      util.restoreSelection(); //a must

      let val = '';
      if (modalInsertImage.querySelector('.is-drop-area').style.display === 'none') {
        val = modalInsertImage.querySelector('#imgInsertImagePreview').src;
      } else {
        val = modalInsertImage.querySelector('.input-src').value;
      }
      if (val === '') return;
      let fileToInsert = modalInsertImage.querySelector('#imgInsertImagePreview').getAttribute('data-filename');
      util.pasteHtmlAtCaret('<img data-filename="' + fileToInsert + '" src="' + val + '" alt="" />', false);
      util.hideModal(modalInsertImage);
      let builderActive = this.builder.doc.querySelector('.builder-active');
      if (builderActive) this.builder.applyBehaviorOn(builderActive);

      //save selection
      util.saveSelection();

      //Trigger Change event
      this.builder.opts.onChange();

      //Trigger Render event
      this.builder.opts.onRender();
    });
    const btnInsertImageCancel = modalInsertImage.querySelector('.input-cancel');
    dom.addEventListener(btnInsertImageCancel, 'click', () => {
      util.hideModal(modalInsertImage);
    });
    const dropArea = modalInsertImage.querySelector('.is-drop-area');
    dom.addEventListener(dropArea, 'dragover', () => {
      dom.addClass(dropArea, 'image-dropping');
    });
    dom.addEventListener(dropArea, 'dragleave', () => {
      dom.removeClass(dropArea, 'image-dropping');
    });
    const delImageInsert = modalInsertImage.querySelector('.is-preview-area button');
    dom.addEventListener(delImageInsert, 'click', () => {
      //Clear drop image area
      modalInsertImage.querySelector('#fileInsertImage').value = ''; // clear
      modalInsertImage.querySelector('.is-preview-area').style.display = 'none';
      fileInsertImage.removeAttribute('disabled');
      dropArea.style.display = 'block';
      dom.removeClass(dropArea, 'image-dropping');
    });
    const inputImageInsertSrc = modalInsertImage.querySelector('.input-src');
    dom.addEventListener(inputImageInsertSrc, 'keyup', () => {
      if (inputImageInsertSrc.value === '') return;
      //Clear drop image area
      modalInsertImage.querySelector('#fileInsertImage').value = ''; // clear
      modalInsertImage.querySelector('.is-preview-area').style.display = 'none';
      fileInsertImage.removeAttribute('disabled');
      dropArea.style.display = 'block';
      dom.removeClass(dropArea, 'image-dropping');
    });
    if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
      modalInsertImage.querySelector('.input-select').style.display = 'none';
    }
    if (this.builder.opts.onImageSelectClick || this.builder.opts.imageselect !== '') {
      dom.addClass(modalInsertImage.querySelector('.image-src'), 'image-select');

      //Open Custom Image Select
      const inputImageSelect = modalInsertImage.querySelector('.input-select');
      if (inputImageSelect) dom.addEventListener(inputImageSelect, 'click', () => {
        if (this.builder.opts.onImageSelectClick) {
          this.builder.opts.onImageSelectClick({
            targetInput: modalInsertImage.querySelector('.input-src'),
            theTrigger: inputImageSelect
          });
        } else {
          let modalImageSelect = this.builderStuff.querySelector('.is-modal.imageselect');
          let iframe = modalImageSelect.querySelector('iframe');
          if (this.builder.opts.assetRefresh) {
            iframe.src = this.builder.opts.imageselect;
            this.builder.opts.assetRefresh = false;
          }
          if (iframe.src === 'about:blank') {
            iframe.src = this.builder.opts.imageselect;
          }
          util.showModal(modalImageSelect, false, () => {
            inputImageSelect.removeAttribute('data-focus');
            inputImageSelect.focus();
          }, false, this.builder.assetPanelFullScreen);
        }
        this.builder.targetInput = modalInsertImage.querySelector('.input-src'); // used by selectAsset() (see contentbuilder.js)
        this.builder.targetCallback = null;
        this.builder.targetAssetType = 'image';
      });
    } else {
      dom.removeClass(inputImageInsertSrc, 'image-select');
    }

    // Live Preview
    let livePreviewButton = builderStuff.querySelectorAll('button.rte-livepreview');
    livePreviewButton.forEach(btn => {
      dom.addEventListener(btn, 'click', () => {
        const modal = builderStuff.querySelector('.is-modal.content-preview');
        if (modal.classList.contains('active')) {
          this.builder.closePreview();
        } else {
          this.builder.livePreview.resizePreview(1440);
          this.builder.openPreview();
        }
      });
    });

    // Page Options
    let btnPageOptions = builderStuff.querySelectorAll('button.rte-pageoptions');
    btnPageOptions.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.openPageOptions();
      });
    });

    // Print
    let btnPrint = builderStuff.querySelectorAll('button.rte-print');
    btnPrint.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.print();
      });
    });

    // Zoom Settings
    let zoomButton = builderStuff.querySelectorAll('button.rte-zoom');
    zoomButton.forEach(btn => {
      dom.addEventListener(btn, 'click', () => {
        this.rteZoomSlider.value = this.builder.opts.zoom * 100;
        const pop = this.rteZoomOptions;
        const top = btn.getBoundingClientRect().top;
        const left = btn.getBoundingClientRect().left;
        pop.style.display = 'flex';
        const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        const h = pop.offsetHeight;
        if (!dom.hasClass(pop, 'active')) {
          this.util.showRtePop(pop, () => {
            if (this.rteTool.style.display !== 'none') {
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = top - h / 2 + 20 + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = top - h / 2 + 20 + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                const n1 = parseInt(this.rteTool.style.left) + this.rteTool.offsetWidth;
                const n2 = left - w / 2 + 23 + w;
                const adj = 0;
                if (n2 > n1) {
                  pop.style.left = parseInt(this.rteTool.style.left) + this.rteTool.offsetWidth - w + adj + 'px';
                } else {
                  pop.style.left = left - w / 2 + 23 + 'px';
                }
                pop.style.right = 'auto';
              }
              if (dom.parentsHasClass(btn, 'rte-more-options')) {
                // Adjustment if button is placed on 2nd bar (div.rte-more-options)
                if (this.builder.opts.toolbar === 'left') {
                  pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                  pop.style.left = left + 54 + 'px';
                  pop.style.right = 'auto';
                } else if (this.builder.opts.toolbar === 'right') {
                  pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                  pop.style.left = 'auto';
                  const viewportWidth = document.body.clientWidth; //window.innerWidth;
                  pop.style.right = viewportWidth - left + 9 + 'px';
                } else {
                  pop.style.top = top + 54 - 6 + 'px';
                  // pop.style.left = (left -(w/2)+23) + 'px'; 
                  pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
                  pop.style.right = 'auto';
                }
              }
            } else {
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = top - h / 2 + 20 + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = top - h / 2 + 20 + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                const n1 = parseInt(this.elementRteTool.style.left) + this.elementRteTool.offsetWidth;
                const n2 = left - w / 2 + 23 + w;
                if (n2 > n1) {
                  pop.style.left = parseInt(this.elementRteTool.style.left) + this.elementRteTool.offsetWidth - w + 'px';
                } else {
                  pop.style.left = left - w / 2 + 23 + 'px';
                }
                pop.style.right = 'auto';
              }
              if (dom.parentsHasClass(btn, 'elementrte-more-optionss')) {
                // Adjustment if button is placed on 2nd bar (div.elementrte-more-optionss)
                if (this.builder.opts.toolbar === 'left') {
                  pop.style.top = parseInt(this.elementRteMoreOptions.style.top) + this.elementRteMoreOptions.offsetHeight - h + 'px';
                  pop.style.left = left + 54 + 'px';
                  pop.style.right = 'auto';
                } else if (this.builder.opts.toolbar === 'right') {
                  pop.style.top = parseInt(this.elementRteMoreOptions.style.top) + this.elementRteMoreOptions.offsetHeight - h + 'px';
                  pop.style.left = 'auto';
                  const viewportWidth = document.body.clientWidth; //window.innerWidth;
                  pop.style.right = viewportWidth - left + 9 + 'px';
                } else {
                  pop.style.top = top + 54 - 6 + 'px';
                  // pop.style.left = (left -(w/2)+23) + 'px'; 
                  pop.style.left = parseInt(this.elementRteMoreOptions.style.left) + this.elementRteMoreOptions.offsetWidth - w + 'px';
                  pop.style.right = 'auto';
                }
              }
            }
            pop.focus();
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });

    // Zoom
    const hideTools = () => {
      // hide tools
      let tools = this.builder.doc.querySelectorAll('.is-tool');
      Array.prototype.forEach.call(tools, tool => {
        tool.style.display = '';
      });
      tools = this.builder.doc.querySelectorAll('.is-row-tool');
      tools.forEach(tool => {
        tool.style.display = 'none';
      });
      tools = this.builder.doc.querySelectorAll('.is-col-tool');
      tools.forEach(tool => {
        tool.style.display = 'none';
      });
      tools = this.builder.doc.querySelectorAll('.is-canvas-tool');
      tools.forEach(tool => {
        tool.style.display = 'none';
      });
      tools = this.builder.doc.querySelectorAll('.is-canvasadd-tool');
      tools.forEach(tool => {
        tool.style.display = 'none';
      });
      tools = this.builder.doc.querySelectorAll('.is-rowadd-tool');
      tools.forEach(tool => {
        tool.style.opacity = 0;
      });
    };
    const showTools = () => {
      setTimeout(() => {
        // show & reposition
        this.builder.elmTool.repositionElementTool();
        let tools = this.builder.doc.querySelectorAll('.is-row-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-rowadd-tool');
        tools.forEach(tool => {
          tool.style.opacity = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-col-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-canvas-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-canvasadd-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
      }, 350);
    };
    this.rteZoomSlider.value = this.builder.opts.zoom * 100;
    this.rteZoomSlider.onfocus = () => {
      if (this.builder.onZoomStart) {
        this.builder.onZoomStart();
      }

      // this.rteZoomSlider.blur();
      // const pop = document.querySelector('.rte-zoom-options.active');
      // pop.focus(); // enable esc to close
    };

    this.rteZoomSlider.oninput = () => {
      //scale: 0.5 - 1
      //val: 50 - 100
      let val = this.rteZoomSlider.value;
      let scale = val / 100;
      this.builder.opts.zoom = scale;
      localStorage.setItem('_zoom', scale); // Save

      // setZoomOnArea
      this.builder.setZoomOnArea();

      // hide tools
      hideTools();
      if (this.builder.onZoom) {
        let val = this.rteZoomSlider.value;
        let scale = val / 100;
        this.builder.onZoom(scale);
      }
    };
    this.rteZoomSlider.onchange = () => {
      setTimeout(() => {
        // setZoomOnControl
        if (this.builder.isContentBox) {
          const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
          this.builder.setZoomOnControl(wrapper);
        } else if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
          // freeform
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          this.builder.setZoomOnControl(docContainer);
        } else {
          const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
          builders.forEach(builder => {
            this.builder.setZoomOnControl(builder);
          });
        }
        if (this.builder.onZoomEnd) {
          let val = this.rteZoomSlider.value;
          let scale = val / 100;
          this.builder.onZoomEnd(scale);
        }
      }, 350);
    };
    this.rteZoomSlider.addEventListener('mouseup', () => {
      showTools();
    });
    this.rteZoomSlider.addEventListener('touchend', () => {
      showTools();
    });

    // Reset Zoom
    const btnResetZoom = builderStuff.querySelector('.reset-zoom');
    btnResetZoom.addEventListener('click', () => {
      this.rteZoomSlider.value = 100;
      this.builder.opts.zoom = 1;
      localStorage.setItem('_zoom', 1); // Save

      // setZoomOnControl
      if (this.builder.isContentBox) {
        const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
        this.builder.setZoomOnControl(wrapper);
      } else if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
        // freeform
        const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
        this.builder.setZoomOnControl(docContainer);
      } else {
        const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
        builders.forEach(builder => {
          this.builder.setZoomOnControl(builder);
        });
      }

      // setZoomOnArea
      this.builder.setZoomOnArea();
    });

    // Zoom Modal
    this.inpZoomSlider.onfocus = () => {
      if (this.builder.onZoomStart) {
        this.builder.onZoomStart();
      }
      // this.inpZoomSlider.blur();
    };

    this.inpZoomSlider.oninput = () => {
      //scale: 0.5 - 1
      //val: 50 - 100
      let val = this.inpZoomSlider.value;
      let scale = val / 100;
      this.builder.opts.zoom = scale;
      localStorage.setItem('_zoom', scale); // Save

      // setZoomOnArea
      this.builder.setZoomOnArea();

      // hide tools
      hideTools();
      if (this.builder.onZoom) {
        let val = this.inpZoomSlider.value;
        let scale = val / 100;
        this.builder.onZoom(scale);
      }
    };
    this.inpZoomSlider.onchange = () => {
      setTimeout(() => {
        // setZoomOnControl
        if (this.builder.isContentBox) {
          const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
          this.builder.setZoomOnControl(wrapper);
        } else if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
          // freeform
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          this.builder.setZoomOnControl(docContainer);
        } else {
          const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
          builders.forEach(builder => {
            this.builder.setZoomOnControl(builder);
          });
        }

        // show & reposition
        this.builder.elmTool.repositionElementTool();
        let tools = this.builder.doc.querySelectorAll('.is-row-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-rowadd-tool');
        tools.forEach(tool => {
          tool.style.opacity = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-col-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-canvas-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        tools = this.builder.doc.querySelectorAll('.is-canvasadd-tool');
        tools.forEach(tool => {
          tool.style.display = '';
        });
        if (this.builder.onZoomEnd) {
          let val = this.rteZoomSlider.value;
          let scale = val / 100;
          this.builder.onZoomEnd(scale);
        }
        if (this.builder.onZoomEnd) {
          let val = this.inpZoomSlider.value;
          let scale = val / 100;
          this.builder.onZoomEnd(scale);
        }
        this.rteZoomSlider.value = this.inpZoomSlider.value;
      }, 300);
    };
    this.inpZoomSlider.addEventListener('mouseup', () => {
      showTools();
    });
    this.inpZoomSlider.addEventListener('touchend', () => {
      showTools();
    });

    // Text Settings
    let btnRteTextSettings = builderStuff.querySelectorAll('button.rte-textsettings');
    btnRteTextSettings.forEach(btn => {
      dom.addEventListener(btn, 'click', () => {
        const pop = this.rteTextSettingOptions;
        const top = btn.getBoundingClientRect().top;
        const left = btn.getBoundingClientRect().left;
        pop.style.display = 'flex';
        const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
        const h = pop.offsetHeight;
        if (!dom.hasClass(pop, 'active')) {
          this.getTextSettingsState();
          this.util.showRtePop(pop, () => {
            if (this.builder.opts.toolbar === 'left') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = left + 54 + 'px';
              pop.style.right = 'auto';
            } else if (this.builder.opts.toolbar === 'right') {
              pop.style.top = top - h / 2 + 20 + 'px';
              pop.style.left = 'auto';
              const viewportWidth = document.body.clientWidth; //window.innerWidth;
              pop.style.right = viewportWidth - left + 9 + 'px';
            } else {
              pop.style.top = top + 54 - 6 + 'px';
              pop.style.left = left - w / 2 + 23 + 'px';
              pop.style.right = 'auto';
            }
            if (dom.parentsHasClass(btn, 'rte-more-options')) {
              // Adjustment if button is placed on 2nd bar (div.rte-more-options)
              if (this.builder.opts.toolbar === 'left') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = left + 54 + 'px';
                pop.style.right = 'auto';
              } else if (this.builder.opts.toolbar === 'right') {
                pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
                pop.style.left = 'auto';
                const viewportWidth = document.body.clientWidth; //window.innerWidth;
                pop.style.right = viewportWidth - left + 9 + 'px';
              } else {
                pop.style.top = top + 54 - 6 + 'px';
                pop.style.left = left - w / 2 + 23 + 'px'; //(parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w) + 'px';
                pop.style.right = 'auto';
              }
            }
            pop.focus();
          }, btn);
        } else {
          this.util.hideRtePop(pop);
        }
      });
    });
    const handleTextSettingsKeyDown = e => {
      if (e.which === 9 && !e.shiftKey) {
        // tab key pressed
        if (e.target === document.querySelector('.rte-letterspacing-options button:last-child')) {
          document.querySelector('.rte-textsetting-options button').focus();
          e.preventDefault();
        }
      } else if (e.which === 9 && e.shiftKey) {
        // tab + shift key pressed
        if (e.target === document.querySelector('.rte-textsetting-options button')) {
          document.querySelector('.rte-letterspacing-options button:last-child').focus();
          e.preventDefault();
        }
      }
    };
    btns = rteTextSettingOptions.querySelectorAll('button');
    btns.forEach(elm => {
      elm.addEventListener('keydown', handleTextSettingsKeyDown);
    });

    // More
    let btnRteMore = this.rteTool.querySelectorAll('button.rte-more');
    btnRteMore.forEach(btn => {
      btn.addEventListener('click', () => {
        this.showRteMore();
      });
    });
    let btnElementRteMore = this.elementRteTool.querySelector('button.rte-more');
    if (btnElementRteMore) dom.addEventListener(btnElementRteMore, 'click', () => {
      this.showElementRteMore();
    });

    // -----------------------------

    // Formatting
    var btns = Array.prototype.slice.call(this.rteTool.querySelectorAll('.rte-format')).concat(Array.prototype.slice.call(this.rteFormattingOptions.querySelectorAll('.rte-format'))).concat(Array.prototype.slice.call(this.rteMoreOptions.querySelectorAll('.rte-format')));
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        // old 8368

        this.builder.uo.saveForUndo();
        const command = btn.getAttribute('data-command');
        var text = dom.getSelected();
        this.formatText(command);

        //save selection (only for desktop)
        if (!this.builder.isTouchSupport) {
          util.saveSelection(); //Needed because after format, a tag is added (ex. <b>,<i>), so, make selection again. 
        }

        if (text.trim() === '') {
          util.restoreSelection(); //place cursor back after formatting (bold, italic, ...)

          if (this.builder.isTouchSupport) {
            //prevent keyboard open
            const btnFocus = this.rteTool.querySelector('button');
            btnFocus.focus();
          }
        }

        // Or can be placed here:
        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });

    // Align
    btns = this.rteAlignOptions.querySelectorAll('button[data-align]');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        this.builder.uo.saveForUndo();
        util.restoreSelection(); //a must

        if (this.builder.isTouchSupport) {
          //prevent keyboard open
          const btnFocus = this.rteTool.querySelector('button');
          btnFocus.focus();
        }
        const command = btn.getAttribute('data-align');
        let elm;
        try {
          let curr;
          if (this.builder.win.getSelection) {
            curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
            if (curr.nodeType === 3) {
              //text node
              elm = curr.parentNode;
            } else {
              elm = curr;
            }
          } else if (this.builder.doc.selection) {
            curr = this.builder.doc.selection.createRange();
            elm = this.builder.doc.selection.createRange().parentElement();
          }
        } catch (e) {
          return;
        }
        let element = elm;

        /*
        getSelection works only if element selectable. If not, it uses previous selected element which is incorrect.
        So we check if activeElement is different with getSelection() => means incorrect
        */
        if (this.builder.activeElement.contains(element)) ; else {
          element = this.builder.activeElement; // If incorrect, uses activeElement
        }

        //if element is button in email mode
        //mod by Jack
        let tbl_button = element.closest('table.button');
        if (tbl_button) {
          if (command === 'center') {
            if (tbl_button.parentNode.tagName.toLowerCase() !== 'center') {
              //wrap with center
              let centerEl = document.createElement('CENTER');
              tbl_button.parentNode.insertBefore(centerEl, tbl_button);
              centerEl.appendChild(tbl_button);
            } else {
              tbl_button.setAttribute('align', '');
            }
          } else {
            tbl_button.setAttribute('align', command);
          }
          dom.removeClass(tbl_button, 'float-center');
        } else {
          while (element.tagName.toLowerCase() !== 'p' && element.tagName.toLowerCase() !== 'h1' && element.tagName.toLowerCase() !== 'h2' && element.tagName.toLowerCase() !== 'h3' && element.tagName.toLowerCase() !== 'h4' && element.tagName.toLowerCase() !== 'h5' && element.tagName.toLowerCase() !== 'h6' && element.tagName.toLowerCase() !== 'pre' && element.tagName.toLowerCase() !== 'blockquote' && element.tagName.toLowerCase() !== 'div' && element.tagName.toLowerCase() !== 'td' && element.tagName.toLowerCase() !== 'th') {
            element = element.parentNode;
          }
          if (this.builder.useCssClasses) {
            element.style.textAlign = '';
            dom.removeClass(element, this.builder.cssClasses.textAlign.left);
            dom.removeClass(element, this.builder.cssClasses.textAlign.center);
            dom.removeClass(element, this.builder.cssClasses.textAlign.right);
            dom.removeClass(element, this.builder.cssClasses.textAlign.justify);
            if (command === 'left') dom.addClass(element, this.builder.cssClasses.textAlign.left);
            if (command === 'center') dom.addClass(element, this.builder.cssClasses.textAlign.center);
            if (command === 'right') dom.addClass(element, this.builder.cssClasses.textAlign.right);
            if (command === 'justify') dom.addClass(element, this.builder.cssClasses.textAlign.justify);
          } else {
            element.style.textAlign = command;
          }
        }
        this.getState();

        //save selection
        util.saveSelection();

        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });
    btns = this.elementRteTool.querySelectorAll('button[data-align]');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        this.builder.uo.saveForUndo();

        //util.restoreSelection(); //a must

        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        const command = btn.getAttribute('data-align');

        // let elm;
        // try{
        //     let curr;
        //     if (this.builder.win.getSelection) {
        //         curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
        //         if (curr.nodeType === 3) {  //text node
        //             elm = curr.parentNode;
        //         } else {
        //             elm = curr;
        //         }
        //     }
        //     else if (this.builder.doc.selection) {
        //         curr = this.builder.doc.selection.createRange();
        //         elm = this.builder.doc.selection.createRange().parentElement();
        //     }
        // } catch(e) {return;}

        let elm = this.builder.inspectedElement;
        let element = elm;
        while (element.tagName.toLowerCase() !== 'p' && element.tagName.toLowerCase() !== 'h1' && element.tagName.toLowerCase() !== 'h2' && element.tagName.toLowerCase() !== 'h3' && element.tagName.toLowerCase() !== 'h4' && element.tagName.toLowerCase() !== 'h5' && element.tagName.toLowerCase() !== 'h6' && element.tagName.toLowerCase() !== 'pre' && element.tagName.toLowerCase() !== 'blockquote' && element.tagName.toLowerCase() !== 'div' && element.tagName.toLowerCase() !== 'td' && element.tagName.toLowerCase() !== 'th') {
          element = element.parentNode;
        }
        if (this.builder.useCssClasses) {
          element.style.textAlign = '';
          dom.removeClass(element, this.builder.cssClasses.textAlign.left);
          dom.removeClass(element, this.builder.cssClasses.textAlign.center);
          dom.removeClass(element, this.builder.cssClasses.textAlign.right);
          dom.removeClass(element, this.builder.cssClasses.textAlign.justify);
          if (command === 'left') dom.addClass(element, this.builder.cssClasses.textAlign.left);
          if (command === 'center') dom.addClass(element, this.builder.cssClasses.textAlign.center);
          if (command === 'right') dom.addClass(element, this.builder.cssClasses.textAlign.right);
          if (command === 'justify') dom.addClass(element, this.builder.cssClasses.textAlign.justify);
        } else {
          element.style.textAlign = command;
        }
        this.getState();

        //save selection
        // util.saveSelection();

        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });
    btns = this.elementRteMoreOptions.querySelectorAll('button[data-align]'); // new
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        this.builder.uo.saveForUndo();
        const command = btn.getAttribute('data-align');
        let elm = this.builder.inspectedElement;
        let element = elm;
        while (element.tagName.toLowerCase() !== 'p' && element.tagName.toLowerCase() !== 'h1' && element.tagName.toLowerCase() !== 'h2' && element.tagName.toLowerCase() !== 'h3' && element.tagName.toLowerCase() !== 'h4' && element.tagName.toLowerCase() !== 'h5' && element.tagName.toLowerCase() !== 'h6' && element.tagName.toLowerCase() !== 'pre' && element.tagName.toLowerCase() !== 'blockquote' && element.tagName.toLowerCase() !== 'div' && element.tagName.toLowerCase() !== 'td' && element.tagName.toLowerCase() !== 'th') {
          element = element.parentNode;
        }
        if (this.builder.useCssClasses) {
          element.style.textAlign = '';
          dom.removeClass(element, this.builder.cssClasses.textAlign.left);
          dom.removeClass(element, this.builder.cssClasses.textAlign.center);
          dom.removeClass(element, this.builder.cssClasses.textAlign.right);
          dom.removeClass(element, this.builder.cssClasses.textAlign.justify);
          if (command === 'left') dom.addClass(element, this.builder.cssClasses.textAlign.left);
          if (command === 'center') dom.addClass(element, this.builder.cssClasses.textAlign.center);
          if (command === 'right') dom.addClass(element, this.builder.cssClasses.textAlign.right);
          if (command === 'justify') dom.addClass(element, this.builder.cssClasses.textAlign.justify);
        } else {
          element.style.textAlign = command;
        }
        this.getState();

        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });

    // List
    btns = this.rteListOptions.querySelectorAll('button[data-action]');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        this.builder.uo.saveForUndo();
        util.restoreSelection(); //a must

        // cleanup span with style
        let activeCol = this.builder.activeCol;
        let spans = activeCol.querySelectorAll('span');
        Array.prototype.forEach.call(spans, span => {
          span.setAttribute('data-keep', '');
        });
        const command = btn.getAttribute('data-action'); //insertUnorderedList, insertOrderedList, indent, outdent           
        this.builder.doc.execCommand(command, false, null);

        // cleanup span with style
        activeCol = this.builder.activeCol;
        spans = activeCol.querySelectorAll('span');
        Array.prototype.forEach.call(spans, span => {
          let attr = span.getAttribute('data-keep');
          if (!attr) {
            span.outerHTML = span.innerHTML;
          }
        });
        Array.prototype.forEach.call(spans, span => {
          let attr = span.getAttribute('data-keep');
          if (attr) {
            dom.removeAttribute(span, 'data-keep');
          }
        });
        this.getState();

        //save selection
        util.saveSelection();

        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.isTouchSupport) {
          //prevent keyboard open
          const btnFocus = this.rteTool.querySelector('button');
          btnFocus.focus();
        }
      });
    });

    // Color
    let tabs = rteColorPicker.querySelectorAll('.is-pop-tab-item');
    Array.prototype.forEach.call(tabs, tab => {
      dom.addEventListener(tab, 'click', e => {
        this.builder.uo.saveForUndo(true); // checkLater = true

        let elms = rteColorPicker.querySelectorAll('.is-pop-tab-item');
        Array.prototype.forEach.call(elms, elm => {
          dom.removeClass(elm, 'active');
        });
        dom.addClass(e.target, 'active');
        let val = rteColorPicker.querySelector('.active').getAttribute('data-value');
        if (val === 'forecolor') {
          rteColorPicker.setAttribute('data-command', 'forecolor');
        } else {
          rteColorPicker.setAttribute('data-command', 'backcolor');
        }
      });
    });
    new ColorPicker({
      colors: this.builder.opts.colors,
      onPick: color => {
        util.restoreSelection(); //a must

        let elm;
        try {
          let curr;
          if (this.builder.win.getSelection) {
            curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
            if (curr.nodeType === 3) {
              //text node
              elm = curr.parentNode;
            } else {
              elm = curr;
            }
          } else if (this.builder.doc.selection) {
            curr = this.builder.doc.selection.createRange();
            elm = this.builder.doc.selection.createRange().parentElement();
          }
        } catch (e) {
          if (this.builder.activeIcon) {
            // If icon is selected, the selection will not be a text selection
            elm = this.builder.activeIcon;
          } else {
            return;
          }
        }

        // If icon is selected
        if (this.builder.activeIcon) {
          elm = this.builder.activeIcon;
        }
        const command = rteColorPicker.getAttribute('data-command');

        // If svg is selected
        if (this.builder.activeSvg) {
          elm = this.builder.activeSvg;
          if (command === 'forecolor') {
            if (elm.style.fill) {
              elm.style.fill = color;
            } else {
              elm.style.color = color;
            }
          } else {
            elm.style.backgroundColor = color;
          }

          // if(!this.builder.isTouchSupport) {
          //     util.saveSelection(); //Needed because after format, a tag is added (ex. <b>,<i>), so, make selection again. 
          // }

          this.builder.opts.onChange();
          if (this.builder.onTextChange) this.builder.onTextChange();
          if (this.builder.onIconChange) this.builder.onIconChange();
          return;
        }
        let text = dom.getSelected();
        if (text.trim() === '') {
          if (command === 'forecolor') {
            elm.style.color = color;
          } else {
            elm.style.backgroundColor = color;
          }
        } else {
          if (elm.innerText === text) {
            if (command === 'forecolor') {
              elm.style.color = color;
            } else {
              elm.style.backgroundColor = color;
            }
          } else {
            if (command === 'forecolor') {
              this.builder.doc.execCommand('ForeColor', false, color);
            } else {
              this.builder.doc.execCommand('BackColor', false, color);
            }

            //Cleanup FONTs
            let fontElements = this.builder.doc.getElementsByTagName('font');
            for (let i = 0, len = fontElements.length; i < len; ++i) {
              let s = fontElements[i].color;
              if (s !== '') {
                if (command === 'forecolor') {
                  fontElements[i].removeAttribute('color');
                  fontElements[i].style.color = color; //s;
                }
              }
            }
          }
        }

        //save selection (only for desktop)
        if (!this.builder.isTouchSupport) {
          util.saveSelection(); //Needed because after format, a tag is added (ex. <b>,<i>), so, make selection again. 
        }

        if (text.trim() === '') {
          util.restoreSelection(); //place cursor back after formatting (bold, italic, ...)
        }

        if (this.builder.isTouchSupport) {
          //prevent keyboard open
          const btnFocus = this.rteTool.querySelector('button');
          btnFocus.focus();
        }
        //Trigger Change event
        this.builder.opts.onChange();
        if (this.builder.onTextChange) this.builder.onTextChange();
        if (this.builder.onIconChange) this.builder.onIconChange();
      },
      renderOn: '.rte-color-picker-area',
      animateModal: this.builder.opts.animateModal,
      elementToAnimate: this.builder.opts.container,
      lang: this.builder.opts.lang
    });

    // Font Size (new execCommand)
    btns = rteTextSettingOptions.querySelectorAll('.rte-fontsize-options button');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        // old 9135

        let num = btn.getAttribute('data-value');
        util.restoreSelection(); //a must

        this.builder.uo.saveForUndo();
        const selection = dom.getSelection();
        if (!selection) return;
        const anchorNode = selection.anchorNode;
        let currentFontSize = 1;
        if (anchorNode) {
          const container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
          currentFontSize = Number(window.getComputedStyle(container).getPropertyValue('font-size').match(/\d+/)[0]);
        }
        const btns = rteTextSettingOptions.querySelectorAll('.rte-fontsize-options button');
        Array.prototype.forEach.call(btns, btn => {
          btn.classList.remove('on'); // clear selection
        });

        dom.execCommand('font-size', currentFontSize + 1 + 'px', (ok, container) => {
          // 1px is dummy so that it won't be cleaned in util.js (checkStyleIfSameAsParent) because of same size

          if (!ok) {
            // If icon is selected
            if (this.builder.activeIcon) {
              let elm = this.builder.activeIcon;
              if (this.builder.opts.fontSizeClassValues.length > 0) {
                this.applyClassFontSize(elm, num);
              } else {
                this.applyInlineFontSize(elm, num);
              }
            }
          }
          if (container) {
            if (this.builder.opts.fontSizeClassValues.length > 0) {
              this.applyClassFontSize(container, num);
            } else {
              this.applyInlineFontSize(container, num);
            }
            container.style.fontSize = '';
          }
          if (this.builder.onTextChange) this.builder.onTextChange();
          if (this.builder.onIconChange) this.builder.onIconChange();
        });

        //save selection
        util.saveSelection();

        // this.getState();
        this.getTextSettingsState();

        //Trigger Change event
        this.builder.opts.onChange();

        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        // btn.focus();
      });
    });

    // Font Weight (new execCommand)
    btns = rteTextSettingOptions.querySelectorAll('.rte-fontweight-options button');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        // old 9135

        let num = btn.getAttribute('data-value');
        util.restoreSelection(); //a must

        this.builder.uo.saveForUndo();
        const btns = rteTextSettingOptions.querySelectorAll('.rte-fontweight-options button');
        Array.prototype.forEach.call(btns, btn => {
          btn.classList.remove('on'); // clear selection
        });

        dom.execCommand('font-weight', num, (ok, container) => {
          if (this.builder.useCssClasses) {
            if (container) {
              this.applyClassFontWeight(container, num);
            }
          }
        });

        //save selection
        util.saveSelection();
        this.getState();
        this.getTextSettingsState();

        //Trigger Change event
        this.builder.opts.onChange();

        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        // btn.focus();

        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });

    // Line Height
    btns = rteTextSettingOptions.querySelectorAll('.rte-lineheight-options button');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        let num = btn.getAttribute('data-value');
        util.restoreSelection(); //a must

        this.builder.uo.saveForUndo();
        const btns = rteTextSettingOptions.querySelectorAll('.rte-lineheight-options button');
        Array.prototype.forEach.call(btns, btn => {
          btn.classList.remove('on'); // clear selection
        });

        if (this.builder.useCssClasses) {
          const selection = dom.getSelection();
          if (!selection) return;
          const anchorNode = selection.anchorNode;
          let container;
          if (anchorNode) {
            container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
          }
          if (!container) return; // ex. when selecting an icon

          let newClassName;
          const classes = this.builder.cssClasses.leading;
          if (num === '') {
            // clean
            newClassName = '';
          } else if (num === '+' || num === '-') {
            for (let i = 0; i < Object.keys(classes).length; i++) {
              let className = Object.values(classes)[i];
              if (container.closest(`.${className}`)) {
                if (num === '+') {
                  if (i + 1 === Object.keys(classes).length) return;
                  newClassName = Object.values(classes)[i + 1];
                  break;
                } else if (num === '-') {
                  if (i - 1 < 0) return;
                  newClassName = Object.values(classes)[i - 1];
                  break;
                }
              }
            }
          } else {
            if (num === '0.8') {
              newClassName = classes.leading_8;
            } else if (num === '0.9') {
              newClassName = classes.leading_9;
            } else if (num === '1') {
              newClassName = classes.leading_10;
            } else if (num === '1.1') {
              newClassName = classes.leading_11;
            } else if (num === '1.2') {
              newClassName = classes.leading_12;
            } else if (num === '1.3') {
              newClassName = classes.leading_13;
            } else if (num === '1.4') {
              newClassName = classes.leading_14;
            } else if (num === '1.5') {
              newClassName = classes.leading_15;
            } else if (num === '1.6') {
              newClassName = classes.leading_16;
            } else if (num === '1.7') {
              newClassName = classes.leading_17;
            } else if (num === '1.8') {
              newClassName = classes.leading_18;
            } else if (num === '1.9') {
              newClassName = classes.leading_19;
            } else if (num === '2') {
              newClassName = classes.leading_20;
            } else if (num === '2.1') {
              newClassName = classes.leading_21;
            } else if (num === '2.2') {
              newClassName = classes.leading_22;
            }
          }
          if (!newClassName) {
            if (num === '+') {
              newClassName = classes.leading_16;
            } else if (num === '-') {
              newClassName = classes.leading_14;
            }
          }
          const elm = dom.getParentBlock(container);
          if (elm) elm.style.lineHeight = ''; // Clean inline style

          dom.execCommandClass(newClassName, classes, true, 'block');
        } else {
          let elm;
          try {
            let curr;
            if (this.builder.win.getSelection) {
              curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
              if (curr.nodeType === 3) {
                //text node
                elm = curr.parentNode;
              } else {
                elm = curr;
              }
            } else if (this.builder.doc.selection) {
              curr = this.builder.doc.selection.createRange();
              elm = this.builder.doc.selection.createRange().parentElement();
            }
          } catch (e) {
            if (this.builder.activeIcon) {
              // If icon is selected, the selection will not be a text selection
              elm = this.builder.activeIcon;
            } else {
              return;
            }
          }

          // If icon is selected
          if (this.builder.activeIcon) {
            elm = this.builder.activeIcon;
          }

          // Find block element (line-height only works on block element)
          let element = elm;
          while (element) {
            if (element.tagName === 'BODY' || element.tagName === 'HTML') return false;
            if (window.getComputedStyle(element).getPropertyValue('display') !== 'inline') {
              elm = element;
              break;
            }
            element = element.parentNode;
          }

          // var text = dom.getSelected();

          // let currentLineHeight = Number(window.getComputedStyle(elm).getPropertyValue('line-height').match(/\d+/)[0]);
          let isInPx = false;
          let currentLineHeight = elm.style.lineHeight;
          if (currentLineHeight) {
            if (currentLineHeight.indexOf('px') === -1) {
              currentLineHeight = parseFloat(currentLineHeight);
            } else {
              isInPx = true;
            }
          } else {
            isInPx = true;
          }
          if (isInPx) {
            let fontSize = Number(window.getComputedStyle(elm).getPropertyValue('font-size').match(/\d+/)[0]);
            currentLineHeight = Number(window.getComputedStyle(elm).getPropertyValue('line-height').match(/\d+/)[0]);
            if (fontSize > currentLineHeight) {
              currentLineHeight = fontSize / currentLineHeight;
            } else if (fontSize < currentLineHeight) {
              currentLineHeight = currentLineHeight / fontSize;
            } else {
              currentLineHeight = 1;
            }
          }
          let lineheight;
          if (num === '+') {
            lineheight = currentLineHeight + 0.1;
          } else if (num === '-') {
            lineheight = currentLineHeight - 0.1;
            if (lineheight < 0.2) lineheight = 0.2; // prevent very small number
          } else if (num === '') {
            lineheight = '';
          } else {
            lineheight = num;
          }

          /** mod by Jack */
          //elm.style.lineHeight = lineheight;
          dom.doFunction(elm, function (theEl) {
            // apply to block element only
            if (window.getComputedStyle(theEl).getPropertyValue('display') !== 'inline') {
              theEl.style.lineHeight = lineheight;
            }
          }, true);
        }

        //save selection
        util.saveSelection();

        // this.getState();
        this.getTextSettingsState();

        //Trigger Change event
        this.builder.opts.onChange();

        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        // btn.focus();

        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });

    // Letter Spacing
    btns = rteTextSettingOptions.querySelectorAll('.rte-letterspacing-options button');
    Array.prototype.forEach.call(btns, btn => {
      dom.addEventListener(btn, 'click', () => {
        let num = btn.getAttribute('data-value');
        util.restoreSelection(); //a must

        this.builder.uo.saveForUndo();
        const btns = rteTextSettingOptions.querySelectorAll('.rte-letterspacing-options button');
        Array.prototype.forEach.call(btns, btn => {
          btn.classList.remove('on'); // clear selection
        });

        if (this.builder.useCssClasses) {
          const selection = dom.getSelection();
          if (!selection) return;
          const anchorNode = selection.anchorNode;
          let container;
          if (anchorNode) {
            container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
          }
          if (!container) return; // ex. when selecting an icon

          let newClassName;
          const classes = this.builder.cssClasses.tracking;
          if (num === '') {
            // clean
            newClassName = '';
          } else if (num === '+' || num === '-') {
            for (let i = 0; i < Object.keys(classes).length; i++) {
              let className = Object.values(classes)[i];
              if (container.closest('.' + className) && !container.classList.contains('is-builder')) {
                if (num === '+') {
                  if (i + 1 === Object.keys(classes).length) return;
                  newClassName = Object.values(classes)[i + 1];
                  break;
                } else if (num === '-') {
                  if (i - 1 < 0) return;
                  newClassName = Object.values(classes)[i - 1];
                  break;
                }
              }
            }
          } else {
            if (num === '1') {
              newClassName = classes.tracking_025;
            }
            if (num === '2') {
              newClassName = classes.tracking_050;
            }
          }
          if (!newClassName) {
            if (num === '+') {
              newClassName = classes.tracking_025;
            } else if (num === '-') {
              newClassName = classes.tracking__025;
            }
          }
          if (this.builder.activeElement) this.builder.activeElement.style.letterSpacing = '';
          container.style.letterSpacing = ''; // Clean inline style

          if (newClassName === classes.tracking_000) newClassName = ''; // clear for normal tracking
          dom.execCommandClass(newClassName, classes);
        } else {
          let elm;
          try {
            let curr;
            if (this.builder.win.getSelection) {
              curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
              if (curr.nodeType === 3) {
                //text node
                elm = curr.parentNode;
              } else {
                elm = curr;
              }
            } else if (this.builder.doc.selection) {
              curr = this.builder.doc.selection.createRange();
              elm = this.builder.doc.selection.createRange().parentElement();
            }
          } catch (e) {
            if (this.builder.activeIcon) {
              // If icon is selected, the selection will not be a text selection
              elm = this.builder.activeIcon;
            } else {
              return;
            }
          }

          // If icon is selected
          if (this.builder.activeIcon) {
            elm = this.builder.activeIcon;
          }
          let currentLetterSpacing = parseInt(window.getComputedStyle(elm).getPropertyValue('letter-spacing'));
          if (isNaN(currentLetterSpacing)) currentLetterSpacing = 0;
          let letterspacing;
          if (num === '+') {
            letterspacing = currentLetterSpacing + 1 + 'px';
          } else if (num === '-') {
            letterspacing = currentLetterSpacing - 1 + 'px';
          } else if (num === '') {
            letterspacing = '';
          } else {
            letterspacing = num + 'px';
          }
          /** mod by Jack */
          //elm.style.letterSpacing = letterspacing;
          dom.doFunction(elm, function (theEl) {
            theEl.style.letterSpacing = letterspacing;
          }, true);
        }

        //save selection
        util.saveSelection();

        // this.getState();
        this.getTextSettingsState();

        //Trigger Change event
        this.builder.opts.onChange();

        // if(this.builder.isTouchSupport) { //prevent keyboard open
        //     const btnFocus = this.rteTool.querySelector('button'); 
        //     btnFocus.focus();
        // }

        // btn.focus();

        if (this.builder.onTextChange) this.builder.onTextChange();
      });
    });

    // freeform

    let btnGroup = builderStuff.querySelectorAll('button.rte-group');
    btnGroup.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.group();
        builderStuff.querySelectorAll('button.rte-group').forEach(elm => elm.style.display = 'none');
        builderStuff.querySelectorAll('button.rte-ungroup').forEach(elm => elm.style.display = '');
      });
    });
    let btnUnGroup = builderStuff.querySelectorAll('button.rte-ungroup');
    btnUnGroup.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.unGroup();
        builderStuff.querySelectorAll('button.rte-group').forEach(elm => elm.style.display = '');
        builderStuff.querySelectorAll('button.rte-ungroup').forEach(elm => elm.style.display = 'none');
      });
    });
    let btnDelete = builderStuff.querySelectorAll('button.rte-delete');
    btnDelete.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.delete();
      });
    });
    let btnBlockSettings = builderStuff.querySelectorAll('button.rte-blocksettings');
    btnBlockSettings.forEach(btn => {
      btn.addEventListener('click', () => {
        this.builder.blockmodal.show();
      });
    });
    let btnFront = builderStuff.querySelectorAll('button.rte-front');
    btnFront.forEach(btn => {
      btn.addEventListener('click', () => {
        let activeBlock = this.builder.doc.querySelector('.is-block.cloned');
        if (!activeBlock) return;
        this.builder.forward(activeBlock);
      });
    });
    let btnBackward = builderStuff.querySelectorAll('button.rte-backward');
    btnBackward.forEach(btn => {
      btn.addEventListener('click', () => {
        let activeBlock = this.builder.doc.querySelector('.is-block.cloned');
        if (!activeBlock) return;
        if (activeBlock.style.zIndex === '0') {
          this.builder.moveUp(activeBlock);
        }
        this.builder.backward(activeBlock);
      });
    });
    let btnMoveUp = builderStuff.querySelectorAll('button.rte-moveup');
    btnMoveUp.forEach(btn => {
      btn.addEventListener('click', () => {
        let activeBlock = this.builder.doc.querySelector('.is-block.active');
        if (!activeBlock) return;
        this.builder.moveUp(activeBlock);
      });
    });
    let btnMoveDown = builderStuff.querySelectorAll('button.rte-movedown');
    btnMoveDown.forEach(btn => {
      btn.addEventListener('click', () => {
        let activeBlock = this.builder.doc.querySelector('.is-block.active');
        if (!activeBlock) return;
        this.builder.moveDown(activeBlock);
      });
    });
    let btnDuplicate = builderStuff.querySelectorAll('button.rte-duplicate');
    btnDuplicate.forEach(btn => {
      btn.addEventListener('click', () => {
        let activeBlock = this.builder.doc.querySelector('.is-block.cloned');
        if (!activeBlock) return;
        this.builder.duplicate(activeBlock);
      });
    });

    // Backward compatible
    this.builderStuff.insertAdjacentHTML('afterbegin', `
        <style>
            #_cbhtml[toolbarfull] .is-rte-tool,
            #_cbhtml[toolbarfull] .is-elementrte-tool {
                top: 0;
                left: 0;
                width: 100vw;
                align-items: center;
                box-shadow: rgba(0, 0, 0, 0.07) -1px 1px 0px 0px;
            }
            #_cbhtml[toolbarfull] .is-rte-pop {
                box-shadow: rgba(0, 0, 0, 0.05) 0px 1px 0px 1px;
            }
        </style>
        `);
    if (this.builder.toolbarDisplay !== 'auto') {
      this.showDefaultToolbar(); // first time
    }
  } //contructor

  zoomStart() {
    if (this.builder.onZoomStart) {
      this.builder.onZoomStart();
    }
  }
  zoom(inp) {
    //scale: 0.5 - 1
    //val: 50 - 100
    let val = inp.value;
    let scale = val / 100;
    this.builder.opts.zoom = scale;
    localStorage.setItem('_zoom', scale); // Save

    // setZoomOnArea
    this.builder.setZoomOnArea();

    // hide tools
    let tools = this.builder.doc.querySelectorAll('.is-tool');
    Array.prototype.forEach.call(tools, tool => {
      tool.style.display = '';
    });
    tools = this.builder.doc.querySelectorAll('.is-row-tool');
    tools.forEach(tool => {
      tool.style.display = 'none';
    });
    tools = this.builder.doc.querySelectorAll('.is-col-tool');
    tools.forEach(tool => {
      tool.style.display = 'none';
    });
    tools = this.builder.doc.querySelectorAll('.is-canvas-tool');
    tools.forEach(tool => {
      tool.style.display = 'none';
    });
    tools = this.builder.doc.querySelectorAll('.is-canvasadd-tool');
    tools.forEach(tool => {
      tool.style.display = 'none';
    });
    tools = this.builder.doc.querySelectorAll('.is-rowadd-tool');
    tools.forEach(tool => {
      tool.style.opacity = 0;
    });
    if (this.builder.onZoom) {
      let val = inp.value;
      let scale = val / 100;
      this.builder.onZoom(scale);
    }
  }
  zoomEnd(inp) {
    setTimeout(() => {
      // setZoomOnControl
      if (this.builder.isContentBox) {
        const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
        this.builder.setZoomOnControl(wrapper);
      } else if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
        // freeform
        const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
        this.builder.setZoomOnControl(docContainer);
      } else {
        const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
        builders.forEach(builder => {
          this.builder.setZoomOnControl(builder);
        });
      }

      // show & reposition
      this.builder.elmTool.repositionElementTool();
      let tools = this.builder.doc.querySelectorAll('.is-row-tool');
      tools.forEach(tool => {
        tool.style.display = '';
      });
      tools = this.builder.doc.querySelectorAll('.is-rowadd-tool');
      tools.forEach(tool => {
        tool.style.opacity = '';
      });
      tools = this.builder.doc.querySelectorAll('.is-col-tool');
      tools.forEach(tool => {
        tool.style.display = '';
      });
      tools = this.builder.doc.querySelectorAll('.is-canvas-tool');
      tools.forEach(tool => {
        tool.style.display = '';
      });
      tools = this.builder.doc.querySelectorAll('.is-canvasadd-tool');
      tools.forEach(tool => {
        tool.style.display = '';
      });
      if (this.builder.onZoomEnd) {
        let val = inp.value;
        let scale = val / 100;
        this.builder.onZoomEnd(scale);
      }
    }, 300);
  }
  formatText(command) {
    const dom = this.builder.dom;
    let elm;
    try {
      let curr;
      if (this.builder.win.getSelection) {
        curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
        if (curr.nodeType === 3) {
          //text node
          elm = curr.parentNode;
        } else {
          elm = curr;
        }
      } else if (this.builder.doc.selection) {
        curr = this.builder.doc.selection.createRange();
        elm = this.builder.doc.selection.createRange().parentElement();
      }
    } catch (e) {
      return;
    }
    var text = dom.getSelected();
    if (command === 'bold') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('fontWeight', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          var tagname = elm.tagName.toLowerCase();
          if (tagname === 'b') {
            dom.selectElementContents(elm);
            this.builder.doc.execCommand('bold', false, null);
          } else {
            if (elm.style.fontWeight === 'bold' || elm.style.fontWeight > 400) {
              elm.style.fontWeight = '';
            } else {
              elm.style.fontWeight = 'bold';
            }
          }
        } else {
          this.builder.doc.execCommand('bold', false, null);
        }
      }
    }
    if (command === 'italic') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('fontStyle', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          tagname = elm.tagName.toLowerCase();
          if (tagname === 'i') {
            dom.selectElementContents(elm);
            this.builder.doc.execCommand('italic', false, null);
          } else {
            let fontStyle = window.getComputedStyle(elm).getPropertyValue('font-style');
            if (fontStyle === 'italic') {
              elm.style.fontStyle = 'normal';
            } else {
              elm.style.fontStyle = 'italic';
            }
          }
        } else {
          this.builder.doc.execCommand('italic', false, null);
        }
      }
    }
    if (command === 'underline') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('textUnderline', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          tagname = elm.tagName.toLowerCase();
          if (tagname === 'u') {
            dom.selectElementContents(elm);
            this.builder.doc.execCommand('underline', false, null);
          } else {
            if (elm.style.textDecoration.indexOf('underline') !== -1) {
              elm.style.textDecoration = '';
            } else {
              elm.style.textDecoration = 'underline';
            }
          }
        } else {
          this.builder.doc.execCommand('underline', false, null);
        }
      }
    }
    if (command === 'strikethrough') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('textLinethrough', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          tagname = elm.tagName.toLowerCase();
          if (tagname === 'strike') {
            dom.selectElementContents(elm);
            this.builder.doc.execCommand('strikethrough', false, null);
          } else {
            if (elm.style.textDecoration.indexOf('line-through') !== -1) {
              elm.style.textDecoration = '';
            } else {
              elm.style.textDecoration = 'line-through';
            }
          }
        } else {
          this.builder.doc.execCommand('strikethrough', false, null);
        }
      }
    }
    if (command === 'superscript') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('extend', 'superscript', this.builder.cssClasses);
      } else {
        this.builder.doc.execCommand('superscript', false, null);
      }
    }
    if (command === 'subscript') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('extend', 'subscript', this.builder.cssClasses);
      } else {
        this.builder.doc.execCommand('subscript', false, null);
      }
    }
    if (command === 'uppercase') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('textTransform', '', this.builder.cssClasses);
      } else {
        let textTransform = window.getComputedStyle(elm).getPropertyValue('text-transform');
        if (textTransform === 'uppercase') {
          elm.style.textTransform = 'lowercase';
        } else if (textTransform === 'lowercase') {
          elm.style.textTransform = 'capitalize';
        } else if (textTransform === 'capitalize') {
          elm.style.textTransform = 'none';
        } else if (textTransform === 'none') {
          elm.style.textTransform = 'uppercase';
        } else {
          elm.style.textTransform = 'none';
        }
      }
    }
    if (command === 'clean') {
      if (this.builder.useCssClasses) {
        this.builder.doc.execCommand('removeFormat', false, null); // optional: backward compatible (for cleaning old b, i tags)
        dom.execCommandToggle('clean', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          elm.style.cssText = '';
          elm.className = '';
        } else {
          if (elm.innerText.replace(/(\r\n|\n|\r)/gm, '') === text.trim().replace(/(\r\n|\n|\r)/gm, '')) {
            elm.style.cssText = '';
            elm.className = '';
            this.builder.doc.execCommand('removeFormat', false, null);
            this.builder.doc.execCommand('removeFormat', false, null);
          } else {
            this.builder.doc.execCommand('removeFormat', false, null);
            this.builder.doc.execCommand('removeFormat', false, null);
          }
        }
      }
    }
    this.getState();
  }
  formatTextNonToggle(command) {
    const dom = this.builder.dom;
    let elm;
    try {
      let curr;
      if (this.builder.win.getSelection) {
        curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
        if (curr.nodeType === 3) {
          //text node
          elm = curr.parentNode;
        } else {
          elm = curr;
        }
      } else if (this.builder.doc.selection) {
        curr = this.builder.doc.selection.createRange();
        elm = this.builder.doc.selection.createRange().parentElement();
      }
    } catch (e) {
      return;
    }
    var text = dom.getSelected();
    if (command === 'bold') {
      dom.execCommand('text-weight', 'bold', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.fontWeight.thin);
            container.classList.remove(config.fontWeight.extralight);
            container.classList.remove(config.fontWeight.light);
            container.classList.remove(config.fontWeight.normal);
            container.classList.remove(config.fontWeight.semibold);
            container.classList.remove(config.fontWeight.bold);
            container.classList.remove(config.fontWeight.extrabold);
            container.classList.remove(config.fontWeight.black);
            container.classList.remove(config.fontWeight.defaultBold);
            container.classList.remove(config.fontWeight.defaultNormal);
            container.classList.add(config.fontWeight.semibold);
            dom.doFunction(container, function (theEl) {
              theEl.style.fontWeight = '';
            }, true);
          }
        }
      });
    }
    if (command === 'italic') {
      dom.execCommand('text-style', 'italic', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.fontStyle.italic);
            container.classList.remove(config.fontStyle.normal);
            container.classList.add(config.fontStyle.italic);
            dom.doFunction(container, function (theEl) {
              theEl.style.fontStyle = '';
            }, true);
          }
        }
      });
    }
    if (command === 'underline') {
      dom.execCommand('text-decoration', 'underline', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.textDecoration.underline);
            container.classList.remove(config.textDecoration.linethrough);
            container.classList.remove(config.textDecoration.normal);
            container.classList.add(config.textDecoration.underline);
            dom.doFunction(container, function (theEl) {
              theEl.style.textDecoration = '';
            }, true);
          }
        }
      });
    }
    if (command === 'strikethrough') {
      dom.execCommand('text-decoration', 'line-through', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.textDecoration.underline);
            container.classList.remove(config.textDecoration.linethrough);
            container.classList.remove(config.textDecoration.normal);
            container.classList.add(config.textDecoration.linethrough);
            dom.doFunction(container, function (theEl) {
              theEl.style.textDecoration = '';
            }, true);
          }
        }
      });
    }
    if (command === 'superscript') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('extend', 'superscript', this.builder.cssClasses);
      } else {
        this.builder.doc.execCommand('superscript', false, null);
      }
    }
    if (command === 'subscript') {
      if (this.builder.useCssClasses) {
        dom.execCommandToggle('extend', 'subscript', this.builder.cssClasses);
      } else {
        this.builder.doc.execCommand('subscript', false, null);
      }
    }
    if (command === 'uppercase') {
      dom.execCommand('text-transform', 'uppercase', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.textTransform.uppercase);
            container.classList.remove(config.textTransform.lowercase);
            container.classList.remove(config.textTransform.capitalize);
            container.classList.remove(config.textTransform.normal);
            container.classList.add(config.textTransform.uppercase);
            dom.doFunction(container, function (theEl) {
              theEl.style.textTransform = '';
            }, true);
          }
        }
      });
    }
    if (command === 'lowercase') {
      dom.execCommand('text-transform', 'lowercase', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.textTransform.uppercase);
            container.classList.remove(config.textTransform.lowercase);
            container.classList.remove(config.textTransform.capitalize);
            container.classList.remove(config.textTransform.normal);
            container.classList.add(config.textTransform.lowercase);
            dom.doFunction(container, function (theEl) {
              theEl.style.textTransform = '';
            }, true);
          }
        }
      });
    }
    if (command === 'capitalize') {
      dom.execCommand('text-transform', 'capitalize', (ok, container) => {
        if (this.builder.useCssClasses) {
          if (container) {
            const config = this.builder.cssClasses;
            container.classList.remove(config.textTransform.uppercase);
            container.classList.remove(config.textTransform.lowercase);
            container.classList.remove(config.textTransform.capitalize);
            container.classList.remove(config.textTransform.normal);
            container.classList.add(config.textTransform.capitalize);
            dom.doFunction(container, function (theEl) {
              theEl.style.textTransform = '';
            }, true);
          }
        }
      });
    }
    if (command === 'clean') {
      if (this.builder.useCssClasses) {
        this.builder.doc.execCommand('removeFormat', false, null); // optional: backward compatible (for cleaning old b, i tags)
        dom.execCommandToggle('clean', '', this.builder.cssClasses);
      } else {
        if (text.trim() === '') {
          elm.style.cssText = '';
          elm.className = '';
        } else {
          if (elm.innerText.replace(/(\r\n|\n|\r)/gm, '') === text.trim().replace(/(\r\n|\n|\r)/gm, '')) {
            elm.style.cssText = '';
            elm.className = '';
            this.builder.doc.execCommand('removeFormat', false, null);
            this.builder.doc.execCommand('removeFormat', false, null);
          } else {
            this.builder.doc.execCommand('removeFormat', false, null);
            this.builder.doc.execCommand('removeFormat', false, null);
          }
        }
      }
    }
    this.getState();
  }
  insertImage() {
    const dom = this.dom;
    const modalInsertImage = this.builderStuff.querySelector('.insertimage');
    const fileInsertImage = modalInsertImage.querySelector('#fileInsertImage');
    const modal = this.builderStuff.querySelector('.insertimage');
    this.util.showModal(modal, true, function () {
      //if(!this.builder.isTouchSupport) util.restoreSelection();
    }, false);
    modal.querySelector('#inpInsertImageSrc').focus();

    //Clear previous
    modal.querySelector('#fileInsertImage').value = ''; // clear
    modal.querySelector('.is-preview-area').style.display = 'none';
    fileInsertImage.removeAttribute('disabled');
    modal.querySelector('.is-drop-area').style.display = 'block';
    dom.removeClass(modal.querySelector('.is-drop-area'), 'image-dropping');

    //Clear image source input
    modal.querySelector('.input-src').value = '';
  }
  viewSnippets() {
    const snippets = new Snippets(this.builder);
    let modal = this.builderStuff.querySelector('.snippets');
    this.util.showModal(modal, false, null, false);

    // let iframe = modal.querySelector('iframe');
    // if(iframe.src==='about:blank') {
    //     iframe.src = builder.opts.snippetData;
    // }
    const ifr = modal.querySelector('iframe');
    var doc = ifr.contentWindow.document;
    if (doc.body.innerHTML === '') {
      doc.open();
      doc.write(snippets.getSnippetsHtml());
      doc.close();
    }
  }
  openIcon(e) {
    const pop = this.rteIconOptions;
    const divIconList = pop.querySelector('.div-icon-list');
    if (divIconList.innerHTML.trim() === '') {
      Promise.resolve().then(() => {
        const bootstrapInc = !this.builder.disableBootstrapIcons;
        if (bootstrapInc) {
          divIconList.innerHTML = this.getIcons2() + this.getIcons();
        } else {
          divIconList.innerHTML = this.getIcons();
        }
        divIconList.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', () => {
            this.builder.addIcon(btn.querySelector('i').className);
            btn.focus();
          });
        });
      });
    }
    const dom = this.dom;
    let btnRteIcons = e.target;
    const top = btnRteIcons.getBoundingClientRect().top;
    const left = btnRteIcons.getBoundingClientRect().left;
    pop.style.display = 'flex';
    const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = pop.offsetHeight;
    if (!dom.hasClass(pop, 'active')) {
      this.util.showRtePop(pop, () => {
        if (this.builder.opts.toolbar === 'left') {
          pop.style.top = top - h / 2 + 20 + 'px';
          pop.style.left = left + 54 + 'px';
          pop.style.right = 'auto';
        } else if (this.builder.opts.toolbar === 'right') {
          pop.style.top = top - h / 2 + 20 + 'px';
          pop.style.left = 'auto';
          const viewportWidth = document.body.clientWidth; //window.innerWidth;
          pop.style.right = viewportWidth - left + 9 + 'px';
        } else {
          pop.style.top = top + 54 - 6 + 'px';
          pop.style.left = left - w / 2 + 23 + 'px';
          pop.style.right = 'auto';
          if (btnRteIcons.getBoundingClientRect().left + 45 - parseInt(this.rteTool.style.left) < pop.offsetWidth) {
            pop.style.left = parseInt(this.rteTool.style.left) + 'px';
          } else if (parseInt(this.rteTool.style.left) + this.rteTool.offsetWidth - btnRteIcons.getBoundingClientRect().left + 45 < pop.offsetWidth) {
            pop.style.left = parseInt(this.rteTool.style.left) + this.rteTool.offsetWidth - w + 'px';
          } else ;
          // if(dom.hasClass(this.builder.inspectedElement,'icon')) {
          //     pop.style.left = (parseInt(this.rteTool.style.left) + this.rteTool.offsetWidth - w) + 'px';
          // }
        }

        if (dom.parentsHasClass(btnRteIcons, 'rte-more-options')) {
          // Adjustment if button is placed on 2nd bar (div.rte-more-options)
          if (this.builder.opts.toolbar === 'left') {
            pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
            pop.style.left = left + 54 + 'px';
            pop.style.right = 'auto';
          } else if (this.builder.opts.toolbar === 'right') {
            pop.style.top = parseInt(this.rteMoreOptions.style.top) + this.rteMoreOptions.offsetHeight - h + 'px';
            pop.style.left = 'auto';
            const viewportWidth = document.body.clientWidth; //window.innerWidth;
            pop.style.right = viewportWidth - left + 9 + 'px';
          } else {
            pop.style.top = top + 54 - 6 + 'px';
            if (btnRteIcons.getBoundingClientRect().left + 45 - parseInt(this.rteMoreOptions.style.left) < pop.offsetWidth) {
              pop.style.left = parseInt(this.rteMoreOptions.style.left) + 'px';
            } else if (parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - btnRteIcons.getBoundingClientRect().left + 45 < pop.offsetWidth) {
              pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
            } else ;
            if (dom.hasClass(this.builder.inspectedElement, 'icon')) {
              pop.style.left = parseInt(this.rteMoreOptions.style.left) + this.rteMoreOptions.offsetWidth - w + 'px';
            }
            pop.style.right = 'auto';
          }
        }
      }, btnRteIcons);
      const inpIconSearch = this.rteIconOptions.querySelector('#inpRteIconSearch');
      inpIconSearch.focus();
    } else {
      this.util.hideRtePop(pop);
    }
  }
  showRteMore() {
    const dom = this.dom;
    const pop = this.rteMoreOptions;
    if (!dom.hasClass(pop, 'active')) {
      this.positionRteMore();
      dom.removeClass(pop, 'deactive');
      dom.addClass(pop, 'active');
      // this.util.showRtePop(pop, ()=>{}, btn);
    } else {
      dom.removeClass(pop, 'active');
      dom.addClass(pop, 'deactive');
      // this.util.hideRtePop(pop);
    }
  }

  positionRteMore() {
    let top;
    let left;
    const btnRteMore = this.rteTool.querySelectorAll('button.rte-more');
    let btnWidth = 0;
    btnRteMore.forEach(btn => {
      if (btn.getBoundingClientRect().top > 0) {
        top = btn.getBoundingClientRect().top;
        left = btn.getBoundingClientRect().left;
        btnWidth = btn.offsetWidth;
      }
    });
    const pop = this.rteMoreOptions;
    pop.style.display = 'flex';
    const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = pop.offsetHeight;
    if (this.builder.opts.toolbar === 'left') {
      pop.style.top = parseFloat(this.rteTool.style.top) + this.rteTool.offsetHeight - h + 'px'; //(top - (h/2) + 20) + 'px';
      pop.style.left = left + 54 + 'px';
      pop.style.right = 'auto';
    } else if (this.builder.opts.toolbar === 'right') {
      pop.style.top = parseFloat(this.rteTool.style.top) + this.rteTool.offsetHeight - h + 'px'; //(top - (h/2) + 20) + 'px';
      pop.style.left = 'auto';
      const viewportWidth = document.body.clientWidth; //window.innerWidth;
      pop.style.right = viewportWidth - left + 9 + 'px';
    } else {
      const adj = 0;
      pop.style.top = top + 54 - 6 + 'px';
      pop.style.left = parseFloat(this.rteTool.style.left) + this.rteTool.offsetWidth - w + adj + 'px'; //(left -(w/2)+23) + 'px';
      pop.style.right = 'auto';
      if (this.builderStuff.hasAttribute('toolbarfull')) {
        pop.style.left = left - w + btnWidth + 'px';
      }
    }
  }

  // showElementRteMore() {
  //     const btnElementRteMore = this.elementRteTool.querySelector('button.rte-more'); 
  //     const pop = this.elementRteMoreOptions;
  //     const top = btnElementRteMore.getBoundingClientRect().top; // + window.pageYOffset;
  //     const left = btnElementRteMore.getBoundingClientRect().left; // + window.pageXOffset;
  //     pop.style.display = 'flex';
  //     const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
  //     const h = pop.offsetHeight;

  //     if(!dom.hasClass(pop,'active')){  
  //         if(this.builder.opts.toolbar === 'left') {
  //             pop.style.top = (parseInt(this.elementRteTool.style.top) + this.elementRteTool.offsetHeight - h) + 'px'; //(top - (h/2) + 20) + 'px';
  //             pop.style.left = (left + 54) + 'px';     
  //             pop.style.right = 'auto';              
  //         } else if(this.builder.opts.toolbar === 'right') {
  //             pop.style.top = (parseInt(this.elementRteTool.style.top) + this.elementRteTool.offsetHeight - h) + 'px'; //(top - (h/2) + 20) + 'px';
  //             pop.style.left = 'auto';
  //             const viewportWidth = document.body.clientWidth;//window.innerWidth;
  //             pop.style.right = (viewportWidth - left + 9) + 'px';  
  //         } else {
  //             pop.style.top = (top + 54 - 6) + 'px';
  //             pop.style.left = (parseInt(this.elementRteTool.style.left) + this.elementRteTool.offsetWidth - w) + 'px'; //(left -(w/2)+23) + 'px';
  //             pop.style.right = 'auto';   
  //         }

  //         dom.removeClass(pop,'deactive');
  //         dom.addClass(pop, 'active');  
  //     } else {
  //         dom.removeClass(pop,'active');
  //         dom.addClass(pop, 'deactive');
  //     }
  // }

  showElementRteMore() {
    const dom = this.dom;
    const pop = this.elementRteMoreOptions;
    if (!dom.hasClass(pop, 'active')) {
      this.positionElementRteMore();
      dom.removeClass(pop, 'deactive');
      dom.addClass(pop, 'active');
      // this.util.showRtePop(pop, ()=>{}, btn);
    } else {
      dom.removeClass(pop, 'active');
      dom.addClass(pop, 'deactive');
      // this.util.hideRtePop(pop);
    }
  }

  positionElementRteMore() {
    const btnElementRteMore = this.elementRteTool.querySelector('button.rte-more');
    const pop = this.elementRteMoreOptions;
    const top = btnElementRteMore.getBoundingClientRect().top;
    const left = btnElementRteMore.getBoundingClientRect().left;
    pop.style.display = 'flex';
    const w = pop.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = pop.offsetHeight;
    if (this.builder.opts.toolbar === 'left') {
      pop.style.top = parseFloat(this.elementRteTool.style.top) + this.elementRteTool.offsetHeight - h + 'px'; //(top - (h/2) + 20) + 'px';
      pop.style.left = left + 54 + 'px';
      pop.style.right = 'auto';
    } else if (this.builder.opts.toolbar === 'right') {
      pop.style.top = parseFloat(this.elementRteTool.style.top) + this.elementRteTool.offsetHeight - h + 'px'; //(top - (h/2) + 20) + 'px';
      pop.style.left = 'auto';
      const viewportWidth = document.body.clientWidth; //window.innerWidth;
      pop.style.right = viewportWidth - left + 9 + 'px';
    } else {
      const adj = 0;
      pop.style.top = top + 54 - 6 + 'px';
      pop.style.left = parseFloat(this.elementRteTool.style.left) + this.elementRteTool.offsetWidth - w + adj + 'px'; //(left -(w/2)+23) + 'px';
      pop.style.right = 'auto';
      if (this.builderStuff.hasAttribute('toolbarfull')) {
        pop.style.left = left - w + btnElementRteMore.offsetWidth + 'px';
      }
    }
  }
  applyInlineFontSize(elm, num) {
    const dom = this.dom;
    let currentFontSize = Number(window.getComputedStyle(elm).getPropertyValue('font-size').match(/\d+/)[0]);
    let fontsize;
    if (num === '+') {
      fontsize = currentFontSize + 1 + 'px';
    } else if (num === '-') {
      fontsize = currentFontSize - 1 + 'px';
    } else if (num === '') {
      fontsize = '';
    } else {
      fontsize = num + 'px';
    }
    /** mod by Jack */
    //elm.style.fontSize = fontsize;
    dom.doFunction(elm, function (theEl) {
      theEl.style.fontSize = fontsize;
    }, true);
  }
  applyClassFontSize(elm, num) {
    let prefix = '';
    let screenMode = this.builder.screenMode;
    if (screenMode === 'desktop') {
      prefix = '';
    } else if (screenMode === 'tablet-landscape') {
      prefix = 'md-';
    } else if (screenMode === 'tablet') {
      prefix = 'sm-';
    } else if (screenMode === 'mobile') {
      prefix = 'xs-';
    }
    const dom = this.dom;
    let currentFontSize = Number(window.getComputedStyle(elm).getPropertyValue('font-size').match(/\d+/)[0]);
    let classname = '';
    if (num === '+' || num === '-' || num === '') classname = num;else classname = prefix + 'size-' + num;
    const arrSizes = this.builder.opts.fontSizeClassValues;

    // Get current class size & remove all class size from the element
    var currentClassSize = '';
    for (var i = 0; i <= arrSizes.length - 1; i++) {
      if (dom.hasClass(elm, prefix + 'size-' + arrSizes[i])) {
        currentClassSize = prefix + 'size-' + arrSizes[i];
        /** mod by Jack */
        //dom.removeClass(elm, 'size-'+arrSizes[i]);
        let n = arrSizes[i];
        dom.doFunction(elm, theEl => {
          dom.removeClass(theEl, prefix + 'size-' + n);
        }, true);
      } else {
        /** mod by Jack */
        let n = arrSizes[i];
        dom.doFunction(elm, theEl => {
          dom.removeClass(theEl, prefix + 'size-' + n);
        }, true);
      }
    }

    // If no class size found AND + or - is clicked, get equivalent class size
    if (currentClassSize === '' && (classname === '+' || classname === '-')) {
      for (i = 0; i <= arrSizes.length - 1; i++) {
        if (currentFontSize >= arrSizes[i] & currentFontSize < arrSizes[i + 1]) {
          currentClassSize = prefix + 'size-' + arrSizes[i];
        }
      }
    }
    if (classname === '+') {
      i = currentClassSize.replace(prefix + 'size-', '') * 1;
      var idx = arrSizes.indexOf(i);
      if (idx < arrSizes.length - 1) {
        currentClassSize = prefix + 'size-' + arrSizes[idx + 1];
      }
      /** mod by Jack */
      //dom.addClass(elm, currentClassSize);
      dom.doFunction(elm, function (theEl) {
        dom.addClass(theEl, currentClassSize);
      }, true);
    } else if (classname === '-') {
      i = currentClassSize.replace(prefix + 'size-', '') * 1;
      idx = arrSizes.indexOf(i);
      if (idx >= 1) {
        currentClassSize = prefix + 'size-' + arrSizes[idx - 1];
      }
      /** mod by Jack */
      //dom.addClass(elm, currentClassSize);
      dom.doFunction(elm, function (theEl) {
        dom.addClass(theEl, currentClassSize);
      }, true);
    } else if (classname === '') ; else {
      /** mod by Jack */
      //dom.addClass(elm, classname);
      dom.doFunction(elm, function (theEl) {
        dom.addClass(theEl, classname);
      }, true);
    }

    /** mod by Jack */
    //elm.style.fontSize = '';
    dom.doFunction(elm, function (theEl) {
      theEl.style.fontSize = '';
    }, true);
    dom.cleanClassSize(elm, classname);
    // dom.cleanUnusedSpan(elm); // will remove empty spans that makes selection changes
  }

  applyClassFontWeight(elm, num) {
    const dom = this.dom;
    let classes = this.builder.cssClasses.fontWeight;
    for (let i = 0; i < Object.keys(classes).length; i++) {
      let className = Object.values(classes)[i];
      if (dom.hasClass(elm, className)) {
        dom.removeClass(elm, className);
      }
      dom.doFunction(elm, theEl => {
        if (dom.hasClass(theEl, className)) {
          dom.removeClass(theEl, className);
        }
      }, true);
    }
    let classname = '';
    if (num === '100') classname = this.builder.cssClasses.fontWeight.thin;
    if (num === '200') classname = this.builder.cssClasses.fontWeight.extralight;
    if (num === '300') classname = this.builder.cssClasses.fontWeight.light;
    if (num === '400') classname = this.builder.cssClasses.fontWeight.normal;
    if (num === '500') classname = this.builder.cssClasses.fontWeight.medium;
    if (num === '600') classname = this.builder.cssClasses.fontWeight.semibold;
    if (num === '700') classname = this.builder.cssClasses.fontWeight.bold;
    if (num === '800') classname = this.builder.cssClasses.fontWeight.extrabold;
    if (num === '900') classname = this.builder.cssClasses.fontWeight.black;
    if (classname === '') ; else {
      dom.addClass(elm, classname);
    }
    dom.doFunction(elm, function (theEl) {
      theEl.style.fontWeight = '';
    }, true);
    dom.cleanClassSize(elm, classname);
    // dom.cleanUnusedSpan(elm); // will remove empty spans that makes selection changes
  }

  hideAlignButtons() {
    let btns = this.elementRteTool.querySelectorAll('button[data-align]');
    let separator1;
    let separator2;
    Array.prototype.forEach.call(btns, btn => {
      btn.style.display = 'none';
      if (btn.previousElementSibling) {
        if (btn.previousElementSibling.classList.contains('rte-separator')) {
          separator1 = btn.previousElementSibling;
        }
      }
      if (btn.nextElementSibling) {
        if (btn.nextElementSibling.classList.contains('rte-separator')) {
          separator2 = btn.nextElementSibling;
        }
      }
    });
    if (separator1 && separator2) {
      separator2.style.display = 'none';
    }
    btns = this.elementRteMoreOptions.querySelectorAll('button[data-align]'); //new
    Array.prototype.forEach.call(btns, btn => {
      btn.style.display = 'none';
    });
  }
  hideBlockButtons() {
    let elms = this.elementRteTool.querySelectorAll('.rte-group');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-ungroup');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-duplicate');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-front');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-backward');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-moveup');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-movedown');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    elms = this.elementRteTool.querySelectorAll('.rte-delete');
    Array.prototype.forEach.call(elms, elm => {
      elm.style.display = 'none';
    });
    // elms = this.elementRteTool.querySelectorAll('.rte-blocksettings'); 
    // Array.prototype.forEach.call(elms, (elm) => {
    //     elm.style.display = 'none';
    // });
  }

  showAlignButtons() {
    let separators = this.elementRteTool.querySelectorAll('.rte-separator');
    Array.prototype.forEach.call(separators, separator => {
      separator.style.display = '';
    });
    let btns = this.elementRteTool.querySelectorAll('button[data-align]');
    Array.prototype.forEach.call(btns, btn => {
      btn.style.display = '';
    });
    btns = this.elementRteMoreOptions.querySelectorAll('button[data-align]'); //new
    Array.prototype.forEach.call(btns, btn => {
      btn.style.display = '';
    });
  }
  showDefaultToolbar() {
    if (this.builder.controlPanel) return;
    this.elementRteTool.style.display = 'flex';
    this.rteTool.style.display = 'none';
    this.hideAlignButtons();
    this.positionToolbar();
  }
  click(col) {
    const dom = this.dom;
    let elm = this.builder.inspectedElement;
    this.rteTool.style.display = 'none';
    this.elementRteTool.style.display = 'none';
    let noedit = false;
    if (col.hasAttribute('data-noedit')) {
      // Column is not (text) editable.
      noedit = true;
    }
    let _protected = false;
    if (col.hasAttribute('data-protected')) {
      // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
      _protected = true;
    }
    let customcode = false;
    let subblock = false;
    if (col.hasAttribute('data-html')) {
      // Column contains custom code.
      customcode = true;
      if (elm.closest('.is-subblock')) {
        // dom.parentsHasAttribute(elm, 'data-subblock')
        subblock = true;
      }
    }
    if (this.builder.canvas) this.hideBlockButtons();

    // default state
    const toolbarText = this.rteTool.querySelector('.rte-for-text');
    const toolbarIcon = this.rteTool.querySelector('.rte-for-icon');
    toolbarText.style.display = 'flex';
    toolbarIcon.style.display = 'none';
    const toolbarMoreText = this.rteMoreOptions.querySelector('.rte-for-text');
    const toolbarMoreIcon = this.rteMoreOptions.querySelector('.rte-for-icon');
    toolbarMoreText.style.display = 'flex';
    toolbarMoreIcon.style.display = 'none';
    const btnIcon = toolbarIcon.querySelector('.rte-icon');
    const btnTextSettings = toolbarIcon.querySelector('.rte-textsettings');
    const btnLink = toolbarIcon.querySelector('.rte-link');
    const btnSymbol = toolbarMoreIcon.querySelector('.insertsymbol-button');
    if (btnIcon) btnIcon.style.display = '';
    if (btnTextSettings) btnTextSettings.style.display = '';
    if (btnLink) btnLink.style.display = '';
    if (btnSymbol) btnSymbol.style.display = '';
    if (!customcode && !noedit && !_protected || subblock) {
      if ((elm.tagName.toLowerCase() === 'img' || dom.hasClass(elm, 'is-social') || dom.hasClass(elm, 'is-rounded-button-medium') || dom.hasClass(elm, 'cell-active')) && !dom.getSelected()) {
        if (this.elementRteTool.style.display === 'none' || this.elementRteTool.style.display === '') {
          this.elementRteTool.style.display = 'flex';
          this.rteTool.style.display = 'none';
          this.showAlignButtons();
          this.positionToolbar();
        }
      } else if (dom.hasClass(elm, 'spacer') || elm.tagName.toLowerCase() === 'video' || dom.hasClass(elm, 'ovl') || col.getAttribute('data-html') && !subblock) {
        //|| col===elm

        if (this.elementRteTool.style.display === 'none' || this.elementRteTool.style.display === '') {
          this.elementRteTool.style.display = 'flex';
          this.rteTool.style.display = 'none';
          this.hideAlignButtons();
          this.positionToolbar();
        }
      } else if (dom.hasClass(elm, 'icon') || dom.hasClass(elm, 'bi')) {
        if (this.rteTool.style.display === 'none' || this.rteTool.style.display === '') {
          this.rteTool.style.display = 'flex';
          this.elementRteTool.style.display = 'none';
          toolbarText.style.display = 'none';
          toolbarIcon.style.display = 'flex';
          toolbarMoreText.style.display = 'none';
          toolbarMoreIcon.style.display = 'flex';
          if (btnSymbol) btnSymbol.style.display = 'none';
          this.positionToolbar();
        }
      } else if (elm.closest('svg')) {
        if (this.rteTool.style.display === 'none' || this.rteTool.style.display === '') {
          this.rteTool.style.display = 'flex';
          this.elementRteTool.style.display = 'none';
          toolbarText.style.display = 'none';
          toolbarIcon.style.display = 'flex';
          toolbarMoreText.style.display = 'none';
          toolbarMoreIcon.style.display = 'flex';
          if (btnIcon) btnIcon.style.display = 'none';
          if (btnTextSettings) btnTextSettings.style.display = 'none';
          if (btnLink) btnLink.style.display = 'none';
          if (btnSymbol) btnSymbol.style.display = 'none';
          this.positionToolbar();
        }
      } else {
        if (dom.textSelection()) {
          if (this.rteTool.style.display === 'none' || this.rteTool.style.display === '') {
            this.rteTool.style.display = 'flex';
            this.elementRteTool.style.display = 'none';
            this.positionToolbar();
          }
        } else {
          if (this.elementRteTool.style.display === 'none' || this.elementRteTool.style.display === '') {
            this.elementRteTool.style.display = 'flex';
            this.rteTool.style.display = 'none';
            this.showAlignButtons();
            this.positionToolbar();
          }
        }
      }
    } else {
      if (this.elementRteTool.style.display === 'none' || this.elementRteTool.style.display === '') {
        this.elementRteTool.style.display = 'flex';
        this.rteTool.style.display = 'none';
        this.hideAlignButtons();
        this.positionToolbar();
      }
    }
    this.util.saveSelection();
    this.getState();
  }
  getState() {
    // old 14140

    const dom = this.dom;
    if (this.builder.doc.queryCommandState('bold')) {
      dom.addClass(this.rteTool.querySelector('button[data-command=bold]'), 'on');
    } else {
      dom.removeClass(this.rteTool.querySelector('button[data-command=bold]'), 'on');
    }
    if (this.builder.doc.queryCommandState('italic')) {
      dom.addClass(this.rteTool.querySelector('button[data-command=italic]'), 'on');
    } else {
      dom.removeClass(this.rteTool.querySelector('button[data-command=italic]'), 'on');
    }
    if (this.builder.doc.queryCommandState('underline')) {
      dom.addClass(this.rteTool.querySelector('button[data-command=underline]'), 'on');
    } else {
      dom.removeClass(this.rteTool.querySelector('button[data-command=underline]'), 'on');
    }
    if (this.builder.doc.queryCommandState('strikethrough')) {
      dom.addClass(this.rteFormattingOptions.querySelector('[data-command=strikethrough]'), 'on');
    } else {
      dom.removeClass(this.rteFormattingOptions.querySelector('[data-command=strikethrough]'), 'on');
    }
    if (this.builder.doc.queryCommandState('superscript')) {
      dom.addClass(this.rteFormattingOptions.querySelector('[data-command=superscript]'), 'on');
    } else {
      dom.removeClass(this.rteFormattingOptions.querySelector('[data-command=superscript]'), 'on');
    }
    if (this.builder.doc.queryCommandState('subscript')) {
      dom.addClass(this.rteFormattingOptions.querySelector('[data-command=subscript]'), 'on');
    } else {
      dom.removeClass(this.rteFormattingOptions.querySelector('[data-command=subscript]'), 'on');
    }
    let elm = dom.textSelection();
    if (elm) {
      if (elm.style.textTransform === 'uppercase') {
        dom.addClass(this.rteFormattingOptions.querySelector('[data-command=uppercase]'), 'on');
      } else {
        dom.removeClass(this.rteFormattingOptions.querySelector('[data-command=uppercase]'), 'on');
      }
    }

    // Alignment
    this.rteAlignOptions.querySelectorAll('[data-align]').forEach(elm => elm.classList.remove('on'));
    if (this.builder.doc.queryCommandState('JustifyFull')) {
      this.rteAlignOptions.querySelector('button[data-align=justify]').classList.add('on');
    }
    if (this.builder.doc.queryCommandState('JustifyLeft')) {
      this.rteAlignOptions.querySelector('button[data-align=left]').classList.add('on');
    }
    if (this.builder.doc.queryCommandState('JustifyRight')) {
      this.rteAlignOptions.querySelector('button[data-align=right]').classList.add('on');
    }
    if (this.builder.doc.queryCommandState('JustifyCenter')) {
      this.rteAlignOptions.querySelector('button[data-align=center]').classList.add('on');
    }
    const blocks = this.builder.dom.getSelectedBlocks();
    if (blocks.length === 0) {
      let activeElement = this.builder.activeElement;
      if (activeElement) {
        this.rteAlignOptions.querySelectorAll('[data-align]').forEach(elm => elm.classList.remove('on'));
        if (activeElement.classList.contains('text-left')) {
          this.rteAlignOptions.querySelector('button[data-align=left]').classList.add('on');
        } else if (activeElement.classList.contains('text-center')) {
          this.rteAlignOptions.querySelector('button[data-align=center]').classList.add('on');
        } else if (activeElement.classList.contains('text-right')) {
          this.rteAlignOptions.querySelector('button[data-align=right]').classList.add('on');
        } else if (activeElement.classList.contains('text-justify')) {
          this.rteAlignOptions.querySelector('button[data-align=justify]').classList.add('on');
        }
        const btnAlignLeft = this.elementRteTool.querySelector('button[data-align=left]');
        const btnAlignCenter = this.elementRteTool.querySelector('button[data-align=center]');
        const btnAlignRight = this.elementRteTool.querySelector('button[data-align=right]');
        const btnAlignJustify = this.elementRteTool.querySelector('button[data-align=justify]');
        this.elementRteTool.querySelectorAll('[data-align]').forEach(elm => elm.classList.remove('on'));
        if (activeElement.classList.contains('text-left')) {
          if (btnAlignLeft) btnAlignLeft.classList.add('on');
        } else if (activeElement.classList.contains('text-center')) {
          if (btnAlignCenter) btnAlignCenter.classList.add('on');
        } else if (activeElement.classList.contains('text-right')) {
          if (btnAlignRight) btnAlignRight.classList.add('on');
        } else if (activeElement.classList.contains('text-justify')) {
          if (btnAlignJustify) btnAlignJustify.classList.add('on');
        }
      }
    }
    let s = this.builder.doc.queryCommandValue('FontName');
    let fontname = s.split(',')[0];
    fontname = fontname.replace(/"/g, '');
    fontname = fontname.replace(/'/g, ''); //NEW 4.0.5
    fontname = fontname.replace(/&quot;/g, ''); //NEW 4.0.5
    fontname = fontname.trim().toLowerCase();
    let btnRteFontFamily = this.rteTool.querySelector('button.rte-fontfamily');
    btnRteFontFamily = btnRteFontFamily ? btnRteFontFamily : this.rteMoreOptions.querySelector('button.rte-fontfamily');
    if (btnRteFontFamily) {
      let divFontList = this.rteFontFamilyOptions.querySelector('.div-font-list');
      let btns = this.rteFontFamilyOptions.querySelectorAll('.div-font-list button');
      btns.forEach(btn => {
        let f = btn.getAttribute('data-font-family');
        f = f.split(',')[0];
        f = f.replace(/'/g, ''); // NEW 4.0.5
        f = f.trim().toLowerCase();
        if (f === fontname && f !== '') {
          btn.classList.add('on');
          let scrollTopPosition = btn.offsetTop - divFontList.offsetTop;
          divFontList.scrollTop = scrollTopPosition;
        } else {
          btn.classList.remove('on');
        }
      });
    }
    let btns = this.rteParagraphOptions.querySelectorAll('[data-block]');
    Array.prototype.forEach.call(btns, btn => {
      dom.removeClass(btn, 'on');
    });
    let block = this.builder.doc.queryCommandValue('FormatBlock');
    block = block.toLowerCase();
    if (block === 'normal') block = 'p';
    if (block === 'heading 1') block = 'h1';
    if (block === 'heading 2') block = 'h2';
    if (block === 'heading 3') block = 'h3';
    if (block === 'heading 4') block = 'h4';
    if (block === 'formatted') block = 'pre';
    if (block === 'p' || block === 'h1' || block === 'h2' || block === 'h3' || block === 'h4' || block === 'div' || block === 'pre') {
      dom.addClass(this.rteParagraphOptions.querySelector('[data-block="' + block + '"]'), 'on');
    }
  }
  getTextSettingsState() {
    let prefix = '';
    let screenMode = this.builder.screenMode;
    if (screenMode === 'desktop') {
      prefix = '';
    } else if (screenMode === 'tablet-landscape') {
      prefix = 'md-';
    } else if (screenMode === 'tablet') {
      prefix = 'sm-';
    } else if (screenMode === 'mobile') {
      prefix = 'xs-';
    }
    const dom = this.dom;
    const pop = this.rteTextSettingOptions;

    // Get realtime status
    const selection = dom.getSelection();
    if (!selection) return;
    const anchorNode = selection.anchorNode;
    let container;
    if (anchorNode) {
      container = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.COMMENT_NODE ? anchorNode : anchorNode.parentElement;
    }
    let btns = pop.querySelectorAll('.rte-fontsize-options button');
    Array.prototype.forEach.call(btns, btn => {
      btn.classList.remove('on'); // clear selection
    });

    if (!container && this.builder.activeIcon) {
      container = this.builder.activeIcon;
    }
    if (container) {
      const arrSizes = this.builder.opts.fontSizeClassValues;
      let found = false;
      // Check if size is defined for specific screenMode
      if (prefix !== '') for (let i = 0; i <= arrSizes.length - 1; i++) {
        if (dom.hasClass(container, prefix + 'size-' + arrSizes[i])) {
          // Get current class

          found = true;
          const btns = pop.querySelectorAll('.rte-fontsize-options button');
          Array.prototype.forEach.call(btns, btn => {
            let num = btn.getAttribute('data-value');
            if (parseInt(num) === arrSizes[i]) {
              btn.classList.add('on');
            }
          });
        }
      }
      if (!found) {
        // Use default (desktop) defined size
        for (let i = 0; i <= arrSizes.length - 1; i++) {
          if (dom.hasClass(container, 'size-' + arrSizes[i])) {
            // Get current class
            const btns = pop.querySelectorAll('.rte-fontsize-options button');
            Array.prototype.forEach.call(btns, btn => {
              let num = btn.getAttribute('data-value');
              if (parseInt(num) === arrSizes[i]) {
                btn.classList.add('on');
              }
            });
          }
        }
      }
    }
    btns = pop.querySelectorAll('.rte-fontweight-options button');
    Array.prototype.forEach.call(btns, btn => {
      btn.classList.remove('on'); // clear selection
    });

    if (container) {
      let classes = this.builder.cssClasses.fontWeight;
      for (let i = 0; i < Object.keys(classes).length; i++) {
        let className = Object.values(classes)[i];
        if (dom.hasClass(container, className)) {
          const btns = pop.querySelectorAll('.rte-fontweight-options button');
          Array.prototype.forEach.call(btns, btn => {
            let num = btn.getAttribute('data-value');
            let val;
            if (className === classes.thin) val = '100';
            if (className === classes.extralight) val = '200';
            if (className === classes.light) val = '300';
            if (className === classes.normal) val = '400';
            if (className === classes.medium) val = '500';
            if (className === classes.semibold) val = '600';
            if (className === classes.bold) val = '700';
            if (className === classes.extrabold) val = '800';
            if (className === classes.black) val = '900';
            if (num === val) {
              btn.classList.add('on');
            }
          });
        }
      }
    }
    btns = pop.querySelectorAll('.rte-lineheight-options button');
    Array.prototype.forEach.call(btns, btn => {
      btn.classList.remove('on'); // clear selection
    });

    const block = dom.getParentBlock(container);
    if (block) {
      let classes = this.builder.cssClasses.leading;
      for (let i = 0; i < Object.keys(classes).length; i++) {
        let className = Object.values(classes)[i];
        if (dom.hasClass(block, className)) {
          const btns = pop.querySelectorAll('.rte-lineheight-options button');
          Array.prototype.forEach.call(btns, btn => {
            let num = btn.getAttribute('data-value');
            let val;
            if (className === classes.leading_8) val = '0.8';
            if (className === classes.leading_9) val = '0.9';
            if (className === classes.leading_10) val = '1';
            if (className === classes.leading_11) val = '1.1';
            if (className === classes.leading_12) val = '1.2';
            if (className === classes.leading_13) val = '1.3';
            if (className === classes.leading_14) val = '1.4';
            if (className === classes.leading_15) val = '1.5';
            if (className === classes.leading_16) val = '1.6';
            if (className === classes.leading_17) val = '1.7';
            if (className === classes.leading_18) val = '1.8';
            if (className === classes.leading_19) val = '1.9';
            if (className === classes.leading_20) val = '2';
            if (className === classes.leading_21) val = '2.1';
            if (className === classes.leading_22) val = '2.2';
            if (num === val) {
              btn.classList.add('on');
            }
          });
        }
      }
    }
    btns = pop.querySelectorAll('.rte-letterspacing-options button');
    Array.prototype.forEach.call(btns, btn => {
      btn.classList.remove('on'); // clear selection
    });

    if (container) {
      let classes = this.builder.cssClasses.tracking;
      for (let i = 0; i < Object.keys(classes).length; i++) {
        let className = Object.values(classes)[i];
        if (dom.hasClass(container, className)) {
          const btns = pop.querySelectorAll('.rte-letterspacing-options button');
          Array.prototype.forEach.call(btns, btn => {
            let num = btn.getAttribute('data-value');
            let val;
            if (className === classes.tracking_025) val = '1';
            if (className === classes.tracking_050) val = '2';
            if (num === val) {
              btn.classList.add('on');
            }
          });
        }
      }
    }
    // /Get realtime status
  }

  getIconsStyle() {
    let css = `
            html, body {height:100%}
            body {overflow:hidden;margin:0;
                font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
                font-size:100%; 
                line-height:1.7;
            }
            button {
                border: none;
                background: transparent;
                border-radius: 1px;
            }
            #divIcons {display:flex;align-content:flex-start;flex-direction:row;flex-wrap:wrap;margin:0;padding:9px 11px 9px 9px;height:100%;overflow-y:scroll !important;box-sizing:border-box;}
            #divIcons > button {
                width:38px;height:36px;font-size:14px;cursor:pointer;overflow:hidden;
                text-align:center;position:relative;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 1px;
            }                
            // #divIcons > button:hover {background:#f5f5f5;}

            #divIcons {
                background: ${this.builder.styleToolBackground};
            }
            #divIcons > button {
                color: ${this.builder.styleButtonColor};
            }
            #divIcons > button * {
                pointer-events: none;
            }
            #divIcons > button svg {
                fill: ${this.builder.styleButtonSvgFill};
            }

            #divIcons > button:hover {
                background: ${this.builder.styleButtonBackgroundHover};
            }
            #divIcons > button:focus {
                // outline: ${this.builder.styleOutlineColor} 2px solid;
                outline: none;
                background: ${this.builder.styleButtonBackgroundHover};
            }

            input[type=text] {
                width: 100%;
                height: 35px;
                box-sizing: border-box;
                margin: 0;
                font-family: sans-serif;
                font-size: 15px;
                letter-spacing: 1px;
                padding: 0;
                padding-left: 10px;
                color: ${this.builder.styleRteInputColor};
                display: inline-block;
                border: none;
                border-bottom: none;
                border-radius: 1px;
                background-color: ${this.builder.styleInputBackground};
            }
            input[type=text]:focus {
                outline: #3e93f7 2px solid;
                outline-offset: -2px;
            }
            ::placeholder {
                color: ${this.builder.styleRteInputColor};
            }

            .dark #divIcons > button {
                opacity: 0.93;
            }

            /* Scrollbar for toolbar/RTE, not modal */

            .dark * {
                scrollbar-width: thin;
                scrollbar-color: rgba(255, 255, 255, 0.3) auto;
            }
            .dark *::-webkit-scrollbar {
                width: 12px;
            }
            .dark *::-webkit-scrollbar-track {
                background: transparent;
            }
            .dark *::-webkit-scrollbar-thumb {
                background-color:rgba(255, 255, 255, 0.3);
            } 

            .colored-dark * {
                scrollbar-width: thin;
                scrollbar-color: rgb(100, 100, 100) auto;
            }
            .colored-dark *::-webkit-scrollbar {
                width: 12px;
            }
            .colored-dark *::-webkit-scrollbar-track {
                background: transparent;
            }
            .colored-dark *::-webkit-scrollbar-thumb {
                background-color:rgb(100, 100, 100);
            } 

            .colored * {
                scrollbar-width: thin;
                scrollbar-color: rgba(0, 0, 0, 0.4) auto;
            }
            .colored *::-webkit-scrollbar {
                width: 12px;
            }
            .colored *::-webkit-scrollbar-track {
                background: transparent;
            }
            .colored *::-webkit-scrollbar-thumb {
                background-color: rgba(0, 0, 0, 0.4);
            } 

            .light * {
                scrollbar-width: thin;
                scrollbar-color: rgba(0, 0, 0, 0.4) auto;
            }
            .light *::-webkit-scrollbar {
                width: 12px;
            }
            .light *::-webkit-scrollbar-track {
                background: transparent;
            }
            .light *::-webkit-scrollbar-thumb {
                background-color: rgba(0, 0, 0, 0.4);
            }`;
    return css;
  }
  getIcons2() {
    let html = `
<button><i class="bi bi-123"></i></button>
<button><i class="bi bi-alarm-fill"></i></button>
<button><i class="bi bi-alarm"></i></button>
<button><i class="bi bi-align-bottom"></i></button>
<button><i class="bi bi-align-center"></i></button>
<button><i class="bi bi-align-end"></i></button>
<button><i class="bi bi-align-middle"></i></button>
<button><i class="bi bi-align-start"></i></button>
<button><i class="bi bi-align-top"></i></button>
<button><i class="bi bi-alt"></i></button>
<button><i class="bi bi-app-indicator"></i></button>
<button><i class="bi bi-app"></i></button>
<button><i class="bi bi-archive-fill"></i></button>
<button><i class="bi bi-archive"></i></button>
<button><i class="bi bi-arrow-90deg-down"></i></button>
<button><i class="bi bi-arrow-90deg-left"></i></button>
<button><i class="bi bi-arrow-90deg-right"></i></button>
<button><i class="bi bi-arrow-90deg-up"></i></button>
<button><i class="bi bi-arrow-bar-down"></i></button>
<button><i class="bi bi-arrow-bar-left"></i></button>
<button><i class="bi bi-arrow-bar-right"></i></button>
<button><i class="bi bi-arrow-bar-up"></i></button>
<button><i class="bi bi-arrow-clockwise"></i></button>
<button><i class="bi bi-arrow-counterclockwise"></i></button>
<button><i class="bi bi-arrow-down-circle-fill"></i></button>
<button><i class="bi bi-arrow-down-circle"></i></button>
<button><i class="bi bi-arrow-down-left-circle-fill"></i></button>
<button><i class="bi bi-arrow-down-left-circle"></i></button>
<button><i class="bi bi-arrow-down-left-square-fill"></i></button>
<button><i class="bi bi-arrow-down-left-square"></i></button>
<button><i class="bi bi-arrow-down-left"></i></button>
<button><i class="bi bi-arrow-down-right-circle-fill"></i></button>
<button><i class="bi bi-arrow-down-right-circle"></i></button>
<button><i class="bi bi-arrow-down-right-square-fill"></i></button>
<button><i class="bi bi-arrow-down-right-square"></i></button>
<button><i class="bi bi-arrow-down-right"></i></button>`;
    html += `
<button><i class="bi bi-arrow-down-short"></i></button>
<button><i class="bi bi-arrow-down-square-fill"></i></button>
<button><i class="bi bi-arrow-down-square"></i></button>
<button><i class="bi bi-arrow-down-up"></i></button>
<button><i class="bi bi-arrow-down"></i></button>
<button><i class="bi bi-arrow-left-circle-fill"></i></button>
<button><i class="bi bi-arrow-left-circle"></i></button>
<button><i class="bi bi-arrow-left-right"></i></button>
<button><i class="bi bi-arrow-left-short"></i></button>
<button><i class="bi bi-arrow-left-square-fill"></i></button>
<button><i class="bi bi-arrow-left-square"></i></button>
<button><i class="bi bi-arrow-left"></i></button>
<button><i class="bi bi-arrow-repeat"></i></button>
<button><i class="bi bi-arrow-return-left"></i></button>
<button><i class="bi bi-arrow-return-right"></i></button>
<button><i class="bi bi-arrow-right-circle-fill"></i></button>
<button><i class="bi bi-arrow-right-circle"></i></button>
<button><i class="bi bi-arrow-right-short"></i></button>
<button><i class="bi bi-arrow-right-square-fill"></i></button>
<button><i class="bi bi-arrow-right-square"></i></button>
<button><i class="bi bi-arrow-right"></i></button>
<button><i class="bi bi-arrow-up-circle-fill"></i></button>
<button><i class="bi bi-arrow-up-circle"></i></button>
<button><i class="bi bi-arrow-up-left-circle-fill"></i></button>
<button><i class="bi bi-arrow-up-left-circle"></i></button>
<button><i class="bi bi-arrow-up-left-square-fill"></i></button>
<button><i class="bi bi-arrow-up-left-square"></i></button>
<button><i class="bi bi-arrow-up-left"></i></button>
<button><i class="bi bi-arrow-up-right-circle-fill"></i></button>
<button><i class="bi bi-arrow-up-right-circle"></i></button>
<button><i class="bi bi-arrow-up-right-square-fill"></i></button>
<button><i class="bi bi-arrow-up-right-square"></i></button>
<button><i class="bi bi-arrow-up-right"></i></button>
<button><i class="bi bi-arrow-up-short"></i></button>
<button><i class="bi bi-arrow-up-square-fill"></i></button>
<button><i class="bi bi-arrow-up-square"></i></button>
<button><i class="bi bi-arrow-up"></i></button>
<button><i class="bi bi-arrows-angle-contract"></i></button>
<button><i class="bi bi-arrows-angle-expand"></i></button>
<button><i class="bi bi-arrows-collapse"></i></button>
<button><i class="bi bi-arrows-expand"></i></button>
<button><i class="bi bi-arrows-fullscreen"></i></button>
<button><i class="bi bi-arrows-move"></i></button>
<button><i class="bi bi-aspect-ratio-fill"></i></button>
<button><i class="bi bi-aspect-ratio"></i></button>
<button><i class="bi bi-asterisk"></i></button>
<button><i class="bi bi-at"></i></button>
<button><i class="bi bi-award-fill"></i></button>
<button><i class="bi bi-award"></i></button>
<button><i class="bi bi-back"></i></button>
<button><i class="bi bi-backspace-fill"></i></button>
<button><i class="bi bi-backspace-reverse-fill"></i></button>
<button><i class="bi bi-backspace-reverse"></i></button>
<button><i class="bi bi-backspace"></i></button>
<button><i class="bi bi-badge-3d-fill"></i></button>
<button><i class="bi bi-badge-3d"></i></button>
<button><i class="bi bi-badge-4k-fill"></i></button>
<button><i class="bi bi-badge-4k"></i></button>
<button><i class="bi bi-badge-8k-fill"></i></button>
<button><i class="bi bi-badge-8k"></i></button>
<button><i class="bi bi-badge-ad-fill"></i></button>
<button><i class="bi bi-badge-ad"></i></button>
<button><i class="bi bi-badge-ar-fill"></i></button>
<button><i class="bi bi-badge-ar"></i></button>
<button><i class="bi bi-badge-cc-fill"></i></button>
<button><i class="bi bi-badge-cc"></i></button>
<button><i class="bi bi-badge-hd-fill"></i></button>
<button><i class="bi bi-badge-hd"></i></button>
<button><i class="bi bi-badge-tm-fill"></i></button>
<button><i class="bi bi-badge-tm"></i></button>
<button><i class="bi bi-badge-vo-fill"></i></button>
<button><i class="bi bi-badge-vo"></i></button>
<button><i class="bi bi-badge-vr-fill"></i></button>
<button><i class="bi bi-badge-vr"></i></button>
<button><i class="bi bi-badge-wc-fill"></i></button>
<button><i class="bi bi-badge-wc"></i></button>
<button><i class="bi bi-bag-check-fill"></i></button>
<button><i class="bi bi-bag-check"></i></button>
<button><i class="bi bi-bag-dash-fill"></i></button>
<button><i class="bi bi-bag-dash"></i></button>
<button><i class="bi bi-bag-fill"></i></button>
<button><i class="bi bi-bag-plus-fill"></i></button>
<button><i class="bi bi-bag-plus"></i></button>
<button><i class="bi bi-bag-x-fill"></i></button>
<button><i class="bi bi-bag-x"></i></button>
<button><i class="bi bi-bag"></i></button>
<button><i class="bi bi-bar-chart-fill"></i></button>
<button><i class="bi bi-bar-chart-line-fill"></i></button>
<button><i class="bi bi-bar-chart-line"></i></button>
<button><i class="bi bi-bar-chart-steps"></i></button>
<button><i class="bi bi-bar-chart"></i></button>
<button><i class="bi bi-basket-fill"></i></button>
<button><i class="bi bi-basket"></i></button>
<button><i class="bi bi-basket2-fill"></i></button>
<button><i class="bi bi-basket2"></i></button>
<button><i class="bi bi-basket3-fill"></i></button>
<button><i class="bi bi-basket3"></i></button>
<button><i class="bi bi-battery-charging"></i></button>
<button><i class="bi bi-battery-full"></i></button>`;
    html += `
<button><i class="bi bi-battery-half"></i></button>
<button><i class="bi bi-battery"></i></button>
<button><i class="bi bi-bell-fill"></i></button>
<button><i class="bi bi-bell"></i></button>
<button><i class="bi bi-bezier"></i></button>
<button><i class="bi bi-bezier2"></i></button>
<button><i class="bi bi-bicycle"></i></button>
<button><i class="bi bi-binoculars-fill"></i></button>
<button><i class="bi bi-binoculars"></i></button>
<button><i class="bi bi-blockquote-left"></i></button>
<button><i class="bi bi-blockquote-right"></i></button>
<button><i class="bi bi-book-fill"></i></button>
<button><i class="bi bi-book-half"></i></button>
<button><i class="bi bi-book"></i></button>
<button><i class="bi bi-bookmark-check-fill"></i></button>
<button><i class="bi bi-bookmark-check"></i></button>
<button><i class="bi bi-bookmark-dash-fill"></i></button>
<button><i class="bi bi-bookmark-dash"></i></button>
<button><i class="bi bi-bookmark-fill"></i></button>
<button><i class="bi bi-bookmark-heart-fill"></i></button>
<button><i class="bi bi-bookmark-heart"></i></button>
<button><i class="bi bi-bookmark-plus-fill"></i></button>
<button><i class="bi bi-bookmark-plus"></i></button>
<button><i class="bi bi-bookmark-star-fill"></i></button>
<button><i class="bi bi-bookmark-star"></i></button>
<button><i class="bi bi-bookmark-x-fill"></i></button>
<button><i class="bi bi-bookmark-x"></i></button>
<button><i class="bi bi-bookmark"></i></button>
<button><i class="bi bi-bookmarks-fill"></i></button>
<button><i class="bi bi-bookmarks"></i></button>
<button><i class="bi bi-bookshelf"></i></button>
<button><i class="bi bi-bootstrap-fill"></i></button>
<button><i class="bi bi-bootstrap-reboot"></i></button>
<button><i class="bi bi-bootstrap"></i></button>
<button><i class="bi bi-border-all"></i></button>
<button><i class="bi bi-border-bottom"></i></button>
<button><i class="bi bi-border-center"></i></button>
<button><i class="bi bi-border-inner"></i></button>
<button><i class="bi bi-border-left"></i></button>
<button><i class="bi bi-border-middle"></i></button>
<button><i class="bi bi-border-outer"></i></button>
<button><i class="bi bi-border-right"></i></button>
<button><i class="bi bi-border-style"></i></button>
<button><i class="bi bi-border-top"></i></button>
<button><i class="bi bi-border-width"></i></button>
<button><i class="bi bi-border"></i></button>
<button><i class="bi bi-bounding-box-circles"></i></button>
<button><i class="bi bi-bounding-box"></i></button>
<button><i class="bi bi-box-arrow-down-left"></i></button>
<button><i class="bi bi-box-arrow-down-right"></i></button>
<button><i class="bi bi-box-arrow-down"></i></button>
<button><i class="bi bi-box-arrow-in-down-left"></i></button>
<button><i class="bi bi-box-arrow-in-down-right"></i></button>
<button><i class="bi bi-box-arrow-in-down"></i></button>
<button><i class="bi bi-box-arrow-in-left"></i></button>
<button><i class="bi bi-box-arrow-in-right"></i></button>
<button><i class="bi bi-box-arrow-in-up-left"></i></button>
<button><i class="bi bi-box-arrow-in-up-right"></i></button>
<button><i class="bi bi-box-arrow-in-up"></i></button>
<button><i class="bi bi-box-arrow-left"></i></button>
<button><i class="bi bi-box-arrow-right"></i></button>
<button><i class="bi bi-box-arrow-up-left"></i></button>
<button><i class="bi bi-box-arrow-up-right"></i></button>
<button><i class="bi bi-box-arrow-up"></i></button>
<button><i class="bi bi-box-seam"></i></button>
<button><i class="bi bi-box"></i></button>
<button><i class="bi bi-braces"></i></button>
<button><i class="bi bi-bricks"></i></button>
<button><i class="bi bi-briefcase-fill"></i></button>
<button><i class="bi bi-briefcase"></i></button>
<button><i class="bi bi-brightness-alt-high-fill"></i></button>
<button><i class="bi bi-brightness-alt-high"></i></button>
<button><i class="bi bi-brightness-alt-low-fill"></i></button>
<button><i class="bi bi-brightness-alt-low"></i></button>
<button><i class="bi bi-brightness-high-fill"></i></button>
<button><i class="bi bi-brightness-high"></i></button>
<button><i class="bi bi-brightness-low-fill"></i></button>
<button><i class="bi bi-brightness-low"></i></button>
<button><i class="bi bi-broadcast-pin"></i></button>
<button><i class="bi bi-broadcast"></i></button>
<button><i class="bi bi-brush-fill"></i></button>
<button><i class="bi bi-brush"></i></button>
<button><i class="bi bi-bucket-fill"></i></button>
<button><i class="bi bi-bucket"></i></button>
<button><i class="bi bi-bug-fill"></i></button>
<button><i class="bi bi-bug"></i></button>
<button><i class="bi bi-building"></i></button>
<button><i class="bi bi-bullseye"></i></button>
<button><i class="bi bi-calculator-fill"></i></button>
<button><i class="bi bi-calculator"></i></button>
<button><i class="bi bi-calendar-check-fill"></i></button>
<button><i class="bi bi-calendar-check"></i></button>
<button><i class="bi bi-calendar-date-fill"></i></button>
<button><i class="bi bi-calendar-date"></i></button>
<button><i class="bi bi-calendar-day-fill"></i></button>
<button><i class="bi bi-calendar-day"></i></button>
<button><i class="bi bi-calendar-event-fill"></i></button>
<button><i class="bi bi-calendar-event"></i></button>
<button><i class="bi bi-calendar-fill"></i></button>`;
    html += `
<button><i class="bi bi-calendar-minus-fill"></i></button>
<button><i class="bi bi-calendar-minus"></i></button>
<button><i class="bi bi-calendar-month-fill"></i></button>
<button><i class="bi bi-calendar-month"></i></button>
<button><i class="bi bi-calendar-plus-fill"></i></button>
<button><i class="bi bi-calendar-plus"></i></button>
<button><i class="bi bi-calendar-range-fill"></i></button>
<button><i class="bi bi-calendar-range"></i></button>
<button><i class="bi bi-calendar-week-fill"></i></button>
<button><i class="bi bi-calendar-week"></i></button>
<button><i class="bi bi-calendar-x-fill"></i></button>
<button><i class="bi bi-calendar-x"></i></button>
<button><i class="bi bi-calendar"></i></button>
<button><i class="bi bi-calendar2-check-fill"></i></button>
<button><i class="bi bi-calendar2-check"></i></button>
<button><i class="bi bi-calendar2-date-fill"></i></button>
<button><i class="bi bi-calendar2-date"></i></button>
<button><i class="bi bi-calendar2-day-fill"></i></button>
<button><i class="bi bi-calendar2-day"></i></button>
<button><i class="bi bi-calendar2-event-fill"></i></button>
<button><i class="bi bi-calendar2-event"></i></button>
<button><i class="bi bi-calendar2-fill"></i></button>
<button><i class="bi bi-calendar2-minus-fill"></i></button>
<button><i class="bi bi-calendar2-minus"></i></button>
<button><i class="bi bi-calendar2-month-fill"></i></button>
<button><i class="bi bi-calendar2-month"></i></button>
<button><i class="bi bi-calendar2-plus-fill"></i></button>
<button><i class="bi bi-calendar2-plus"></i></button>
<button><i class="bi bi-calendar2-range-fill"></i></button>
<button><i class="bi bi-calendar2-range"></i></button>
<button><i class="bi bi-calendar2-week-fill"></i></button>
<button><i class="bi bi-calendar2-week"></i></button>
<button><i class="bi bi-calendar2-x-fill"></i></button>
<button><i class="bi bi-calendar2-x"></i></button>
<button><i class="bi bi-calendar2"></i></button>
<button><i class="bi bi-calendar3-event-fill"></i></button>
<button><i class="bi bi-calendar3-event"></i></button>
<button><i class="bi bi-calendar3-fill"></i></button>
<button><i class="bi bi-calendar3-range-fill"></i></button>
<button><i class="bi bi-calendar3-range"></i></button>
<button><i class="bi bi-calendar3-week-fill"></i></button>
<button><i class="bi bi-calendar3-week"></i></button>
<button><i class="bi bi-calendar3"></i></button>
<button><i class="bi bi-calendar4-event"></i></button>
<button><i class="bi bi-calendar4-range"></i></button>
<button><i class="bi bi-calendar4-week"></i></button>
<button><i class="bi bi-calendar4"></i></button>
<button><i class="bi bi-camera-fill"></i></button>
<button><i class="bi bi-camera-reels-fill"></i></button>
<button><i class="bi bi-camera-reels"></i></button>
<button><i class="bi bi-camera-video-fill"></i></button>
<button><i class="bi bi-camera-video-off-fill"></i></button>
<button><i class="bi bi-camera-video-off"></i></button>
<button><i class="bi bi-camera-video"></i></button>
<button><i class="bi bi-camera"></i></button>
<button><i class="bi bi-camera2"></i></button>
<button><i class="bi bi-capslock-fill"></i></button>
<button><i class="bi bi-capslock"></i></button>
<button><i class="bi bi-card-checklist"></i></button>
<button><i class="bi bi-card-heading"></i></button>
<button><i class="bi bi-card-image"></i></button>
<button><i class="bi bi-card-list"></i></button>
<button><i class="bi bi-card-text"></i></button>
<button><i class="bi bi-caret-down-fill"></i></button>
<button><i class="bi bi-caret-down-square-fill"></i></button>
<button><i class="bi bi-caret-down-square"></i></button>
<button><i class="bi bi-caret-down"></i></button>
<button><i class="bi bi-caret-left-fill"></i></button>
<button><i class="bi bi-caret-left-square-fill"></i></button>
<button><i class="bi bi-caret-left-square"></i></button>
<button><i class="bi bi-caret-left"></i></button>
<button><i class="bi bi-caret-right-fill"></i></button>
<button><i class="bi bi-caret-right-square-fill"></i></button>
<button><i class="bi bi-caret-right-square"></i></button>
<button><i class="bi bi-caret-right"></i></button>
<button><i class="bi bi-caret-up-fill"></i></button>
<button><i class="bi bi-caret-up-square-fill"></i></button>
<button><i class="bi bi-caret-up-square"></i></button>
<button><i class="bi bi-caret-up"></i></button>
<button><i class="bi bi-cart-check-fill"></i></button>
<button><i class="bi bi-cart-check"></i></button>
<button><i class="bi bi-cart-dash-fill"></i></button>
<button><i class="bi bi-cart-dash"></i></button>
<button><i class="bi bi-cart-fill"></i></button>
<button><i class="bi bi-cart-plus-fill"></i></button>
<button><i class="bi bi-cart-plus"></i></button>
<button><i class="bi bi-cart-x-fill"></i></button>
<button><i class="bi bi-cart-x"></i></button>
<button><i class="bi bi-cart"></i></button>
<button><i class="bi bi-cart2"></i></button>
<button><i class="bi bi-cart3"></i></button>
<button><i class="bi bi-cart4"></i></button>
<button><i class="bi bi-cash-stack"></i></button>
<button><i class="bi bi-cash"></i></button>
<button><i class="bi bi-cast"></i></button>
<button><i class="bi bi-chat-dots-fill"></i></button>
<button><i class="bi bi-chat-dots"></i></button>
<button><i class="bi bi-chat-fill"></i></button>
<button><i class="bi bi-chat-left-dots-fill"></i></button>`;
    html += `
<button><i class="bi bi-chat-left-dots"></i></button>
<button><i class="bi bi-chat-left-fill"></i></button>
<button><i class="bi bi-chat-left-quote-fill"></i></button>
<button><i class="bi bi-chat-left-quote"></i></button>
<button><i class="bi bi-chat-left-text-fill"></i></button>
<button><i class="bi bi-chat-left-text"></i></button>
<button><i class="bi bi-chat-left"></i></button>
<button><i class="bi bi-chat-quote-fill"></i></button>
<button><i class="bi bi-chat-quote"></i></button>
<button><i class="bi bi-chat-right-dots-fill"></i></button>
<button><i class="bi bi-chat-right-dots"></i></button>
<button><i class="bi bi-chat-right-fill"></i></button>
<button><i class="bi bi-chat-right-quote-fill"></i></button>
<button><i class="bi bi-chat-right-quote"></i></button>
<button><i class="bi bi-chat-right-text-fill"></i></button>
<button><i class="bi bi-chat-right-text"></i></button>
<button><i class="bi bi-chat-right"></i></button>
<button><i class="bi bi-chat-square-dots-fill"></i></button>
<button><i class="bi bi-chat-square-dots"></i></button>
<button><i class="bi bi-chat-square-fill"></i></button>
<button><i class="bi bi-chat-square-quote-fill"></i></button>
<button><i class="bi bi-chat-square-quote"></i></button>
<button><i class="bi bi-chat-square-text-fill"></i></button>
<button><i class="bi bi-chat-square-text"></i></button>
<button><i class="bi bi-chat-square"></i></button>
<button><i class="bi bi-chat-text-fill"></i></button>
<button><i class="bi bi-chat-text"></i></button>
<button><i class="bi bi-chat"></i></button>
<button><i class="bi bi-check-all"></i></button>
<button><i class="bi bi-check-circle-fill"></i></button>
<button><i class="bi bi-check-circle"></i></button>
<button><i class="bi bi-check-square-fill"></i></button>
<button><i class="bi bi-check-square"></i></button>
<button><i class="bi bi-check"></i></button>
<button><i class="bi bi-check2-all"></i></button>
<button><i class="bi bi-check2-circle"></i></button>
<button><i class="bi bi-check2-square"></i></button>
<button><i class="bi bi-check2"></i></button>
<button><i class="bi bi-chevron-bar-contract"></i></button>
<button><i class="bi bi-chevron-bar-down"></i></button>
<button><i class="bi bi-chevron-bar-expand"></i></button>
<button><i class="bi bi-chevron-bar-left"></i></button>
<button><i class="bi bi-chevron-bar-right"></i></button>
<button><i class="bi bi-chevron-bar-up"></i></button>
<button><i class="bi bi-chevron-compact-down"></i></button>
<button><i class="bi bi-chevron-compact-left"></i></button>
<button><i class="bi bi-chevron-compact-right"></i></button>
<button><i class="bi bi-chevron-compact-up"></i></button>
<button><i class="bi bi-chevron-contract"></i></button>
<button><i class="bi bi-chevron-double-down"></i></button>
<button><i class="bi bi-chevron-double-left"></i></button>
<button><i class="bi bi-chevron-double-right"></i></button>
<button><i class="bi bi-chevron-double-up"></i></button>
<button><i class="bi bi-chevron-down"></i></button>
<button><i class="bi bi-chevron-expand"></i></button>
<button><i class="bi bi-chevron-left"></i></button>
<button><i class="bi bi-chevron-right"></i></button>
<button><i class="bi bi-chevron-up"></i></button>
<button><i class="bi bi-circle-fill"></i></button>
<button><i class="bi bi-circle-half"></i></button>
<button><i class="bi bi-circle-square"></i></button>
<button><i class="bi bi-circle"></i></button>
<button><i class="bi bi-clipboard-check"></i></button>
<button><i class="bi bi-clipboard-data"></i></button>
<button><i class="bi bi-clipboard-minus"></i></button>
<button><i class="bi bi-clipboard-plus"></i></button>
<button><i class="bi bi-clipboard-x"></i></button>
<button><i class="bi bi-clipboard"></i></button>
<button><i class="bi bi-clock-fill"></i></button>
<button><i class="bi bi-clock-history"></i></button>
<button><i class="bi bi-clock"></i></button>
<button><i class="bi bi-cloud-arrow-down-fill"></i></button>
<button><i class="bi bi-cloud-arrow-down"></i></button>
<button><i class="bi bi-cloud-arrow-up-fill"></i></button>
<button><i class="bi bi-cloud-arrow-up"></i></button>
<button><i class="bi bi-cloud-check-fill"></i></button>
<button><i class="bi bi-cloud-check"></i></button>
<button><i class="bi bi-cloud-download-fill"></i></button>
<button><i class="bi bi-cloud-download"></i></button>
<button><i class="bi bi-cloud-drizzle-fill"></i></button>
<button><i class="bi bi-cloud-drizzle"></i></button>
<button><i class="bi bi-cloud-fill"></i></button>
<button><i class="bi bi-cloud-fog-fill"></i></button>
<button><i class="bi bi-cloud-fog"></i></button>
<button><i class="bi bi-cloud-fog2-fill"></i></button>
<button><i class="bi bi-cloud-fog2"></i></button>
<button><i class="bi bi-cloud-hail-fill"></i></button>
<button><i class="bi bi-cloud-hail"></i></button>
<button><i class="bi bi-cloud-haze-fill"></i></button>
<button><i class="bi bi-cloud-haze"></i></button>
<button><i class="bi bi-cloud-haze2-fill"></i></button>
<button><i class="bi bi-cloud-lightning-fill"></i></button>
<button><i class="bi bi-cloud-lightning-rain-fill"></i></button>
<button><i class="bi bi-cloud-lightning-rain"></i></button>
<button><i class="bi bi-cloud-lightning"></i></button>
<button><i class="bi bi-cloud-minus-fill"></i></button>
<button><i class="bi bi-cloud-minus"></i></button>
<button><i class="bi bi-cloud-moon-fill"></i></button>
<button><i class="bi bi-cloud-moon"></i></button>`;
    html += `
<button><i class="bi bi-cloud-plus-fill"></i></button>
<button><i class="bi bi-cloud-plus"></i></button>
<button><i class="bi bi-cloud-rain-fill"></i></button>
<button><i class="bi bi-cloud-rain-heavy-fill"></i></button>
<button><i class="bi bi-cloud-rain-heavy"></i></button>
<button><i class="bi bi-cloud-rain"></i></button>
<button><i class="bi bi-cloud-slash-fill"></i></button>
<button><i class="bi bi-cloud-slash"></i></button>
<button><i class="bi bi-cloud-sleet-fill"></i></button>
<button><i class="bi bi-cloud-sleet"></i></button>
<button><i class="bi bi-cloud-snow-fill"></i></button>
<button><i class="bi bi-cloud-snow"></i></button>
<button><i class="bi bi-cloud-sun-fill"></i></button>
<button><i class="bi bi-cloud-sun"></i></button>
<button><i class="bi bi-cloud-upload-fill"></i></button>
<button><i class="bi bi-cloud-upload"></i></button>
<button><i class="bi bi-cloud"></i></button>
<button><i class="bi bi-clouds-fill"></i></button>
<button><i class="bi bi-clouds"></i></button>
<button><i class="bi bi-cloudy-fill"></i></button>
<button><i class="bi bi-cloudy"></i></button>
<button><i class="bi bi-code-slash"></i></button>
<button><i class="bi bi-code-square"></i></button>
<button><i class="bi bi-code"></i></button>
<button><i class="bi bi-collection-fill"></i></button>
<button><i class="bi bi-collection-play-fill"></i></button>
<button><i class="bi bi-collection-play"></i></button>
<button><i class="bi bi-collection"></i></button>
<button><i class="bi bi-columns-gap"></i></button>
<button><i class="bi bi-columns"></i></button>
<button><i class="bi bi-command"></i></button>
<button><i class="bi bi-compass-fill"></i></button>
<button><i class="bi bi-compass"></i></button>
<button><i class="bi bi-cone-striped"></i></button>
<button><i class="bi bi-cone"></i></button>
<button><i class="bi bi-controller"></i></button>
<button><i class="bi bi-cpu-fill"></i></button>
<button><i class="bi bi-cpu"></i></button>
<button><i class="bi bi-credit-card-2-back-fill"></i></button>
<button><i class="bi bi-credit-card-2-back"></i></button>
<button><i class="bi bi-credit-card-2-front-fill"></i></button>
<button><i class="bi bi-credit-card-2-front"></i></button>
<button><i class="bi bi-credit-card-fill"></i></button>
<button><i class="bi bi-credit-card"></i></button>
<button><i class="bi bi-crop"></i></button>
<button><i class="bi bi-cup-fill"></i></button>
<button><i class="bi bi-cup-straw"></i></button>
<button><i class="bi bi-cup"></i></button>
<button><i class="bi bi-cursor-fill"></i></button>
<button><i class="bi bi-cursor-text"></i></button>
<button><i class="bi bi-cursor"></i></button>
<button><i class="bi bi-dash-circle-dotted"></i></button>
<button><i class="bi bi-dash-circle-fill"></i></button>
<button><i class="bi bi-dash-circle"></i></button>
<button><i class="bi bi-dash-square-dotted"></i></button>
<button><i class="bi bi-dash-square-fill"></i></button>
<button><i class="bi bi-dash-square"></i></button>
<button><i class="bi bi-dash"></i></button>
<button><i class="bi bi-diagram-2-fill"></i></button>
<button><i class="bi bi-diagram-2"></i></button>
<button><i class="bi bi-diagram-3-fill"></i></button>
<button><i class="bi bi-diagram-3"></i></button>
<button><i class="bi bi-diamond-fill"></i></button>
<button><i class="bi bi-diamond-half"></i></button>
<button><i class="bi bi-diamond"></i></button>
<button><i class="bi bi-dice-1-fill"></i></button>
<button><i class="bi bi-dice-1"></i></button>
<button><i class="bi bi-dice-2-fill"></i></button>
<button><i class="bi bi-dice-2"></i></button>
<button><i class="bi bi-dice-3-fill"></i></button>
<button><i class="bi bi-dice-3"></i></button>
<button><i class="bi bi-dice-4-fill"></i></button>
<button><i class="bi bi-dice-4"></i></button>
<button><i class="bi bi-dice-5-fill"></i></button>
<button><i class="bi bi-dice-5"></i></button>
<button><i class="bi bi-dice-6-fill"></i></button>
<button><i class="bi bi-dice-6"></i></button>
<button><i class="bi bi-disc-fill"></i></button>
<button><i class="bi bi-disc"></i></button>
<button><i class="bi bi-discord"></i></button>
<button><i class="bi bi-display-fill"></i></button>
<button><i class="bi bi-display"></i></button>
<button><i class="bi bi-distribute-horizontal"></i></button>
<button><i class="bi bi-distribute-vertical"></i></button>
<button><i class="bi bi-door-closed-fill"></i></button>
<button><i class="bi bi-door-closed"></i></button>
<button><i class="bi bi-door-open-fill"></i></button>
<button><i class="bi bi-door-open"></i></button>
<button><i class="bi bi-dot"></i></button>
<button><i class="bi bi-download"></i></button>
<button><i class="bi bi-droplet-fill"></i></button>
<button><i class="bi bi-droplet-half"></i></button>
<button><i class="bi bi-droplet"></i></button>
<button><i class="bi bi-earbuds"></i></button>
<button><i class="bi bi-easel-fill"></i></button>
<button><i class="bi bi-easel"></i></button>
<button><i class="bi bi-egg-fill"></i></button>
<button><i class="bi bi-egg-fried"></i></button>
<button><i class="bi bi-egg"></i></button>`;
    html += `
<button><i class="bi bi-eject-fill"></i></button>
<button><i class="bi bi-eject"></i></button>
<button><i class="bi bi-emoji-angry-fill"></i></button>
<button><i class="bi bi-emoji-angry"></i></button>
<button><i class="bi bi-emoji-dizzy-fill"></i></button>
<button><i class="bi bi-emoji-dizzy"></i></button>
<button><i class="bi bi-emoji-expressionless-fill"></i></button>
<button><i class="bi bi-emoji-expressionless"></i></button>
<button><i class="bi bi-emoji-frown-fill"></i></button>
<button><i class="bi bi-emoji-frown"></i></button>
<button><i class="bi bi-emoji-heart-eyes-fill"></i></button>
<button><i class="bi bi-emoji-heart-eyes"></i></button>
<button><i class="bi bi-emoji-laughing-fill"></i></button>
<button><i class="bi bi-emoji-laughing"></i></button>
<button><i class="bi bi-emoji-neutral-fill"></i></button>
<button><i class="bi bi-emoji-neutral"></i></button>
<button><i class="bi bi-emoji-smile-fill"></i></button>
<button><i class="bi bi-emoji-smile-upside-down-fill"></i></button>
<button><i class="bi bi-emoji-smile-upside-down"></i></button>
<button><i class="bi bi-emoji-smile"></i></button>
<button><i class="bi bi-emoji-sunglasses-fill"></i></button>
<button><i class="bi bi-emoji-sunglasses"></i></button>
<button><i class="bi bi-emoji-wink-fill"></i></button>
<button><i class="bi bi-emoji-wink"></i></button>
<button><i class="bi bi-envelope-fill"></i></button>
<button><i class="bi bi-envelope-open-fill"></i></button>
<button><i class="bi bi-envelope-open"></i></button>
<button><i class="bi bi-envelope"></i></button>
<button><i class="bi bi-eraser-fill"></i></button>
<button><i class="bi bi-eraser"></i></button>
<button><i class="bi bi-exclamation-circle-fill"></i></button>
<button><i class="bi bi-exclamation-circle"></i></button>
<button><i class="bi bi-exclamation-diamond-fill"></i></button>
<button><i class="bi bi-exclamation-diamond"></i></button>
<button><i class="bi bi-exclamation-octagon-fill"></i></button>
<button><i class="bi bi-exclamation-octagon"></i></button>
<button><i class="bi bi-exclamation-square-fill"></i></button>
<button><i class="bi bi-exclamation-square"></i></button>
<button><i class="bi bi-exclamation-triangle-fill"></i></button>
<button><i class="bi bi-exclamation-triangle"></i></button>
<button><i class="bi bi-exclamation"></i></button>
<button><i class="bi bi-exclude"></i></button>
<button><i class="bi bi-eye-fill"></i></button>
<button><i class="bi bi-eye-slash-fill"></i></button>
<button><i class="bi bi-eye-slash"></i></button>
<button><i class="bi bi-eye"></i></button>
<button><i class="bi bi-eyedropper"></i></button>
<button><i class="bi bi-eyeglasses"></i></button>
<button><i class="bi bi-facebook"></i></button>
<button><i class="bi bi-file-arrow-down-fill"></i></button>
<button><i class="bi bi-file-arrow-down"></i></button>
<button><i class="bi bi-file-arrow-up-fill"></i></button>
<button><i class="bi bi-file-arrow-up"></i></button>
<button><i class="bi bi-file-bar-graph-fill"></i></button>
<button><i class="bi bi-file-bar-graph"></i></button>
<button><i class="bi bi-file-binary-fill"></i></button>
<button><i class="bi bi-file-binary"></i></button>
<button><i class="bi bi-file-break-fill"></i></button>
<button><i class="bi bi-file-break"></i></button>
<button><i class="bi bi-file-check-fill"></i></button>
<button><i class="bi bi-file-check"></i></button>
<button><i class="bi bi-file-code-fill"></i></button>
<button><i class="bi bi-file-code"></i></button>
<button><i class="bi bi-file-diff-fill"></i></button>
<button><i class="bi bi-file-diff"></i></button>
<button><i class="bi bi-file-earmark-arrow-down-fill"></i></button>
<button><i class="bi bi-file-earmark-arrow-down"></i></button>
<button><i class="bi bi-file-earmark-arrow-up-fill"></i></button>
<button><i class="bi bi-file-earmark-arrow-up"></i></button>
<button><i class="bi bi-file-earmark-bar-graph-fill"></i></button>
<button><i class="bi bi-file-earmark-bar-graph"></i></button>
<button><i class="bi bi-file-earmark-binary-fill"></i></button>
<button><i class="bi bi-file-earmark-binary"></i></button>
<button><i class="bi bi-file-earmark-break-fill"></i></button>
<button><i class="bi bi-file-earmark-break"></i></button>
<button><i class="bi bi-file-earmark-check-fill"></i></button>
<button><i class="bi bi-file-earmark-check"></i></button>
<button><i class="bi bi-file-earmark-code-fill"></i></button>
<button><i class="bi bi-file-earmark-code"></i></button>
<button><i class="bi bi-file-earmark-diff-fill"></i></button>
<button><i class="bi bi-file-earmark-diff"></i></button>
<button><i class="bi bi-file-earmark-easel-fill"></i></button>
<button><i class="bi bi-file-earmark-easel"></i></button>
<button><i class="bi bi-file-earmark-excel-fill"></i></button>
<button><i class="bi bi-file-earmark-excel"></i></button>
<button><i class="bi bi-file-earmark-fill"></i></button>
<button><i class="bi bi-file-earmark-font-fill"></i></button>
<button><i class="bi bi-file-earmark-font"></i></button>
<button><i class="bi bi-file-earmark-image-fill"></i></button>
<button><i class="bi bi-file-earmark-image"></i></button>
<button><i class="bi bi-file-earmark-lock-fill"></i></button>
<button><i class="bi bi-file-earmark-lock"></i></button>
<button><i class="bi bi-file-earmark-lock2-fill"></i></button>
<button><i class="bi bi-file-earmark-lock2"></i></button>
<button><i class="bi bi-file-earmark-medical-fill"></i></button>
<button><i class="bi bi-file-earmark-medical"></i></button>
<button><i class="bi bi-file-earmark-minus-fill"></i></button>
<button><i class="bi bi-file-earmark-minus"></i></button>
<button><i class="bi bi-file-earmark-music-fill"></i></button>`;
    html += `
<button><i class="bi bi-file-earmark-music"></i></button>
<button><i class="bi bi-file-earmark-person-fill"></i></button>
<button><i class="bi bi-file-earmark-person"></i></button>
<button><i class="bi bi-file-earmark-play-fill"></i></button>
<button><i class="bi bi-file-earmark-play"></i></button>
<button><i class="bi bi-file-earmark-plus-fill"></i></button>
<button><i class="bi bi-file-earmark-plus"></i></button>
<button><i class="bi bi-file-earmark-post-fill"></i></button>
<button><i class="bi bi-file-earmark-post"></i></button>
<button><i class="bi bi-file-earmark-ppt-fill"></i></button>
<button><i class="bi bi-file-earmark-ppt"></i></button>
<button><i class="bi bi-file-earmark-richtext-fill"></i></button>
<button><i class="bi bi-file-earmark-richtext"></i></button>
<button><i class="bi bi-file-earmark-ruled-fill"></i></button>
<button><i class="bi bi-file-earmark-ruled"></i></button>
<button><i class="bi bi-file-earmark-slides-fill"></i></button>
<button><i class="bi bi-file-earmark-slides"></i></button>
<button><i class="bi bi-file-earmark-spreadsheet-fill"></i></button>
<button><i class="bi bi-file-earmark-spreadsheet"></i></button>
<button><i class="bi bi-file-earmark-text-fill"></i></button>
<button><i class="bi bi-file-earmark-text"></i></button>
<button><i class="bi bi-file-earmark-word-fill"></i></button>
<button><i class="bi bi-file-earmark-word"></i></button>
<button><i class="bi bi-file-earmark-x-fill"></i></button>
<button><i class="bi bi-file-earmark-x"></i></button>
<button><i class="bi bi-file-earmark-zip-fill"></i></button>
<button><i class="bi bi-file-earmark-zip"></i></button>
<button><i class="bi bi-file-earmark"></i></button>
<button><i class="bi bi-file-easel-fill"></i></button>
<button><i class="bi bi-file-easel"></i></button>
<button><i class="bi bi-file-excel-fill"></i></button>
<button><i class="bi bi-file-excel"></i></button>
<button><i class="bi bi-file-fill"></i></button>
<button><i class="bi bi-file-font-fill"></i></button>
<button><i class="bi bi-file-font"></i></button>
<button><i class="bi bi-file-image-fill"></i></button>
<button><i class="bi bi-file-image"></i></button>
<button><i class="bi bi-file-lock-fill"></i></button>
<button><i class="bi bi-file-lock"></i></button>
<button><i class="bi bi-file-lock2-fill"></i></button>
<button><i class="bi bi-file-lock2"></i></button>
<button><i class="bi bi-file-medical-fill"></i></button>
<button><i class="bi bi-file-medical"></i></button>
<button><i class="bi bi-file-minus-fill"></i></button>
<button><i class="bi bi-file-minus"></i></button>
<button><i class="bi bi-file-music-fill"></i></button>
<button><i class="bi bi-file-music"></i></button>
<button><i class="bi bi-file-person-fill"></i></button>
<button><i class="bi bi-file-person"></i></button>
<button><i class="bi bi-file-play-fill"></i></button>
<button><i class="bi bi-file-play"></i></button>
<button><i class="bi bi-file-plus-fill"></i></button>
<button><i class="bi bi-file-plus"></i></button>
<button><i class="bi bi-file-post-fill"></i></button>
<button><i class="bi bi-file-post"></i></button>
<button><i class="bi bi-file-ppt-fill"></i></button>
<button><i class="bi bi-file-ppt"></i></button>
<button><i class="bi bi-file-richtext-fill"></i></button>
<button><i class="bi bi-file-richtext"></i></button>
<button><i class="bi bi-file-ruled-fill"></i></button>
<button><i class="bi bi-file-ruled"></i></button>
<button><i class="bi bi-file-slides-fill"></i></button>
<button><i class="bi bi-file-slides"></i></button>
<button><i class="bi bi-file-spreadsheet-fill"></i></button>
<button><i class="bi bi-file-spreadsheet"></i></button>
<button><i class="bi bi-file-text-fill"></i></button>
<button><i class="bi bi-file-text"></i></button>
<button><i class="bi bi-file-word-fill"></i></button>
<button><i class="bi bi-file-word"></i></button>
<button><i class="bi bi-file-x-fill"></i></button>
<button><i class="bi bi-file-x"></i></button>
<button><i class="bi bi-file-zip-fill"></i></button>
<button><i class="bi bi-file-zip"></i></button>
<button><i class="bi bi-file"></i></button>
<button><i class="bi bi-files-alt"></i></button>
<button><i class="bi bi-files"></i></button>
<button><i class="bi bi-film"></i></button>
<button><i class="bi bi-filter-circle-fill"></i></button>
<button><i class="bi bi-filter-circle"></i></button>
<button><i class="bi bi-filter-left"></i></button>
<button><i class="bi bi-filter-right"></i></button>
<button><i class="bi bi-filter-square-fill"></i></button>
<button><i class="bi bi-filter-square"></i></button>
<button><i class="bi bi-filter"></i></button>
<button><i class="bi bi-flag-fill"></i></button>
<button><i class="bi bi-flag"></i></button>
<button><i class="bi bi-flower1"></i></button>
<button><i class="bi bi-flower2"></i></button>
<button><i class="bi bi-flower3"></i></button>
<button><i class="bi bi-folder-check"></i></button>
<button><i class="bi bi-folder-fill"></i></button>
<button><i class="bi bi-folder-minus"></i></button>
<button><i class="bi bi-folder-plus"></i></button>
<button><i class="bi bi-folder-symlink-fill"></i></button>
<button><i class="bi bi-folder-symlink"></i></button>
<button><i class="bi bi-folder-x"></i></button>
<button><i class="bi bi-folder"></i></button>
<button><i class="bi bi-folder2-open"></i></button>
<button><i class="bi bi-folder2"></i></button>`;
    html += `
<button><i class="bi bi-fonts"></i></button>
<button><i class="bi bi-forward-fill"></i></button>
<button><i class="bi bi-forward"></i></button>
<button><i class="bi bi-front"></i></button>
<button><i class="bi bi-fullscreen-exit"></i></button>
<button><i class="bi bi-fullscreen"></i></button>
<button><i class="bi bi-funnel-fill"></i></button>
<button><i class="bi bi-funnel"></i></button>
<button><i class="bi bi-gear-fill"></i></button>
<button><i class="bi bi-gear-wide-connected"></i></button>
<button><i class="bi bi-gear-wide"></i></button>
<button><i class="bi bi-gear"></i></button>
<button><i class="bi bi-gem"></i></button>
<button><i class="bi bi-geo-alt-fill"></i></button>
<button><i class="bi bi-geo-alt"></i></button>
<button><i class="bi bi-geo-fill"></i></button>
<button><i class="bi bi-geo"></i></button>
<button><i class="bi bi-gift-fill"></i></button>
<button><i class="bi bi-gift"></i></button>
<button><i class="bi bi-github"></i></button>
<button><i class="bi bi-globe"></i></button>
<button><i class="bi bi-globe2"></i></button>
<button><i class="bi bi-google"></i></button>
<button><i class="bi bi-graph-down"></i></button>
<button><i class="bi bi-graph-up"></i></button>
<button><i class="bi bi-grid-1x2-fill"></i></button>
<button><i class="bi bi-grid-1x2"></i></button>
<button><i class="bi bi-grid-3x2-gap-fill"></i></button>
<button><i class="bi bi-grid-3x2-gap"></i></button>
<button><i class="bi bi-grid-3x2"></i></button>
<button><i class="bi bi-grid-3x3-gap-fill"></i></button>
<button><i class="bi bi-grid-3x3-gap"></i></button>
<button><i class="bi bi-grid-3x3"></i></button>
<button><i class="bi bi-grid-fill"></i></button>
<button><i class="bi bi-grid"></i></button>
<button><i class="bi bi-grip-horizontal"></i></button>
<button><i class="bi bi-grip-vertical"></i></button>
<button><i class="bi bi-hammer"></i></button>
<button><i class="bi bi-hand-index-fill"></i></button>
<button><i class="bi bi-hand-index-thumb-fill"></i></button>
<button><i class="bi bi-hand-index-thumb"></i></button>
<button><i class="bi bi-hand-index"></i></button>
<button><i class="bi bi-hand-thumbs-down-fill"></i></button>
<button><i class="bi bi-hand-thumbs-down"></i></button>
<button><i class="bi bi-hand-thumbs-up-fill"></i></button>
<button><i class="bi bi-hand-thumbs-up"></i></button>
<button><i class="bi bi-handbag-fill"></i></button>
<button><i class="bi bi-handbag"></i></button>
<button><i class="bi bi-hash"></i></button>
<button><i class="bi bi-hdd-fill"></i></button>
<button><i class="bi bi-hdd-network-fill"></i></button>
<button><i class="bi bi-hdd-network"></i></button>
<button><i class="bi bi-hdd-rack-fill"></i></button>
<button><i class="bi bi-hdd-rack"></i></button>
<button><i class="bi bi-hdd-stack-fill"></i></button>
<button><i class="bi bi-hdd-stack"></i></button>
<button><i class="bi bi-hdd"></i></button>
<button><i class="bi bi-headphones"></i></button>
<button><i class="bi bi-headset"></i></button>
<button><i class="bi bi-heart-fill"></i></button>
<button><i class="bi bi-heart-half"></i></button>
<button><i class="bi bi-heart"></i></button>
<button><i class="bi bi-heptagon-fill"></i></button>
<button><i class="bi bi-heptagon-half"></i></button>
<button><i class="bi bi-heptagon"></i></button>
<button><i class="bi bi-hexagon-fill"></i></button>
<button><i class="bi bi-hexagon-half"></i></button>
<button><i class="bi bi-hexagon"></i></button>
<button><i class="bi bi-hourglass-bottom"></i></button>
<button><i class="bi bi-hourglass-split"></i></button>
<button><i class="bi bi-hourglass-top"></i></button>
<button><i class="bi bi-hourglass"></i></button>
<button><i class="bi bi-house-door-fill"></i></button>
<button><i class="bi bi-house-door"></i></button>
<button><i class="bi bi-house-fill"></i></button>
<button><i class="bi bi-house"></i></button>
<button><i class="bi bi-hr"></i></button>
<button><i class="bi bi-hurricane"></i></button>
<button><i class="bi bi-image-alt"></i></button>
<button><i class="bi bi-image-fill"></i></button>
<button><i class="bi bi-image"></i></button>
<button><i class="bi bi-images"></i></button>
<button><i class="bi bi-inbox-fill"></i></button>
<button><i class="bi bi-inbox"></i></button>
<button><i class="bi bi-inboxes-fill"></i></button>
<button><i class="bi bi-inboxes"></i></button>
<button><i class="bi bi-info-circle-fill"></i></button>
<button><i class="bi bi-info-circle"></i></button>
<button><i class="bi bi-info-square-fill"></i></button>
<button><i class="bi bi-info-square"></i></button>
<button><i class="bi bi-info"></i></button>
<button><i class="bi bi-input-cursor-text"></i></button>
<button><i class="bi bi-input-cursor"></i></button>
<button><i class="bi bi-instagram"></i></button>
<button><i class="bi bi-intersect"></i></button>
<button><i class="bi bi-journal-album"></i></button>
<button><i class="bi bi-journal-arrow-down"></i></button>
<button><i class="bi bi-journal-arrow-up"></i></button>
<button><i class="bi bi-journal-bookmark-fill"></i></button>`;
    html += `
<button><i class="bi bi-journal-bookmark"></i></button>
<button><i class="bi bi-journal-check"></i></button>
<button><i class="bi bi-journal-code"></i></button>
<button><i class="bi bi-journal-medical"></i></button>
<button><i class="bi bi-journal-minus"></i></button>
<button><i class="bi bi-journal-plus"></i></button>
<button><i class="bi bi-journal-richtext"></i></button>
<button><i class="bi bi-journal-text"></i></button>
<button><i class="bi bi-journal-x"></i></button>
<button><i class="bi bi-journal"></i></button>
<button><i class="bi bi-journals"></i></button>
<button><i class="bi bi-joystick"></i></button>
<button><i class="bi bi-justify-left"></i></button>
<button><i class="bi bi-justify-right"></i></button>
<button><i class="bi bi-justify"></i></button>
<button><i class="bi bi-kanban-fill"></i></button>
<button><i class="bi bi-kanban"></i></button>
<button><i class="bi bi-key-fill"></i></button>
<button><i class="bi bi-key"></i></button>
<button><i class="bi bi-keyboard-fill"></i></button>
<button><i class="bi bi-keyboard"></i></button>
<button><i class="bi bi-ladder"></i></button>
<button><i class="bi bi-lamp-fill"></i></button>
<button><i class="bi bi-lamp"></i></button>
<button><i class="bi bi-laptop-fill"></i></button>
<button><i class="bi bi-laptop"></i></button>
<button><i class="bi bi-layer-backward"></i></button>
<button><i class="bi bi-layer-forward"></i></button>
<button><i class="bi bi-layers-fill"></i></button>
<button><i class="bi bi-layers-half"></i></button>
<button><i class="bi bi-layers"></i></button>
<button><i class="bi bi-layout-sidebar-inset-reverse"></i></button>
<button><i class="bi bi-layout-sidebar-inset"></i></button>
<button><i class="bi bi-layout-sidebar-reverse"></i></button>
<button><i class="bi bi-layout-sidebar"></i></button>
<button><i class="bi bi-layout-split"></i></button>
<button><i class="bi bi-layout-text-sidebar-reverse"></i></button>
<button><i class="bi bi-layout-text-sidebar"></i></button>
<button><i class="bi bi-layout-text-window-reverse"></i></button>
<button><i class="bi bi-layout-text-window"></i></button>
<button><i class="bi bi-layout-three-columns"></i></button>
<button><i class="bi bi-layout-wtf"></i></button>
<button><i class="bi bi-life-preserver"></i></button>
<button><i class="bi bi-lightbulb-fill"></i></button>
<button><i class="bi bi-lightbulb-off-fill"></i></button>
<button><i class="bi bi-lightbulb-off"></i></button>
<button><i class="bi bi-lightbulb"></i></button>
<button><i class="bi bi-lightning-charge-fill"></i></button>
<button><i class="bi bi-lightning-charge"></i></button>
<button><i class="bi bi-lightning-fill"></i></button>
<button><i class="bi bi-lightning"></i></button>
<button><i class="bi bi-link-45deg"></i></button>
<button><i class="bi bi-link"></i></button>
<button><i class="bi bi-linkedin"></i></button>
<button><i class="bi bi-list-check"></i></button>
<button><i class="bi bi-list-nested"></i></button>
<button><i class="bi bi-list-ol"></i></button>
<button><i class="bi bi-list-stars"></i></button>
<button><i class="bi bi-list-task"></i></button>
<button><i class="bi bi-list-ul"></i></button>
<button><i class="bi bi-list"></i></button>
<button><i class="bi bi-lock-fill"></i></button>
<button><i class="bi bi-lock"></i></button>
<button><i class="bi bi-mailbox"></i></button>
<button><i class="bi bi-mailbox2"></i></button>
<button><i class="bi bi-map-fill"></i></button>
<button><i class="bi bi-map"></i></button>
<button><i class="bi bi-markdown-fill"></i></button>
<button><i class="bi bi-markdown"></i></button>
<button><i class="bi bi-mask"></i></button>
<button><i class="bi bi-megaphone-fill"></i></button>
<button><i class="bi bi-megaphone"></i></button>
<button><i class="bi bi-menu-app-fill"></i></button>
<button><i class="bi bi-menu-app"></i></button>
<button><i class="bi bi-menu-button-fill"></i></button>
<button><i class="bi bi-menu-button-wide-fill"></i></button>
<button><i class="bi bi-menu-button-wide"></i></button>
<button><i class="bi bi-menu-button"></i></button>
<button><i class="bi bi-menu-down"></i></button>
<button><i class="bi bi-menu-up"></i></button>
<button><i class="bi bi-mic-fill"></i></button>
<button><i class="bi bi-mic-mute-fill"></i></button>
<button><i class="bi bi-mic-mute"></i></button>
<button><i class="bi bi-mic"></i></button>
<button><i class="bi bi-minecart-loaded"></i></button>
<button><i class="bi bi-minecart"></i></button>
<button><i class="bi bi-moisture"></i></button>
<button><i class="bi bi-moon-fill"></i></button>
<button><i class="bi bi-moon-stars-fill"></i></button>
<button><i class="bi bi-moon-stars"></i></button>
<button><i class="bi bi-moon"></i></button>
<button><i class="bi bi-mouse-fill"></i></button>
<button><i class="bi bi-mouse"></i></button>
<button><i class="bi bi-mouse2-fill"></i></button>
<button><i class="bi bi-mouse2"></i></button>
<button><i class="bi bi-mouse3-fill"></i></button>
<button><i class="bi bi-mouse3"></i></button>
<button><i class="bi bi-music-note-beamed"></i></button>
<button><i class="bi bi-music-note-list"></i></button>`;
    html += `
<button><i class="bi bi-music-note"></i></button>
<button><i class="bi bi-music-player-fill"></i></button>
<button><i class="bi bi-music-player"></i></button>
<button><i class="bi bi-newspaper"></i></button>
<button><i class="bi bi-node-minus-fill"></i></button>
<button><i class="bi bi-node-minus"></i></button>
<button><i class="bi bi-node-plus-fill"></i></button>
<button><i class="bi bi-node-plus"></i></button>
<button><i class="bi bi-nut-fill"></i></button>
<button><i class="bi bi-nut"></i></button>
<button><i class="bi bi-octagon-fill"></i></button>
<button><i class="bi bi-octagon-half"></i></button>
<button><i class="bi bi-octagon"></i></button>
<button><i class="bi bi-option"></i></button>
<button><i class="bi bi-outlet"></i></button>
<button><i class="bi bi-paint-bucket"></i></button>
<button><i class="bi bi-palette-fill"></i></button>
<button><i class="bi bi-palette"></i></button>
<button><i class="bi bi-palette2"></i></button>
<button><i class="bi bi-paperclip"></i></button>
<button><i class="bi bi-paragraph"></i></button>
<button><i class="bi bi-patch-check-fill"></i></button>
<button><i class="bi bi-patch-check"></i></button>
<button><i class="bi bi-patch-exclamation-fill"></i></button>
<button><i class="bi bi-patch-exclamation"></i></button>
<button><i class="bi bi-patch-minus-fill"></i></button>
<button><i class="bi bi-patch-minus"></i></button>
<button><i class="bi bi-patch-plus-fill"></i></button>
<button><i class="bi bi-patch-plus"></i></button>
<button><i class="bi bi-patch-question-fill"></i></button>
<button><i class="bi bi-patch-question"></i></button>
<button><i class="bi bi-pause-btn-fill"></i></button>
<button><i class="bi bi-pause-btn"></i></button>
<button><i class="bi bi-pause-circle-fill"></i></button>
<button><i class="bi bi-pause-circle"></i></button>
<button><i class="bi bi-pause-fill"></i></button>
<button><i class="bi bi-pause"></i></button>
<button><i class="bi bi-peace-fill"></i></button>
<button><i class="bi bi-peace"></i></button>
<button><i class="bi bi-pen-fill"></i></button>
<button><i class="bi bi-pen"></i></button>
<button><i class="bi bi-pencil-fill"></i></button>
<button><i class="bi bi-pencil-square"></i></button>
<button><i class="bi bi-pencil"></i></button>
<button><i class="bi bi-pentagon-fill"></i></button>
<button><i class="bi bi-pentagon-half"></i></button>
<button><i class="bi bi-pentagon"></i></button>
<button><i class="bi bi-people-fill"></i></button>
<button><i class="bi bi-people"></i></button>
<button><i class="bi bi-percent"></i></button>
<button><i class="bi bi-person-badge-fill"></i></button>
<button><i class="bi bi-person-badge"></i></button>
<button><i class="bi bi-person-bounding-box"></i></button>
<button><i class="bi bi-person-check-fill"></i></button>
<button><i class="bi bi-person-check"></i></button>
<button><i class="bi bi-person-circle"></i></button>
<button><i class="bi bi-person-dash-fill"></i></button>
<button><i class="bi bi-person-dash"></i></button>
<button><i class="bi bi-person-fill"></i></button>
<button><i class="bi bi-person-lines-fill"></i></button>
<button><i class="bi bi-person-plus-fill"></i></button>
<button><i class="bi bi-person-plus"></i></button>
<button><i class="bi bi-person-square"></i></button>
<button><i class="bi bi-person-x-fill"></i></button>
<button><i class="bi bi-person-x"></i></button>
<button><i class="bi bi-person"></i></button>
<button><i class="bi bi-phone-fill"></i></button>
<button><i class="bi bi-phone-landscape-fill"></i></button>
<button><i class="bi bi-phone-landscape"></i></button>
<button><i class="bi bi-phone-vibrate-fill"></i></button>
<button><i class="bi bi-phone-vibrate"></i></button>
<button><i class="bi bi-phone"></i></button>
<button><i class="bi bi-pie-chart-fill"></i></button>
<button><i class="bi bi-pie-chart"></i></button>
<button><i class="bi bi-pin-angle-fill"></i></button>
<button><i class="bi bi-pin-angle"></i></button>
<button><i class="bi bi-pin-fill"></i></button>
<button><i class="bi bi-pin"></i></button>
<button><i class="bi bi-pip-fill"></i></button>
<button><i class="bi bi-pip"></i></button>
<button><i class="bi bi-play-btn-fill"></i></button>
<button><i class="bi bi-play-btn"></i></button>
<button><i class="bi bi-play-circle-fill"></i></button>
<button><i class="bi bi-play-circle"></i></button>
<button><i class="bi bi-play-fill"></i></button>
<button><i class="bi bi-play"></i></button>
<button><i class="bi bi-plug-fill"></i></button>
<button><i class="bi bi-plug"></i></button>
<button><i class="bi bi-plus-circle-dotted"></i></button>
<button><i class="bi bi-plus-circle-fill"></i></button>
<button><i class="bi bi-plus-circle"></i></button>
<button><i class="bi bi-plus-square-dotted"></i></button>
<button><i class="bi bi-plus-square-fill"></i></button>
<button><i class="bi bi-plus-square"></i></button>
<button><i class="bi bi-plus"></i></button>
<button><i class="bi bi-power"></i></button>
<button><i class="bi bi-printer-fill"></i></button>
<button><i class="bi bi-printer"></i></button>
<button><i class="bi bi-puzzle-fill"></i></button>`;
    html += `
<button><i class="bi bi-puzzle"></i></button>
<button><i class="bi bi-question-circle-fill"></i></button>
<button><i class="bi bi-question-circle"></i></button>
<button><i class="bi bi-question-diamond-fill"></i></button>
<button><i class="bi bi-question-diamond"></i></button>
<button><i class="bi bi-question-octagon-fill"></i></button>
<button><i class="bi bi-question-octagon"></i></button>
<button><i class="bi bi-question-square-fill"></i></button>
<button><i class="bi bi-question-square"></i></button>
<button><i class="bi bi-question"></i></button>
<button><i class="bi bi-rainbow"></i></button>
<button><i class="bi bi-receipt-cutoff"></i></button>
<button><i class="bi bi-receipt"></i></button>
<button><i class="bi bi-reception-0"></i></button>
<button><i class="bi bi-reception-1"></i></button>
<button><i class="bi bi-reception-2"></i></button>
<button><i class="bi bi-reception-3"></i></button>
<button><i class="bi bi-reception-4"></i></button>
<button><i class="bi bi-record-btn-fill"></i></button>
<button><i class="bi bi-record-btn"></i></button>
<button><i class="bi bi-record-circle-fill"></i></button>
<button><i class="bi bi-record-circle"></i></button>
<button><i class="bi bi-record-fill"></i></button>
<button><i class="bi bi-record"></i></button>
<button><i class="bi bi-record2-fill"></i></button>
<button><i class="bi bi-record2"></i></button>
<button><i class="bi bi-reply-all-fill"></i></button>
<button><i class="bi bi-reply-all"></i></button>
<button><i class="bi bi-reply-fill"></i></button>
<button><i class="bi bi-reply"></i></button>
<button><i class="bi bi-rss-fill"></i></button>
<button><i class="bi bi-rss"></i></button>
<button><i class="bi bi-rulers"></i></button>
<button><i class="bi bi-save-fill"></i></button>
<button><i class="bi bi-save"></i></button>
<button><i class="bi bi-save2-fill"></i></button>
<button><i class="bi bi-save2"></i></button>
<button><i class="bi bi-scissors"></i></button>
<button><i class="bi bi-screwdriver"></i></button>
<button><i class="bi bi-search"></i></button>
<button><i class="bi bi-segmented-nav"></i></button>
<button><i class="bi bi-server"></i></button>
<button><i class="bi bi-share-fill"></i></button>
<button><i class="bi bi-share"></i></button>
<button><i class="bi bi-shield-check"></i></button>
<button><i class="bi bi-shield-exclamation"></i></button>
<button><i class="bi bi-shield-fill-check"></i></button>
<button><i class="bi bi-shield-fill-exclamation"></i></button>
<button><i class="bi bi-shield-fill-minus"></i></button>
<button><i class="bi bi-shield-fill-plus"></i></button>
<button><i class="bi bi-shield-fill-x"></i></button>
<button><i class="bi bi-shield-fill"></i></button>
<button><i class="bi bi-shield-lock-fill"></i></button>
<button><i class="bi bi-shield-lock"></i></button>
<button><i class="bi bi-shield-minus"></i></button>
<button><i class="bi bi-shield-plus"></i></button>
<button><i class="bi bi-shield-shaded"></i></button>
<button><i class="bi bi-shield-slash-fill"></i></button>
<button><i class="bi bi-shield-slash"></i></button>
<button><i class="bi bi-shield-x"></i></button>
<button><i class="bi bi-shield"></i></button>
<button><i class="bi bi-shift-fill"></i></button>
<button><i class="bi bi-shift"></i></button>
<button><i class="bi bi-shop-window"></i></button>
<button><i class="bi bi-shop"></i></button>
<button><i class="bi bi-shuffle"></i></button>
<button><i class="bi bi-signpost-2-fill"></i></button>
<button><i class="bi bi-signpost-2"></i></button>
<button><i class="bi bi-signpost-fill"></i></button>
<button><i class="bi bi-signpost-split-fill"></i></button>
<button><i class="bi bi-signpost-split"></i></button>
<button><i class="bi bi-signpost"></i></button>
<button><i class="bi bi-sim-fill"></i></button>
<button><i class="bi bi-sim"></i></button>
<button><i class="bi bi-skip-backward-btn-fill"></i></button>
<button><i class="bi bi-skip-backward-btn"></i></button>
<button><i class="bi bi-skip-backward-circle-fill"></i></button>
<button><i class="bi bi-skip-backward-circle"></i></button>
<button><i class="bi bi-skip-backward-fill"></i></button>
<button><i class="bi bi-skip-backward"></i></button>
<button><i class="bi bi-skip-end-btn-fill"></i></button>
<button><i class="bi bi-skip-end-btn"></i></button>
<button><i class="bi bi-skip-end-circle-fill"></i></button>
<button><i class="bi bi-skip-end-circle"></i></button>
<button><i class="bi bi-skip-end-fill"></i></button>
<button><i class="bi bi-skip-end"></i></button>
<button><i class="bi bi-skip-forward-btn-fill"></i></button>
<button><i class="bi bi-skip-forward-btn"></i></button>
<button><i class="bi bi-skip-forward-circle-fill"></i></button>
<button><i class="bi bi-skip-forward-circle"></i></button>
<button><i class="bi bi-skip-forward-fill"></i></button>
<button><i class="bi bi-skip-forward"></i></button>
<button><i class="bi bi-skip-start-btn-fill"></i></button>
<button><i class="bi bi-skip-start-btn"></i></button>
<button><i class="bi bi-skip-start-circle-fill"></i></button>
<button><i class="bi bi-skip-start-circle"></i></button>
<button><i class="bi bi-skip-start-fill"></i></button>
<button><i class="bi bi-skip-start"></i></button>
<button><i class="bi bi-slack"></i></button>`;
    html += `
<button><i class="bi bi-slash-circle-fill"></i></button>
<button><i class="bi bi-slash-circle"></i></button>
<button><i class="bi bi-slash-square-fill"></i></button>
<button><i class="bi bi-slash-square"></i></button>
<button><i class="bi bi-slash"></i></button>
<button><i class="bi bi-sliders"></i></button>
<button><i class="bi bi-smartwatch"></i></button>
<button><i class="bi bi-snow"></i></button>
<button><i class="bi bi-snow2"></i></button>
<button><i class="bi bi-snow3"></i></button>
<button><i class="bi bi-sort-alpha-down-alt"></i></button>
<button><i class="bi bi-sort-alpha-down"></i></button>
<button><i class="bi bi-sort-alpha-up-alt"></i></button>
<button><i class="bi bi-sort-alpha-up"></i></button>
<button><i class="bi bi-sort-down-alt"></i></button>
<button><i class="bi bi-sort-down"></i></button>
<button><i class="bi bi-sort-numeric-down-alt"></i></button>
<button><i class="bi bi-sort-numeric-down"></i></button>
<button><i class="bi bi-sort-numeric-up-alt"></i></button>
<button><i class="bi bi-sort-numeric-up"></i></button>
<button><i class="bi bi-sort-up-alt"></i></button>
<button><i class="bi bi-sort-up"></i></button>
<button><i class="bi bi-soundwave"></i></button>
<button><i class="bi bi-speaker-fill"></i></button>
<button><i class="bi bi-speaker"></i></button>
<button><i class="bi bi-speedometer"></i></button>
<button><i class="bi bi-speedometer2"></i></button>
<button><i class="bi bi-spellcheck"></i></button>
<button><i class="bi bi-square-fill"></i></button>
<button><i class="bi bi-square-half"></i></button>
<button><i class="bi bi-square"></i></button>
<button><i class="bi bi-stack"></i></button>
<button><i class="bi bi-star-fill"></i></button>
<button><i class="bi bi-star-half"></i></button>
<button><i class="bi bi-star"></i></button>
<button><i class="bi bi-stars"></i></button>
<button><i class="bi bi-stickies-fill"></i></button>
<button><i class="bi bi-stickies"></i></button>
<button><i class="bi bi-sticky-fill"></i></button>
<button><i class="bi bi-sticky"></i></button>
<button><i class="bi bi-stop-btn-fill"></i></button>
<button><i class="bi bi-stop-btn"></i></button>
<button><i class="bi bi-stop-circle-fill"></i></button>
<button><i class="bi bi-stop-circle"></i></button>
<button><i class="bi bi-stop-fill"></i></button>
<button><i class="bi bi-stop"></i></button>
<button><i class="bi bi-stoplights-fill"></i></button>
<button><i class="bi bi-stoplights"></i></button>
<button><i class="bi bi-stopwatch-fill"></i></button>
<button><i class="bi bi-stopwatch"></i></button>
<button><i class="bi bi-subtract"></i></button>
<button><i class="bi bi-suit-club-fill"></i></button>
<button><i class="bi bi-suit-club"></i></button>
<button><i class="bi bi-suit-diamond-fill"></i></button>
<button><i class="bi bi-suit-diamond"></i></button>
<button><i class="bi bi-suit-heart-fill"></i></button>
<button><i class="bi bi-suit-heart"></i></button>
<button><i class="bi bi-suit-spade-fill"></i></button>
<button><i class="bi bi-suit-spade"></i></button>
<button><i class="bi bi-sun-fill"></i></button>
<button><i class="bi bi-sun"></i></button>
<button><i class="bi bi-sunglasses"></i></button>
<button><i class="bi bi-sunrise-fill"></i></button>
<button><i class="bi bi-sunrise"></i></button>
<button><i class="bi bi-sunset-fill"></i></button>
<button><i class="bi bi-sunset"></i></button>
<button><i class="bi bi-symmetry-horizontal"></i></button>
<button><i class="bi bi-symmetry-vertical"></i></button>
<button><i class="bi bi-table"></i></button>
<button><i class="bi bi-tablet-fill"></i></button>
<button><i class="bi bi-tablet-landscape-fill"></i></button>
<button><i class="bi bi-tablet-landscape"></i></button>
<button><i class="bi bi-tablet"></i></button>
<button><i class="bi bi-tag-fill"></i></button>
<button><i class="bi bi-tag"></i></button>
<button><i class="bi bi-tags-fill"></i></button>
<button><i class="bi bi-tags"></i></button>
<button><i class="bi bi-telegram"></i></button>
<button><i class="bi bi-telephone-fill"></i></button>
<button><i class="bi bi-telephone-forward-fill"></i></button>
<button><i class="bi bi-telephone-forward"></i></button>
<button><i class="bi bi-telephone-inbound-fill"></i></button>
<button><i class="bi bi-telephone-inbound"></i></button>
<button><i class="bi bi-telephone-minus-fill"></i></button>
<button><i class="bi bi-telephone-minus"></i></button>
<button><i class="bi bi-telephone-outbound-fill"></i></button>
<button><i class="bi bi-telephone-outbound"></i></button>
<button><i class="bi bi-telephone-plus-fill"></i></button>
<button><i class="bi bi-telephone-plus"></i></button>
<button><i class="bi bi-telephone-x-fill"></i></button>
<button><i class="bi bi-telephone-x"></i></button>
<button><i class="bi bi-telephone"></i></button>
<button><i class="bi bi-terminal-fill"></i></button>
<button><i class="bi bi-terminal"></i></button>
<button><i class="bi bi-text-center"></i></button>
<button><i class="bi bi-text-indent-left"></i></button>
<button><i class="bi bi-text-indent-right"></i></button>
<button><i class="bi bi-text-left"></i></button>
<button><i class="bi bi-text-paragraph"></i></button>`;
    html += `
<button><i class="bi bi-text-right"></i></button>
<button><i class="bi bi-textarea-resize"></i></button>
<button><i class="bi bi-textarea-t"></i></button>
<button><i class="bi bi-textarea"></i></button>
<button><i class="bi bi-thermometer-half"></i></button>
<button><i class="bi bi-thermometer-high"></i></button>
<button><i class="bi bi-thermometer-low"></i></button>
<button><i class="bi bi-thermometer-snow"></i></button>
<button><i class="bi bi-thermometer-sun"></i></button>
<button><i class="bi bi-thermometer"></i></button>
<button><i class="bi bi-three-dots-vertical"></i></button>
<button><i class="bi bi-three-dots"></i></button>
<button><i class="bi bi-toggle-off"></i></button>
<button><i class="bi bi-toggle-on"></i></button>
<button><i class="bi bi-toggle2-off"></i></button>
<button><i class="bi bi-toggle2-on"></i></button>
<button><i class="bi bi-toggles"></i></button>
<button><i class="bi bi-toggles2"></i></button>
<button><i class="bi bi-tools"></i></button>
<button><i class="bi bi-tornado"></i></button>
<button><i class="bi bi-trash-fill"></i></button>
<button><i class="bi bi-trash"></i></button>
<button><i class="bi bi-trash2-fill"></i></button>
<button><i class="bi bi-trash2"></i></button>
<button><i class="bi bi-tree-fill"></i></button>
<button><i class="bi bi-tree"></i></button>
<button><i class="bi bi-triangle-fill"></i></button>
<button><i class="bi bi-triangle-half"></i></button>
<button><i class="bi bi-triangle"></i></button>
<button><i class="bi bi-trophy-fill"></i></button>
<button><i class="bi bi-trophy"></i></button>
<button><i class="bi bi-tropical-storm"></i></button>
<button><i class="bi bi-truck-flatbed"></i></button>
<button><i class="bi bi-truck"></i></button>
<button><i class="bi bi-tsunami"></i></button>
<button><i class="bi bi-tv-fill"></i></button>
<button><i class="bi bi-tv"></i></button>
<button><i class="bi bi-twitch"></i></button>
<button><i class="bi bi-twitter"></i></button>
<button><i class="bi bi-type-bold"></i></button>
<button><i class="bi bi-type-h1"></i></button>
<button><i class="bi bi-type-h2"></i></button>
<button><i class="bi bi-type-h3"></i></button>
<button><i class="bi bi-type-italic"></i></button>
<button><i class="bi bi-type-strikethrough"></i></button>
<button><i class="bi bi-type-underline"></i></button>
<button><i class="bi bi-type"></i></button>
<button><i class="bi bi-ui-checks-grid"></i></button>
<button><i class="bi bi-ui-checks"></i></button>
<button><i class="bi bi-ui-radios-grid"></i></button>
<button><i class="bi bi-ui-radios"></i></button>
<button><i class="bi bi-umbrella-fill"></i></button>
<button><i class="bi bi-umbrella"></i></button>
<button><i class="bi bi-union"></i></button>
<button><i class="bi bi-unlock-fill"></i></button>
<button><i class="bi bi-unlock"></i></button>
<button><i class="bi bi-upc-scan"></i></button>
<button><i class="bi bi-upc"></i></button>
<button><i class="bi bi-upload"></i></button>
<button><i class="bi bi-vector-pen"></i></button>
<button><i class="bi bi-view-list"></i></button>
<button><i class="bi bi-view-stacked"></i></button>
<button><i class="bi bi-vinyl-fill"></i></button>
<button><i class="bi bi-vinyl"></i></button>
<button><i class="bi bi-voicemail"></i></button>
<button><i class="bi bi-volume-down-fill"></i></button>
<button><i class="bi bi-volume-down"></i></button>
<button><i class="bi bi-volume-mute-fill"></i></button>
<button><i class="bi bi-volume-mute"></i></button>
<button><i class="bi bi-volume-off-fill"></i></button>
<button><i class="bi bi-volume-off"></i></button>
<button><i class="bi bi-volume-up-fill"></i></button>
<button><i class="bi bi-volume-up"></i></button>
<button><i class="bi bi-vr"></i></button>
<button><i class="bi bi-wallet-fill"></i></button>
<button><i class="bi bi-wallet"></i></button>
<button><i class="bi bi-wallet2"></i></button>
<button><i class="bi bi-watch"></i></button>
<button><i class="bi bi-water"></i></button>
<button><i class="bi bi-whatsapp"></i></button>
<button><i class="bi bi-wifi-1"></i></button>
<button><i class="bi bi-wifi-2"></i></button>
<button><i class="bi bi-wifi-off"></i></button>
<button><i class="bi bi-wifi"></i></button>
<button><i class="bi bi-wind"></i></button>
<button><i class="bi bi-window-dock"></i></button>
<button><i class="bi bi-window-sidebar"></i></button>
<button><i class="bi bi-window"></i></button>
<button><i class="bi bi-wrench"></i></button>
<button><i class="bi bi-x-circle-fill"></i></button>
<button><i class="bi bi-x-circle"></i></button>
<button><i class="bi bi-x-diamond-fill"></i></button>
<button><i class="bi bi-x-diamond"></i></button>
<button><i class="bi bi-x-octagon-fill"></i></button>
<button><i class="bi bi-x-octagon"></i></button>
<button><i class="bi bi-x-square-fill"></i></button>
<button><i class="bi bi-x-square"></i></button>
<button><i class="bi bi-x"></i></button>
<button><i class="bi bi-youtube"></i></button>`;
    html += `
<button><i class="bi bi-zoom-in"></i></button>
<button><i class="bi bi-zoom-out"></i></button>
<button><i class="bi bi-bank"></i></button>
<button><i class="bi bi-bank2"></i></button>
<button><i class="bi bi-bell-slash-fill"></i></button>
<button><i class="bi bi-bell-slash"></i></button>
<button><i class="bi bi-cash-coin"></i></button>
<button><i class="bi bi-check-lg"></i></button>
<button><i class="bi bi-coin"></i></button>
<button><i class="bi bi-currency-bitcoin"></i></button>
<button><i class="bi bi-currency-dollar"></i></button>
<button><i class="bi bi-currency-euro"></i></button>
<button><i class="bi bi-currency-exchange"></i></button>
<button><i class="bi bi-currency-pound"></i></button>
<button><i class="bi bi-currency-yen"></i></button>
<button><i class="bi bi-dash-lg"></i></button>
<button><i class="bi bi-exclamation-lg"></i></button>
<button><i class="bi bi-file-earmark-pdf-fill"></i></button>
<button><i class="bi bi-file-earmark-pdf"></i></button>
<button><i class="bi bi-file-pdf-fill"></i></button>
<button><i class="bi bi-file-pdf"></i></button>
<button><i class="bi bi-gender-ambiguous"></i></button>
<button><i class="bi bi-gender-female"></i></button>
<button><i class="bi bi-gender-male"></i></button>
<button><i class="bi bi-gender-trans"></i></button>
<button><i class="bi bi-headset-vr"></i></button>
<button><i class="bi bi-info-lg"></i></button>
<button><i class="bi bi-mastodon"></i></button>
<button><i class="bi bi-messenger"></i></button>
<button><i class="bi bi-piggy-bank-fill"></i></button>
<button><i class="bi bi-piggy-bank"></i></button>
<button><i class="bi bi-pin-map-fill"></i></button>
<button><i class="bi bi-pin-map"></i></button>
<button><i class="bi bi-plus-lg"></i></button>
<button><i class="bi bi-question-lg"></i></button>
<button><i class="bi bi-recycle"></i></button>
<button><i class="bi bi-reddit"></i></button>
<button><i class="bi bi-safe-fill"></i></button>
<button><i class="bi bi-safe2-fill"></i></button>
<button><i class="bi bi-safe2"></i></button>
<button><i class="bi bi-sd-card-fill"></i></button>
<button><i class="bi bi-sd-card"></i></button>
<button><i class="bi bi-skype"></i></button>
<button><i class="bi bi-slash-lg"></i></button>
<button><i class="bi bi-translate"></i></button>
<button><i class="bi bi-x-lg"></i></button>
<button><i class="bi bi-safe"></i></button>
<button><i class="bi bi-apple"></i></button>
<button><i class="bi bi-microsoft"></i></button>
<button><i class="bi bi-windows"></i></button>
<button><i class="bi bi-behance"></i></button>
<button><i class="bi bi-dribbble"></i></button>
<button><i class="bi bi-line"></i></button>
<button><i class="bi bi-medium"></i></button>
<button><i class="bi bi-paypal"></i></button>
<button><i class="bi bi-pinterest"></i></button>
<button><i class="bi bi-signal"></i></button>
<button><i class="bi bi-snapchat"></i></button>
<button><i class="bi bi-spotify"></i></button>
<button><i class="bi bi-stack-overflow"></i></button>
<button><i class="bi bi-strava"></i></button>
<button><i class="bi bi-wordpress"></i></button>
<button><i class="bi bi-vimeo"></i></button>
<button><i class="bi bi-activity"></i></button>
<button><i class="bi bi-easel2-fill"></i></button>
<button><i class="bi bi-easel2"></i></button>
<button><i class="bi bi-easel3-fill"></i></button>
<button><i class="bi bi-easel3"></i></button>
<button><i class="bi bi-fan"></i></button>
<button><i class="bi bi-fingerprint"></i></button>
<button><i class="bi bi-graph-down-arrow"></i></button>
<button><i class="bi bi-graph-up-arrow"></i></button>
<button><i class="bi bi-hypnotize"></i></button>
<button><i class="bi bi-magic"></i></button>
<button><i class="bi bi-person-rolodex"></i></button>
<button><i class="bi bi-person-video"></i></button>
<button><i class="bi bi-person-video2"></i></button>
<button><i class="bi bi-person-video3"></i></button>
<button><i class="bi bi-person-workspace"></i></button>
<button><i class="bi bi-radioactive"></i></button>
<button><i class="bi bi-webcam-fill"></i></button>
<button><i class="bi bi-webcam"></i></button>
<button><i class="bi bi-yin-yang"></i></button>
<button><i class="bi bi-bandaid-fill"></i></button>
<button><i class="bi bi-bandaid"></i></button>
<button><i class="bi bi-bluetooth"></i></button>
<button><i class="bi bi-body-text"></i></button>
<button><i class="bi bi-boombox"></i></button>
<button><i class="bi bi-boxes"></i></button>
<button><i class="bi bi-dpad-fill"></i></button>
<button><i class="bi bi-dpad"></i></button>
<button><i class="bi bi-ear-fill"></i></button>
<button><i class="bi bi-ear"></i></button>
<button><i class="bi bi-envelope-check-fill"></i></button>
<button><i class="bi bi-envelope-check"></i></button>
<button><i class="bi bi-envelope-dash-fill"></i></button>
<button><i class="bi bi-envelope-dash"></i></button>
<button><i class="bi bi-envelope-exclamation-fill"></i></button>
<button><i class="bi bi-envelope-exclamation"></i></button>`;
    html += `
<button><i class="bi bi-envelope-plus-fill"></i></button>
<button><i class="bi bi-envelope-plus"></i></button>
<button><i class="bi bi-envelope-slash-fill"></i></button>
<button><i class="bi bi-envelope-slash"></i></button>
<button><i class="bi bi-envelope-x-fill"></i></button>
<button><i class="bi bi-envelope-x"></i></button>
<button><i class="bi bi-explicit-fill"></i></button>
<button><i class="bi bi-explicit"></i></button>
<button><i class="bi bi-git"></i></button>
<button><i class="bi bi-infinity"></i></button>
<button><i class="bi bi-list-columns-reverse"></i></button>
<button><i class="bi bi-list-columns"></i></button>
<button><i class="bi bi-meta"></i></button>
<button><i class="bi bi-nintendo-switch"></i></button>
<button><i class="bi bi-pc-display-horizontal"></i></button>
<button><i class="bi bi-pc-display"></i></button>
<button><i class="bi bi-pc-horizontal"></i></button>
<button><i class="bi bi-pc"></i></button>
<button><i class="bi bi-playstation"></i></button>
<button><i class="bi bi-plus-slash-minus"></i></button>
<button><i class="bi bi-projector-fill"></i></button>
<button><i class="bi bi-projector"></i></button>
<button><i class="bi bi-qr-code-scan"></i></button>
<button><i class="bi bi-qr-code"></i></button>
<button><i class="bi bi-quora"></i></button>
<button><i class="bi bi-quote"></i></button>
<button><i class="bi bi-robot"></i></button>
<button><i class="bi bi-send-check-fill"></i></button>
<button><i class="bi bi-send-check"></i></button>
<button><i class="bi bi-send-dash-fill"></i></button>
<button><i class="bi bi-send-dash"></i></button>
<button><i class="bi bi-send-exclamation-fill"></i></button>
<button><i class="bi bi-send-exclamation"></i></button>
<button><i class="bi bi-send-fill"></i></button>
<button><i class="bi bi-send-plus-fill"></i></button>
<button><i class="bi bi-send-plus"></i></button>
<button><i class="bi bi-send-slash-fill"></i></button>
<button><i class="bi bi-send-slash"></i></button>
<button><i class="bi bi-send-x-fill"></i></button>
<button><i class="bi bi-send-x"></i></button>
<button><i class="bi bi-send"></i></button>
<button><i class="bi bi-steam"></i></button>
<button><i class="bi bi-terminal-dash"></i></button>
<button><i class="bi bi-terminal-plus"></i></button>
<button><i class="bi bi-terminal-split"></i></button>
<button><i class="bi bi-ticket-detailed-fill"></i></button>
<button><i class="bi bi-ticket-detailed"></i></button>
<button><i class="bi bi-ticket-fill"></i></button>
<button><i class="bi bi-ticket-perforated-fill"></i></button>
<button><i class="bi bi-ticket-perforated"></i></button>
<button><i class="bi bi-ticket"></i></button>
<button><i class="bi bi-tiktok"></i></button>
<button><i class="bi bi-window-dash"></i></button>
<button><i class="bi bi-window-desktop"></i></button>
<button><i class="bi bi-window-fullscreen"></i></button>
<button><i class="bi bi-window-plus"></i></button>
<button><i class="bi bi-window-split"></i></button>
<button><i class="bi bi-window-stack"></i></button>
<button><i class="bi bi-window-x"></i></button>
<button><i class="bi bi-xbox"></i></button>
<button><i class="bi bi-ethernet"></i></button>
<button><i class="bi bi-hdmi-fill"></i></button>
<button><i class="bi bi-hdmi"></i></button>
<button><i class="bi bi-usb-c-fill"></i></button>
<button><i class="bi bi-usb-c"></i></button>
<button><i class="bi bi-usb-fill"></i></button>
<button><i class="bi bi-usb-plug-fill"></i></button>
<button><i class="bi bi-usb-plug"></i></button>
<button><i class="bi bi-usb-symbol"></i></button>
<button><i class="bi bi-usb"></i></button>
<button><i class="bi bi-boombox-fill"></i></button>
<button><i class="bi bi-displayport"></i></button>
<button><i class="bi bi-gpu-card"></i></button>
<button><i class="bi bi-memory"></i></button>
<button><i class="bi bi-modem-fill"></i></button>
<button><i class="bi bi-modem"></i></button>
<button><i class="bi bi-motherboard-fill"></i></button>
<button><i class="bi bi-motherboard"></i></button>
<button><i class="bi bi-optical-audio-fill"></i></button>
<button><i class="bi bi-optical-audio"></i></button>
<button><i class="bi bi-pci-card"></i></button>
<button><i class="bi bi-router-fill"></i></button>
<button><i class="bi bi-router"></i></button>
<button><i class="bi bi-thunderbolt-fill"></i></button>
<button><i class="bi bi-thunderbolt"></i></button>
<button><i class="bi bi-usb-drive-fill"></i></button>
<button><i class="bi bi-usb-drive"></i></button>
<button><i class="bi bi-usb-micro-fill"></i></button>
<button><i class="bi bi-usb-micro"></i></button>
<button><i class="bi bi-usb-mini-fill"></i></button>
<button><i class="bi bi-usb-mini"></i></button>
<button><i class="bi bi-cloud-haze2"></i></button>
<button><i class="bi bi-device-hdd-fill"></i></button>
<button><i class="bi bi-device-hdd"></i></button>
<button><i class="bi bi-device-ssd-fill"></i></button>
<button><i class="bi bi-device-ssd"></i></button>
<button><i class="bi bi-displayport-fill"></i></button>
<button><i class="bi bi-mortarboard-fill"></i></button>
<button><i class="bi bi-mortarboard"></i></button>`;
    html += `
<button><i class="bi bi-terminal-x"></i></button>
<button><i class="bi bi-arrow-through-heart-fill"></i></button>
<button><i class="bi bi-arrow-through-heart"></i></button>
<button><i class="bi bi-badge-sd-fill"></i></button>
<button><i class="bi bi-badge-sd"></i></button>
<button><i class="bi bi-bag-heart-fill"></i></button>
<button><i class="bi bi-bag-heart"></i></button>
<button><i class="bi bi-balloon-fill"></i></button>
<button><i class="bi bi-balloon-heart-fill"></i></button>
<button><i class="bi bi-balloon-heart"></i></button>
<button><i class="bi bi-balloon"></i></button>
<button><i class="bi bi-box2-fill"></i></button>
<button><i class="bi bi-box2-heart-fill"></i></button>
<button><i class="bi bi-box2-heart"></i></button>
<button><i class="bi bi-box2"></i></button>
<button><i class="bi bi-braces-asterisk"></i></button>
<button><i class="bi bi-calendar-heart-fill"></i></button>
<button><i class="bi bi-calendar-heart"></i></button>
<button><i class="bi bi-calendar2-heart-fill"></i></button>
<button><i class="bi bi-calendar2-heart"></i></button>
<button><i class="bi bi-chat-heart-fill"></i></button>
<button><i class="bi bi-chat-heart"></i></button>
<button><i class="bi bi-chat-left-heart-fill"></i></button>
<button><i class="bi bi-chat-left-heart"></i></button>
<button><i class="bi bi-chat-right-heart-fill"></i></button>
<button><i class="bi bi-chat-right-heart"></i></button>
<button><i class="bi bi-chat-square-heart-fill"></i></button>
<button><i class="bi bi-chat-square-heart"></i></button>
<button><i class="bi bi-clipboard-check-fill"></i></button>
<button><i class="bi bi-clipboard-data-fill"></i></button>
<button><i class="bi bi-clipboard-fill"></i></button>
<button><i class="bi bi-clipboard-heart-fill"></i></button>
<button><i class="bi bi-clipboard-heart"></i></button>
<button><i class="bi bi-clipboard-minus-fill"></i></button>
<button><i class="bi bi-clipboard-plus-fill"></i></button>
<button><i class="bi bi-clipboard-pulse"></i></button>
<button><i class="bi bi-clipboard-x-fill"></i></button>
<button><i class="bi bi-clipboard2-check-fill"></i></button>
<button><i class="bi bi-clipboard2-check"></i></button>
<button><i class="bi bi-clipboard2-data-fill"></i></button>
<button><i class="bi bi-clipboard2-data"></i></button>
<button><i class="bi bi-clipboard2-fill"></i></button>
<button><i class="bi bi-clipboard2-heart-fill"></i></button>
<button><i class="bi bi-clipboard2-heart"></i></button>
<button><i class="bi bi-clipboard2-minus-fill"></i></button>
<button><i class="bi bi-clipboard2-minus"></i></button>
<button><i class="bi bi-clipboard2-plus-fill"></i></button>
<button><i class="bi bi-clipboard2-plus"></i></button>
<button><i class="bi bi-clipboard2-pulse-fill"></i></button>
<button><i class="bi bi-clipboard2-pulse"></i></button>
<button><i class="bi bi-clipboard2-x-fill"></i></button>
<button><i class="bi bi-clipboard2-x"></i></button>
<button><i class="bi bi-clipboard2"></i></button>
<button><i class="bi bi-emoji-kiss-fill"></i></button>
<button><i class="bi bi-emoji-kiss"></i></button>
<button><i class="bi bi-envelope-heart-fill"></i></button>
<button><i class="bi bi-envelope-heart"></i></button>
<button><i class="bi bi-envelope-open-heart-fill"></i></button>
<button><i class="bi bi-envelope-open-heart"></i></button>
<button><i class="bi bi-envelope-paper-fill"></i></button>
<button><i class="bi bi-envelope-paper-heart-fill"></i></button>
<button><i class="bi bi-envelope-paper-heart"></i></button>
<button><i class="bi bi-envelope-paper"></i></button>
<button><i class="bi bi-filetype-aac"></i></button>
<button><i class="bi bi-filetype-ai"></i></button>
<button><i class="bi bi-filetype-bmp"></i></button>
<button><i class="bi bi-filetype-cs"></i></button>
<button><i class="bi bi-filetype-css"></i></button>
<button><i class="bi bi-filetype-csv"></i></button>
<button><i class="bi bi-filetype-doc"></i></button>
<button><i class="bi bi-filetype-docx"></i></button>
<button><i class="bi bi-filetype-exe"></i></button>
<button><i class="bi bi-filetype-gif"></i></button>
<button><i class="bi bi-filetype-heic"></i></button>
<button><i class="bi bi-filetype-html"></i></button>
<button><i class="bi bi-filetype-java"></i></button>
<button><i class="bi bi-filetype-jpg"></i></button>
<button><i class="bi bi-filetype-js"></i></button>
<button><i class="bi bi-filetype-jsx"></i></button>
<button><i class="bi bi-filetype-key"></i></button>
<button><i class="bi bi-filetype-m4p"></i></button>
<button><i class="bi bi-filetype-md"></i></button>
<button><i class="bi bi-filetype-mdx"></i></button>
<button><i class="bi bi-filetype-mov"></i></button>
<button><i class="bi bi-filetype-mp3"></i></button>
<button><i class="bi bi-filetype-mp4"></i></button>
<button><i class="bi bi-filetype-otf"></i></button>
<button><i class="bi bi-filetype-pdf"></i></button>
<button><i class="bi bi-filetype-php"></i></button>
<button><i class="bi bi-filetype-png"></i></button>
<button><i class="bi bi-filetype-ppt"></i></button>
<button><i class="bi bi-filetype-psd"></i></button>
<button><i class="bi bi-filetype-py"></i></button>
<button><i class="bi bi-filetype-raw"></i></button>
<button><i class="bi bi-filetype-rb"></i></button>
<button><i class="bi bi-filetype-sass"></i></button>
<button><i class="bi bi-filetype-scss"></i></button>
<button><i class="bi bi-filetype-sh"></i></button>
<button><i class="bi bi-filetype-svg"></i></button>`;
    html += `
<button><i class="bi bi-filetype-tiff"></i></button>
<button><i class="bi bi-filetype-tsx"></i></button>
<button><i class="bi bi-filetype-ttf"></i></button>
<button><i class="bi bi-filetype-txt"></i></button>
<button><i class="bi bi-filetype-wav"></i></button>
<button><i class="bi bi-filetype-woff"></i></button>
<button><i class="bi bi-filetype-xls"></i></button>
<button><i class="bi bi-filetype-xml"></i></button>
<button><i class="bi bi-filetype-yml"></i></button>
<button><i class="bi bi-heart-arrow"></i></button>
<button><i class="bi bi-heart-pulse-fill"></i></button>
<button><i class="bi bi-heart-pulse"></i></button>
<button><i class="bi bi-heartbreak-fill"></i></button>
<button><i class="bi bi-heartbreak"></i></button>
<button><i class="bi bi-hearts"></i></button>
<button><i class="bi bi-hospital-fill"></i></button>
<button><i class="bi bi-hospital"></i></button>
<button><i class="bi bi-house-heart-fill"></i></button>
<button><i class="bi bi-house-heart"></i></button>
<button><i class="bi bi-incognito"></i></button>
<button><i class="bi bi-magnet-fill"></i></button>
<button><i class="bi bi-magnet"></i></button>
<button><i class="bi bi-person-heart"></i></button>
<button><i class="bi bi-person-hearts"></i></button>
<button><i class="bi bi-phone-flip"></i></button>
<button><i class="bi bi-plugin"></i></button>
<button><i class="bi bi-postage-fill"></i></button>
<button><i class="bi bi-postage-heart-fill"></i></button>
<button><i class="bi bi-postage-heart"></i></button>
<button><i class="bi bi-postage"></i></button>
<button><i class="bi bi-postcard-fill"></i></button>
<button><i class="bi bi-postcard-heart-fill"></i></button>
<button><i class="bi bi-postcard-heart"></i></button>
<button><i class="bi bi-postcard"></i></button>
<button><i class="bi bi-search-heart-fill"></i></button>
<button><i class="bi bi-search-heart"></i></button>
<button><i class="bi bi-sliders2-vertical"></i></button>
<button><i class="bi bi-sliders2"></i></button>
<button><i class="bi bi-trash3-fill"></i></button>
<button><i class="bi bi-trash3"></i></button>
<button><i class="bi bi-valentine"></i></button>
<button><i class="bi bi-valentine2"></i></button>
<button><i class="bi bi-wrench-adjustable-circle-fill"></i></button>
<button><i class="bi bi-wrench-adjustable-circle"></i></button>
<button><i class="bi bi-wrench-adjustable"></i></button>
<button><i class="bi bi-filetype-json"></i></button>
<button><i class="bi bi-filetype-pptx"></i></button>
<button><i class="bi bi-filetype-xlsx"></i></button>
<button><i class="bi bi-1-circle-fill"></i></button>
<button><i class="bi bi-1-circle"></i></button>
<button><i class="bi bi-1-square-fill"></i></button>
<button><i class="bi bi-1-square"></i></button>
<button><i class="bi bi-2-circle-fill"></i></button>
<button><i class="bi bi-2-circle"></i></button>
<button><i class="bi bi-2-square-fill"></i></button>
<button><i class="bi bi-2-square"></i></button>
<button><i class="bi bi-3-circle-fill"></i></button>
<button><i class="bi bi-3-circle"></i></button>
<button><i class="bi bi-3-square-fill"></i></button>
<button><i class="bi bi-3-square"></i></button>
<button><i class="bi bi-4-circle-fill"></i></button>
<button><i class="bi bi-4-circle"></i></button>
<button><i class="bi bi-4-square-fill"></i></button>
<button><i class="bi bi-4-square"></i></button>
<button><i class="bi bi-5-circle-fill"></i></button>
<button><i class="bi bi-5-circle"></i></button>
<button><i class="bi bi-5-square-fill"></i></button>
<button><i class="bi bi-5-square"></i></button>
<button><i class="bi bi-6-circle-fill"></i></button>
<button><i class="bi bi-6-circle"></i></button>
<button><i class="bi bi-6-square-fill"></i></button>
<button><i class="bi bi-6-square"></i></button>
<button><i class="bi bi-7-circle-fill"></i></button>
<button><i class="bi bi-7-circle"></i></button>
<button><i class="bi bi-7-square-fill"></i></button>
<button><i class="bi bi-7-square"></i></button>
<button><i class="bi bi-8-circle-fill"></i></button>
<button><i class="bi bi-8-circle"></i></button>
<button><i class="bi bi-8-square-fill"></i></button>
<button><i class="bi bi-8-square"></i></button>
<button><i class="bi bi-9-circle-fill"></i></button>
<button><i class="bi bi-9-circle"></i></button>
<button><i class="bi bi-9-square-fill"></i></button>
<button><i class="bi bi-9-square"></i></button>
<button><i class="bi bi-airplane-engines-fill"></i></button>
<button><i class="bi bi-airplane-engines"></i></button>
<button><i class="bi bi-airplane-fill"></i></button>
<button><i class="bi bi-airplane"></i></button>
<button><i class="bi bi-alexa"></i></button>
<button><i class="bi bi-alipay"></i></button>
<button><i class="bi bi-android"></i></button>
<button><i class="bi bi-android2"></i></button>
<button><i class="bi bi-box-fill"></i></button>
<button><i class="bi bi-box-seam-fill"></i></button>
<button><i class="bi bi-browser-chrome"></i></button>
<button><i class="bi bi-browser-edge"></i></button>
<button><i class="bi bi-browser-firefox"></i></button>
<button><i class="bi bi-browser-safari"></i></button>
<button><i class="bi bi-c-circle-fill"></i></button>`;
    html += `
<button><i class="bi bi-c-circle"></i></button>
<button><i class="bi bi-c-square-fill"></i></button>
<button><i class="bi bi-c-square"></i></button>
<button><i class="bi bi-capsule-pill"></i></button>
<button><i class="bi bi-capsule"></i></button>
<button><i class="bi bi-car-front-fill"></i></button>
<button><i class="bi bi-car-front"></i></button>
<button><i class="bi bi-cassette-fill"></i></button>
<button><i class="bi bi-cassette"></i></button>
<button><i class="bi bi-cc-circle-fill"></i></button>
<button><i class="bi bi-cc-circle"></i></button>
<button><i class="bi bi-cc-square-fill"></i></button>
<button><i class="bi bi-cc-square"></i></button>
<button><i class="bi bi-cup-hot-fill"></i></button>
<button><i class="bi bi-cup-hot"></i></button>
<button><i class="bi bi-currency-rupee"></i></button>
<button><i class="bi bi-dropbox"></i></button>
<button><i class="bi bi-escape"></i></button>
<button><i class="bi bi-fast-forward-btn-fill"></i></button>
<button><i class="bi bi-fast-forward-btn"></i></button>
<button><i class="bi bi-fast-forward-circle-fill"></i></button>
<button><i class="bi bi-fast-forward-circle"></i></button>
<button><i class="bi bi-fast-forward-fill"></i></button>
<button><i class="bi bi-fast-forward"></i></button>
<button><i class="bi bi-filetype-sql"></i></button>
<button><i class="bi bi-fire"></i></button>
<button><i class="bi bi-google-play"></i></button>
<button><i class="bi bi-h-circle-fill"></i></button>
<button><i class="bi bi-h-circle"></i></button>
<button><i class="bi bi-h-square-fill"></i></button>
<button><i class="bi bi-h-square"></i></button>
<button><i class="bi bi-indent"></i></button>
<button><i class="bi bi-lungs-fill"></i></button>
<button><i class="bi bi-lungs"></i></button>
<button><i class="bi bi-microsoft-teams"></i></button>
<button><i class="bi bi-p-circle-fill"></i></button>
<button><i class="bi bi-p-circle"></i></button>
<button><i class="bi bi-p-square-fill"></i></button>
<button><i class="bi bi-p-square"></i></button>
<button><i class="bi bi-pass-fill"></i></button>
<button><i class="bi bi-pass"></i></button>
<button><i class="bi bi-prescription"></i></button>
<button><i class="bi bi-prescription2"></i></button>
<button><i class="bi bi-r-circle-fill"></i></button>
<button><i class="bi bi-r-circle"></i></button>
<button><i class="bi bi-r-square-fill"></i></button>
<button><i class="bi bi-r-square"></i></button>
<button><i class="bi bi-repeat-1"></i></button>
<button><i class="bi bi-repeat"></i></button>
<button><i class="bi bi-rewind-btn-fill"></i></button>
<button><i class="bi bi-rewind-btn"></i></button>
<button><i class="bi bi-rewind-circle-fill"></i></button>
<button><i class="bi bi-rewind-circle"></i></button>
<button><i class="bi bi-rewind-fill"></i></button>
<button><i class="bi bi-rewind"></i></button>
<button><i class="bi bi-train-freight-front-fill"></i></button>
<button><i class="bi bi-train-freight-front"></i></button>
<button><i class="bi bi-train-front-fill"></i></button>
<button><i class="bi bi-train-front"></i></button>
<button><i class="bi bi-train-lightrail-front-fill"></i></button>
<button><i class="bi bi-train-lightrail-front"></i></button>
<button><i class="bi bi-truck-front-fill"></i></button>
<button><i class="bi bi-truck-front"></i></button>
<button><i class="bi bi-ubuntu"></i></button>
<button><i class="bi bi-unindent"></i></button>
<button><i class="bi bi-unity"></i></button>
<button><i class="bi bi-universal-access-circle"></i></button>
<button><i class="bi bi-universal-access"></i></button>
<button><i class="bi bi-virus"></i></button>
<button><i class="bi bi-virus2"></i></button>
<button><i class="bi bi-wechat"></i></button>
<button><i class="bi bi-yelp"></i></button>
<button><i class="bi bi-sign-stop-fill"></i></button>
<button><i class="bi bi-sign-stop-lights-fill"></i></button>
<button><i class="bi bi-sign-stop-lights"></i></button>
<button><i class="bi bi-sign-stop"></i></button>
<button><i class="bi bi-sign-turn-left-fill"></i></button>
<button><i class="bi bi-sign-turn-left"></i></button>
<button><i class="bi bi-sign-turn-right-fill"></i></button>
<button><i class="bi bi-sign-turn-right"></i></button>
<button><i class="bi bi-sign-turn-slight-left-fill"></i></button>
<button><i class="bi bi-sign-turn-slight-left"></i></button>
<button><i class="bi bi-sign-turn-slight-right-fill"></i></button>
<button><i class="bi bi-sign-turn-slight-right"></i></button>
<button><i class="bi bi-sign-yield-fill"></i></button>
<button><i class="bi bi-sign-yield"></i></button>
<button><i class="bi bi-ev-station-fill"></i></button>
<button><i class="bi bi-ev-station"></i></button>
<button><i class="bi bi-fuel-pump-diesel-fill"></i></button>
<button><i class="bi bi-fuel-pump-diesel"></i></button>
<button><i class="bi bi-fuel-pump-fill"></i></button>
<button><i class="bi bi-fuel-pump"></i></button>
<button><i class="bi bi-0-circle-fill"></i></button>
<button><i class="bi bi-0-circle"></i></button>
<button><i class="bi bi-0-square-fill"></i></button>
<button><i class="bi bi-0-square"></i></button>
<button><i class="bi bi-rocket-fill"></i></button>
<button><i class="bi bi-rocket-takeoff-fill"></i></button>
<button><i class="bi bi-rocket-takeoff"></i></button>`;
    html += `
<button><i class="bi bi-rocket"></i></button>
<button><i class="bi bi-stripe"></i></button>
<button><i class="bi bi-subscript"></i></button>
<button><i class="bi bi-superscript"></i></button>
<button><i class="bi bi-trello"></i></button>
<button><i class="bi bi-envelope-at-fill"></i></button>
<button><i class="bi bi-envelope-at"></i></button>
<button><i class="bi bi-regex"></i></button>
<button><i class="bi bi-text-wrap"></i></button>
<button><i class="bi bi-sign-dead-end-fill"></i></button>
<button><i class="bi bi-sign-dead-end"></i></button>
<button><i class="bi bi-sign-do-not-enter-fill"></i></button>
<button><i class="bi bi-sign-do-not-enter"></i></button>
<button><i class="bi bi-sign-intersection-fill"></i></button>
<button><i class="bi bi-sign-intersection-side-fill"></i></button>
<button><i class="bi bi-sign-intersection-side"></i></button>
<button><i class="bi bi-sign-intersection-t-fill"></i></button>
<button><i class="bi bi-sign-intersection-t"></i></button>
<button><i class="bi bi-sign-intersection-y-fill"></i></button>
<button><i class="bi bi-sign-intersection-y"></i></button>
<button><i class="bi bi-sign-intersection"></i></button>
<button><i class="bi bi-sign-merge-left-fill"></i></button>
<button><i class="bi bi-sign-merge-left"></i></button>
<button><i class="bi bi-sign-merge-right-fill"></i></button>
<button><i class="bi bi-sign-merge-right"></i></button>
<button><i class="bi bi-sign-no-left-turn-fill"></i></button>
<button><i class="bi bi-sign-no-left-turn"></i></button>
<button><i class="bi bi-sign-no-parking-fill"></i></button>
<button><i class="bi bi-sign-no-parking"></i></button>
<button><i class="bi bi-sign-no-right-turn-fill"></i></button>
<button><i class="bi bi-sign-no-right-turn"></i></button>
<button><i class="bi bi-sign-railroad-fill"></i></button>
<button><i class="bi bi-sign-railroad"></i></button>
<button><i class="bi bi-building-add"></i></button>
<button><i class="bi bi-building-check"></i></button>
<button><i class="bi bi-building-dash"></i></button>
<button><i class="bi bi-building-down"></i></button>
<button><i class="bi bi-building-exclamation"></i></button>
<button><i class="bi bi-building-fill-add"></i></button>
<button><i class="bi bi-building-fill-check"></i></button>
<button><i class="bi bi-building-fill-dash"></i></button>
<button><i class="bi bi-building-fill-down"></i></button>
<button><i class="bi bi-building-fill-exclamation"></i></button>
<button><i class="bi bi-building-fill-gear"></i></button>
<button><i class="bi bi-building-fill-lock"></i></button>
<button><i class="bi bi-building-fill-slash"></i></button>
<button><i class="bi bi-building-fill-up"></i></button>
<button><i class="bi bi-building-fill-x"></i></button>
<button><i class="bi bi-building-fill"></i></button>
<button><i class="bi bi-building-gear"></i></button>
<button><i class="bi bi-building-lock"></i></button>
<button><i class="bi bi-building-slash"></i></button>
<button><i class="bi bi-building-up"></i></button>
<button><i class="bi bi-building-x"></i></button>
<button><i class="bi bi-buildings-fill"></i></button>
<button><i class="bi bi-buildings"></i></button>
<button><i class="bi bi-bus-front-fill"></i></button>
<button><i class="bi bi-bus-front"></i></button>
<button><i class="bi bi-ev-front-fill"></i></button>
<button><i class="bi bi-ev-front"></i></button>
<button><i class="bi bi-globe-americas"></i></button>
<button><i class="bi bi-globe-asia-australia"></i></button>
<button><i class="bi bi-globe-central-south-asia"></i></button>
<button><i class="bi bi-globe-europe-africa"></i></button>
<button><i class="bi bi-house-add-fill"></i></button>
<button><i class="bi bi-house-add"></i></button>
<button><i class="bi bi-house-check-fill"></i></button>
<button><i class="bi bi-house-check"></i></button>
<button><i class="bi bi-house-dash-fill"></i></button>
<button><i class="bi bi-house-dash"></i></button>
<button><i class="bi bi-house-down-fill"></i></button>
<button><i class="bi bi-house-down"></i></button>
<button><i class="bi bi-house-exclamation-fill"></i></button>
<button><i class="bi bi-house-exclamation"></i></button>
<button><i class="bi bi-house-gear-fill"></i></button>
<button><i class="bi bi-house-gear"></i></button>
<button><i class="bi bi-house-lock-fill"></i></button>
<button><i class="bi bi-house-lock"></i></button>
<button><i class="bi bi-house-slash-fill"></i></button>
<button><i class="bi bi-house-slash"></i></button>
<button><i class="bi bi-house-up-fill"></i></button>
<button><i class="bi bi-house-up"></i></button>
<button><i class="bi bi-house-x-fill"></i></button>
<button><i class="bi bi-house-x"></i></button>
<button><i class="bi bi-person-add"></i></button>
<button><i class="bi bi-person-down"></i></button>
<button><i class="bi bi-person-exclamation"></i></button>
<button><i class="bi bi-person-fill-add"></i></button>
<button><i class="bi bi-person-fill-check"></i></button>
<button><i class="bi bi-person-fill-dash"></i></button>
<button><i class="bi bi-person-fill-down"></i></button>
<button><i class="bi bi-person-fill-exclamation"></i></button>
<button><i class="bi bi-person-fill-gear"></i></button>
<button><i class="bi bi-person-fill-lock"></i></button>
<button><i class="bi bi-person-fill-slash"></i></button>
<button><i class="bi bi-person-fill-up"></i></button>
<button><i class="bi bi-person-fill-x"></i></button>
<button><i class="bi bi-person-gear"></i></button>
<button><i class="bi bi-person-lock"></i></button>`;
    html += `
<button><i class="bi bi-person-slash"></i></button>
<button><i class="bi bi-person-up"></i></button>
<button><i class="bi bi-scooter"></i></button>
<button><i class="bi bi-taxi-front-fill"></i></button>
<button><i class="bi bi-taxi-front"></i></button>
<button><i class="bi bi-amd"></i></button>
<button><i class="bi bi-database-add"></i></button>
<button><i class="bi bi-database-check"></i></button>
<button><i class="bi bi-database-dash"></i></button>
<button><i class="bi bi-database-down"></i></button>
<button><i class="bi bi-database-exclamation"></i></button>
<button><i class="bi bi-database-fill-add"></i></button>
<button><i class="bi bi-database-fill-check"></i></button>
<button><i class="bi bi-database-fill-dash"></i></button>
<button><i class="bi bi-database-fill-down"></i></button>
<button><i class="bi bi-database-fill-exclamation"></i></button>
<button><i class="bi bi-database-fill-gear"></i></button>
<button><i class="bi bi-database-fill-lock"></i></button>
<button><i class="bi bi-database-fill-slash"></i></button>
<button><i class="bi bi-database-fill-up"></i></button>
<button><i class="bi bi-database-fill-x"></i></button>
<button><i class="bi bi-database-fill"></i></button>
<button><i class="bi bi-database-gear"></i></button>
<button><i class="bi bi-database-lock"></i></button>
<button><i class="bi bi-database-slash"></i></button>
<button><i class="bi bi-database-up"></i></button>
<button><i class="bi bi-database-x"></i></button>
<button><i class="bi bi-database"></i></button>
<button><i class="bi bi-houses-fill"></i></button>
<button><i class="bi bi-houses"></i></button>
<button><i class="bi bi-nvidia"></i></button>
<button><i class="bi bi-person-vcard-fill"></i></button>
<button><i class="bi bi-person-vcard"></i></button>
<button><i class="bi bi-sina-weibo"></i></button>
<button><i class="bi bi-tencent-qq"></i></button>
<button><i class="bi bi-wikipedia"></i></button>
<button><i class="bi bi-alphabet-uppercase"></i></button>
<button><i class="bi bi-alphabet"></i></button>
<button><i class="bi bi-amazon"></i></button>
<button><i class="bi bi-arrows-collapse-vertical"></i></button>
<button><i class="bi bi-arrows-expand-vertical"></i></button>
<button><i class="bi bi-arrows-vertical"></i></button>
<button><i class="bi bi-arrows"></i></button>
<button><i class="bi bi-ban-fill"></i></button>
<button><i class="bi bi-ban"></i></button>
<button><i class="bi bi-bing"></i></button>
<button><i class="bi bi-cake"></i></button>
<button><i class="bi bi-cake2"></i></button>
<button><i class="bi bi-cookie"></i></button>
<button><i class="bi bi-copy"></i></button>
<button><i class="bi bi-crosshair"></i></button>
<button><i class="bi bi-crosshair2"></i></button>
<button><i class="bi bi-emoji-astonished-fill"></i></button>
<button><i class="bi bi-emoji-astonished"></i></button>
<button><i class="bi bi-emoji-grimace-fill"></i></button>
<button><i class="bi bi-emoji-grimace"></i></button>
<button><i class="bi bi-emoji-grin-fill"></i></button>
<button><i class="bi bi-emoji-grin"></i></button>
<button><i class="bi bi-emoji-surprise-fill"></i></button>
<button><i class="bi bi-emoji-surprise"></i></button>
<button><i class="bi bi-emoji-tear-fill"></i></button>
<button><i class="bi bi-emoji-tear"></i></button>
<button><i class="bi bi-envelope-arrow-down-fill"></i></button>
<button><i class="bi bi-envelope-arrow-down"></i></button>
<button><i class="bi bi-envelope-arrow-up-fill"></i></button>
<button><i class="bi bi-envelope-arrow-up"></i></button>
<button><i class="bi bi-feather"></i></button>
<button><i class="bi bi-feather2"></i></button>
<button><i class="bi bi-floppy-fill"></i></button>
<button><i class="bi bi-floppy"></i></button>
<button><i class="bi bi-floppy2-fill"></i></button>
<button><i class="bi bi-floppy2"></i></button>
<button><i class="bi bi-gitlab"></i></button>
<button><i class="bi bi-highlighter"></i></button>
<button><i class="bi bi-marker-tip"></i></button>
<button><i class="bi bi-nvme-fill"></i></button>
<button><i class="bi bi-nvme"></i></button>
<button><i class="bi bi-opencollective"></i></button>
<button><i class="bi bi-pci-card-network"></i></button>
<button><i class="bi bi-pci-card-sound"></i></button>
<button><i class="bi bi-radar"></i></button>
<button><i class="bi bi-send-arrow-down-fill"></i></button>
<button><i class="bi bi-send-arrow-down"></i></button>
<button><i class="bi bi-send-arrow-up-fill"></i></button>
<button><i class="bi bi-send-arrow-up"></i></button>
<button><i class="bi bi-sim-slash-fill"></i></button>
<button><i class="bi bi-sim-slash"></i></button>
<button><i class="bi bi-sourceforge"></i></button>
<button><i class="bi bi-substack"></i></button>
<button><i class="bi bi-threads-fill"></i></button>
<button><i class="bi bi-threads"></i></button>
<button><i class="bi bi-transparency"></i></button>
<button><i class="bi bi-twitter-x"></i></button>
<button><i class="bi bi-type-h4"></i></button>
<button><i class="bi bi-type-h5"></i></button>
<button><i class="bi bi-type-h6"></i></button>
<button><i class="bi bi-backpack-fill"></i></button>
<button><i class="bi bi-backpack"></i></button>
<button><i class="bi bi-backpack2-fill"></i></button>`;
    html += `
<button><i class="bi bi-backpack2"></i></button>
<button><i class="bi bi-backpack3-fill"></i></button>
<button><i class="bi bi-backpack3"></i></button>
<button><i class="bi bi-backpack4-fill"></i></button>
<button><i class="bi bi-backpack4"></i></button>
<button><i class="bi bi-brilliance"></i></button>
<button><i class="bi bi-cake-fill"></i></button>
<button><i class="bi bi-cake2-fill"></i></button>
<button><i class="bi bi-duffle-fill"></i></button>
<button><i class="bi bi-duffle"></i></button>
<button><i class="bi bi-exposure"></i></button>
<button><i class="bi bi-gender-neuter"></i></button>
<button><i class="bi bi-highlights"></i></button>
<button><i class="bi bi-luggage-fill"></i></button>
<button><i class="bi bi-luggage"></i></button>
<button><i class="bi bi-mailbox-flag"></i></button>
<button><i class="bi bi-mailbox2-flag"></i></button>
<button><i class="bi bi-noise-reduction"></i></button>
<button><i class="bi bi-passport-fill"></i></button>
<button><i class="bi bi-passport"></i></button>
<button><i class="bi bi-person-arms-up"></i></button>
<button><i class="bi bi-person-raised-hand"></i></button>
<button><i class="bi bi-person-standing-dress"></i></button>
<button><i class="bi bi-person-standing"></i></button>
<button><i class="bi bi-person-walking"></i></button>
<button><i class="bi bi-person-wheelchair"></i></button>
<button><i class="bi bi-shadows"></i></button>
<button><i class="bi bi-suitcase-fill"></i></button>
<button><i class="bi bi-suitcase-lg-fill"></i></button>
<button><i class="bi bi-suitcase-lg"></i></button>
<button><i class="bi bi-suitcase"></i></button>
<button><i class="bi bi-suitcase2-fill"></i></button>
<button><i class="bi bi-suitcase2"></i></button>
<button><i class="bi bi-vignette"></i></button>
        `;
    return html;
  }
  getIcons() {
    let html = `
<button><i class="icon ion-alert"> </i></button>
<button><i class="icon ion-alert-circled"> </i></button>
<button><i class="icon ion-android-add"> </i></button>
<button><i class="icon ion-android-add-circle"> </i></button>
<button><i class="icon ion-android-alarm-clock"> </i></button>
<button><i class="icon ion-android-alert"> </i></button>
<button><i class="icon ion-android-apps"> </i></button>
<button><i class="icon ion-android-archive"> </i></button>
<button><i class="icon ion-android-arrow-back"> </i></button>
<button><i class="icon ion-android-arrow-down"> </i></button>
<button><i class="icon ion-android-arrow-dropdown"> </i></button>
<button><i class="icon ion-android-arrow-dropdown-circle"> </i></button>
<button><i class="icon ion-android-arrow-dropleft"> </i></button>
<button><i class="icon ion-android-arrow-dropleft-circle"> </i></button>
<button><i class="icon ion-android-arrow-dropright"> </i></button>
<button><i class="icon ion-android-arrow-dropright-circle"> </i></button>
<button><i class="icon ion-android-arrow-dropup"> </i></button>
<button><i class="icon ion-android-arrow-dropup-circle"> </i></button>
<button><i class="icon ion-android-arrow-forward"> </i></button>
<button><i class="icon ion-android-arrow-up"> </i></button>
<button><i class="icon ion-android-attach"> </i></button>
<button><i class="icon ion-android-bar"> </i></button>
<button><i class="icon ion-android-bicycle"> </i></button>
<button><i class="icon ion-android-boat"> </i></button>
<button><i class="icon ion-android-bookmark"> </i></button>
<button><i class="icon ion-android-bulb"> </i></button>
<button><i class="icon ion-android-bus"> </i></button>
<button><i class="icon ion-android-calendar"> </i></button>
<button><i class="icon ion-android-call"> </i></button>
<button><i class="icon ion-android-camera"> </i></button>
<button><i class="icon ion-android-cancel"> </i></button>
<button><i class="icon ion-android-car"> </i></button>
<button><i class="icon ion-android-cart"> </i></button>
<button><i class="icon ion-android-chat"> </i></button>
<button><i class="icon ion-android-checkbox"> </i></button>
<button><i class="icon ion-android-checkbox-blank"> </i></button>
<button><i class="icon ion-android-checkbox-outline"> </i></button>
<button><i class="icon ion-android-checkbox-outline-blank"> </i></button>
<button><i class="icon ion-android-checkmark-circle"> </i></button>
<button><i class="icon ion-android-clipboard"> </i></button>
<button><i class="icon ion-android-close"> </i></button>
<button><i class="icon ion-android-cloud"> </i></button>
<button><i class="icon ion-android-cloud-circle"> </i></button>
<button><i class="icon ion-android-cloud-done"> </i></button>
<button><i class="icon ion-android-cloud-outline"> </i></button>
<button><i class="icon ion-android-color-palette"> </i></button>
<button><i class="icon ion-android-compass"> </i></button>
<button><i class="icon ion-android-contact"> </i></button>
<button><i class="icon ion-android-contacts"> </i></button>
<button><i class="icon ion-android-contract"> </i></button>
<button><i class="icon ion-android-create"> </i></button>
<button><i class="icon ion-android-delete"> </i></button>
<button><i class="icon ion-android-desktop"> </i></button>
<button><i class="icon ion-android-document"> </i></button>
<button><i class="icon ion-android-done"> </i></button>
<button><i class="icon ion-android-done-all"> </i></button>
<button><i class="icon ion-android-download"> </i></button>
<button><i class="icon ion-android-drafts"> </i></button>
<button><i class="icon ion-android-exit"> </i></button>
<button><i class="icon ion-android-expand"> </i></button>
<button><i class="icon ion-android-favorite"> </i></button>
<button><i class="icon ion-android-favorite-outline"> </i></button>
<button><i class="icon ion-android-film"> </i></button>
<button><i class="icon ion-android-folder"> </i></button>
<button><i class="icon ion-android-folder-open"> </i></button>
<button><i class="icon ion-android-funnel"> </i></button>
<button><i class="icon ion-android-globe"> </i></button>
<button><i class="icon ion-android-hand"> </i></button>
<button><i class="icon ion-android-hangout"> </i></button>
<button><i class="icon ion-android-happy"> </i></button>
<button><i class="icon ion-android-home"> </i></button>
<button><i class="icon ion-android-image"> </i></button>
<button><i class="icon ion-android-laptop"> </i></button>
<button><i class="icon ion-android-list"> </i></button>
<button><i class="icon ion-android-locate"> </i></button>
<button><i class="icon ion-android-lock"> </i></button>
<button><i class="icon ion-android-mail"> </i></button>
<button><i class="icon ion-android-map"> </i></button>
<button><i class="icon ion-android-menu"> </i></button>
<button><i class="icon ion-android-microphone"> </i></button>
<button><i class="icon ion-android-microphone-off"> </i></button>
<button><i class="icon ion-android-more-horizontal"> </i></button>
<button><i class="icon ion-android-more-vertical"> </i></button>
<button><i class="icon ion-android-navigate"> </i></button>
<button><i class="icon ion-android-notifications"> </i></button>
<button><i class="icon ion-android-notifications-none"> </i></button>
<button><i class="icon ion-android-notifications-off"> </i></button>
<button><i class="icon ion-android-open"> </i></button>
<button><i class="icon ion-android-options"> </i></button>
<button><i class="icon ion-android-people"> </i></button>
<button><i class="icon ion-android-person"> </i></button>
<button><i class="icon ion-android-person-add"> </i></button>
<button><i class="icon ion-android-phone-landscape"> </i></button>
<button><i class="icon ion-android-phone-portrait"> </i></button>
<button><i class="icon ion-android-pin"> </i></button>
<button><i class="icon ion-android-plane"> </i></button>
<button><i class="icon ion-android-playstore"> </i></button>
<button><i class="icon ion-android-print"> </i></button>
<button><i class="icon ion-android-radio-button-off"> </i></button>
<button><i class="icon ion-android-radio-button-on"> </i></button>
<button><i class="icon ion-android-refresh"> </i></button>
<button><i class="icon ion-android-remove"> </i></button>
<button><i class="icon ion-android-remove-circle"> </i></button>
<button><i class="icon ion-android-restaurant"> </i></button>
<button><i class="icon ion-android-sad"> </i></button>
<button><i class="icon ion-android-search"> </i></button>
<button><i class="icon ion-android-send"> </i></button>
<button><i class="icon ion-android-settings"> </i></button>
<button><i class="icon ion-android-share"> </i></button>
<button><i class="icon ion-android-share-alt"> </i></button>
<button><i class="icon ion-android-star"> </i></button>
<button><i class="icon ion-android-star-half"> </i></button>
<button><i class="icon ion-android-star-outline"> </i></button>
<button><i class="icon ion-android-stopwatch"> </i></button>
<button><i class="icon ion-android-subway"> </i></button>
<button><i class="icon ion-android-sunny"> </i></button>
<button><i class="icon ion-android-sync"> </i></button>
<button><i class="icon ion-android-textsms"> </i></button>`;
    html += `
<button><i class="icon ion-android-time"> </i></button>
<button><i class="icon ion-android-train"> </i></button>
<button><i class="icon ion-android-unlock"> </i></button>
<button><i class="icon ion-android-upload"> </i></button>
<button><i class="icon ion-android-volume-down"> </i></button>
<button><i class="icon ion-android-volume-mute"> </i></button>
<button><i class="icon ion-android-volume-off"> </i></button>
<button><i class="icon ion-android-volume-up"> </i></button>
<button><i class="icon ion-android-walk"> </i></button>
<button><i class="icon ion-android-warning"> </i></button>
<button><i class="icon ion-android-watch"> </i></button>
<button><i class="icon ion-android-wifi"> </i></button>
<button><i class="icon ion-aperture"> </i></button>
<button><i class="icon ion-archive"> </i></button>
<button><i class="icon ion-arrow-down-a"> </i></button>
<button><i class="icon ion-arrow-down-b"> </i></button>
<button><i class="icon ion-arrow-down-c"> </i></button>
<button><i class="icon ion-arrow-expand"> </i></button>
<button><i class="icon ion-arrow-graph-down-left"> </i></button>
<button><i class="icon ion-arrow-graph-down-right"> </i></button>
<button><i class="icon ion-arrow-graph-up-left"> </i></button>
<button><i class="icon ion-arrow-graph-up-right"> </i></button>
<button><i class="icon ion-arrow-left-a"> </i></button>
<button><i class="icon ion-arrow-left-b"> </i></button>
<button><i class="icon ion-arrow-left-c"> </i></button>
<button><i class="icon ion-arrow-move"> </i></button>
<button><i class="icon ion-arrow-resize"> </i></button>
<button><i class="icon ion-arrow-return-left"> </i></button>
<button><i class="icon ion-arrow-return-right"> </i></button>
<button><i class="icon ion-arrow-right-a"> </i></button>
<button><i class="icon ion-arrow-right-b"> </i></button>
<button><i class="icon ion-arrow-right-c"> </i></button>
<button><i class="icon ion-arrow-shrink"> </i></button>
<button><i class="icon ion-arrow-swap"> </i></button>
<button><i class="icon ion-arrow-up-a"> </i></button>
<button><i class="icon ion-arrow-up-b"> </i></button>
<button><i class="icon ion-arrow-up-c"> </i></button>
<button><i class="icon ion-asterisk"> </i></button>
<button><i class="icon ion-at"> </i></button>
<button><i class="icon ion-backspace"> </i></button>
<button><i class="icon ion-backspace-outline"> </i></button>
<button><i class="icon ion-bag"> </i></button>
<button><i class="icon ion-battery-charging"> </i></button>
<button><i class="icon ion-battery-empty"> </i></button>
<button><i class="icon ion-battery-full"> </i></button>
<button><i class="icon ion-battery-half"> </i></button>
<button><i class="icon ion-battery-low"> </i></button>
<button><i class="icon ion-beaker"> </i></button>
<button><i class="icon ion-beer"> </i></button>
<button><i class="icon ion-bluetooth"> </i></button>
<button><i class="icon ion-bonfire"> </i></button>
<button><i class="icon ion-bookmark"> </i></button>
<button><i class="icon ion-bowtie"> </i></button>
<button><i class="icon ion-briefcase"> </i></button>
<button><i class="icon ion-bug"> </i></button>
<button><i class="icon ion-calculator"> </i></button>
<button><i class="icon ion-calendar"> </i></button>
<button><i class="icon ion-camera"> </i></button>
<button><i class="icon ion-card"> </i></button>
<button><i class="icon ion-cash"> </i></button>
<button><i class="icon ion-chatbox"> </i></button>
<button><i class="icon ion-chatbox-working"> </i></button>
<button><i class="icon ion-chatboxes"> </i></button>
<button><i class="icon ion-chatbubble"> </i></button>
<button><i class="icon ion-chatbubble-working"> </i></button>
<button><i class="icon ion-chatbubbles"> </i></button>
<button><i class="icon ion-checkmark"> </i></button>
<button><i class="icon ion-checkmark-circled"> </i></button>
<button><i class="icon ion-checkmark-round"> </i></button>
<button><i class="icon ion-chevron-down"> </i></button>
<button><i class="icon ion-chevron-left"> </i></button>
<button><i class="icon ion-chevron-right"> </i></button>
<button><i class="icon ion-chevron-up"> </i></button>
<button><i class="icon ion-clipboard"> </i></button>
<button><i class="icon ion-clock"> </i></button>
<button><i class="icon ion-close"> </i></button>
<button><i class="icon ion-close-circled"> </i></button>
<button><i class="icon ion-close-round"> </i></button>
<button><i class="icon ion-closed-captioning"> </i></button>
<button><i class="icon ion-cloud"> </i></button>
<button><i class="icon ion-code"> </i></button>
<button><i class="icon ion-code-download"> </i></button>
<button><i class="icon ion-code-working"> </i></button>
<button><i class="icon ion-coffee"> </i></button>
<button><i class="icon ion-compass"> </i></button>
<button><i class="icon ion-compose"> </i></button>
<button><i class="icon ion-connection-bars"> </i></button>
<button><i class="icon ion-contrast"> </i></button>
<button><i class="icon ion-crop"> </i></button>
<button><i class="icon ion-cube"> </i></button>
<button><i class="icon ion-disc"> </i></button>
<button><i class="icon ion-document"> </i></button>
<button><i class="icon ion-document-text"> </i></button>
<button><i class="icon ion-drag"> </i></button>
<button><i class="icon ion-earth"> </i></button>
<button><i class="icon ion-easel"> </i></button>
<button><i class="icon ion-edit"> </i></button>
<button><i class="icon ion-egg"> </i></button>
<button><i class="icon ion-eject"> </i></button>
<button><i class="icon ion-email"> </i></button>
<button><i class="icon ion-email-unread"> </i></button>
<button><i class="icon ion-erlenmeyer-flask"> </i></button>
<button><i class="icon ion-erlenmeyer-flask-bubbles"> </i></button>
<button><i class="icon ion-eye"> </i></button>
<button><i class="icon ion-eye-disabled"> </i></button>
<button><i class="icon ion-female"> </i></button>
<button><i class="icon ion-filing"> </i></button>
<button><i class="icon ion-film-marker"> </i></button>
<button><i class="icon ion-fireball"> </i></button>
<button><i class="icon ion-flag"> </i></button>
<button><i class="icon ion-flame"> </i></button>
<button><i class="icon ion-flash"> </i></button>
<button><i class="icon ion-flash-off"> </i></button>
<button><i class="icon ion-folder"> </i></button>
<button><i class="icon ion-fork"> </i></button>
<button><i class="icon ion-fork-repo"> </i></button>
<button><i class="icon ion-forward"> </i></button>
<button><i class="icon ion-funnel"> </i></button>
<button><i class="icon ion-gear-a"> </i></button>
<button><i class="icon ion-gear-b"> </i></button>
<button><i class="icon ion-grid"> </i></button>
<button><i class="icon ion-hammer"> </i></button>
<button><i class="icon ion-happy"> </i></button>
<button><i class="icon ion-happy-outline"> </i></button>
<button><i class="icon ion-headphone"> </i></button>
<button><i class="icon ion-heart"> </i></button>
<button><i class="icon ion-heart-broken"> </i></button>
<button><i class="icon ion-help"> </i></button>
<button><i class="icon ion-help-buoy"> </i></button>
<button><i class="icon ion-help-circled"> </i></button>
<button><i class="icon ion-home"> </i></button>
<button><i class="icon ion-icecream"> </i></button>
<button><i class="icon ion-image"> </i></button>
<button><i class="icon ion-images"> </i></button>
<button><i class="icon ion-information"> </i></button>
<button><i class="icon ion-information-circled"> </i></button>
<button><i class="icon ion-ionic"> </i></button>
<button><i class="icon ion-ios-alarm"> </i></button>
<button><i class="icon ion-ios-alarm-outline"> </i></button>
<button><i class="icon ion-ios-albums"> </i></button>
<button><i class="icon ion-ios-albums-outline"> </i></button>
<button><i class="icon ion-ios-americanfootball"> </i></button>
<button><i class="icon ion-ios-americanfootball-outline"> </i></button>
<button><i class="icon ion-ios-analytics"> </i></button>
<button><i class="icon ion-ios-analytics-outline"> </i></button>
<button><i class="icon ion-ios-arrow-back"> </i></button>
<button><i class="icon ion-ios-arrow-down"> </i></button>
<button><i class="icon ion-ios-arrow-forward"> </i></button>
<button><i class="icon ion-ios-arrow-left"> </i></button>`;
    html += `
<button><i class="icon ion-ios-arrow-right"> </i></button>
<button><i class="icon ion-ios-arrow-thin-down"> </i></button>
<button><i class="icon ion-ios-arrow-thin-left"> </i></button>
<button><i class="icon ion-ios-arrow-thin-right"> </i></button>
<button><i class="icon ion-ios-arrow-thin-up"> </i></button>
<button><i class="icon ion-ios-arrow-up"> </i></button>
<button><i class="icon ion-ios-at"> </i></button>
<button><i class="icon ion-ios-at-outline"> </i></button>
<button><i class="icon ion-ios-barcode"> </i></button>
<button><i class="icon ion-ios-barcode-outline"> </i></button>
<button><i class="icon ion-ios-baseball"> </i></button>
<button><i class="icon ion-ios-baseball-outline"> </i></button>
<button><i class="icon ion-ios-basketball"> </i></button>
<button><i class="icon ion-ios-basketball-outline"> </i></button>
<button><i class="icon ion-ios-bell"> </i></button>
<button><i class="icon ion-ios-bell-outline"> </i></button>
<button><i class="icon ion-ios-body"> </i></button>
<button><i class="icon ion-ios-body-outline"> </i></button>
<button><i class="icon ion-ios-bolt"> </i></button>
<button><i class="icon ion-ios-bolt-outline"> </i></button>
<button><i class="icon ion-ios-book"> </i></button>
<button><i class="icon ion-ios-book-outline"> </i></button>
<button><i class="icon ion-ios-bookmarks"> </i></button>
<button><i class="icon ion-ios-bookmarks-outline"> </i></button>
<button><i class="icon ion-ios-box"> </i></button>
<button><i class="icon ion-ios-box-outline"> </i></button>
<button><i class="icon ion-ios-briefcase"> </i></button>
<button><i class="icon ion-ios-briefcase-outline"> </i></button>
<button><i class="icon ion-ios-browsers"> </i></button>
<button><i class="icon ion-ios-browsers-outline"> </i></button>
<button><i class="icon ion-ios-calculator"> </i></button>
<button><i class="icon ion-ios-calculator-outline"> </i></button>
<button><i class="icon ion-ios-calendar"> </i></button>
<button><i class="icon ion-ios-calendar-outline"> </i></button>
<button><i class="icon ion-ios-camera"> </i></button>
<button><i class="icon ion-ios-camera-outline"> </i></button>
<button><i class="icon ion-ios-cart"> </i></button>
<button><i class="icon ion-ios-cart-outline"> </i></button>
<button><i class="icon ion-ios-chatboxes"> </i></button>
<button><i class="icon ion-ios-chatboxes-outline"> </i></button>
<button><i class="icon ion-ios-chatbubble"> </i></button>
<button><i class="icon ion-ios-chatbubble-outline"> </i></button>
<button><i class="icon ion-ios-checkmark"> </i></button>
<button><i class="icon ion-ios-checkmark-empty"> </i></button>
<button><i class="icon ion-ios-checkmark-outline"> </i></button>
<button><i class="icon ion-ios-circle-filled"> </i></button>
<button><i class="icon ion-ios-circle-outline"> </i></button>
<button><i class="icon ion-ios-clock"> </i></button>
<button><i class="icon ion-ios-clock-outline"> </i></button>
<button><i class="icon ion-ios-close"> </i></button>
<button><i class="icon ion-ios-close-empty"> </i></button>
<button><i class="icon ion-ios-close-outline"> </i></button>
<button><i class="icon ion-ios-cloud"> </i></button>
<button><i class="icon ion-ios-cloud-download"> </i></button>
<button><i class="icon ion-ios-cloud-download-outline"> </i></button>
<button><i class="icon ion-ios-cloud-outline"> </i></button>
<button><i class="icon ion-ios-cloud-upload"> </i></button>
<button><i class="icon ion-ios-cloud-upload-outline"> </i></button>
<button><i class="icon ion-ios-cloudy"> </i></button>
<button><i class="icon ion-ios-cloudy-night"> </i></button>
<button><i class="icon ion-ios-cloudy-night-outline"> </i></button>
<button><i class="icon ion-ios-cloudy-outline"> </i></button>
<button><i class="icon ion-ios-cog"> </i></button>
<button><i class="icon ion-ios-cog-outline"> </i></button>
<button><i class="icon ion-ios-color-filter"> </i></button>
<button><i class="icon ion-ios-color-filter-outline"> </i></button>
<button><i class="icon ion-ios-color-wand"> </i></button>
<button><i class="icon ion-ios-color-wand-outline"> </i></button>
<button><i class="icon ion-ios-compose"> </i></button>
<button><i class="icon ion-ios-compose-outline"> </i></button>
<button><i class="icon ion-ios-contact"> </i></button>
<button><i class="icon ion-ios-contact-outline"> </i></button>
<button><i class="icon ion-ios-copy"> </i></button>
<button><i class="icon ion-ios-copy-outline"> </i></button>
<button><i class="icon ion-ios-crop"> </i></button>
<button><i class="icon ion-ios-crop-strong"> </i></button>
<button><i class="icon ion-ios-download"> </i></button>
<button><i class="icon ion-ios-download-outline"> </i></button>
<button><i class="icon ion-ios-drag"> </i></button>
<button><i class="icon ion-ios-email"> </i></button>
<button><i class="icon ion-ios-email-outline"> </i></button>
<button><i class="icon ion-ios-eye"> </i></button>
<button><i class="icon ion-ios-eye-outline"> </i></button>
<button><i class="icon ion-ios-fastforward"> </i></button>
<button><i class="icon ion-ios-fastforward-outline"> </i></button>
<button><i class="icon ion-ios-filing"> </i></button>
<button><i class="icon ion-ios-filing-outline"> </i></button>
<button><i class="icon ion-ios-film"> </i></button>
<button><i class="icon ion-ios-film-outline"> </i></button>
<button><i class="icon ion-ios-flag"> </i></button>
<button><i class="icon ion-ios-flag-outline"> </i></button>
<button><i class="icon ion-ios-flame"> </i></button>
<button><i class="icon ion-ios-flame-outline"> </i></button>
<button><i class="icon ion-ios-flask"> </i></button>
<button><i class="icon ion-ios-flask-outline"> </i></button>
<button><i class="icon ion-ios-flower"> </i></button>
<button><i class="icon ion-ios-flower-outline"> </i></button>
<button><i class="icon ion-ios-folder"> </i></button>
<button><i class="icon ion-ios-folder-outline"> </i></button>
<button><i class="icon ion-ios-football"> </i></button>
<button><i class="icon ion-ios-football-outline"> </i></button>
<button><i class="icon ion-ios-game-controller-a"> </i></button>
<button><i class="icon ion-ios-game-controller-a-outline"> </i></button>
<button><i class="icon ion-ios-game-controller-b"> </i></button>
<button><i class="icon ion-ios-game-controller-b-outline"> </i></button>
<button><i class="icon ion-ios-gear"> </i></button>
<button><i class="icon ion-ios-gear-outline"> </i></button>
<button><i class="icon ion-ios-glasses"> </i></button>
<button><i class="icon ion-ios-glasses-outline"> </i></button>
<button><i class="icon ion-ios-grid-view"> </i></button>
<button><i class="icon ion-ios-grid-view-outline"> </i></button>
<button><i class="icon ion-ios-heart"> </i></button>
<button><i class="icon ion-ios-heart-outline"> </i></button>
<button><i class="icon ion-ios-help"> </i></button>
<button><i class="icon ion-ios-help-empty"> </i></button>
<button><i class="icon ion-ios-help-outline"> </i></button>
<button><i class="icon ion-ios-home"> </i></button>
<button><i class="icon ion-ios-home-outline"> </i></button>
<button><i class="icon ion-ios-infinite"> </i></button>
<button><i class="icon ion-ios-infinite-outline"> </i></button>
<button><i class="icon ion-ios-information"> </i></button>
<button><i class="icon ion-ios-information-empty"> </i></button>
<button><i class="icon ion-ios-information-outline"> </i></button>
<button><i class="icon ion-ios-ionic-outline"> </i></button>
<button><i class="icon ion-ios-keypad"> </i></button>
<button><i class="icon ion-ios-keypad-outline"> </i></button>
<button><i class="icon ion-ios-lightbulb"> </i></button>
<button><i class="icon ion-ios-lightbulb-outline"> </i></button>
<button><i class="icon ion-ios-list"> </i></button>
<button><i class="icon ion-ios-list-outline"> </i></button>
<button><i class="icon ion-ios-location"> </i></button>
<button><i class="icon ion-ios-location-outline"> </i></button>
<button><i class="icon ion-ios-locked"> </i></button>
<button><i class="icon ion-ios-locked-outline"> </i></button>
<button><i class="icon ion-ios-loop"> </i></button>
<button><i class="icon ion-ios-loop-strong"> </i></button>
<button><i class="icon ion-ios-medical"> </i></button>
<button><i class="icon ion-ios-medical-outline"> </i></button>
<button><i class="icon ion-ios-medkit"> </i></button>
<button><i class="icon ion-ios-medkit-outline"> </i></button>
<button><i class="icon ion-ios-mic"> </i></button>
<button><i class="icon ion-ios-mic-off"> </i></button>
<button><i class="icon ion-ios-mic-outline"> </i></button>
<button><i class="icon ion-ios-minus"> </i></button>
<button><i class="icon ion-ios-minus-empty"> </i></button>
<button><i class="icon ion-ios-minus-outline"> </i></button>
<button><i class="icon ion-ios-monitor"> </i></button>
<button><i class="icon ion-ios-monitor-outline"> </i></button>`;
    html += `
<button><i class="icon ion-ios-moon"> </i></button>
<button><i class="icon ion-ios-moon-outline"> </i></button>
<button><i class="icon ion-ios-more"> </i></button>
<button><i class="icon ion-ios-more-outline"> </i></button>
<button><i class="icon ion-ios-musical-note"> </i></button>
<button><i class="icon ion-ios-musical-notes"> </i></button>
<button><i class="icon ion-ios-navigate"> </i></button>
<button><i class="icon ion-ios-navigate-outline"> </i></button>
<button><i class="icon ion-ios-nutrition"> </i></button>
<button><i class="icon ion-ios-nutrition-outline"> </i></button>
<button><i class="icon ion-ios-paper"> </i></button>
<button><i class="icon ion-ios-paper-outline"> </i></button>
<button><i class="icon ion-ios-paperplane"> </i></button>
<button><i class="icon ion-ios-paperplane-outline"> </i></button>
<button><i class="icon ion-ios-partlysunny"> </i></button>
<button><i class="icon ion-ios-partlysunny-outline"> </i></button>
<button><i class="icon ion-ios-pause"> </i></button>
<button><i class="icon ion-ios-pause-outline"> </i></button>
<button><i class="icon ion-ios-paw"> </i></button>
<button><i class="icon ion-ios-paw-outline"> </i></button>
<button><i class="icon ion-ios-people"> </i></button>
<button><i class="icon ion-ios-people-outline"> </i></button>
<button><i class="icon ion-ios-person"> </i></button>
<button><i class="icon ion-ios-person-outline"> </i></button>
<button><i class="icon ion-ios-personadd"> </i></button>
<button><i class="icon ion-ios-personadd-outline"> </i></button>
<button><i class="icon ion-ios-photos"> </i></button>
<button><i class="icon ion-ios-photos-outline"> </i></button>
<button><i class="icon ion-ios-pie"> </i></button>
<button><i class="icon ion-ios-pie-outline"> </i></button>
<button><i class="icon ion-ios-pint"> </i></button>
<button><i class="icon ion-ios-pint-outline"> </i></button>
<button><i class="icon ion-ios-play"> </i></button>
<button><i class="icon ion-ios-play-outline"> </i></button>
<button><i class="icon ion-ios-plus"> </i></button>
<button><i class="icon ion-ios-plus-empty"> </i></button>
<button><i class="icon ion-ios-plus-outline"> </i></button>
<button><i class="icon ion-ios-pricetag"> </i></button>
<button><i class="icon ion-ios-pricetag-outline"> </i></button>
<button><i class="icon ion-ios-pricetags"> </i></button>
<button><i class="icon ion-ios-pricetags-outline"> </i></button>
<button><i class="icon ion-ios-printer"> </i></button>
<button><i class="icon ion-ios-printer-outline"> </i></button>
<button><i class="icon ion-ios-pulse"> </i></button>
<button><i class="icon ion-ios-pulse-strong"> </i></button>
<button><i class="icon ion-ios-rainy"> </i></button>
<button><i class="icon ion-ios-rainy-outline"> </i></button>
<button><i class="icon ion-ios-recording"> </i></button>
<button><i class="icon ion-ios-recording-outline"> </i></button>
<button><i class="icon ion-ios-redo"> </i></button>
<button><i class="icon ion-ios-redo-outline"> </i></button>
<button><i class="icon ion-ios-refresh"> </i></button>
<button><i class="icon ion-ios-refresh-empty"> </i></button>
<button><i class="icon ion-ios-refresh-outline"> </i></button>
<button><i class="icon ion-ios-reload"> </i></button>
<button><i class="icon ion-ios-reverse-camera"> </i></button>
<button><i class="icon ion-ios-reverse-camera-outline"> </i></button>
<button><i class="icon ion-ios-rewind"> </i></button>
<button><i class="icon ion-ios-rewind-outline"> </i></button>
<button><i class="icon ion-ios-rose"> </i></button>
<button><i class="icon ion-ios-rose-outline"> </i></button>
<button><i class="icon ion-ios-search"> </i></button>
<button><i class="icon ion-ios-search-strong"> </i></button>
<button><i class="icon ion-ios-settings"> </i></button>
<button><i class="icon ion-ios-settings-strong"> </i></button>
<button><i class="icon ion-ios-shuffle"> </i></button>
<button><i class="icon ion-ios-shuffle-strong"> </i></button>
<button><i class="icon ion-ios-skipbackward"> </i></button>
<button><i class="icon ion-ios-skipbackward-outline"> </i></button>
<button><i class="icon ion-ios-skipforward"> </i></button>
<button><i class="icon ion-ios-skipforward-outline"> </i></button>
<button><i class="icon ion-ios-snowy"> </i></button>
<button><i class="icon ion-ios-speedometer"> </i></button>
<button><i class="icon ion-ios-speedometer-outline"> </i></button>
<button><i class="icon ion-ios-star"> </i></button>
<button><i class="icon ion-ios-star-half"> </i></button>
<button><i class="icon ion-ios-star-outline"> </i></button>
<button><i class="icon ion-ios-stopwatch"> </i></button>
<button><i class="icon ion-ios-stopwatch-outline"> </i></button>
<button><i class="icon ion-ios-sunny"> </i></button>
<button><i class="icon ion-ios-sunny-outline"> </i></button>
<button><i class="icon ion-ios-telephone"> </i></button>
<button><i class="icon ion-ios-telephone-outline"> </i></button>
<button><i class="icon ion-ios-tennisball"> </i></button>
<button><i class="icon ion-ios-tennisball-outline"> </i></button>
<button><i class="icon ion-ios-thunderstorm"> </i></button>
<button><i class="icon ion-ios-thunderstorm-outline"> </i></button>
<button><i class="icon ion-ios-time"> </i></button>
<button><i class="icon ion-ios-time-outline"> </i></button>
<button><i class="icon ion-ios-timer"> </i></button>
<button><i class="icon ion-ios-timer-outline"> </i></button>
<button><i class="icon ion-ios-toggle"> </i></button>
<button><i class="icon ion-ios-toggle-outline"> </i></button>
<button><i class="icon ion-ios-trash"> </i></button>
<button><i class="icon ion-ios-trash-outline"> </i></button>
<button><i class="icon ion-ios-undo"> </i></button>
<button><i class="icon ion-ios-undo-outline"> </i></button>
<button><i class="icon ion-ios-unlocked"> </i></button>
<button><i class="icon ion-ios-unlocked-outline"> </i></button>
<button><i class="icon ion-ios-upload"> </i></button>
<button><i class="icon ion-ios-upload-outline"> </i></button>
<button><i class="icon ion-ios-videocam"> </i></button>
<button><i class="icon ion-ios-videocam-outline"> </i></button>
<button><i class="icon ion-ios-volume-high"> </i></button>
<button><i class="icon ion-ios-volume-low"> </i></button>
<button><i class="icon ion-ios-wineglass"> </i></button>
<button><i class="icon ion-ios-wineglass-outline"> </i></button>
<button><i class="icon ion-ios-world"> </i></button>
<button><i class="icon ion-ios-world-outline"> </i></button>
<button><i class="icon ion-ipad"> </i></button>
<button><i class="icon ion-iphone"> </i></button>
<button><i class="icon ion-ipod"> </i></button>
<button><i class="icon ion-jet"> </i></button>
<button><i class="icon ion-key"> </i></button>
<button><i class="icon ion-knife"> </i></button>
<button><i class="icon ion-laptop"> </i></button>
<button><i class="icon ion-leaf"> </i></button>
<button><i class="icon ion-levels"> </i></button>
<button><i class="icon ion-lightbulb"> </i></button>
<button><i class="icon ion-link"> </i></button>
<button><i class="icon ion-load-a"> </i></button>
<button><i class="icon ion-load-b"> </i></button>
<button><i class="icon ion-load-c"> </i></button>
<button><i class="icon ion-load-d"> </i></button>
<button><i class="icon ion-location"> </i></button>
<button><i class="icon ion-lock-combination"> </i></button>
<button><i class="icon ion-locked"> </i></button>
<button><i class="icon ion-log-in"> </i></button>
<button><i class="icon ion-log-out"> </i></button>
<button><i class="icon ion-loop"> </i></button>
<button><i class="icon ion-magnet"> </i></button>
<button><i class="icon ion-male"> </i></button>
<button><i class="icon ion-man"> </i></button>
<button><i class="icon ion-map"> </i></button>
<button><i class="icon ion-medkit"> </i></button>
<button><i class="icon ion-merge"> </i></button>
<button><i class="icon ion-mic-a"> </i></button>
<button><i class="icon ion-mic-b"> </i></button>
<button><i class="icon ion-mic-c"> </i></button>
<button><i class="icon ion-minus"> </i></button>
<button><i class="icon ion-minus-circled"> </i></button>
<button><i class="icon ion-minus-round"> </i></button>
<button><i class="icon ion-model-s"> </i></button>
<button><i class="icon ion-monitor"> </i></button>
<button><i class="icon ion-more"> </i></button>
<button><i class="icon ion-mouse"> </i></button>
<button><i class="icon ion-music-note"> </i></button>
<button><i class="icon ion-navicon"> </i></button>
<button><i class="icon ion-navicon-round"> </i></button>
<button><i class="icon ion-navigate"> </i></button>`;
    html += `
<button><i class="icon ion-network"> </i></button>
<button><i class="icon ion-no-smoking"> </i></button>
<button><i class="icon ion-nuclear"> </i></button>
<button><i class="icon ion-outlet"> </i></button>
<button><i class="icon ion-paintbrush"> </i></button>
<button><i class="icon ion-paintbucket"> </i></button>
<button><i class="icon ion-paper-airplane"> </i></button>
<button><i class="icon ion-paperclip"> </i></button>
<button><i class="icon ion-pause"> </i></button>
<button><i class="icon ion-person"> </i></button>
<button><i class="icon ion-person-add"> </i></button>
<button><i class="icon ion-person-stalker"> </i></button>
<button><i class="icon ion-pie-graph"> </i></button>
<button><i class="icon ion-pin"> </i></button>
<button><i class="icon ion-pinpoint"> </i></button>
<button><i class="icon ion-pizza"> </i></button>
<button><i class="icon ion-plane"> </i></button>
<button><i class="icon ion-planet"> </i></button>
<button><i class="icon ion-play"> </i></button>
<button><i class="icon ion-playstation"> </i></button>
<button><i class="icon ion-plus"> </i></button>
<button><i class="icon ion-plus-circled"> </i></button>
<button><i class="icon ion-plus-round"> </i></button>
<button><i class="icon ion-podium"> </i></button>
<button><i class="icon ion-pound"> </i></button>
<button><i class="icon ion-power"> </i></button>
<button><i class="icon ion-pricetag"> </i></button>
<button><i class="icon ion-pricetags"> </i></button>
<button><i class="icon ion-printer"> </i></button>
<button><i class="icon ion-pull-request"> </i></button>
<button><i class="icon ion-qr-scanner"> </i></button>
<button><i class="icon ion-quote"> </i></button>
<button><i class="icon ion-radio-waves"> </i></button>
<button><i class="icon ion-record"> </i></button>
<button><i class="icon ion-refresh"> </i></button>
<button><i class="icon ion-reply"> </i></button>
<button><i class="icon ion-reply-all"> </i></button>
<button><i class="icon ion-ribbon-a"> </i></button>
<button><i class="icon ion-ribbon-b"> </i></button>
<button><i class="icon ion-sad"> </i></button>
<button><i class="icon ion-sad-outline"> </i></button>
<button><i class="icon ion-scissors"> </i></button>
<button><i class="icon ion-search"> </i></button>
<button><i class="icon ion-settings"> </i></button>
<button><i class="icon ion-share"> </i></button>
<button><i class="icon ion-shuffle"> </i></button>
<button><i class="icon ion-skip-backward"> </i></button>
<button><i class="icon ion-skip-forward"> </i></button>
<button><i class="icon ion-social-android"> </i></button>
<button><i class="icon ion-social-android-outline"> </i></button>
<button><i class="icon ion-social-angular"> </i></button>
<button><i class="icon ion-social-angular-outline"> </i></button>
<button><i class="icon ion-social-apple"> </i></button>
<button><i class="icon ion-social-apple-outline"> </i></button>
<button><i class="icon ion-social-bitcoin"> </i></button>
<button><i class="icon ion-social-bitcoin-outline"> </i></button>
<button><i class="icon ion-social-buffer"> </i></button>
<button><i class="icon ion-social-buffer-outline"> </i></button>
<button><i class="icon ion-social-chrome"> </i></button>
<button><i class="icon ion-social-chrome-outline"> </i></button>
<button><i class="icon ion-social-codepen"> </i></button>
<button><i class="icon ion-social-codepen-outline"> </i></button>
<button><i class="icon ion-social-css3"> </i></button>
<button><i class="icon ion-social-css3-outline"> </i></button>
<button><i class="icon ion-social-designernews"> </i></button>
<button><i class="icon ion-social-designernews-outline"> </i></button>
<button><i class="icon ion-social-dribbble"> </i></button>
<button><i class="icon ion-social-dribbble-outline"> </i></button>
<button><i class="icon ion-social-dropbox"> </i></button>
<button><i class="icon ion-social-dropbox-outline"> </i></button>
<button><i class="icon ion-social-euro"> </i></button>
<button><i class="icon ion-social-euro-outline"> </i></button>
<button><i class="icon ion-social-facebook"> </i></button>
<button><i class="icon ion-social-facebook-outline"> </i></button>
<button><i class="icon ion-social-foursquare"> </i></button>
<button><i class="icon ion-social-foursquare-outline"> </i></button>
<button><i class="icon ion-social-freebsd-devil"> </i></button>
<button><i class="icon ion-social-github"> </i></button>
<button><i class="icon ion-social-github-outline"> </i></button>
<button><i class="icon ion-social-google"> </i></button>
<button><i class="icon ion-social-google-outline"> </i></button>
<button><i class="icon ion-social-googleplus"> </i></button>
<button><i class="icon ion-social-googleplus-outline"> </i></button>
<button><i class="icon ion-social-hackernews"> </i></button>
<button><i class="icon ion-social-hackernews-outline"> </i></button>
<button><i class="icon ion-social-html5"> </i></button>
<button><i class="icon ion-social-html5-outline"> </i></button>
<button><i class="icon ion-social-instagram"> </i></button>
<button><i class="icon ion-social-instagram-outline"> </i></button>
<button><i class="icon ion-social-javascript"> </i></button>
<button><i class="icon ion-social-javascript-outline"> </i></button>
<button><i class="icon ion-social-linkedin"> </i></button>
<button><i class="icon ion-social-linkedin-outline"> </i></button>
<button><i class="icon ion-social-markdown"> </i></button>
<button><i class="icon ion-social-nodejs"> </i></button>
<button><i class="icon ion-social-octocat"> </i></button>
<button><i class="icon ion-social-pinterest"> </i></button>
<button><i class="icon ion-social-pinterest-outline"> </i></button>
<button><i class="icon ion-social-python"> </i></button>
<button><i class="icon ion-social-reddit"> </i></button>
<button><i class="icon ion-social-reddit-outline"> </i></button>
<button><i class="icon ion-social-rss"> </i></button>
<button><i class="icon ion-social-rss-outline"> </i></button>
<button><i class="icon ion-social-sass"> </i></button>
<button><i class="icon ion-social-skype"> </i></button>
<button><i class="icon ion-social-skype-outline"> </i></button>
<button><i class="icon ion-social-snapchat"> </i></button>
<button><i class="icon ion-social-snapchat-outline"> </i></button>
<button><i class="icon ion-social-tumblr"> </i></button>
<button><i class="icon ion-social-tumblr-outline"> </i></button>
<button><i class="icon ion-social-tux"> </i></button>
<button><i class="icon ion-social-twitch"> </i></button>
<button><i class="icon ion-social-twitch-outline"> </i></button>
<button><i class="icon ion-social-twitter"> </i></button>
<button><i class="icon ion-social-twitter-outline"> </i></button>
<button><i class="icon ion-social-usd"> </i></button>
<button><i class="icon ion-social-usd-outline"> </i></button>
<button><i class="icon ion-social-vimeo"> </i></button>
<button><i class="icon ion-social-vimeo-outline"> </i></button>
<button><i class="icon ion-social-whatsapp"> </i></button>
<button><i class="icon ion-social-whatsapp-outline"> </i></button>
<button><i class="icon ion-social-windows"> </i></button>
<button><i class="icon ion-social-windows-outline"> </i></button>
<button><i class="icon ion-social-wordpress"> </i></button>
<button><i class="icon ion-social-wordpress-outline"> </i></button>
<button><i class="icon ion-social-yahoo"> </i></button>
<button><i class="icon ion-social-yahoo-outline"> </i></button>
<button><i class="icon ion-social-yen"> </i></button>
<button><i class="icon ion-social-yen-outline"> </i></button>
<button><i class="icon ion-social-youtube"> </i></button>
<button><i class="icon ion-social-youtube-outline"> </i></button>
<button><i class="icon ion-soup-can"> </i></button>
<button><i class="icon ion-soup-can-outline"> </i></button>
<button><i class="icon ion-speakerphone"> </i></button>
<button><i class="icon ion-speedometer"> </i></button>
<button><i class="icon ion-spoon"> </i></button>
<button><i class="icon ion-star"> </i></button>
<button><i class="icon ion-stats-bars"> </i></button>
<button><i class="icon ion-steam"> </i></button>
<button><i class="icon ion-stop"> </i></button>
<button><i class="icon ion-thermometer"> </i></button>
<button><i class="icon ion-thumbsdown"> </i></button>
<button><i class="icon ion-thumbsup"> </i></button>
<button><i class="icon ion-toggle"> </i></button>
<button><i class="icon ion-toggle-filled"> </i></button>
<button><i class="icon ion-transgender"> </i></button>
<button><i class="icon ion-trash-a"> </i></button>
<button><i class="icon ion-trash-b"> </i></button>
<button><i class="icon ion-trophy"> </i></button>
<button><i class="icon ion-tshirt"> </i></button>
<button><i class="icon ion-tshirt-outline"> </i></button>
<button><i class="icon ion-umbrella"> </i></button>
<button><i class="icon ion-university"> </i></button>
<button><i class="icon ion-unlocked"> </i></button>
<button><i class="icon ion-upload"> </i></button>
<button><i class="icon ion-usb"> </i></button>
<button><i class="icon ion-videocamera"> </i></button>
<button><i class="icon ion-volume-high"> </i></button>
<button><i class="icon ion-volume-low"> </i></button>
<button><i class="icon ion-volume-medium"> </i></button>
<button><i class="icon ion-volume-mute"> </i></button>
<button><i class="icon ion-wand"> </i></button>
<button><i class="icon ion-waterdrop"> </i></button>
<button><i class="icon ion-wifi"> </i></button>
<button><i class="icon ion-wineglass"> </i></button>
<button><i class="icon ion-woman"> </i></button>
<button><i class="icon ion-wrench"> </i></button>
<button><i class="icon ion-xbox"> </i></button>        
        `;
    return html;
  }
  isBootstrapIconsIncluded() {
    const stylesheets = this.builder.doc.styleSheets;
    for (let i = 0; i < stylesheets.length; i++) {
      let stylesheet = stylesheets[i];
      try {
        let rules = stylesheet.rules || stylesheet.cssRules;
        for (let j = 0; j < rules.length; j++) {
          let rule = rules[j];
          if (rule.cssText.includes('bootstrap-icons')) {
            return true;
          }
        }
      } catch (error) {
        // Accessing some stylesheets may throw a security error due to cross-origin restrictions
        // Do Nothing
      }
    }
    return false;
  }
  addIcon(classname) {
    const dom = this.dom;
    this.util.restoreSelection();
    if (this.builder.activeIcon && this.builder.doc.contains(this.builder.activeIcon)) {
      this.builder.uo.saveForUndo();

      /*
      const arrSizes = this.builder.opts.fontSizeClassValues;
       // Get current class size
      var currentClassSize = '';
      for(var i=0;i<=arrSizes.length-1;i++){
          if (dom.hasClass(this.builder.activeIcon, 'size-'+arrSizes[i])) {
              currentClassSize = 'size-'+arrSizes[i];
          }
      }
       this.builder.activeIcon.className = classname + (currentClassSize!==''? ' ' + currentClassSize: '');
      dom.addClass(this.builder.activeIcon, 'icon-active');
      */
      let currentClasses = '';
      this.builder.activeIcon.classList.forEach(item => {
        if (item === 'icon' || item.includes('ion-') || item === 'bi' || item.includes('bi-')) {
          this.builder.activeIcon.classList.remove(item);
        } else {
          currentClasses += ' ' + item;
        }
      });
      this.builder.activeIcon.className = classname + currentClasses;
      dom.addClass(this.builder.activeIcon, 'icon-active');
      dom.selectElementContents(this.builder.activeIcon);
      this.util.saveSelection();
    } else {
      if (!dom.textSelection()) return;
      this.builder.uo.saveForUndo();
      this.util.pasteHtmlAtCaret('<i class="' + classname + ' icon-active"></i>', true);
      this.builder.activeIcon = this.builder.doc.querySelector('.icon-active');

      // this.util.pasteHtmlAtCaret('<i class="icon-active"></i>', true); 
      // const newIcon = this.builder.doc.querySelector('.icon-active');
      // newIcon.className = classname + ' icon-active';
      // this.builder.activeIcon = newIcon;

      dom.selectElementContents(this.builder.activeIcon);
      this.util.saveSelection();
    }

    //Trigger Change event
    this.builder.opts.onChange();

    //Trigger Render event
    this.builder.opts.onRender();
  }
  clearFont() {
    this.builder.uo.saveForUndo();
    this.applyFont('', '', '');
  }
  applyFont(fontfamily, fontstyle, provider) {
    const dom = this.dom;
    let elm;
    var panel = this.builderStuff.querySelector('.is-side.elementstyles');
    if (dom.hasClass(panel, 'active')) {
      this.builder.uo.saveForUndo();
      elm = this.builder.inspectedElement;
      elm.style.fontFamily = fontfamily;
      this.builderStuff.querySelector('#inpElmFontFamily').value = fontfamily; //direct (see elementpanel-text.js)

      this.elementStyleEditor.refresh();
    } else {
      try {
        let curr;
        if (this.builder.win.getSelection) {
          curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
          if (curr.nodeType === 3) {
            //text node
            elm = curr.parentNode;
          } else {
            elm = curr;
          }
          if (elm.tagName !== 'H1' && elm.tagName !== 'H2' && elm.tagName !== 'H3' && elm.tagName !== 'H4' && elm.tagName !== 'H5' && elm.tagName !== 'H6' && elm.tagName !== 'P') {
            elm = elm.parentNode;
          }
        } else if (this.builder.doc.selection) {
          curr = this.builder.doc.selection.createRange();
          elm = this.builder.doc.selection.createRange().parentElement();
          if (elm.tagName !== 'H1' && elm.tagName !== 'H2' && elm.tagName !== 'H3' && elm.tagName !== 'H4' && elm.tagName !== 'H5' && elm.tagName !== 'H6' && elm.tagName !== 'P') {
            elm = elm.parentElement();
          }
        }
      } catch (e) {
        return;
      }
      this.builder.uo.saveForUndo();
      var text = dom.getSelected();
      if (text.trim() !== '' && elm.innerText !== text) {
        this.builder.doc.execCommand('fontName', false, fontfamily);
        var fontElements = this.builder.doc.getElementsByTagName('font');
        for (var i = 0, len = fontElements.length; i < len; ++i) {
          if (fontElements[i].face === fontfamily) {
            fontElements[i].removeAttribute('face');
            fontElements[i].style.fontFamily = fontfamily;
            dom.selectElementContents(fontElements[i]);
          }
        }
      } else if (text.trim() !== '' && elm.innerText === text) {
        //selection fully mode on text AND element. Use element then.
        elm.style.fontFamily = fontfamily;
      } else {
        elm.style.fontFamily = fontfamily;
      }
    }
    var o = fontstyle;
    if (!o) {
      o = '';
    } else {
      o = ':' + o;
    }
    var fontname = fontfamily.split(',')[0];
    if (provider === 'google') {
      var bExist = false;
      var links = this.builder.doc.getElementsByTagName('link');
      for (i = 0; i < links.length; i++) {
        var sSrc = links[i].href.toLowerCase();
        sSrc = sSrc.replace(/\+/g, ' ').replace(/%20/g, ' ');
        if (sSrc.indexOf(fontname.toLowerCase()) !== -1) bExist = true;
      }
      if (!bExist) {
        var element = elm;
        while (!dom.hasClass(element, 'is-builder')) {
          element = element.parentNode;
        }
        dom.appendHtml(element, '<link href="//fonts.googleapis.com/css2?family=' + fontname + o + '" rel="stylesheet" property="stylesheet">');
      }
    }
    if (!this.builder.inspectedElement) {
      //save selection
      this.util.saveSelection(); //Needed because after format, a tag is added (ex. <span>), so, make selection again. 

      if (this.builder.isTouchSupport) {
        //prevent keyboard open
        const btnFocus = this.rteTool.querySelector('button');
        btnFocus.focus();
      }
      this.getState();
    }

    //Trigger Change event
    this.builder.opts.onChange();
    setTimeout(() => {
      this.builder.opts.onChange();
    }, 300);

    //LATER: make function
    //Cleanup Google font css link

    links = this.builder.doc.getElementsByTagName('link');
    for (i = 0; i < links.length; i++) {
      sSrc = links[i].href.toLowerCase();
      if (sSrc.indexOf('googleapis') !== -1) {
        //get fontname
        sSrc = sSrc.replace(/\+/g, ' ').replace(/%20/g, ' ');
        fontname = sSrc.substr(sSrc.indexOf('family=') + 7);
        if (fontname.indexOf(':') !== -1) {
          fontname = fontname.split(':')[0];
        }
        if (fontname.indexOf('|') !== -1) {
          fontname = fontname.split('|')[0];
        }
        //check if fontname used in content
        var tmp = this.builder.doc.body.innerHTML.toLowerCase();
        var count = tmp.split(fontname).length;
        if (count < 3) {
          //not used     
          let attr = links[i].getAttribute('data-protect');
          if (!attr) {
            links[i].setAttribute('data-rel', '_del');
          }
        }
      }
    }
    [].forEach.call(this.builder.doc.querySelectorAll('link[data-rel="_del"]'), function (e) {
      e.parentNode.removeChild(e);
    });
    if (this.builder.onTextChange) this.builder.onTextChange();
  }
  setFont(fontfamily, fontstyle, fontdisplay, provider) {
    // NEW 4.0.5

    const dom = this.dom;
    let elm;
    var panel = this.builderStuff.querySelector('.is-side.elementstyles');
    if (dom.hasClass(panel, 'active')) {
      this.builder.uo.saveForUndo();
      elm = this.builder.inspectedElement;
      elm.style.fontFamily = fontfamily;
      this.builderStuff.querySelector('#inpElmFontFamily').value = fontfamily; //direct (see elementpanel-text.js)

      this.elementStyleEditor.refresh();
    } else {
      // if(this.builder.isIE) this.util.restoreSelection(); //a must (IE)
      this.util.restoreSelection();
      try {
        let curr;
        if (this.builder.win.getSelection) {
          curr = this.builder.win.getSelection().getRangeAt(0).commonAncestorContainer;
          if (curr.nodeType === 3) {
            //text node
            elm = curr.parentNode;
          } else {
            elm = curr;
          }
          if (elm.tagName !== 'H1' && elm.tagName !== 'H2' && elm.tagName !== 'H3' && elm.tagName !== 'H4' && elm.tagName !== 'H5' && elm.tagName !== 'H6' && elm.tagName !== 'P') {
            elm = elm.parentNode;
          }
        } else if (this.builder.doc.selection) {
          curr = this.builder.doc.selection.createRange();
          elm = this.builder.doc.selection.createRange().parentElement();
          if (elm.tagName !== 'H1' && elm.tagName !== 'H2' && elm.tagName !== 'H3' && elm.tagName !== 'H4' && elm.tagName !== 'H5' && elm.tagName !== 'H6' && elm.tagName !== 'P') {
            elm = elm.parentElement();
          }
        }
      } catch (e) {
        return;
      }
      this.builder.uo.saveForUndo();
      var text = dom.getSelected();
      if (text.trim() !== '' && elm.innerText !== text) {
        this.builder.doc.execCommand('fontName', false, fontfamily); // this removes all quotes, so needs to make valid later (below).
        var fontElements = this.builder.doc.getElementsByTagName('font');
        for (var i = 0, len = fontElements.length; i < len; ++i) {
          // fontElements[i].face = Press Start 2p, cursive => no quotes here
          // fontfamily = 'Press Start 2p', cursive
          if (fontElements[i].face.replace(/'/g, '') === fontfamily.replace(/'/g, '')) {
            fontElements[i].removeAttribute('face');
            fontElements[i].style.fontFamily = fontfamily;
            dom.selectElementContents(fontElements[i]);
          }
        }

        //cleaning added <span face="">.
        // example: 
        // <p style="text-align: justify;"><span style="font-family: &quot;Press Start 2p&quot;, cursive;">Lorem </span>
        // <span style="font-family: &quot;M PLUS Rounded 1c&quot;, sans-serif;">Ipsum</span>
        // <span face="Press Start 2p, cursive;"> is simply dummy text of the printing and typesetting industry...</span></p>
        fontElements = this.builder.doc.querySelectorAll('[face]');
        for (i = 0, len = fontElements.length; i < len; ++i) {
          // Make valid (adding quotes):
          let tmp = fontElements[i].getAttribute('face');
          if (tmp.indexOf(',') !== -1) {
            var f1 = tmp.split(',')[0];
            var f2 = tmp.split(',')[1];
            if (f1.indexOf(' ') !== -1) {
              tmp = `'${f1}',${f2}`;
            }
          }
          fontElements[i].style.fontFamily = tmp;
          fontElements[i].removeAttribute('face');
        }
      } else if (text.trim() !== '' && elm.innerText === text) {
        //selection fully mode on text AND element. Use element then.
        elm.style.fontFamily = fontfamily;
        let allfonts = elm.querySelectorAll('*');
        Array.prototype.forEach.call(allfonts, item => {
          if (item.style.fontFamily !== '') {
            item.style.fontFamily = '';
          }
        });
      } else {
        elm.style.fontFamily = fontfamily;
      }
    }
    var o = fontstyle;
    if (!o) {
      o = '';
    } else {
      o = ':' + o;
    }
    var d = ''; // NEW 4.0.5
    if (fontdisplay) {
      d = '&display=swap';
    }
    var fontname = fontfamily.split(',')[0];
    fontname = fontname.replace(/'/g, ''); // NEW 4.0.5 (replace quotes in font family)

    if (provider === 'google') {
      let bExist = false;
      bExist = this.checkIfFontCssLinkExists(fontfamily);
      if (!bExist) {
        let element = elm;
        while (!dom.hasClass(element, 'is-builder')) {
          element = element.parentNode;
        }
        let cssUrl = '';
        if (this.builder.fontPath) {
          const cssFileName = fontfamily.split(',')[0].toLowerCase().replace(/'/g, '').replace(/"/g, '').replace(/\s/g, '-') + '.css';
          cssUrl = this.builder.fontPath + cssFileName;
          dom.appendHtml(element, `<link data-name="fontfamily" href="${cssUrl}" rel="stylesheet" property="stylesheet">`);
        } else {
          dom.appendHtml(element, '<link href="//fonts.googleapis.com/css2?family=' + fontname + d + o + '" rel="stylesheet" property="stylesheet">');
        }
      }
    }
    if (provider === 'others') {
      let bExist = false;
      bExist = this.checkIfFontCssLinkExists(fontfamily);
      if (!bExist) {
        let element = elm;
        while (!dom.hasClass(element, 'is-builder')) {
          element = element.parentNode;
        }
        let cssUrl = '';
        if (this.builder.fontPath) {
          const cssFileName = fontfamily.split(',')[0].toLowerCase().replace(/'/g, '').replace(/"/g, '').replace(/\s/g, '-') + '.css';
          cssUrl = this.builder.fontPath + cssFileName;
          dom.appendHtml(element, `<link data-name="fontfamily" href="${cssUrl}" rel="stylesheet" property="stylesheet">`);
        }
      }
    }
    if (!this.builder.inspectedElement) {
      //save selection
      this.util.saveSelection(); //Needed because after format, a tag is added (ex. <span>), so, make selection again. 

      if (this.builder.isTouchSupport) {
        //prevent keyboard open
        const btnFocus = this.rteTool.querySelector('button');
        btnFocus.focus();
      }
      this.getState();
    }

    //Trigger Change event
    this.builder.opts.onChange();

    //Cleanup Google font css link
    this.cleanupFontCssLink();
    if (this.builder.onTextChange) this.builder.onTextChange();
  }
  cleanupFontCssLink() {
    const fonts = [];
    if (this.builder.opts.page !== '') {
      const wrapper = this.builder.doc.querySelector(this.builder.opts.page);
      wrapper.querySelectorAll('*').forEach(function (element) {
        let fontFamily = window.getComputedStyle(element).getPropertyValue('font-family');
        if (fonts.indexOf(fontFamily) === -1) fonts.push(fontFamily);
      });
    } else {
      const builders = this.builder.doc.querySelectorAll(this.builder.opts.container);
      builders.forEach(builder => {
        builder.querySelectorAll('*').forEach(function (element) {
          let fontFamily = window.getComputedStyle(element).getPropertyValue('font-family');
          if (fonts.indexOf(fontFamily) === -1) fonts.push(fontFamily);
        });
      });
    }

    // Cleanup
    let links = this.builder.doc.getElementsByTagName('link');
    for (let i = 0; i < links.length; i++) {
      let sSrc = links[i].href.toLowerCase();
      if (sSrc.indexOf('googleapis') !== -1) {
        //get fontname
        sSrc = sSrc.replace(/\+/g, ' ').replace(/%20/g, ' ');
        let linkFontName = sSrc.substr(sSrc.indexOf('family=') + 7);
        if (linkFontName.indexOf(':') !== -1) {
          linkFontName = linkFontName.split(':')[0];
        }
        if (linkFontName.indexOf('|') !== -1) {
          linkFontName = linkFontName.split('|')[0];
        }
        linkFontName = linkFontName.replace('&display=swap', ''); // NEW 4.0.5

        // console.log(linkFontName);
        // check if fontname used in content

        let used = false;
        fonts.forEach(item => {
          let currentContentFont = item.split(',')[0].replace(/"/g, '').replace(/'/g, '').toLowerCase();
          if (linkFontName === currentContentFont) {
            used = true;
          }
          // if(item.toLowerCase().indexOf(linkFontName.toLowerCase())===-1) {
          //     // Do Nothing
          // } else {
          //     used=true;
          // }
        });

        if (!used) {
          //not used
          let attr = links[i].getAttribute('data-protect');
          if (!attr) {
            links[i].setAttribute('data-rel', '_del');
          }
        }
      } else if (links[i].getAttribute('data-name') === 'fontfamily') {
        let used = false;
        fonts.forEach(item => {
          const cssFileName = item.split(',')[0].replace(/'/g, '').replace(/"/g, '').replace(/\s/g, '-').toLowerCase() + '.css';
          if (sSrc.toLowerCase().indexOf('/' + cssFileName) === -1) ; else {
            used = true;
          }
        });
        if (!used) {
          //not used
          let attr = links[i].getAttribute('data-protect');
          if (!attr) {
            links[i].setAttribute('data-rel', '_del');
          }
        }
      }
    }
    [].forEach.call(this.builder.doc.querySelectorAll('link[data-rel="_del"]'), function (e) {
      e.parentNode.removeChild(e);
    });
  }
  checkIfFontCssLinkExists(fontfamily) {
    let bExist = false;
    let fontname = fontfamily.split(',')[0];
    fontname = fontname.replace(/'/g, '');
    fontname = fontname.replace(/"/g, ''); // (replace double quotes in font family)
    fontname = fontname.toLowerCase();
    let links = this.builder.doc.getElementsByTagName('link');
    for (let i = 0; i < links.length; i++) {
      let sSrc = links[i].href.toLowerCase();
      if (sSrc.indexOf('googleapis') !== -1) {
        if (!this.builder.fontPath) {
          //get fontname
          sSrc = sSrc.replace(/\+/g, ' ').replace(/%20/g, ' ');
          let linkFontName = sSrc.substr(sSrc.indexOf('family=') + 7);
          if (linkFontName.indexOf(':') !== -1) {
            linkFontName = linkFontName.split(':')[0];
          }
          if (linkFontName.indexOf('|') !== -1) {
            linkFontName = linkFontName.split('|')[0];
          }
          linkFontName = linkFontName.replace('&display=swap', ''); // NEW 4.0.5

          //check if fontname used in content
          // let tmp = this.builder.doc.body.innerHTML.toLowerCase();
          if (linkFontName === fontname.toLowerCase()) {
            bExist = true;
            // console.log(fontname.toLowerCase() + '-' +linkFontName);
          }
        }
      } else if (links[i].getAttribute('data-name') === 'fontfamily') {
        if (this.builder.fontPath) {
          let cssFile = fontname.replace(/\s/g, '-').toLowerCase() + '.css';
          if (sSrc.toLowerCase().indexOf('/' + cssFile) !== -1) {
            bExist = true;
          }
        }
      }
    }
    return bExist;
  }
  positionToolbar() {
    let leftSidebarAdj = this.builder.leftSidebarAdj || 0;
    let leftSidebarAdj2 = this.builder.leftSidebarAdj2 || 0;
    if (document.body.classList.contains('controlpanel')) {
      leftSidebarAdj = leftSidebarAdj - 290 / 2;
      leftSidebarAdj2 = leftSidebarAdj2 - 290 / 2;
    }
    const viewportWidth = document.body.clientWidth; //window.innerWidth;
    const viewportHeight = window.innerHeight;
    if (this.builder.opts.toolbar === 'right') {
      let h = this.rteTool.offsetHeight;
      let top = viewportHeight / 2 - h / 2;
      this.rteTool.style.left = '';
      this.rteTool.style.top = top + 'px';

      // Element Toolbar
      h = this.elementRteTool.offsetHeight;
      top = viewportHeight / 2 - h / 2;
      this.elementRteTool.style.left = '';
      this.elementRteTool.style.top = top + 'px';
    } else if (this.builder.opts.toolbar === 'left') {
      let h = this.rteTool.offsetHeight;
      let top = viewportHeight / 2 - h / 2;
      this.rteTool.style.left = leftSidebarAdj2 + 'px';
      this.rteTool.style.top = top + 'px';

      // Element Toolbar
      h = this.elementRteTool.offsetHeight;
      top = viewportHeight / 2 - h / 2;
      this.elementRteTool.style.left = leftSidebarAdj2 + 'px';
      this.elementRteTool.style.top = top + 'px';
    } else {
      let w = this.rteTool.offsetWidth;
      let left = viewportWidth / 2 - w / 2 + leftSidebarAdj;
      this.rteTool.style.top = '';
      this.rteTool.style.left = left + 'px';

      // Element Toolbar
      w = this.elementRteTool.offsetWidth;
      left = viewportWidth / 2 - w / 2 + leftSidebarAdj;
      this.elementRteTool.style.top = '';
      this.elementRteTool.style.left = left + 'px';
    }
  }
  viewZoom() {
    if (this.builder.onZoomOpen) this.builder.onZoomOpen();
    this.inpZoomSlider.value = this.builder.opts.zoom * 100;
    if (document.activeElement) this.elmFocus = document.activeElement;
    const modal = this.builderStuff.querySelector('.viewzoom');
    this.util.showModal(modal, false, () => {
      if (this.elmFocus) this.elmFocus.focus();
    }, false);
  }
}

class SaveImages {
  constructor(opts = {}, builder) {
    let defaults = {
      page: '',
      container: '.container',
      handler: 'saveimage.php',
      onComplete: function () {},
      customval: '',
      stuffPlacement: '#_cbhtml',
      hiquality: false
      // onBase64Upload: function () { },
    };

    this.opts = Object.assign(this, defaults, opts);
    this.builder = builder;
    const dom = this.builder.dom;
    this.dom = dom;
    this.count = 0;
    let builderStuff = document.querySelector(this.opts.stuffPlacement);
    if (!builderStuff) {
      builderStuff = document.createElement('div');
      builderStuff.id = '_cbhtml';
      builderStuff.className = 'is-ui';
      dom.appendChild(document.body, builderStuff);
    }
    this.builderStuff = builderStuff;
  }
  save() {
    if (this.opts.page !== '') {
      let area = this.builder.doc.querySelector(this.opts.page);
      this.uploadImages(area);
    } else {
      let areas = this.builder.doc.querySelectorAll(this.opts.container);
      Array.prototype.forEach.call(areas, area => {
        this.uploadImages(area);
      });
    }

    //Check per 2 sec if all images have been changed with the new saved images.
    var int = setInterval(() => {
      let finished = true;
      if (this.opts.page !== '') {
        let area = this.builder.doc.querySelector(this.opts.page);
        finished = this.checkImages(area);
      } else {
        let areas = this.builder.doc.querySelectorAll(this.opts.container);
        Array.prototype.forEach.call(areas, area => {
          if (this.checkImages(area) === false) {
            finished = false;
          }
        });
      }
      if (finished) {
        try {
          this.opts.onComplete();
        } catch (e) {
          // Do Nothing
        }
        window.clearInterval(int);

        // No need to remove hidden iframes
        // //remove unused forms (previously used for submitting images)
        // for (var i = 1; i <= this.count; i++) {
        //     let frm = this.builderStuff.querySelector('#form-' + i);
        //     frm.parentNode.removeChild(frm);
        // }
      }
    }, 2000);
  }
  checkImages(area) {
    const images = area.querySelectorAll('img');
    let returnVal = true;
    Array.prototype.forEach.call(images, img => {
      let src = img.getAttribute('src');
      if (typeof src !== typeof undefined && src !== false) {
        if (src.indexOf('base64') !== -1) {
          //if there is still base64 image, means not yet finished.
          returnVal = false;
        }
      }
    });
    return returnVal;
  }
  uploadImages(area) {
    if (!area) return;

    //Check all images

    const divs = area.querySelectorAll('.is-overlay-bg,.is-container > div > div,.is-lightbox,.block-click');
    divs.forEach(div => {
      let src = '';
      if (div.style.backgroundImage && div.style.backgroundImage.includes('base64')) {
        if (div.style.backgroundImage.indexOf('url(') !== -1) {
          src = div.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      } else if (div.classList.contains('is-lightbox') && div.getAttribute('href').includes('base64')) {
        src = div.getAttribute('href');
      } else if (div.classList.contains('block-click') && div.style.backgroundImage && !div.style.backgroundImage.includes('base64')) {
        src = div.getAttribute('data-modal-url');
      }
      if (src.includes('base64')) {
        if (this.opts.onBase64Upload) {
          let ext = 'jpg';
          if (src.includes('image/png')) {
            ext = 'png';
          }

          //Read image (base64 string)
          let image = src;
          image = image.replace(/^data:image\/(png|svg\+xml|jpeg);base64,/, '');
          let filename;
          if (div.hasAttribute('data-filename')) {
            filename = div.getAttribute('data-filename');
          } else {
            filename = this.builder.util.makeId() + '.' + ext;
          }

          // console.log(div)
          this.opts.onBase64Upload(div, image, filename); // target image, base64 string, filename
        }
      }
    });

    const images = area.querySelectorAll('img');
    Array.prototype.forEach.call(images, img => {
      let src = img.getAttribute('src');
      if (typeof src !== typeof undefined && src !== false) {
        if (src.indexOf('base64') !== -1) {
          // let customcode = false;
          // if(dom.parentsHasAttribute(img, 'data-html')){
          //     customcode = true;
          // }
          // let subblock = false;
          // if(dom.parentsHasAttribute(img, 'data-subblock')){
          //     subblock = true;
          // }
          // if(!customcode || (customcode && subblock)) {

          // }

          if (this.opts.onBase64Upload) {
            //Read image (base64 string)
            let image = src;
            image = image.replace(/^data:image\/(png|svg\+xml|jpeg);base64,/, '');
            let filename = img.getAttribute('data-filename');
            this.opts.onBase64Upload(img, image, filename); // target image, base64 string, filename
          } else {
            this.count++;

            //Read image (base64 string)
            let image = src;
            image = image.replace(/^data:image\/(png|svg\+xml|jpeg);base64,/, '');

            //Prepare form to submit image
            if (!this.builderStuff.querySelector('#form-' + this.count)) {
              var html = '<form id="form-' + this.count + '" target="frame-' + this.count + '" method="post" enctype="multipart/form-data">' + '<input id="hidimg-' + this.count + '" name="hidimg-' + this.count + '" type="hidden" />' + '<input id="hidname-' + this.count + '" name="hidname-' + this.count + '" type="hidden" />' + '<input id="hidtype-' + this.count + '" name="hidtype-' + this.count + '" type="hidden" />' + '<input id="hidcustomval-' + this.count + '" name="hidcustomval-' + this.count + '" type="hidden" />' + '' + '<input name="count" value="' + this.count + '" type="hidden" />' + '<iframe tabindex="0" id="frame-' + this.count + '" name="frame-' + this.count + '" style="width:1px;height:1px;border:none;position:absolute;z-index:-100000;left:-5px;"></iframe>' + '</form>';
              this.builderStuff.insertAdjacentHTML('beforeend', html);
            }

            //Give ID to image
            img.setAttribute('id', 'img-' + this.count);

            //Set hidden field with image (base64 string) to be submitted
            this.builderStuff.querySelector('#hidimg-' + this.count).value = image;

            //Set hidden field with custom value to be submitted
            this.builderStuff.querySelector('#hidcustomval-' + this.count).value = this.customval;

            //Set hidden field with file name to be submitted
            let filename = img.getAttribute('data-filename');
            if (filename) {
              let filename_without_ext = filename.substr(0, filename.lastIndexOf('.')) || filename;
              filename_without_ext = filename_without_ext.toLowerCase().replace(/ /g, '-');
              this.builderStuff.querySelector('#hidname-' + this.count).value = filename_without_ext;
            }

            //Set hidden field with file extension to be submitted
            if (this.opts.hiquality) {
              //If high quality is set true, set image as png
              this.builderStuff.querySelector('#hidtype-' + this.count).value = 'png'; //high quality
            } else {
              //If high quality is set false, depend on image extension
              var extension = filename.substr(filename.lastIndexOf('.') + 1);
              extension = extension.toLowerCase();
              if (extension === 'jpg' || extension === 'jpeg') {
                this.builderStuff.querySelector('#hidtype-' + this.count).value = 'jpg';
              } else {
                this.builderStuff.querySelector('#hidtype-' + this.count).value = 'png';
              }
            }

            //Submit form
            this.builderStuff.querySelector('#form-' + this.count).setAttribute('action', this.opts.handler + (this.opts.handler.indexOf('?') >= 0 ? '&' : '?') + 'count=' + this.count);
            this.builderStuff.querySelector('#form-' + this.count).submit();

            //Note: the submitted image will be saved on the server 
            //by saveimage.php (if using PHP) or saveimage.ashx (if using .NET)
            //and the image src will be changed with the new saved image.
          }
        }
      }
    });
  }
}

const dom$1 = new Dom();
class Tooltip {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    let tooltip = builderStuff.querySelector('.is-tooltip');
    if (!tooltip) {
      let html = '<div class="is-tooltip"></div>';
      dom$1.appendHtml(builderStuff, html);
      tooltip = builderStuff.querySelector('.is-tooltip');
    }
    this.tooltip = tooltip;
  }
  setAll(o) {
    let area;
    if (!o) area = this.builderStuff;else area = o;
    //let elms = Array.prototype.slice.call(this.builderStuff.querySelectorAll('[data-title]')).concat(Array.prototype.slice.call(document.querySelectorAll('.is-builder .is-tool [data-title]')));
    let elms = area.querySelectorAll('[data-title]');
    Array.prototype.forEach.call(elms, elm => {
      this.set(elm, 0, 0);
    });
    if (this.builder.iframe) {
      if (!o) {
        let elms = this.builder.contentStuff.querySelectorAll('[data-title]');
        Array.prototype.forEach.call(elms, elm => {
          this.set(elm, 0, 0, true);
        });
      }
    }
  }
  set(elm, topadj, leftadj, iframe) {
    if (!topadj) topadj = 0;
    if (!leftadj) leftadj = 0;
    let tooltip = this.tooltip;
    elm.addEventListener('mouseover', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      const style = window.getComputedStyle(elm.parentNode);
      let direction = style.getPropertyValue('flex-direction');
      //console.log(style.flexDirection); 

      let s = elm.getAttribute('data-title');
      tooltip.innerHTML = s;
      let top, left;
      top = elm.getBoundingClientRect().top + window.pageYOffset;
      left = elm.getBoundingClientRect().left + window.pageXOffset;

      /*
      if(iframe) {
          let adjY = this.builder.iframe.getBoundingClientRect().top + window.pageYOffset;
          let adjX = this.builder.iframe.getBoundingClientRect().left + window.pageXOffset;
           top = elm.getBoundingClientRect().top + adjY;
          left = elm.getBoundingClientRect().left + adjX;
      }
      */

      if (iframe) {
        const newPos = this.util.getElementPosition(elm);
        top = newPos.top;
        left = newPos.left;
      }

      //console.log(top + ' - ' + left);
      tooltip.style.display = 'flex';
      tooltip.style.whiteSpace = 'nowrap';
      const w = elm.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
      const h = elm.offsetHeight;
      tooltip.style.marginRight = ''; //reset

      const viewportWidth = window.innerWidth;
      tooltip.style.top = top + h + 5 + topadj + 'px';
      if (h < 30) {
        tooltip.style.top = top + h + 2 + topadj + 'px';
      }
      if (direction === 'column') {
        tooltip.style.top = top + h / 2 - tooltip.offsetHeight / 2 + topadj + 'px';
        tooltip.style.left = left + w + 3 + leftadj + 'px';
        if (viewportWidth - (left + w) < 100) {
          // 100 or tooltip.offsetWidth
          tooltip.style.left = left - tooltip.offsetWidth - 3 + leftadj + 'px';
        }
      } else {
        let tooltipLeft = left + w / 2 - tooltip.offsetWidth / 2 + leftadj;
        tooltip.style.left = tooltipLeft + 'px'; // center

        // Adjustment for snippet handle tooltip (or any other that is outside viewport)
        let rightedge = tooltipLeft + tooltip.offsetWidth;
        if (rightedge > viewportWidth) {
          let adj = rightedge - viewportWidth;
          tooltip.style.left = tooltipLeft - adj - 3 + 'px'; //3 = additional adjustment

          if (tooltip.offsetHeight > 25) tooltip.style.marginRight = '5px'; // to fix incorrect position if tooltip has more than 1 line
        }

        if (tooltipLeft < 0) {
          tooltip.style.left = '3px';
        }
      }

      // overide
      let tipOnTop = elm.hasAttribute('data-tooltip-top');
      if (tipOnTop) {
        tooltip.style.top = top - tooltip.offsetHeight - 3 + 'px'; //10 = additional adjustment
      }

      elm.removeAttribute('title');
    }, false);
    elm.addEventListener('mouseout', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      elm.setAttribute('title', elm.getAttribute('data-title'));
      tooltip.style.display = 'none';
    }, false);
    elm.addEventListener('click', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      elm.setAttribute('title', elm.getAttribute('data-title'));
      tooltip.style.display = 'none';
    }, false);
  }
  set2(elm, topadj, leftadj) {
    if (!topadj) topadj = 0;
    if (!leftadj) leftadj = 0;
    let tooltip = this.tooltip;
    elm.addEventListener('mouseover', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      const style = window.getComputedStyle(elm.parentNode);
      let direction = style.getPropertyValue('flex-direction');
      //console.log(style.flexDirection); 

      let s = elm.getAttribute('data-title');
      tooltip.innerHTML = s;
      const top = elm.getBoundingClientRect().top + window.pageYOffset;
      const left = elm.getBoundingClientRect().left + window.pageXOffset;
      //console.log(top + ' - ' + left);
      tooltip.style.display = 'flex';
      tooltip.style.whiteSpace = 'nowrap';
      const w = elm.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
      const h = elm.offsetHeight;
      tooltip.style.marginRight = ''; //reset

      const viewportWidth = window.innerWidth;
      tooltip.style.top = top + h + 5 + topadj + 'px';
      if (h < 30) {
        tooltip.style.top = top + h + 2 + topadj + 'px';
      }
      if (direction === 'column') {
        tooltip.style.top = top + h / 2 - tooltip.offsetHeight / 2 + topadj + 'px';
        tooltip.style.left = left + w + 3 + leftadj + 'px';
        if (viewportWidth - (left + w) < 100) {
          // 100 or tooltip.offsetWidth
          tooltip.style.left = left - tooltip.offsetWidth - 3 + leftadj + 'px';
        }
      } else {
        let tooltipLeft = left + w / 2 - tooltip.offsetWidth / 2 + leftadj;
        tooltip.style.left = tooltipLeft + 'px'; // center

        // Adjustment for snippet handle tooltip (or any other that is outside viewport)
        let rightedge = tooltipLeft + tooltip.offsetWidth;
        if (rightedge > viewportWidth) {
          let adj = rightedge - viewportWidth;
          tooltip.style.left = tooltipLeft - adj - 3 + 'px'; //3 = additional adjustment

          if (tooltip.offsetHeight > 25) tooltip.style.marginRight = '5px'; // to fix incorrect position if tooltip has more than 1 line
        }

        if (tooltipLeft < 0) {
          tooltip.style.left = '3px';
        }
      }

      // overide
      let tipOnTop = elm.hasAttribute('data-tooltip-top');
      if (tipOnTop) {
        tooltip.style.top = top - tooltip.offsetHeight - 3 + 'px'; //10 = additional adjustment
      }

      elm.removeAttribute('title');
    }, false);
    elm.addEventListener('mouseout', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      elm.setAttribute('title', elm.getAttribute('data-title'));
      tooltip.style.display = 'none';
    }, false);
    elm.addEventListener('click', e => {
      var relTarget = e.relatedTarget;
      if (this === relTarget || isAChildOf(this, relTarget)) return;
      elm.setAttribute('title', elm.getAttribute('data-title'));
      tooltip.style.display = 'none';
    }, false);
  }
}

// https://stackoverflow.com/questions/8399408/mouseover-mouseout-eventlistener-inheriting-to-child-nodes
function isAChildOf(parent, child) {
  if (parent === child) {
    return false;
  }
  while (child && child !== parent) {
    child = child.parentNode;
  }
  return child === parent;
}

class Lightbox {
  constructor(builder) {
    this.builder = builder;
    this.arrow = this.builder.lightboxArrow;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;

    // let builderStuff = document.querySelector('#_cbhtml'); // All editing controls will be placed within <div id="_cbhtml">...</div>
    // if(!builderStuff) {
    //     builderStuff = dom.createElement('div');
    //     builderStuff.id = '_cbhtml';
    //     builderStuff.className = 'is-ui';
    //     dom.appendChild(document.body, builderStuff);
    // } 
    // this.builderStuff = builderStuff;

    this.id = this.makeid();

    // let html = `
    //     <div class="is-lightbox lightbox-externalvideo-edit" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
    //         <button class="cmd-lightbox-close" title="${util.out('Close')}" type="button" style="flex:none;position:absolute;top:0;right:0;background:none;z-index:1;">
    //             <svg><use xlink:href="#_${this.id}svgIconClose"></use></svg>
    //         </button>
    //         <div class="lightbox-content" style="width:100%;">
    //             <div class="embed-responsive embed-responsive-16by9" style="width:100%;">
    //             <iframe tabindex="0" width="560" height="315" src="about:blank" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    //             </div>
    //         </div>
    //     </div>
    //     <div class="is-lightbox lightbox-video-edit light" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
    //         <button class="cmd-lightbox-close" title="${util.out('Close')}" type="button" style="flex:none;position:absolute;top:0;right:0;background:none;z-index:1;">
    //             <svg><use xlink:href="#_${this.id}svgIconClose"></use></svg>
    //         </button>
    //         <div class="lightbox-content" style="width:100%;"></div>
    //     </div>
    //     <div class="is-lightbox lightbox-image-edit light" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
    //         <button class="cmd-lightbox-close" title="${util.out('Close')}" type="button" style="flex:none;position:absolute;top:0;right:0;background:none;z-index:1;">
    //             <svg><use xlink:href="#_${this.id}svgIconClose"></use></svg>
    //         </button>
    //         <div class="lightbox-content" style="width:100%;"></div>
    //     </div>
    //     <svg width="0" height="0" style="position:absolute;display:none;">
    //         <defs>
    //             <symbol viewBox="0 0 24 24" id="_${this.id}svgIconClose" stroke-width="0.7" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    //                 <path stroke="none" d="M0 0h24v24H0z" fill="none"></path><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
    //             </symbol>
    //         </defs>
    //     </svg>
    // `;

    let html = `

                <div class="is-lightbox lightbox-edit" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                    <button class="cmd-lightbox-close" title="${util.out('Close')}" type="button">
                        <svg><use xlink:href="#__${this.id}svgLightboxClose"></use></svg>
                    </button>

                    <div class="lightbox-content" style="width:100%;">
                    </div>

                    <button class="cmd-lightbox-prev" title="${util.out('Previous')}" type="button" style="top:50%;left:3px;">
                        <svg><use xlink:href="#__${this.id}svgLightboxLeft"></use></svg>
                    </button>
                    <button class="cmd-lightbox-next" title="${util.out('Next')}" type="button" style="top:50%;left:auto;right:3px">
                        <svg><use xlink:href="#__${this.id}svgLightboxRight"></use></svg>
                    </button>
                </div>

                <svg width="0" height="0" style="position:absolute;display:none;">
                    <defs>
                        <symbol viewBox="0 0 24 24" id="__${this.id}svgLightboxClose" stroke-width="0.7" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
                        </symbol>
                        <symbol viewBox="0 0 24 24" id="__${this.id}svgLightboxLeft" stroke-width="0.7" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                            <polyline points="15 6 9 12 15 18"></polyline>
                        </symbol>
                        <symbol viewBox="0 0 24 24" id="__${this.id}svgLightboxRight" stroke-width="0.7" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                            <polyline points="9 6 15 12 9 18"></polyline>
                        </symbol>
                    </defs>
                </svg>
            `;
    dom.appendHtml(this.builderStuff, html);
    const close = () => {
      let lightbox = document.querySelector('.is-lightbox.lightbox-edit.active');
      dom.removeClass(lightbox, 'active');
      const btnClose = lightbox.querySelector('.cmd-lightbox-close');
      btnClose.style.opacity = 0;
      document.body.style.overflowY = '';
      setTimeout(() => {
        let iframe = lightbox.querySelector('iframe');
        if (iframe) {
          iframe.setAttribute('src', 'about:blank');
        }
        const div = lightbox.querySelector('.lightbox-content');
        if (lightbox.querySelector('video')) div.innerHTML = '';
        lightbox.style.display = '';
        this.builder.preserveSelection = false;
        if (this.elmFocus) this.elmFocus.focus();
      }, 300);
    };
    const prev = () => {
      const list = this.getList();
      let lightbox = document.querySelector('.is-lightbox.lightbox-edit.active');
      let url = lightbox.getAttribute('data-url');
      list.forEach(item => {
        if (url === item.url) {
          const currentIndex = list.indexOf(item);
          let prevIndex;
          prevIndex = (currentIndex - 1) % list.length;
          if (prevIndex === -1) {
            prevIndex = list.length - 1;
          }
          this.openThen(list[prevIndex]);
          const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
          btnPrev.focus();
        }
      });
    };
    const next = () => {
      const list = this.getList();
      let lightbox = document.querySelector('.is-lightbox.lightbox-edit.active');
      let url = lightbox.getAttribute('data-url');
      list.forEach(item => {
        if (url === item.url) {
          const currentIndex = list.indexOf(item);
          const nextIndex = (currentIndex + 1) % list.length;
          this.openThen(list[nextIndex]);
          const btnNext = lightbox.querySelector('.cmd-lightbox-next');
          btnNext.focus();
        }
      });
    };
    const handleItemKeyDown = e => {
      if (e.keyCode === 27) {
        // escape key
        close();
        e.preventDefault();
      } /*else if ((e.which === 9 && !e.shiftKey)) { // tab key pressed
          let lightbox = document.querySelector('.is-lightbox.active');
          const btnClose = lightbox.querySelector('.cmd-lightbox-close');
          btnClose.focus();
          e.preventDefault();
        }*/

      if (this.arrow) {
        if (e.which === 37 && !e.shiftKey) {
          // left
          prev();
        }
        if (e.which === 39 && !e.shiftKey) {
          // right
          next();
        }
      }
    };
    const lightboxes = this.builderStuff.querySelectorAll('div.lightbox-edit');
    lightboxes.forEach(lightbox => {
      lightbox.addEventListener('keydown', handleItemKeyDown);
      const btnClose = lightbox.querySelector('.cmd-lightbox-close');
      btnClose.addEventListener('click', e => {
        close();
        e.preventDefault();
        e.stopImmediatePropagation();
      });
      btnClose.addEventListener('keydown', e => {
        if (e.keyCode === 13 || e.keyCode === 32) {
          // enter or spacebar key
          close();
        }
        e.preventDefault();
        e.stopImmediatePropagation();
      });
      const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
      if (btnPrev) btnPrev.addEventListener('click', e => {
        prev();
        e.preventDefault();
        e.stopImmediatePropagation();
      });
      if (btnPrev) btnPrev.addEventListener('keydown', e => {
        if (e.keyCode === 13 || e.keyCode === 32) {
          // enter or spacebar key
          prev();
          e.preventDefault();
        }
      });
      const btnNext = lightbox.querySelector('.cmd-lightbox-next');
      if (btnNext) btnNext.addEventListener('click', e => {
        next();
        e.preventDefault();
        e.stopImmediatePropagation();
      });
      if (btnNext) btnNext.addEventListener('keydown', e => {
        if (e.keyCode === 13 || e.keyCode === 32) {
          // enter or spacebar key
          next();
          e.preventDefault();
        }
      });
    });

    // this.init();
  } //constructor

  /*
  init() {
       // Find all elements that have .block-click & .button-click class.
      // Then read data attributes:
      //  - data-modal-theme: dark or light
      //  - data-modal-color (background color)
      //  - data-modal-image (image url)
      //  - data-modal-video (video url)
      //  - data-modal-externalvideo (ex. youtube url)
      const blockClickables = document.querySelectorAll('.is-lightbox'); //.block-click,.button-click
      blockClickables.forEach((block)=>{
          block.addEventListener('click', (e)=>{
              let url;
              let extension;
               if(block.tagName.toLowerCase() === 'a') {
                  url = block.getAttribute('href');
                  extension = url.split('.').pop();
              } else {
                  return;
              }
               let theme = block.getAttribute('data-modal-theme');
              if(!theme) theme='light';
               const color = block.getAttribute('data-modal-color');
               if(extension==='jpg'||extension==='jpeg'||extension==='png'||extension==='gif'||extension==='webm') {
                  this.openImage(url, theme, color);
              } 
              if(extension==='mp4') {
                  this.openVideo(url, 'dark', color);
              } 
               if(url.toLowerCase().indexOf('youtube.com')!==-1 ||
              url.toLowerCase().indexOf('vimeo.com')!==-1) {
                  this.openExternalVideo(url, 'dark', color);
              } 
               if(block.getAttribute('data-modal-image')) {
                  url = block.getAttribute('data-modal-image');
                  this.openImage(url, theme, color);
              }
              if(block.getAttribute('data-modal-video')) {
                  url = block.getAttribute('data-modal-video');
                  this.openVideo(url, 'dark', color);
              }
              if(block.getAttribute('data-modal-externalvideo')) {
                  url = block.getAttribute('data-modal-externalvideo');
                  this.openExternalVideo(url, 'dark', color);
              }
               e.preventDefault();
          });
      });
   } //init
  */

  openThen(item) {
    if (item.type === 'image') {
      this.programmatically = true;
      this.openImage(item.url, item.theme, item.color);
    }
    if (item.type === 'video') {
      this.programmatically = true;
      this.openVideo(item.url, item.theme, item.color);
    }
    if (item.type === 'externalvideo') {
      this.programmatically = true;
      this.openExternalVideo(item.url, item.theme, item.color);
    }
  }
  openImage(url, theme, color) {
    const dom = this.dom;
    if (this.builder.doc.activeElement) {
      this.elmFocus = this.builder.doc.activeElement;
      if (!this.programmatically) {
        const parent = this.builder.doc.activeElement.closest('[data-gallery]');
        this.parent = parent;
      }
    }
    this.builder.preserveSelection = true;
    let lightbox = document.querySelector('.is-lightbox.lightbox-edit');

    // in case opened in an iframe (ex. preview)
    if (window.frameElement && !lightbox) {
      lightbox = window.parent.document.querySelector('.is-lightbox.lightbox-edit');
    }
    if (!this.programmatically) {
      const list = this.getList();
      const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
      btnPrev.style.opacity = 0;
      const btnNext = lightbox.querySelector('.cmd-lightbox-next');
      btnNext.style.opacity = 0;
      btnPrev.style.display = 'none';
      btnNext.style.display = 'none';
      if (list.length > 1 && this.arrow) {
        btnPrev.style.display = 'flex';
        btnNext.style.display = 'flex';
        setTimeout(() => {
          const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
          btnPrev.style.opacity = 1;
          const btnNext = lightbox.querySelector('.cmd-lightbox-next');
          btnNext.style.opacity = 1;
        }, 500);
      }
      const btnClose = lightbox.querySelector('.cmd-lightbox-close');
      btnClose.style.opacity = 0;
      setTimeout(() => {
        dom.addClass(lightbox, 'active');
        setTimeout(() => {
          btnClose.style.opacity = 1;
        }, 450);
      }, 10);
    }
    lightbox.setAttribute('data-url', url);
    lightbox.classList.remove('lightbox-video');
    lightbox.classList.remove('lightbox-externalvideo');
    lightbox.classList.add('lightbox-image');
    if (color) lightbox.style.backgroundColor = color;
    const div = lightbox.querySelector('.lightbox-content');
    if (!this.programmatically) {
      div.innerHTML = `<img src="${url}">`;
    } else {
      div.style.transition = 'all 200ms ease';
      div.style.opacity = '0';
      setTimeout(() => {
        div.innerHTML = `<img src="${url}">`;
        div.style.opacity = '1';
      }, 200);
    }
    if (theme === 'light') {
      dom.addClass(lightbox, 'light');
      dom.removeClass(lightbox, 'dark');
    } else {
      dom.addClass(lightbox, 'dark');
      dom.removeClass(lightbox, 'light');
    }
    lightbox.style.display = 'flex';
    if (!window.frameElement) document.body.style.overflowY = 'hidden';
    lightbox.focus({
      preventScroll: true
    });
    this.programmatically = false;
  }
  openVideo(url, theme, color) {
    const dom = this.dom;
    if (this.builder.doc.activeElement) {
      this.elmFocus = this.builder.doc.activeElement;
      if (!this.programmatically) {
        const parent = this.builder.doc.activeElement.closest('[data-gallery]');
        this.parent = parent;
      }
    }
    this.builder.preserveSelection = true;
    let lightbox = document.querySelector('.is-lightbox.lightbox-edit');

    // in case opened in an iframe (ex. preview)
    if (window.frameElement && !lightbox) {
      lightbox = window.parent.document.querySelector('.is-lightbox.lightbox-edit');
    }
    if (!this.programmatically) {
      const list = this.getList();
      const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
      btnPrev.style.opacity = 0;
      const btnNext = lightbox.querySelector('.cmd-lightbox-next');
      btnNext.style.opacity = 0;
      btnPrev.style.display = 'none';
      btnNext.style.display = 'none';
      if (list.length > 1 && this.arrow) {
        btnPrev.style.display = 'flex';
        btnNext.style.display = 'flex';
        setTimeout(() => {
          const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
          btnPrev.style.opacity = 1;
          const btnNext = lightbox.querySelector('.cmd-lightbox-next');
          btnNext.style.opacity = 1;
        }, 500);
      }
      const btnClose = lightbox.querySelector('.cmd-lightbox-close');
      btnClose.style.opacity = 0;
      setTimeout(() => {
        dom.addClass(lightbox, 'active');
        setTimeout(() => {
          btnClose.style.opacity = 1;
        }, 450);
      }, 10);
    }
    lightbox.setAttribute('data-url', url);
    lightbox.classList.add('lightbox-video');
    lightbox.classList.remove('lightbox-externalvideo');
    lightbox.classList.remove('lightbox-image');
    if (color) lightbox.style.backgroundColor = color;
    const div = lightbox.querySelector('.lightbox-content');
    if (!this.programmatically) {
      div.innerHTML = `<video playsinline controls autoplay width="100%">
                <source src="${url}" type="video/mp4">
            </video>`;
    } else {
      div.style.transition = 'all 200ms ease';
      div.style.opacity = '0';
      setTimeout(() => {
        div.innerHTML = `<video playsinline controls autoplay width="100%">
                    <source src="${url}" type="video/mp4">
                </video>`;
        div.style.opacity = '1';
      }, 200);
    }
    if (theme === 'light') {
      dom.addClass(lightbox, 'light');
      dom.removeClass(lightbox, 'dark');
    } else {
      dom.addClass(lightbox, 'dark');
      dom.removeClass(lightbox, 'light');
    }
    lightbox.style.display = 'flex';
    if (!window.frameElement) document.body.style.overflowY = 'hidden';
    lightbox.focus({
      preventScroll: true
    });
    this.programmatically = false;
  }
  openExternalVideo(url, theme, color) {
    const dom = this.dom;
    if (this.builder.doc.activeElement) {
      this.elmFocus = this.builder.doc.activeElement;
      if (!this.programmatically) {
        const parent = this.builder.doc.activeElement.closest('[data-gallery]');
        this.parent = parent;
      }
    }
    this.builder.preserveSelection = true;
    let lightbox = document.querySelector('.is-lightbox.lightbox-edit');

    // in case opened in an iframe (ex. preview)
    if (window.frameElement && !lightbox) {
      lightbox = window.parent.document.querySelector('.is-lightbox.lightbox-edit');
    }
    if (!this.programmatically) {
      const list = this.getList();
      const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
      btnPrev.style.opacity = 0;
      const btnNext = lightbox.querySelector('.cmd-lightbox-next');
      btnNext.style.opacity = 0;
      btnPrev.style.display = 'none';
      btnNext.style.display = 'none';
      if (list.length > 1 && this.arrow) {
        btnPrev.style.display = 'flex';
        btnNext.style.display = 'flex';
        setTimeout(() => {
          const btnPrev = lightbox.querySelector('.cmd-lightbox-prev');
          btnPrev.style.opacity = 1;
          const btnNext = lightbox.querySelector('.cmd-lightbox-next');
          btnNext.style.opacity = 1;
        }, 500);
      }
      const btnClose = lightbox.querySelector('.cmd-lightbox-close');
      btnClose.style.opacity = 0;
      setTimeout(() => {
        dom.addClass(lightbox, 'active');
        setTimeout(() => {
          btnClose.style.opacity = 1;
        }, 450);
      }, 10);
    }
    lightbox.setAttribute('data-url', url);
    lightbox.classList.remove('lightbox-video');
    lightbox.classList.add('lightbox-externalvideo');
    lightbox.classList.remove('lightbox-image');
    if (color) lightbox.style.backgroundColor = color;
    if (theme === 'light') {
      dom.addClass(lightbox, 'light');
      dom.removeClass(lightbox, 'dark');
    } else {
      dom.addClass(lightbox, 'dark');
      dom.removeClass(lightbox, 'light');
    }
    const div = lightbox.querySelector('.lightbox-content');
    if (!this.programmatically) {
      div.innerHTML = `<div class="embed-responsive embed-responsive-16by9" style="width:100%;">
                <iframe width="560" height="315" src="about:blank" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>`;
      const iframe = lightbox.querySelector('iframe');
      url = this.getIframeVideoUrl(url);
      if (url !== '') iframe.setAttribute('src', url);
    } else {
      div.style.transition = 'all 200ms ease';
      div.style.opacity = '0';
      setTimeout(() => {
        div.innerHTML = `<div class="embed-responsive embed-responsive-16by9" style="width:100%;">
                    <iframe width="560" height="315" src="about:blank" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                </div>`;
        div.style.opacity = '1';
        const iframe = lightbox.querySelector('iframe');
        url = this.getIframeVideoUrl(url);
        if (url !== '') iframe.setAttribute('src', url);
      }, 200);
    }
    lightbox.style.display = 'flex';
    if (!window.frameElement) document.body.style.overflowY = 'hidden';

    // const div = lightbox.querySelector('.lightbox-content');
    // div.style.width=((div.offsetHeight*16)/9) + 'px';

    lightbox.focus({
      preventScroll: true
    });
    this.programmatically = false;
  }
  getIframeVideoUrl(src) {
    // https://regex101.com/library/OY96XI
    // https://stackoverflow.com/questions/3452546/how-do-i-get-the-youtube-video-id-from-a-url
    // let youRegex = /^http[s]?:\/\/(((www.youtube.com\/watch\?(feature=player_detailpage&)?)v=)|(youtu.be\/))([^#&?]*)/;
    let youRegex = /^.*(?:https?:)?(?:\/\/)?(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\/\S*?[^\w\s-])((?!videoseries)[\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/;
    let vimeoRegex = /^.*(vimeo\.com\/)((channels\/[A-z]+\/)|(groups\/[A-z]+\/videos\/)|(video\/))?([0-9]+)\/?/;
    // let youRegexMatches = youRegex.exec(src);
    let youRegexMatches = src.match(youRegex);
    let vimeoRegexMatches = vimeoRegex.exec(src);
    // if (youRegexMatches !== null || vimeoRegexMatches !== null) {
    if ((youRegexMatches !== null || vimeoRegexMatches !== null) && src.indexOf('player.vimeo.com') === -1 && src.indexOf('youtube.com/embed/') === -1 && src.indexOf('youtube-nocookie.com/embed/') === -1) {
      if (youRegexMatches !== null) {
        // && youRegexMatches.length >= 7) {
        // let youMatch = youRegexMatches[6];
        let youMatch = youRegexMatches[1];

        // src = 'https://www.youtube.com/embed/' + youMatch + '?rel=0&autoplay=1&color=white';
        src = 'https://www.youtube-nocookie.com/embed/' + youMatch + '?rel=0&autoplay=1&color=white';
      }
      if (vimeoRegexMatches !== null && vimeoRegexMatches.length >= 7) {
        let vimeoMatch = vimeoRegexMatches[6];
        src = 'https://player.vimeo.com/video/' + vimeoMatch;
      }
    } else {
      if (src.indexOf('youtube-nocookie.com/embed/') !== -1) {
        if (src.indexOf('?') === -1) {
          src += '?rel=0&autoplay=1&color=white';
        }
      }
    }
    return src;
  }
  makeid() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  getList() {
    const arrGallery = [];
    let blockClickables = this.builder.doc.querySelectorAll('.block-click,.button-click,.is-lightbox');
    if (this.parent) {
      blockClickables = this.parent.querySelectorAll('.block-click,.button-click,.is-lightbox');
    }
    blockClickables.forEach(block => {
      if (!this.parent) {
        if (block.closest('[data-gallery')) return;
      }
      let url;
      let extension;
      if (block.tagName.toLowerCase() === 'a') {
        url = block.getAttribute('href');
        extension = url.split('.').pop().split('?')[0].split('#')[0];
      } else if (block.getAttribute('data-modal-url')) {
        url = block.getAttribute('data-modal-url');
        extension = url.split('.').pop().split('?')[0].split('#')[0];
      }
      let theme = block.getAttribute('data-modal-theme');
      if (!theme) theme = 'light';
      const color = block.getAttribute('data-modal-color');
      if (url) {
        if (extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
          arrGallery.push({
            type: 'image',
            url: url,
            theme: theme,
            color: color
          });
        } else if (extension === 'mp4') {
          arrGallery.push({
            type: 'video',
            url: url,
            theme: 'dark',
            color: color
          });
        } else if (url.toLowerCase().indexOf('youtube.com') !== -1 || url.toLowerCase().indexOf('youtube-nocookie.com') !== -1 || url.toLowerCase().indexOf('vimeo.com') !== -1) {
          arrGallery.push({
            type: 'externalvideo',
            url: url,
            theme: 'dark',
            color: color
          });
        }
      }
      if (block.getAttribute('data-modal-image')) {
        url = block.getAttribute('data-modal-image');
        arrGallery.push({
          type: 'image',
          url: url,
          theme: theme,
          color: color
        });
      } else if (block.getAttribute('data-modal-video')) {
        url = block.getAttribute('data-modal-video');
        arrGallery.push({
          type: 'video',
          url: url,
          theme: 'dark',
          color: color
        });
      } else if (block.getAttribute('data-modal-externalvideo')) {
        url = block.getAttribute('data-modal-externalvideo');
        arrGallery.push({
          type: 'externalvideo',
          url: url,
          theme: 'dark',
          color: color
        });
      }
    });
    return arrGallery;
  }
} //Lightbox

class ShortcutInfo {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const dom = this.builder.dom;
    this.dom = dom;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    let shortcutModal = builderStuff.querySelector('.is-modal.shortcuts');
    if (!shortcutModal) {
      let html = `<div class="is-modal shortcuts" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content">
                <div class="is-modal-bar is-draggable">${util.out('Shortcuts')}</div>

                <table>
                    <tr>
                        <td class="shortcut-title" colspan="2">${util.out('Basic')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Copy')}</td><td>C</td>
                    </tr>
                    <tr>
                        <td>${util.out('Cut')}</td><td>X</td>
                    </tr>
                    <tr>
                        <td>${util.out('Paste')}</td><td>V</td>
                    </tr>
                    <tr>
                        <td>${util.out('Undo')}</td><td>Z</td>
                    </tr>
                    <tr>
                        <td>${util.out('Redo')}</td><td>Shift+Z</td>
                    </tr>

                    <tr>
                        <td class="shortcut-title" colspan="2">${util.out('Editing')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Bold')}</td><td>B</td>
                    </tr>
                    <tr>
                        <td>${util.out('Italic')}</td><td>I</td>
                    </tr>
                    <tr>
                        <td>${util.out('Underline')}</td><td>U</td>
                    </tr>
                    <tr>
                        <td>${util.out('Strikethrough')}</td><td>S</td>
                    </tr>
                    <tr>
                        <td>${util.out('Indent')}</td><td>]</td>
                    </tr>
                    <tr>
                        <td>${util.out('Outdent')}</td><td>[</td>
                    </tr>
                    <tr>
                        <td>${util.out('Insert Link')}</td><td>K</td>
                    </tr>
                    <tr>
                        <td>${util.out('Insert Image')}</td><td>P</td>
                    </tr>

                    <tr>
                        <td class="shortcut-title" colspan="2">${util.out('Navigation')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Show shortcut info')}</td><td>/</td>
                    </tr>
                    <tr>
                        <td>${util.out('Navigate to the next control')}</td><td>${util.out('Tab')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Navigate to the previous control')}</td><td>${util.out('Shift')}+${util.out('Tab')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Select control that has focus')}<br></td><td>${util.out('Enter')} ${util.out('or')} ${util.out('Spacebar')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Select option that has focus (eg. checkbox)')}<br></td><td>${util.out('Spacebar')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Move up in selection list or menu')}</td><td>${util.out('Up arrow')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Move down in selection list or menu')}</td><td>${util.out('Down arrow')}</td>
                    </tr>
                    <tr>
                        <td>${util.out('Close modal or popup')}</td><td>${util.out('Esc')}</td>
                    </tr>
                </table>
            
            </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      shortcutModal = builderStuff.querySelector('.is-modal.shortcuts');
      let btnClose = shortcutModal.querySelector('.is-modal-close');
      dom.addEventListener(btnClose, 'click', () => {
        dom.removeClass(shortcutModal, 'active');
      });
    }
    this.shortcutModal = shortcutModal;
  }
  open() {
    const util = this.builder.util;
    util.showModal(this.shortcutModal, false);
  }
}

class Resizeable {
  constructor(opts = {}) {
    let defaults = {
      treshholds: 13,
      minWidth: 50,
      minHeight: 50,
      adj: 4,
      onResize: function () {},
      resizeHeight: false
    };
    this.opts = Object.assign(this, defaults, opts);
    const pane = this.pane;
    const container = pane.closest('.is-builder');
    let scale = this.getScale(container);
    if (!scale) {
      const wrapper = container.closest('.is-wrapper');
      if (wrapper) scale = this.getScale(wrapper);else scale = 1;
    }

    // Minimum resize
    const minWidth = this.minWidth;
    const minHeight = this.minHeight;

    // Thresholds
    const treshholds = this.treshholds; //4;
    const adj = this.adj;

    // End of what's configurable.
    let clicked = null;
    let onRightEdge, onBottomEdge, onLeftEdge, onTopEdge;
    let b, x, y;
    let redraw = false;
    const calc = e => {
      b = this.pane.getBoundingClientRect();
      x = e.clientX - b.left;
      y = e.clientY - b.top;
      onTopEdge = y < treshholds;
      onLeftEdge = x < treshholds;
      onRightEdge = x >= b.width - treshholds;
      onBottomEdge = y >= b.height - treshholds;
    };
    const onDown = e => {
      calc(e);
      if (e.target.closest('.glide__arrows')) return false;
      const isResizing = onRightEdge || onBottomEdge || onTopEdge || onLeftEdge;
      clicked = {
        x: x,
        y: y,
        cx: e.clientX,
        cy: e.clientY,
        w: b.width,
        h: b.height,
        isResizing: isResizing,
        onTopEdge: onTopEdge,
        onLeftEdge: onLeftEdge,
        onRightEdge: onRightEdge,
        onBottomEdge: onBottomEdge
      };
    };
    const onMouseDown = e => {
      onDown(e);
      // e.preventDefault();
    };

    const onTouchDown = e => {
      onDown(e.touches[0]);
      // e.preventDefault();
    };

    let ee;
    function onMove(e) {
      calc(e);
      ee = e;
      redraw = true;
      if (clicked) {
        if (clicked.isResizing) {
          // Prevent text selection
          if (e.stopPropagation) e.stopPropagation();
          if (e.preventDefault) e.preventDefault();
          e.cancelBubble = true;
          e.returnValue = false;
          return false;
        }
      }
    }
    const onTouchMove = e => {
      onMove(e.touches[0]);
    };
    const onUp = e => {
      let isResizing = clicked ? clicked.isResizing : false;
      calc(e);
      clicked = null;
      if (isResizing) if (this.resizeEnd) this.resizeEnd();
    };
    const onTouchEnd = e => {
      if (e.touches.length == 0) onUp(e.changedTouches[0]);
    };
    this.onMouseDown = onMouseDown;
    this.onMove = onMove;
    this.onUp = onUp;
    this.onTouchDown = onTouchDown;
    this.onTouchMove = onTouchMove;
    this.onTouchEnd = onTouchEnd;
    pane.addEventListener('mousedown', onMouseDown);
    pane.ownerDocument.addEventListener('mousemove', onMove);
    pane.ownerDocument.addEventListener('mouseup', onUp);

    // pane.addEventListener('touchstart', onTouchDown);
    pane.addEventListener('touchstart', onTouchDown, {
      passive: true
    });
    pane.ownerDocument.addEventListener('touchmove', onTouchMove);
    pane.ownerDocument.addEventListener('touchend', onTouchEnd);
    const resizing = () => {
      requestAnimationFrame(resizing);
      if (!redraw) return;
      redraw = false;
      if (clicked && clicked.isResizing) {
        let newWidth;
        let newWHeight;
        if (this.resizeHeight) if (clicked.onBottomEdge) {
          newWHeight = Math.max(y / scale, minHeight) + adj;
          pane.style.height = newWHeight + 'px';
        }
        if (clicked.onRightEdge) {
          let currentWidth = Math.max(ee.clientX - clicked.cx + clicked.w, minWidth);
          if (currentWidth > minWidth) {
            newWidth = currentWidth / scale;
            pane.style.width = newWidth + 'px';
          }
        }
        if (clicked.onLeftEdge) {
          let currentWidth = Math.max(clicked.cx - ee.clientX + clicked.w, minWidth);
          if (currentWidth > minWidth) {
            newWidth = currentWidth / scale;
            pane.style.width = newWidth + 'px';
          }
        }
        this.onResize(newWidth, newWHeight);
        return;
      }

      // mouseover
      if (onRightEdge && onBottomEdge) {
        if (this.resizeHeight) pane.style.cursor = 'nwse-resize';
      } else if (onBottomEdge && onLeftEdge) {
        if (this.resizeHeight) pane.style.cursor = 'nesw-resize';
      } else if (onRightEdge || onLeftEdge) {
        pane.style.cursor = 'ew-resize';
      } else if (onBottomEdge) {
        if (this.resizeHeight) pane.style.cursor = 'ns-resize';
      } else {
        pane.style.cursor = '';
      }
    };
    resizing();
  }
  getScale(container) {
    let matrix = window.getComputedStyle(container).transform;
    if (matrix === 'none') return false;
    let values = matrix.split('(')[1];
    values = values.split(')')[0];
    values = values.split(',');
    let a = values[0];
    let b = values[1];
    let scale = Math.sqrt(a * a + b * b);
    return scale;
  }
  destroy() {
    const pane = this.pane;
    pane.removeEventListener('mousedown', this.onMouseDown);
    pane.ownerDocument.removeEventListener('mousemove', this.onMove);
    pane.ownerDocument.removeEventListener('mouseup', this.onUp);
    pane.removeEventListener('touchstart', this.onTouchDown);
    pane.ownerDocument.removeEventListener('touchmove', this.onTouchMove);
    pane.ownerDocument.removeEventListener('touchend', this.onTouchEnd);
    pane.style.cursor = '';
  }
}

class Resize {
  constructor(element, builder, opts = {}) {
    let defaults = {
      filterSiblingClass: 'is-row-tool'
    };
    this.opts = Object.assign(this, defaults, opts);
    this.builder = builder;
    this.element = element;
  }
  enable() {
    const col = this.element;
    const row = col.parentNode;
    this.resize = new Resizeable({
      pane: col,
      resizeHeight: this.builder.resizeHeight,
      onResize: (width, height) => {
        this.builder.util.hideControls();
        let numOfCols = 1;
        Array.from(col.parentNode.children).map(item => {
          if (item.classList.contains('is-row-tool')) return;
          if (item.classList.contains('is-rowadd-tool')) return;
          if (item.classList.contains('is-col-tool')) return;
          if (item === col) return;
          numOfCols++;
        });
        if (width) {
          col.style.flex = 'none';
          col.style.width = `${width}px`;

          // adjust others
          const maxWidth = () => {
            let otherWidth = 0;
            Array.from(col.parentNode.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

              if (item === col) return;
              otherWidth += item.offsetWidth;
            });
            return row.offsetWidth - otherWidth;
          };
          const max = maxWidth();
          if (parseInt(col.style.width) > max) {
            // Adjust to max
            // percentage = (max / row.offsetWidth) * 100;
            // Or make others auto

            Array.from(col.parentNode.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

              if (item === col) return;

              // // item.style.width = '100%';
              // if(!item.getAttribute('data-html')) item.style.width = '100%';
              // item.style.flex = '';
              if (numOfCols === 2) {
                if (!item.getAttribute('data-html')) {
                  item.style.width = '100%';
                  item.style.flex = '';
                }
              } /*else {
                  // if(!item.getAttribute('data-html') && !item.style.width) {
                  //     item.style.width = '100%';
                  //     item.style.flex = '';
                  // }
                  if(!item.getAttribute('data-html') && item===col.nextElementSibling) {
                      item.style.width = '100%';
                      item.style.flex = '';
                  }
                }*/

              /* New: Specify width for module only, and only if num of columns = 2 */
              if (numOfCols === 2) {
                if (item.getAttribute('data-html')) {
                  let percentage = col.offsetWidth / col.parentNode.offsetWidth * 100;
                  item.style.width = 100 - percentage + '%';
                  item.style.flex = '0 0 auto';
                }
              }
            });
            if (numOfCols === 1) {
              col.style.width = '100%';
            }
          } else {
            // New: if other cols has no width, set to 100%
            Array.from(col.parentNode.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

              if (item === col) return;
              if (item.style.width === '') {
                // item.style.width = '100%';
                if (!item.getAttribute('data-html')) item.style.width = '100%';
                item.style.flex = '';
              }

              /* New: Specify width for module only, and only if num of columns = 2 */
              if (numOfCols === 2) {
                if (item.getAttribute('data-html')) {
                  let percentage = col.offsetWidth / col.parentNode.offsetWidth * 100;
                  item.style.width = 100 - percentage + '%';
                  item.style.flex = '0 0 auto';
                }
              }
            });
          }
          // /adjust others
        }

        if (height) {
          col.style.height = `${height}px`;
          col.style.minHeight = '';
        }
      },
      resizeEnd: () => {
        let numOfCols = 1;
        Array.from(col.parentNode.children).map(item => {
          if (item.classList.contains('is-row-tool')) return;
          if (item.classList.contains('is-rowadd-tool')) return;
          if (item.classList.contains('is-col-tool')) return;
          if (item === col) return;
          numOfCols++;
        });
        if (col.style.width) {
          col.style.width = col.offsetWidth + 'px'; // change from % to px

          let percentage = parseInt(col.style.width) / row.offsetWidth * 100;

          // adjust others
          const maxWidth = () => {
            let otherWidth = 0;
            Array.from(col.parentNode.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

              if (item.classList.contains('row-tool')) return;
              if (item === col) return;
              otherWidth += item.offsetWidth;
            });
            return row.offsetWidth - otherWidth;
          };
          const max = maxWidth();
          if (parseInt(col.style.width) > max) {
            // Adjust to max
            // percentage = (max / row.offsetWidth) * 100;
            // Or make others auto

            Array.from(col.parentNode.children).map(item => {
              if (item.classList.contains('is-row-tool')) return;
              if (item.classList.contains('is-rowadd-tool')) return;
              if (item.classList.contains('is-col-tool')) return;
              // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

              if (item === col) return;

              // // item.style.width = '100%';
              // if(!item.getAttribute('data-html')) item.style.width = '100%';
              // item.style.flex = '';
              if (numOfCols === 2) {
                if (!item.getAttribute('data-html')) {
                  item.style.width = '100%';
                  item.style.flex = '';
                }
              } /*else {
                  // if(!item.getAttribute('data-html') && !item.style.width) {
                  //     item.style.width = '100%';
                  //     item.style.flex = '';
                  // }
                  if(!item.getAttribute('data-html') && item===col.nextElementSibling) {
                      item.style.width = '100%';
                      item.style.flex = '';
                  }
                }*/
            });
          }
          // /adjust others

          // New: Final fix (if column resized exceeds its max)
          let othersWidth = 0;
          let activeColumnWidth = 0;
          Array.from(col.parentNode.children).map(item => {
            if (item.classList.contains('is-row-tool')) return;
            if (item.classList.contains('is-rowadd-tool')) return;
            if (item.classList.contains('is-col-tool')) return;
            // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

            // // Refresh Module
            // if(item.getAttribute('data-html')) {
            //     this.builder.util.refreshModuleLayout(item);
            // }

            if (item === col) {
              activeColumnWidth = item.offsetWidth;
            } else {
              othersWidth += item.offsetWidth;
            }
          });
          let maxResult = row.offsetWidth - othersWidth;
          if (activeColumnWidth > maxResult) {
            percentage = maxResult / row.offsetWidth * 100;
          }
          col.style.width = percentage + '%';

          // Refresh Module
          Array.from(col.parentNode.children).map(item => {
            if (item.classList.contains('is-row-tool')) return;
            if (item.classList.contains('is-rowadd-tool')) return;
            if (item.classList.contains('is-col-tool')) return;
            if (item.getAttribute('data-html')) {
              let moduleWidth = item.offsetWidth / row.offsetWidth * 100;
              item.style.width = moduleWidth + '%';
              item.style.flex = 'none';
              if (!item.hasAttribute('data-norefresh')) this.builder.util.refreshModuleLayout(item);
            }
          });
        }
        if (col.style.height) {
          col.style.minHeight = col.style.height;
          col.style.height = '';
          Array.from(col.parentNode.children).map(item => {
            if (item.classList.contains('is-row-tool')) return;
            if (item.classList.contains('is-rowadd-tool')) return;
            if (item.classList.contains('is-col-tool')) return;
            // if(this.opts.filterSibling) if(item.classList.contains(this.opts.filterSibling)) return;

            if (item === col) return;
            item.style.height = '';
            item.style.minHeight = '';
          });
        }

        // // To position columnTool correctly, add delay.
        // setTimeout(()=>{
        //     col.click();
        // },30);

        //Trigger Change event
        this.builder.opts.onChange();
      }
    });
  }
  destroy() {
    this.resize.destroy();
  }
}

class ContentStuff {
  constructor(builder) {
    this.builder = builder;
    const util = builder.util;
    const html = `<div class="is-tool is-column-tool">
            <button type="button" tabindex="-1" title="${util.out('Add')}" class="cell-add"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            <button type="button" tabindex="-1" title="${util.out('More')}" class="cell-more"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
            <button type="button" tabindex="-1" title="${util.out('Delete')}" class="cell-remove"><svg class="is-icon-flex" style="margin-left:-1px"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
        </div>
        <div class="is-tool is-element-tool">
            <button type="button" tabindex="-1" title="${util.out('Add')}" class="elm-add"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
            <button type="button" tabindex="-1" title="${util.out('More')}" class="elm-more"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
            <button type="button" tabindex="-1" title="${util.out('Delete')}" class="elm-remove"><svg class="is-icon-flex" style="margin-left:-1px"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
            <button type="button" tabindex="-1" title="${util.out('Settings')}" class="elm-settings"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>

        <div id="divButtonTool" class="is-tool">
            <button title="${util.out('Edit Button')}" data-title="${util.out('Edit Button')}" class="button-edit"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-android-create"></use></svg></button>
            <button title="${util.out('Duplicate')}" data-title="${util.out('Duplicate')}" class="button-duplicate"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
            <button title="${util.out('Delete')}" data-title="${util.out('Delete')}" class="button-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
        </div>
        <div class="is-tool is-code-tool">
            <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div id="divLinkTool" class="is-tool">
            <button title="${util.out('Edit Button')}" data-title="${util.out('Edit Button')}" class="link-button-edit" style="display:none;"><svg class="is-icon-flex" style="width:12px;height:12px;"><use xlink:href="#ion-android-create"></use></svg></button>
            <button title="${util.out('Link')}" data-title="${util.out('Link')}" class="link-edit"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-link"></use></svg></button>
            <button title="${util.out('Duplicate')}" data-title="${util.out('Duplicate')}" class="link-duplicate"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#ion-ios-photos-outline"></use></svg></button>
            <button title="${util.out('Delete')}" data-title="${util.out('Delete')}" class="link-remove"><svg class="is-icon-flex" style="width:20px;height:20px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
        </div>
        <div class="is-tool is-iframe-tool">
            <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div class="is-tool is-module-tool">
            <button class="btn-module-refresh" title="${util.out('Refresh')}" data-title="${util.out('Refresh')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#icon-reload"></use></svg></button>
            <button class="btn-module-settings" title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div class="is-tool is-svg-tool">
            <button class="btn-svg-settings" title="${util.out('Settings')}" data-title="${util.out('Settings')}"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div id="divSpacerTool" class="is-tool is-spacer-tool">
            <button title="${util.out('Decrease')}" data-value="-"><svg class="is-icon-flex"><use xlink:href="#ion-ios-minus-empty"></use></svg></button>
            <button title="${util.out('Increase')}" data-value="+" style="border-left: none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-plus-empty"></use></svg></button>
        </div>
        <div class="is-tool is-table-tool">
            <button title="${util.out('Settings')}" style="width:40px;height:40px;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div class="is-tool is-video-tool">
            <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:40px;height:40px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        <div class="is-tool is-audio-tool">
            <button title="${util.out('Settings')}" data-title="${util.out('Settings')}" style="width:37px;height:37px;background:none;"><svg class="is-icon-flex"><use xlink:href="#ion-ios-gear"></use></svg></button>
        </div>
        
        <div class="is-locked-indicator">
            <svg class="is-icon-flex"><use xlink:href="#icon-lock"></use></svg>
        </div>

        <svg width="0" height="0" style="position:absolute;display:none;">
            <defs>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-left"><path d="M352 115.4L331.3 96 160 256l171.3 160 20.7-19.3L201.5 256z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-right"><path d="M160 115.4L180.7 96 352 256 180.7 416 160 396.7 310.5 256z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-plus-outline"><path d="M256 48C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48zm0 398.7c-105.1 0-190.7-85.5-190.7-190.7S150.9 65.3 256 65.3 446.7 150.9 446.7 256 361.1 446.7 256 446.7z"></path><path d="M264.1 128h-16.8v119.9H128v16.8h119.3V384h16.8V264.7H384v-16.8H264.1z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-image"><path d="M368 224c26.5 0 48-21.5 48-48s-21.5-48-48-48-48 21.5-48 48 21.5 48 48 48z"></path><path d="M452 64H60c-15.6 0-28 12.7-28 28.3v327.4c0 15.6 12.4 28.3 28 28.3h392c15.6 0 28-12.7 28-28.3V92.3c0-15.6-12.4-28.3-28-28.3zM348.9 261.7c-3-3.5-7.6-6.2-12.8-6.2-5.1 0-8.7 2.4-12.8 5.7L304.6 277c-3.9 2.8-7 4.7-11.5 4.7-4.3 0-8.2-1.6-11-4.1-1-.9-2.8-2.6-4.3-4.1L224 215.3c-4-4.6-10-7.5-16.7-7.5-6.7 0-12.9 3.3-16.8 7.8L64 368.2V107.7c1-6.8 6.3-11.7 13.1-11.7h357.7c6.9 0 12.5 5.1 12.9 12l.3 260.4-99.1-106.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-photos-outline"><path d="M96 128v320h384V128H96zm368 304H112V144h352v288z"></path><path d="M32 64v320h48v-16H48V80h352v32h16V64z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-settings-strong"><path d="M32 376h283.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32h-91.35c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32M32 240h91.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32H196.65c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32M32 104h283.35c6.186-14.112 20.281-24 36.65-24s30.465 9.888 36.65 24H480v32h-91.35c-6.186 14.112-20.281 24-36.65 24s-30.465-9.888-36.65-24H32"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-settings"><path d="M352 104c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM352 376c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM160 240c8.837 0 16 7.163 16 16s-7.163 16-16 16-16-7.163-16-16 7.163-16 16-16m0-16c-17.645 0-32 14.355-32 32s14.355 32 32 32 32-14.355 32-32-14.355-32-32-32zM207.32 248H480v16H207.32c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM112 256c0 2.727.24 5.396.68 8H32v-16h80.68a47.955 47.955 0 0 0-.68 8zM399.32 384H480v16h-80.68c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM304 392c0 2.727.24 5.396.68 8H32v-16h272.68a47.955 47.955 0 0 0-.68 8zM399.32 112H480v16h-80.68c.439-2.604.68-5.273.68-8s-.24-5.396-.68-8zM304.68 112c-.439 2.604-.68 5.273-.68 8s.24 5.396.68 8H32v-16h272.68z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-options"><path d="M32 384h272v32H32zM400 384h80v32h-80zM384 447.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path><g><path d="M32 240h80v32H32zM208 240h272v32H208zM192 303.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path></g><g><path d="M32 96h272v32H32zM400 96h80v32h-80zM384 159.5c0 17.949-14.327 32.5-32 32.5-17.673 0-32-14.551-32-32.5v-95c0-17.949 14.327-32.5 32-32.5 17.673 0 32 14.551 32 32.5v95z"></path></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-list-number"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-1043.45,1024 C-1039.25,946.283 -1023.18,878.648 -995.249,821.096 C-967.313,763.544 -912.806,711.242 -831.728,664.192 L-710.742,594.247 C-656.55,562.74 -618.532,535.854 -596.687,513.589 C-562.24,478.722 -545.016,438.813 -545.016,393.863 C-545.016,341.352 -560.769,299.658 -592.276,268.781 C-623.783,237.904 -665.792,222.466 -718.304,222.466 C-796.02,222.466 -849.792,251.873 -879.619,310.685 C-895.582,342.192 -904.404,385.882 -906.084,441.754 L-1021.4,441.754 C-1020.14,363.197 -1005.65,299.133 -977.92,249.562 C-928.769,162.183 -842.02,118.494 -717.673,118.494 C-614.331,118.494 -538.82,146.43 -491.139,202.302 C-443.459,258.174 -419.619,320.347 -419.619,388.822 C-419.619,461.078 -445.034,522.831 -495.865,574.082 C-525.272,603.909 -577.993,640.037 -654.03,682.466 L-740.358,730.356 C-781.527,753.041 -813.874,774.676 -837.399,795.26 C-879.408,831.808 -905.874,872.347 -916.797,916.877 L-424.03,916.877 L-424.03,1024 L-1043.45,1024 Z "  /><path d="M-922.391,-764.384 L-922.391,-851.343 C-840.474,-859.324 -783.341,-872.662 -750.994,-891.356 C-718.647,-910.05 -694.492,-954.265 -678.529,-1024 L-589.049,-1024 L-589.049,-125.425 L-710.035,-125.425 L-710.035,-764.384 L-922.391,-764.384 Z "  /><path d="M-198.618,-510.942 L-198.618,-667.156 L1004.57,-667.156 L1004.57,-510.942 L-198.618,-510.942 Z "  /><path d="M-198.618,78.1071 L-198.618,-78.1071 L1004.57,-78.1071 L1004.57,78.1071 L-198.618,78.1071 Z "  /><path d="M-179.185,649.354 L-179.185,493.14 L1024,493.14 L1024,649.354 L-179.185,649.354 Z "  /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-list-bullet"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-379.801,-514.33 L-379.801,-670.545 L914.662,-670.545 L914.662,-514.33 L-379.801,-514.33 Z "  /><path d="M-379.801,78.1071 L-379.801,-78.1071 L914.662,-78.1071 L914.662,78.1071 L-379.801,78.1071 Z "  /><path d="M-379.801,670.545 L-379.801,514.33 L914.662,514.33 L914.662,670.545 L-379.801,670.545 Z "  /><path d="M-929.642,-469.441 L-929.642,-715.434 L-669.092,-715.434 L-669.092,-469.441 L-929.642,-469.441 Z "  /><path d="M-929.642,127.109 L-929.642,-118.885 L-669.092,-118.885 L-669.092,127.109 L-929.642,127.109 Z "  /><path d="M-929.642,715.434 L-929.642,469.441 L-669.092,469.441 L-669.092,715.434 L-929.642,715.434 Z "  /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-clean">
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                    <path d="M75.0013,893.849 L-1030.73,900.993 L-32.1518,-880.838 L1009.54,-880.838 L75.0013,893.849 Z " fill="currentColor" />
                    <path d="M-30.8571,780.685 L-845.2,787.828 L-508.893,193.749 L305.26,194.963 L-30.8571,780.685 Z " fill="#ffffff" fill-opacity="1.00" />
                </g>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-location"><path d="M256 64c-65.9 0-119.3 53.7-119.3 120 0 114.6 119.3 264 119.3 264s119.3-149.4 119.3-264c0-66.3-53.4-120-119.3-120zm0 178.2c-31.2 0-56.4-25.4-56.4-56.7 0-31.3 25.3-56.8 56.4-56.8 31.2 0 56.4 25.4 56.4 56.8 0 31.3-25.2 56.7-56.4 56.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-film-outline"><path d="M0 360h400v-336h-400v336zM72 40v48h-56v-48h56zM72 104v48h-56v-48h56zM72 168v48h-56v-48h56zM72 232v48h-56v-48h56zM72 296v48h-56v-48h56zM312 40v144h-224v-144h224zM312 200v144h-224v-144h224zM384 40v48h-56v-48h56zM384 104v48h-56v-48h56zM384 168v48h-56v-48
                h56zM384 232v48h-56v-48h56zM384 296v48h-56v-48h56z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-social-youtube-outline"><path d="M265 96c65.3 0 118.7 1.1 168.1 3.3h1.4c23.1 0 42 22 42 49.1v1.1l.1 1.1c2.3 34 3.4 69.3 3.4 104.9.1 35.6-1.1 70.9-3.4 104.9l-.1 1.1v1.1c0 13.8-4.7 26.6-13.4 36.1-7.8 8.6-18 13.4-28.6 13.4h-1.6c-52.9 2.5-108.8 3.8-166.4 3.8h-10.6.1-10.9c-57.8 0-113.7-1.3-166.2-3.7h-1.6c-10.6 0-20.7-4.8-28.5-13.4-8.6-9.5-13.4-22.3-13.4-36.1v-1.1l-.1-1.1c-2.4-34.1-3.5-69.4-3.3-104.7v-.2c-.1-35.3 1-70.5 3.3-104.6l.1-1.1v-1.1c0-27.2 18.8-49.3 41.9-49.3h1.4c49.5-2.3 102.9-3.3 168.2-3.3H265m0-32.2h-18c-57.6 0-114.2.8-169.6 3.3-40.8 0-73.9 36.3-73.9 81.3C1 184.4-.1 220 0 255.7c-.1 35.7.9 71.3 3.4 107 0 45 33.1 81.6 73.9 81.6 54.8 2.6 110.7 3.8 167.8 3.8h21.6c57.1 0 113-1.2 167.9-3.8 40.9 0 74-36.6 74-81.6 2.4-35.7 3.5-71.4 3.4-107.1.1-35.7-1-71.3-3.4-107.1 0-45-33.1-81.1-74-81.1C379.2 64.8 322.7 64 265 64z"></path><path d="M207 353.8V157.4l145 98.2-145 98.2z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-play"><path d="M128 96v320l256-160L128 96z"></path></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-full"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-770.219,-115.563 L-770.219,-271.777 L770.219,-271.777 L770.219,-115.563 L-770.219,-115.563 Z " /><path d="M-770.219,303.503 L-770.219,147.288 L770.219,147.288 L770.219,303.503 L-770.219,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-center"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-552.286,-107.697 L-552.286,-263.911 L552.286,-263.911 L552.286,-107.697 L-552.286,-107.697 Z " /><path d="M-467.355,319.234 L-467.355,163.02 L466.34,163.02 L466.34,319.234 L-467.355,319.234 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-left"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-770.219,-115.563 L-770.219,-271.777 L482.839,-271.777 L482.839,-115.563 L-770.219,-115.563 Z " /><path d="M-770.219,303.503 L-770.219,147.288 L122.787,147.288 L122.787,303.503 L-770.219,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-align-right"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-770.727,738.299 L-770.727,582.085 L769.712,582.085 L769.712,738.299 L-770.727,738.299 Z " /><path d="M-770.727,-534.628 L-770.727,-690.842 L769.712,-690.842 L769.712,-534.628 L-770.727,-534.628 Z " /><path d="M-483.346,-118.081 L-483.346,-274.295 L769.712,-274.295 L769.712,-118.081 L-483.346,-118.081 Z " /><path d="M-123.871,303.503 L-123.871,147.288 L769.136,147.288 L769.136,303.503 L-123.871,303.503 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-indent"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-829.04,-514.33 L-829.04,-670.545 L808.959,-670.545 L808.959,-514.33 L-829.04,-514.33 Z " /><path d="M-829.04,670.545 L-829.04,514.33 L808.959,514.33 L808.959,670.545 L-829.04,670.545 Z " /><path d="M-254.279,-110.244 L-254.279,-266.458 L808.959,-266.458 L808.959,-110.244 L-254.279,-110.244 Z " /><path d="M-254.279,266.458 L-254.279,110.244 L808.959,110.244 L808.959,266.458 L-254.279,266.458 Z " /><path d="M-829.04,-195.117 L-490.958,-1.03508e-14 L-829.04,195.117 L-829.04,-195.117 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-outdent"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-829.04,-514.33 L-829.04,-670.545 L808.959,-670.545 L808.959,-514.33 L-829.04,-514.33 Z " /><path d="M-829.04,670.545 L-829.04,514.33 L808.959,514.33 L808.959,670.545 L-829.04,670.545 Z " /><path d="M-829.04,-110.244 L-829.04,-266.458 L234.198,-266.458 L234.198,-110.244 L-829.04,-110.244 Z " /><path d="M-829.04,266.458 L-829.04,110.244 L234.198,110.244 L234.198,266.458 L-829.04,266.458 Z " /><path d="M808.959,-195.117 L470.877,-1.03508e-14 L808.959,195.117 L808.959,-195.117 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-table"><rect x="0" y="0" width="2048.00" height="2048.00" fill="none" /><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M-660.783,660.783 L660.783,660.783 L660.783,-660.783 L-660.783,-660.783 L-660.783,660.783 Z " fill="none" stroke-width="75.82" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /><path d="M-37.9645,698.933 L37.9645,698.933 L37.9645,-698.569 L-37.9645,-698.569 L-37.9645,698.933 Z " fill="currentColor" fill-opacity="1.00" stroke-width="0.25" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /><path d="M-698.933,-37.7825 L-698.933,38.1465 L698.569,38.1465 L698.569,-37.7825 L-698.933,-37.7825 Z " fill="currentColor" fill-opacity="1.00" stroke-width="0.25" stroke="currentColor" stroke-linecap="square" stroke-linejoin="miter" /></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-happy"><path d="M256 48C140.563 48 48 141.6 48 256s92.563 208 208 208 208-93.6 208-208S370.401 48 256 48zm0 374.4c-91.518 0-166.404-74.883-166.404-166.4 0-91.518 74.887-166.4 166.404-166.4S422.404 164.482 422.404 256 347.518 422.4 256 422.4zm72.8-187.2c17.683 0 31.201-13.518 31.201-31.2s-13.519-31.2-31.201-31.2c-17.682 0-31.2 13.518-31.2 31.2s13.518 31.2 31.2 31.2zm-145.6 0c17.682 0 31.2-13.518 31.2-31.2s-13.519-31.2-31.2-31.2c-17.683 0-31.201 13.518-31.201 31.2s13.519 31.2 31.201 31.2zM256 370.4c48.883 0 89.436-30.164 106.081-72.801H149.919C166.564 340.236 207.117 370.4 256 370.4z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-create"><path d="M64 368v80h80l235.727-235.729-79.999-79.998L64 368zm377.602-217.602c8.531-8.531 8.531-21.334 0-29.865l-50.135-50.135c-8.531-8.531-21.334-8.531-29.865 0l-39.468 39.469 79.999 79.998 39.469-39.467z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-minus-empty"><path d="M384 265H128v-17h256v17z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-eye"><path d="M256 128c-81.9 0-145.7 48.8-224 128 67.4 67.7 124 128 224 128 99.9 0 173.4-76.4 224-126.6C428.2 198.6 354.8 128 256 128zm0 219.3c-49.4 0-89.6-41-89.6-91.3 0-50.4 40.2-91.3 89.6-91.3s89.6 41 89.6 91.3c0 50.4-40.2 91.3-89.6 91.3z"></path><path d="M256 224c0-7.9 2.9-15.1 7.6-20.7-2.5-.4-5-.6-7.6-.6-28.8 0-52.3 23.9-52.3 53.3s23.5 53.3 52.3 53.3 52.3-23.9 52.3-53.3c0-2.3-.2-4.6-.4-6.9-5.5 4.3-12.3 6.9-19.8 6.9-17.8 0-32.1-14.3-32.1-32z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-reply"><path d="M448 400s-36.8-208-224-208v-80L64 256l160 134.4v-92.3c101.6 0 171 8.9 224 101.9z"></path></symbol>
            
            <symbol viewBox="0 0 512 512" id="ion-wrench"><path d="M461.9 114.9l-56.5 56.7-55.1-10-9.9-55.1 56.5-56.7c-12.7-12.7-30.8-18.5-44.2-17.8-13.5.7-42.3 8.3-64.6 32-21.6 22.8-44.3 65.3-24.2 112.5 2.4 5.7 5.1 13.2-2.9 21.2-8.1 8-215 202.8-215 202.8-19.4 16.7-18 47.6-.1 65.6 18.2 17.9 48.9 19 65.6-.3 0 0 193.2-205.8 202.7-215.1 8.5-8.3 16.1-5.5 21.2-2.9 35.6 18.4 86.3 2.4 112.6-23.9 26.3-26.3 31.1-51.7 31.9-64.7.8-12.9-3.7-30-18-44.3zM91.3 443.2c-6.3 6.2-16.5 6.2-22.7 0-6.2-6.3-6.2-16.5 0-22.7 6.3-6.2 16.5-6.2 22.7 0 6.2 6.3 6.2 16.5 0 22.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-more"><path d="M113.7 304C86.2 304 64 282.6 64 256c0-26.5 22.2-48 49.7-48 27.6 0 49.8 21.5 49.8 48 0 26.6-22.2 48-49.8 48zM256 304c-27.5 0-49.8-21.4-49.8-48 0-26.5 22.3-48 49.8-48 27.5 0 49.7 21.5 49.7 48 0 26.6-22.2 48-49.7 48zM398.2 304c-27.5 0-49.8-21.4-49.8-48 0-26.5 22.2-48 49.8-48 27.5 0 49.8 21.5 49.8 48 0 26.6-22.2 48-49.8 48z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-code-working"><circle cx="184.166" cy="256.166" r="24"></circle><circle cx="256.166" cy="256.166" r="24"></circle><circle cx="328.166" cy="256.166" r="24"></circle><g><path d="M168 392a23.929 23.929 0 0 1-16.971-7.029l-112-112c-9.373-9.373-9.373-24.569 0-33.941l112-112c9.373-9.372 24.568-9.372 33.941 0 9.371 9.372 9.371 24.568 0 33.941L89.941 256l95.029 95.029c9.371 9.372 9.371 24.568 0 33.941A23.925 23.925 0 0 1 168 392zM344 392a23.929 23.929 0 0 0 16.971-7.029l112-112c9.373-9.373 9.373-24.569 0-33.941l-112-112c-9.373-9.372-24.568-9.372-33.941 0-9.371 9.372-9.371 24.568 0 33.941L422.059 256l-95.029 95.029c-9.371 9.372-9.371 24.568 0 33.941A23.925 23.925 0 0 0 344 392z"></path></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-gear"><path d="M416.349 256.046c-.001-21.013 13.143-38.948 31.651-46.062a196.302 196.302 0 0 0-23.664-57.139 49.423 49.423 0 0 1-20.082 4.254c-12.621 0-25.238-4.811-34.871-14.442-14.863-14.863-18.248-36.846-10.18-54.97A196.274 196.274 0 0 0 302.074 64C294.971 82.529 277.027 95.69 256 95.69c-21.025 0-38.969-13.161-46.073-31.69a196.243 196.243 0 0 0-57.128 23.688c8.068 18.122 4.683 40.104-10.181 54.97-9.631 9.631-22.25 14.443-34.871 14.443a49.429 49.429 0 0 1-20.083-4.255A196.273 196.273 0 0 0 64 209.984c18.509 7.112 31.652 25.049 31.652 46.062 0 21.008-13.132 38.936-31.63 46.054a196.318 196.318 0 0 0 23.692 57.128 49.428 49.428 0 0 1 20.032-4.232c12.622 0 25.239 4.812 34.871 14.443 14.841 14.841 18.239 36.781 10.215 54.889a196.257 196.257 0 0 0 57.13 23.673c7.128-18.479 25.046-31.596 46.038-31.596 20.992 0 38.91 13.115 46.037 31.596a196.234 196.234 0 0 0 57.132-23.675c-8.023-18.106-4.626-40.046 10.216-54.887 9.629-9.632 22.248-14.444 34.868-14.444 6.836 0 13.67 1.411 20.033 4.233a196.318 196.318 0 0 0 23.692-57.128c-18.498-7.119-31.629-25.048-31.629-46.054zM256.9 335.9c-44.3 0-80-35.9-80-80 0-44.101 35.7-80 80-80 44.299 0 80 35.899 80 80 0 44.1-35.701 80-80 80z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-arrow-expand"><path d="M274 209.7l63.9-63.8L288 96h128v128l-49.9-49.9-63.8 63.9zM274 302.3l63.9 63.8L288 416h128V288l-49.9 49.9-63.8-63.9zM238 302.3l-63.9 63.8L224 416H96V288l49.9 49.9 63.8-63.9zM238 209.7l-63.9-63.8L224 96H96v128l49.9-49.9 63.8 63.9z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-expand"><path d="M396.795 396.8H320V448h128V320h-51.205zM396.8 115.205V192H448V64H320v51.205zM115.205 115.2H192V64H64v128h51.205zM115.2 396.795V320H64v128h128v-51.205z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-arrow-move"><path d="M480 256l-96-96v76H276V128h76l-96-96-96 96h76v108H128v-76l-96 96 96 96v-76h108v108h-76l96 96 96-96h-76.2l-.4-108.5 108.6.3V352z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-drag"><path d="M0 144h512v32H0zM0 240h512v32H0zM0 336h512v32H0z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-link"><path d="M74.6 256c0-38.3 31.1-69.4 69.4-69.4h88V144h-88c-61.8 0-112 50.2-112 112s50.2 112 112 112h88v-42.6h-88c-38.3 0-69.4-31.1-69.4-69.4zm85.4 22h192v-44H160v44zm208-134h-88v42.6h88c38.3 0 69.4 31.1 69.4 69.4s-31.1 69.4-69.4 69.4h-88V368h88c61.8 0 112-50.2 112-112s-50.2-112-112-112z"/></symbol>
            <symbol viewBox="0 0 512 512" id="ion-contrast"><path d="M256 32C132.3 32 32 132.3 32 256s100.3 224 224 224 224-100.3 224-224S379.7 32 256 32zm135.8 359.8C355.5 428 307 448 256 448V64c51 0 99.5 20 135.8 56.2C428 156.5 448 204.7 448 256c0 51.3-20 99.5-56.2 135.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-plus-empty"><path d="M384 265H264v119h-17V265H128v-17h119V128h17v120h120v17z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-up"><path d="M349.7 189.8c-3.1 3.1-8 3-11.3 0L264 123.4V408c0 4.4-3.6 8-8 8s-8-3.6-8-8V123.4l-74.4 66.3c-3.4 2.9-8.1 3.2-11.2.1-3.1-3.1-3.3-8.5-.1-11.4 0 0 87-79.2 88-80s2.8-2.4 5.7-2.4 4.9 1.6 5.7 2.4 88 80 88 80c1.5 1.5 2.3 3.6 2.3 5.7s-.8 4.1-2.3 5.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-down"><path d="M349.7 322.2c-3.1-3.1-8-3-11.3 0L264 388.6V104c0-4.4-3.6-8-8-8s-8 3.6-8 8v284.6l-74.4-66.3c-3.4-2.9-8.1-3.2-11.2-.1-3.1 3.1-3.3 8.5-.1 11.4 0 0 87 79.2 88 80s2.8 2.4 5.7 2.4 4.9-1.6 5.7-2.4 88-80 88-80c1.5-1.5 2.3-3.6 2.3-5.7s-.8-4.1-2.3-5.7z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-left"><path d="M189.8 349.7c3.1-3.1 3-8 0-11.3L123.4 264H408c4.4 0 8-3.6 8-8s-3.6-8-8-8H123.4l66.3-74.4c2.9-3.4 3.2-8.1.1-11.2-3.1-3.1-8.5-3.3-11.4-.1 0 0-79.2 87-80 88S96 253.1 96 256s1.6 4.9 2.4 5.7 80 88 80 88c1.5 1.5 3.6 2.3 5.7 2.3s4.1-.8 5.7-2.3z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-arrow-thin-right"><path d="M322.2 349.7c-3.1-3.1-3-8 0-11.3l66.4-74.4H104c-4.4 0-8-3.6-8-8s3.6-8 8-8h284.6l-66.3-74.4c-2.9-3.4-3.2-8.1-.1-11.2 3.1-3.1 8.5-3.3 11.4-.1 0 0 79.2 87 80 88s2.4 2.8 2.4 5.7-1.6 4.9-2.4 5.7-80 88-80 88c-1.5 1.5-3.6 2.3-5.7 2.3s-4.1-.8-5.7-2.3z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-close-empty"><path d="M340.2 160l-84.4 84.3-84-83.9-11.8 11.8 84 83.8-84 83.9 11.8 11.7 84-83.8 84.4 84.2 11.8-11.7-84.4-84.3 84.4-84.2z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-more-vertical"><path d="M296 136c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0 240c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40zm0-120c0-22.002-17.998-40-40-40s-40 17.998-40 40 17.998 40 40 40 40-17.998 40-40z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-quote"><path d="M192 64c-40.646 0-72.483 11.229-94.627 33.373C75.229 119.517 64 151.354 64 192v256h160V192h-96c0-23.056 4.922-39.666 14.627-49.373C152.334 132.922 168.944 128 192 128M416 64c-40.646 0-72.483 11.229-94.627 33.373C299.229 119.517 288 151.354 288 192v256h160V192h-96c0-23.056 4.922-39.666 14.627-49.373C376.334 132.922 392.944 128 416 128"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-code"><path d="M168 392a23.929 23.929 0 0 1-16.971-7.029l-112-112c-9.373-9.373-9.373-24.569 0-33.941l112-112c9.373-9.372 24.568-9.372 33.941 0 9.371 9.372 9.371 24.568 0 33.941L89.941 256l95.029 95.029c9.371 9.373 9.371 24.568 0 33.941A23.925 23.925 0 0 1 168 392zM344 392a23.929 23.929 0 0 0 16.971-7.029l112-112c9.373-9.373 9.373-24.569 0-33.941l-112-112c-9.373-9.372-24.568-9.372-33.941 0-9.371 9.372-9.371 24.568 0 33.941L422.059 256l-95.029 95.029c-9.371 9.373-9.371 24.568 0 33.941A23.925 23.925 0 0 0 344 392z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-camera"><path d="M430.4 147h-67.5l-40.4-40.8s-.2-.2-.3-.2l-.2-.2c-6-6-14.1-9.8-23.3-9.8h-84c-9.8 0-18.5 4.2-24.6 10.9v.1l-39.5 40h-69C63 147 48 161.6 48 180.2v202.1c0 18.6 15 33.7 33.6 33.7h348.8c18.5 0 33.6-15.1 33.6-33.7V180.2c0-18.6-15.1-33.2-33.6-33.2zM256 365.5c-50.9 0-92.4-41.6-92.4-92.6 0-51.1 41.5-92.6 92.4-92.6 51 0 92.4 41.5 92.4 92.6 0 51-41.4 92.6-92.4 92.6zm168.1-165c-7.7 0-14-6.3-14-14.1s6.3-14.1 14-14.1 14 6.3 14 14.1-6.3 14.1-14 14.1z"></path><path d="M256 202.9c-38.6 0-69.8 31.3-69.8 70 0 38.6 31.2 70 69.8 70 38.5 0 69.8-31.3 69.8-70s-31.3-70-69.8-70z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-move"><path d="M475.9 246.2l-79.4-79.4c-5.4-5.4-14.2-5.4-19.6 0l-.2.2c-5.4 5.4-5.4 14.2 0 19.6l54.9 54.9-161.8.5.5-161.8 54.9 54.9c5.4 5.4 14.2 5.4 19.6 0l.2-.2c5.4-5.4 5.4-14.2 0-19.6l-79.4-79.4c-5.4-5.4-14.2-5.4-19.6 0l-79.4 79.4c-5.4 5.4-5.4 14.2 0 19.6l.2.2c5.4 5.4 14.2 5.4 19.6 0l54.9-54.9.5 161.8-161.8-.5 54.9-54.9c5.4-5.4 5.4-14.2 0-19.6l-.2-.2c-5.4-5.4-14.2-5.4-19.6 0l-79.4 79.4c-5.4 5.4-5.4 14.2 0 19.6l79.4 79.4c5.4 5.4 14.2 5.4 19.6 0l.2-.2c5.4-5.4 5.4-14.2 0-19.6L80 270.5l161.8-.5-.5 161.8-54.9-54.9c-5.4-5.4-14.2-5.4-19.6 0l-.2.2c-5.4 5.4-5.4 14.2 0 19.6l79.4 79.4c5.4 5.4 14.2 5.4 19.6 0l79.4-79.4c5.4-5.4 5.4-14.2 0-19.6l-.2-.2c-5.4-5.4-14.2-5.4-19.6 0l-54.9 54.9-.5-161.8 161.8.5-54.9 54.9c-5.4 5.4-5.4 14.2 0 19.6l.2.2c5.4 5.4 14.2 5.4 19.6 0l79.4-79.4c5.5-5.4 5.5-14.2 0-19.6z"/></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-ok">
                <rect x="0" y="0" width="2048.00" height="2048.00" fill="none" />
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                <path d="M330.323,493.628 L330.323,398.406 L-330.323,398.406 L-330.323,493.628 L330.323,493.628 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M230.718,468.568 L328.59,468.568 L328.59,-599.718 L230.718,-599.718 L230.718,468.568 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M-300.714,376.053 L-373.748,449.088 L-68.5805,754.255 L4.45387,681.221 L-300.714,376.053 Z " fill="currentColor" fill-opacity="1.00" />
                <path d="M-9.9476e-14,216.241 L-73.0344,143.207 L-378.202,448.375 L-305.168,521.409 L-9.9476e-14,216.241 Z " fill="currentColor" fill-opacity="1.00" />
                </g>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-grid"><path d="M160 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 153.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path><g><path d="M160 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 281.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path></g><g><path d="M160 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM288 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5zM416 409.3c0 3.7-3 6.7-6.7 6.7h-50.5c-3.7 0-6.7-3-6.7-6.7v-50.5c0-3.7 3-6.7 6.7-6.7h50.5c3.7 0 6.7 3 6.7 6.7v50.5z"></path></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-gear-b"><path d="M448 294.4v-76.8h-42.8c-3.4-14.4-8.9-28-16.1-40.5l29.8-29.7-54.3-54.3-29.1 29.1c-12.6-7.7-26.4-13.5-41.1-17.3V64h-76.8v40.9c-14.7 3.8-28.5 9.7-41.1 17.3l-29.1-29.1-54.3 54.3 29.8 29.7c-7.2 12.5-12.6 26.1-16.1 40.5H64v76.8h44.1c3.8 13.7 9.5 26.6 16.7 38.6l-31.7 31.7 54.3 54.3 32.3-32.3c11.7 6.8 24.5 11.9 37.9 15.4v46h76.8v-46c13.5-3.5 26.2-8.6 37.9-15.4l32.3 32.3 54.3-54.3-31.6-31.7c7.2-11.9 12.9-24.8 16.7-38.6h44zm-192 15.4c-29.7 0-53.7-24.1-53.7-53.8s24-53.8 53.7-53.8 53.8 24.1 53.8 53.8-24.1 53.8-53.8 53.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-grid-view-outline"><path d="M448 192v-16H336V64h-16v112H192V64h-16v112H64v16h112v128H64v16h112v112h16V336h128v112h16V336h112v-16H336V192h112zM320 320H192V192h128v128z"></path></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-increase"><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M852.574,595.004 L852.574,507.837 L-852.574,507.837 L-852.574,595.004 L852.574,595.004 Z " /><path d="M852.574,224.232 L852.574,137.066 L-852.574,137.066 L-852.574,224.232 L852.574,224.232 Z " /><path d="M852.574,-134.971 L852.574,-222.138 L-852.574,-222.138 L-852.574,-134.971 L852.574,-134.971 Z " /><path d="M852.574,-505.743 L852.574,-592.909 L-852.574,-592.909 L-852.574,-505.743 L852.574,-505.743 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-decrease"><g transform="matrix(1,0,0,1,1024.0,1024.0)"><path d="M509.832,595.004 L509.832,507.837 L-509.832,507.837 L-509.832,595.004 L509.832,595.004 Z " /><path d="M509.832,224.232 L509.832,137.066 L-509.832,137.066 L-509.832,224.232 L509.832,224.232 Z " /><path d="M509.832,-136.947 L509.832,-224.113 L-509.832,-224.113 L-509.832,-136.947 L509.832,-136.947 Z " /><path d="M509.832,-505.743 L509.832,-592.909 L-509.832,-592.909 L-509.832,-505.743 L509.832,-505.743 Z " /></g></symbol>
            <symbol viewBox="0 0 2048.0 2048.0" id="icon-strike">
                <g transform="matrix(1,0,0,1,1024.0,1024.0)">
                <path d="M298.298,-653.766 C292.151,-624.873 284.005,-605.663 273.862,-596.135 C263.719,-586.607 250.656,-581.842 234.673,-581.842 C220.535,-581.842 196.253,-589.526 161.828,-604.895 C87.4454,-637.475 17.0588,-653.766 -49.3321,-653.766 C-155.68,-653.766 -243.28,-621.339 -312.129,-556.485 C-380.979,-491.631 -415.404,-414.328 -415.404,-324.578 C-415.404,-272.94 -403.724,-225.606 -380.364,-182.575 C-357.005,-139.544 -322.733,-100.201 -277.551,-64.5467 C-232.368,-28.8923 -156.295,18.903 -49.3321,78.8392 C57.631,138.775 123.1,177.964 147.074,196.406 C182.729,223.455 209.008,252.654 225.913,284.005 C242.819,315.357 251.271,346.401 251.271,377.137 C251.271,432.463 228.987,480.412 184.419,520.984 C139.851,561.556 79.1465,581.842 2.30524,581.842 C-64.0856,581.842 -125.098,567.089 -180.731,537.582 C-236.364,508.075 -277.704,471.037 -304.753,426.469 C-331.801,381.901 -353.316,314.742 -369.299,224.991 L-403.417,224.991 L-403.417,653.766 L-369.299,653.766 C-364.996,624.873 -358.388,605.817 -349.474,596.596 C-340.561,587.375 -328.42,582.764 -313.051,582.764 C-297.068,582.764 -259.109,592.446 -199.173,611.81 C-139.236,631.174 -99.74,642.393 -80.6834,645.467 C-48.7174,651 -14.5998,653.766 21.6692,653.766 C137.239,653.766 231.753,619.495 305.214,550.952 C378.674,482.41 415.404,400.804 415.404,306.136 C415.404,256.343 403.878,208.701 380.826,163.211 C357.773,117.721 324.885,78.2244 282.161,44.7216 C239.438,11.2188 159.676,-36.8838 42.8774,-99.5863 C-100.355,-176.428 -191.027,-237.901 -229.141,-284.005 C-255.574,-315.357 -268.791,-350.089 -268.791,-388.202 C-268.791,-437.995 -247.89,-482.41 -206.088,-521.445 C-164.287,-560.48 -111.42,-579.998 -47.4879,-579.998 C9.06727,-579.998 63.7783,-565.552 116.645,-536.66 C169.512,-507.767 210.238,-468.732 238.823,-419.554 C267.408,-370.375 287.233,-304.292 298.298,-221.303 L332.415,-221.303 L332.415,-653.766 L298.298,-653.766 Z " fill="currentColor" fill-opacity="1.00" /><path d="M-530.954,-41.4477 L-530.954,41.4477 L530.954,41.4477 L530.954,-41.4477 L-530.954,-41.4477 Z " fill="currentColor" fill-opacity="1.00" /></g></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-undo"><path d="M447.9 368.2c0-16.8 3.6-83.1-48.7-135.7-35.2-35.4-80.3-53.4-143.3-56.2V96L64 224l192 128v-79.8c40 1.1 62.4 9.1 86.7 20 30.9 13.8 55.3 44 75.8 76.6l19.2 31.2H448c0-10.1-.1-22.9-.1-31.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-redo"><path d="M64 400h10.3l19.2-31.2c20.5-32.7 44.9-62.8 75.8-76.6 24.4-10.9 46.7-18.9 86.7-20V352l192-128L256 96v80.3c-63 2.8-108.1 20.7-143.3 56.2C60.4 285.2 64 351.5 64 368.2c.1 8.9 0 21.7 0 31.8z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-arrow-dropdown"><path d="M128 192l128 128 128-128z"></path></symbol>
            <symbol viewBox="0 0 512 512" id="ion-social-twitter"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6-18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6.8 15 2.5 22.1-80.5-4-151.9-42.6-199.6-101.3-8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7-16-.4-31-4.8-44-12.1v1.2c0 47 33.4 86.1 77.7 95-8.1 2.2-16.7 3.4-25.5 3.4-6.2 0-12.3-.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3-33.1 26-74.9 41.5-120.3 41.5-7.8 0-15.5-.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-.1-8.4-.3-12.5C462.6 146 479 129 492 109.5z"></path></symbol>
            <symbol viewBox="0 0 24 24" id="icon-zoom-in" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <circle cx="10" cy="10" r="7"></circle>
                <line x1="7" y1="10" x2="13" y2="10"></line>
                <line x1="10" y1="7" x2="10" y2="13"></line>
                <line x1="21" y1="21" x2="15" y2="15"></line>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-android-contract"><path d="M64 371.2h76.795V448H192V320H64v51.2zm76.795-230.4H64V192h128V64h-51.205v76.8zM320 448h51.2v-76.8H448V320H320v128zm51.2-307.2V64H320v128h128v-51.2h-76.8z"></path></symbol>
            
            <symbol viewBox="0 0 24 24" id="icon-lock-off" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <line x1="3" y1="3" x2="21" y2="21" />
                <path d="M19 19a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6a2 2 0 0 1 2 -2h4m4 0h2a2 2 0 0 1 2 2v2" />
                <circle cx="12" cy="16" r="1" />
                <path d="M8 11v-3m.712 -3.278a4 4 0 0 1 7.288 2.278v4" />
            </symbol>
            <symbol viewBox="0 0 24 24" id="icon-lock" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
                <rect x="5" y="11" width="14" height="10" rx="2" />
                <circle cx="12" cy="16" r="1" />
                <path d="M8 11v-4a4 4 0 0 1 8 0v4" />
            </symbol>
            <symbol viewBox="0 0 24 24" id="icon-code" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z"/>
                <polyline points="7 8 3 12 7 16" />
                <polyline points="17 8 21 12 17 16" />
                <line x1="14" y1="4" x2="10" y2="20" />
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-ios-cloud-upload-outline">
                <path d="M193.3 260.4l-11.6-11.6 74.5-74.3 74.5 74.3-11.7 11.6-54.6-54.6v241.8h-16.5V205.8z"/>
                <path d="M399.3 183.6c0-1.2.2-2.4.2-3.6 0-64.3-52.8-116.4-116.8-116.4-46.1 0-85.8 27.1-104.4 66.3-8.1-4.1-17.1-6.4-26.8-6.4-29.6 0-54.1 23.6-58.9 52C57.4 187.6 32 222.2 32 261.8c0 49.7 40.1 90.2 89.6 90.2H213v-16h-90.6c-40.9 0-74.2-33.5-74.2-74.6 0-31.8 20.2-61.2 50.2-71.6l8.4-2.9 1.5-8.8c3.6-21.6 22.1-39.3 43.9-39.3 6.9 0 13.7 1.6 19.9 4.8l13.5 6.8 6.5-13.7c16.6-34.9 52.1-57.4 90.4-57.4 55.3 0 100.9 43.3 100.9 98.9 0 13.3-.2 20.3-.2 20.3l15.2.1c36.6.5 65.6 33.4 65.6 70.3 0 36.8-29.8 66.9-66.5 67.1H297v16h101c45 0 82-37.3 82-82.8s-35.5-85.5-80.7-85.6z"/>
            </symbol>
            <symbol viewBox="0 0 512 512" id="ion-volume-medium">
                <path d="M270 407.7V104.4L175.3 192H71v128h104.3zm56.3-52.1c20.5-27.8 32.8-62.3 32.8-99.6 0-37.4-12.3-71.8-32.8-99.6l-20.4 15.3c17.4 23.6 27.8 52.7 27.8 84.3 0 31.6-10.4 60.7-27.8 84.3l20.4 15.3zm66.5 46c30-40.7 48-91 48-145.6s-18-104.9-48-145.6l-20.4 15.3c26.9 36.4 43 81.4 43 130.3 0 48.9-16.1 93.8-43 130.3l20.4 15.3z"/>
            </symbol>
            <symbol id="icon-folder2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M11 19h-6a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2.5"></path>
                <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
                <path d="M20.2 20.2l1.8 1.8"></path>
            </symbol>
            <symbol id="icon-reload" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M19.933 13.041a8 8 0 1 1 -9.925 -8.788c3.899 -1.002 7.935 1.007 9.425 4.747"></path>
                <path d="M20 4v5h-5"></path>
            </symbol>
            </defs>
        </svg>


        <div class="is-locked-indicator">
            <svg class="is-icon-flex"><use xlink:href="#icon-lock"></use></svg>
        </div>
        `;
    builder.contentStuff.insertAdjacentHTML('afterbegin', html);
    let css = `


        /* General */

        body {
            overflow-x: hidden !important;
        }

        svg {
            overflow: hidden;
            vertical-align: middle;
            pointer-events: none;
        }
        [contenteditable] svg {
            pointer-events: initial;
        }
        .is-container > div > div svg {
            pointer-events: initial;
        }

        .is-icon-flex {
            width: 16px;
            height: 16px;
        }

        a:focus,
        button:focus {
            outline:none; 
        }

        .transition1 { 
            transition: all ease 0.1s; 
        }

        /* Editable Area */

        .is-builder {
            transition: all ease 0.3s;
            transform-origin: top;
        }
        .is-builder > div > div:focus {
            outline: none;
        }
        .is-builder .is-subblock:focus {
            outline: none;
        }
        .is-builder > div {
            position: relative;
            transition: none;
            margin-left: 0;
            margin-right: 0;
            width: auto;
        }
        .is-builder[gridoutline] > div > div {
            outline: 1px solid rgba(132, 132, 132, 0.27);
            outline-offset: 1px;
        }
        .is-builder > div > div.cell-active:not([data-protected]) {
            outline: 1px solid #00da89;
        }
        .is-builder .row-active:not([data-protected]) {
            outline: 1px solid #00da89;
            z-index: 1;
        }
        .is-builder .row-active:not([data-protected]).row-outline {
            outline: 1px solid rgba(132, 132, 132, 0.2);
        }
        .is-builder .row-active:not([data-protected]):not(.row-outline) > div.cell-active {
            outline: none;
        }

        .is-builder table.default td {
            border: transparent 1px dashed;
        }
        .is-builder .cell-active .elm-active:not(button) {
            background: rgba(200, 200, 201, 0.11);
        }
        .is-builder .cell-active table.elm-active {
            background-color: transparent;
        }
        .is-builder .cell-active table.default td {
            border: #cccccc 1px dashed;
        }
        .is-builder .cell-active hr {
            cursor: pointer;
        }
        .is-builder .cell-active[data-html] {
            background-color: rgba(200, 200, 201, 0.11);
        }
        .is-builder .cell-active .icon-active {
            background-color: rgba(200, 200, 201, 0.4);
        }
        .is-builder .elm-inspected {
            animation-name: elm-inspected-anim;
            animation-duration: 0.6s;
            outline: 1px solid #ffb84a !important;
        }
        .is-builder .elm-inspected .elm-active {
            background: none;
        }
        @keyframes elm-inspected-anim {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.97);
            }
            100% {
                transform: scale(1);
            }
        }

        /*
        @media (min-width: 640px) {
            .is-builder > div {
                display:flex
            }
        }*/

        /* sortable */
        .sortable-drag {
            background: transparent;
            outline:none !important;
        }
        .sortable-drag * {
            opacity:0;
        }
        
        .sortable-ghost {
            background: rgba(0, 0, 0 , 0.03);
            width: 100%;
            outline: none !important;
        }
        .sortable-ghost * {
            outline: none !important;
        }
        .sortable-ghost .is-row-tool {
            display:none !important;
        }
        
        .sortable-drag::before {
            content: ' ';
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left:0;
            background: rgba(0, 0, 0 , 0.03);
            transform-origin: top left;
        }

        /* Canvas Mode */
        .box-canvas > .sortable-ghost {
            background: transparent;
            outline: rgba(140, 140, 140, 0.5) 4px dashed !important;
            outline-offset: -15px;
            height:100% !important;
            transition: none !important;
            z-index:1;
        }

        /* Moveable (Image resizer) */
        .moveable-control {
            border: none !important; 
            width: 7px !important; 
            height: 7px !important; 
            margin-top: -3px !important; 
            margin-left: -3px !important;  
            background: #2196f3 !important;
        }
        .moveable-control.moveable-origin {
            display: none !important;
        }
        .moveable-direction.moveable-s, .moveable-direction.moveable-n { 
            display:none !important; 
        }
        .moveable-direction.moveable-e, .moveable-direction.moveable-w { 
            display:none !important; 
        }
        .moveable-line { 
            display:none !important; 
        }

        /* Tool */
        .is-tool.is-video-tool,
        .is-tool.is-audio-tool,
        .is-tool.is-iframe-tool {
            background: rgba(0, 0, 0, 0.15);
            border: transparent 1px solid;
        }
        .is-tool.is-video-tool > div,
        .is-tool.is-audio-tool > div,
        .is-tool.is-iframe-tool > div,
        .is-tool.is-video-tool > button,
        .is-tool.is-audio-tool > button,
        .is-tool.is-iframe-tool > button {
            background: transparent;
        }
        .is-tool.is-video-tool svg,
        .is-tool.is-audio-tool svg,
        .is-tool.is-iframe-tool svg {
            fill: #fff;
        }


        .is-tool.is-spacer-tool,
        .is-tool.is-table-tool,
        .is-tool.is-code-tool,
        .is-tool.is-module-tool,
        .is-tool#divLinkTool,
        .is-tool#divButtonTool,
        .is-tool.is-svg-tool { 
            border: none;
            background: none;
            border-radius: 3px;
            overflow: hidden;
        }

        .is-tool.is-spacer-tool > button,
        .is-tool.is-table-tool > button,
        .is-tool.is-code-tool > button,
        .is-tool.is-module-tool > button,
        .is-tool#divLinkTool > button,
        .is-tool#divButtonTool > button,
        .is-tool.is-svg-tool > button { 
            width: 30px;
            height: 30px;
            background: rgba(240, 240, 240, 0.9);
        }

        .is-tool.is-spacer-tool > button svg,
        .is-tool.is-table-tool > button svg,
        .is-tool.is-code-tool > button svg,
        .is-tool.is-module-tool > button svg,
        .is-tool#divLinkTool > button svg,
        .is-tool#divButtonTool > button svg,
        .is-tool.is-svg-tool > button svg {
            fill: #111;
        }

        .is-tool.is-table-tool:hover {
            z-index:10001 !important
        }


        .dot {
            height: 7px;
            width: 7px;
            border-radius: 50%;
            display: inline-block;
            margin: 25px 2px 0;
            animation: jump 1.5s linear infinite;
        }
        @keyframes jump {
            0%, 100% {transform: translateY(0px);}
            20% {transform: translateY(-10px);}
            40% {transform: translateY(0px);}
        }
        .dot:nth-of-type(2) {
            animation-delay: 0.2s;
        }
        .dot:nth-of-type(3) {
            animation-delay: 0.4s;
        }

        /* Lock Indicator */

        .is-locked-indicator {
            display: none;
            width: 28px;
            height: 28px;
            position: absolute;
            align-items: center;
            justify-content: center;
            background: rgba(243, 243, 243, 0.9);
            border-radius: 500px;
            pointer-events: none;
        }

        /* Tools */
        .is-tool {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            z-index: 10001;
            box-sizing: border-box;
            padding: 0;
            outline: none;
           
        } 
        .is-tool:hover { 
            z-index:10003; 
        }
        .is-tool.active { 
            display:flex; 
        }
        .is-tool button {
            width:100%; height: 25px;
            background-color:transparent;
            border: none;
            cursor: pointer;
            user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            -o-user-select: none; 
    
           
            color: #000;
            display: inline-block;
            box-sizing:border-box;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            letter-spacing: 1px;
            font-size: 12px;
            font-weight: 300;
            text-transform: uppercase;
            text-align: center;  
            line-height: unset;
            position: relative;
            border-radius: 1px;
            transition: all ease 0.3s; 
        }
        .is-tool button:focus {
            outline: none !important;
            outline-offset: 0;
        }
        .is-tool svg {
            fill: #000;
        }

        /* is-element-tool */

        .is-tool.is-element-tool {
            background: rgba(243, 243, 243, 0.9);
            border-radius: 3px;
            overflow: hidden;
        } 
        .is-tool.is-element-tool button {
            width: 25px; 
            height: 25px;
            background: transparent;
        }
        .is-tool.is-element-tool svg {
            width: 14px;
            height: 14px;
            fill: #111;
        }
        .is-tool.is-element-tool .elm-more svg {
            width: 11px;
            height: 11px;
        }
        .is-tool.is-element-tool .elm-settings { display: none; }

        /* is-block-tool 

        .is-tool.is-block-tool {
            background: rgba(243, 243, 243, 0.9);
            border-radius: 3px;
            overflow: hidden;
            top: 3px;
            right: 3px;
            left: auto;
            width: 25px;
        } 
        .is-tool.is-block-tool button {
            width: 25px; 
            height: 25px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .is-tool.is-block-tool svg {
            width: 14px;
            height: 14px;
            fill: #000;
        }
        .is-block.active:not(.multi):not(.editable) .is-block-tool {
            display:flex;
        }
        */

        /* is-column-tool */

        .is-tool.is-column-tool {
            flex-direction: row;
            margin-top: 0px;
        }
        .is-tool.is-column-tool button {
            width: 25px; 
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .is-tool.is-column-tool .cell-add {background: #0fcc52;}
        .is-tool.is-column-tool .cell-more {background: rgba(216, 200, 6, 0.9);}
        .is-tool.is-column-tool .cell-remove {background: rgba(255, 85, 4, 0.9);} 
        .is-tool.is-column-tool svg {
            width: 23px;
            height:23px;
            fill: #fff;
        }
        .is-tool.is-column-tool .cell-more svg {width:14px;height:14px;}

        /* is-row-tool */
        
        .is-tool.is-row-tool {
            flex-direction: column;
            width: auto;
            left: auto;
            right: -30px;
            border-radius: 2px;
            overflow: hidden;
        }

        .is-tool.is-row-tool button {
            width: 25px; 
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .is-tool.is-row-tool svg {
            fill: #fff;
        }
        .is-tool.is-row-tool .row-handle {
            display: flex;
            height: 25px;
            justify-content: center;
            align-items: center;
            background: #169af7;
            
        }
        .is-tool.is-row-tool .row-handle svg { 
            width: 13px; height: 13px; 
        }
        .is-tool.is-row-tool .row-grideditor {
            background: rgba(216, 200, 6, 0.9);
        }
        .is-tool.is-row-tool .row-grideditor svg {
            width: 14px; height: 14px; margin-top: -1px;
        }
        .is-tool.is-row-tool .row-more {
            background: rgba(216, 200, 6, 0.9);
        }
        .is-tool.is-row-tool .row-more svg {
            width: 14px; height: 14px;
        }
        .is-tool.is-row-tool .row-remove {
            background: rgba(255, 85, 4, 0.9);
        }  
        .is-tool.is-row-tool .row-remove svg {
            width: 23px; height: 23px;
        }
        .row-outline .is-row-tool, 
        .row-active .is-row-tool {
            display:flex;
        }

        .row-outline .is-rowadd-tool, 
        .row-active .is-rowadd-tool {
            display:block;
        }
        .is-tool.is-row-tool .row-grideditor {
            display:none;
        }

        /* is-rowadd-tool */

        .is-rowadd-tool {
            display: none;
            position: absolute;
            bottom: -1px;
            left: -20px;
            width: calc(100% + 40px);
            height: 1px;
            border: none;
            border-bottom: 1px solid rgb(255, 183, 132);
            z-index: 1;
            background: transparent;
            transition:none;
        }
        .is-rowadd-tool button {
            position:absolute;
            top: -9px;
            left:calc(50% - 10px);
            border:  1px solid rgb(255, 142, 62);
            border-radius: 500px;
            height:auto;
        }
        .row-outline .is-rowadd-tool, 
        .row-active .is-rowadd-tool {
            display:block;
        }

        .row-add-initial {
            width: 100%;
            height: 120px;
            font-family: sans-serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            justify-content: center;
            align-items: center;
            color:#333;
            border: 1px dashed rgba(169, 169, 169, 0.8);
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all ease 0.3s;
            outline: none !important;
        }
        .row-add-initial:hover {
            background: rgba(248, 248, 248, 0.35);
        }
        .row-add-initial:focus {
            outline:none;
        }
        .row-add-initial span {
            text-transform: none;
            display: block;
            margin-top: 5px;
            font-size: 13px;
            opacity: 0.5;
            color: #333;
        }
        .is-builder .row-active.row-add-initial {
            outline:none;
        }

        /* is-col-tool */

        .row-active .is-col-tool {
            display: flex;
        }
        .is-builder[rowoutline] .row-active .is-col-tool {
            display: none;
        }
        .is-builder[hidecolumntool] .row-active .is-col-tool {
            display: none;
        }
        

        .is-tool.is-col-tool {
            flex-direction: row;
            margin-top: 0px;
            margin-left: -1px;
            box-shadow: none;
            border-radius: 2px;
            overflow: hidden;
        }
        .is-tool.is-col-tool button {
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .is-tool.is-col-tool .cell-add {
            background: #0fcc52;
        }
        .is-tool.is-col-tool .cell-more {
            background: rgba(216, 200, 6, 0.9);
        }
        .is-tool.is-col-tool .cell-remove {
            background: rgba(255, 85, 4, 0.9);
        }
        .is-tool.is-col-tool svg {
            width: 23px;
            height: 23px;
            fill: #fff !important;
        }
        .is-tool.is-col-tool .cell-more svg {
            width: 14px;
            height: 14px;
        }

        
        .is-builder[gray] .is-tool.is-col-tool {
            background: rgba(243, 243, 243, 0.9);
            flex-direction: row;
            margin-top: -2px;
        }
        .is-builder[gray] .is-tool.is-col-tool button {
            width: 27px;
            height: 27px;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-add {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-more {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-remove {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool svg {
            width: 18px;
            height: 18px;
            fill: #000 !important;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-more svg {
            width: 12px;
            height: 12px;
        }


        .is-builder[gridoutline] > div > div {
            outline: 1px solid rgba(132, 132, 132, 0.27);
            outline-offset: 1px;
        }


        

        /* Preferences */

        #_cbhtml[gray] .is-tool.is-column-tool {
            background: rgba(243, 243, 243, 0.9);
            flex-direction: row;
            margin-top: -2px;
        }
        #_cbhtml[gray] .is-tool.is-column-tool button {
            width: 27px;
            height: 27px;
        }
        #_cbhtml[gray] .is-tool.is-column-tool .cell-add {
            background: transparent;
        }
        #_cbhtml[gray] .is-tool.is-column-tool .cell-more {
            background: transparent;
        }
        #_cbhtml[gray] .is-tool.is-column-tool .cell-remove {
            background: transparent;
        }
        #_cbhtml[gray] .is-tool.is-column-tool svg {
            width: 18px;
            height: 18px;
            fill: #000;
        }
        #_cbhtml[gray] .is-tool.is-column-tool .cell-more svg {
            width: 12px;
            height: 12px;
        }



        .is-builder[gray] .is-tool.is-row-tool {
            background: rgba(243, 243, 243, 0.9);
        }
        .is-builder[gray] .is-tool.is-row-tool button {
            width: 27px;
            height: 27px;
        }
        .is-builder[gray] .is-tool.is-row-tool svg {
            fill: #000;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-handle {
            display: flex;
            height: 27px;
            justify-content: center;
            align-items: center;
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-handle svg {
            width: 11px;
            height: 11px;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-grideditor {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-grideditor svg {
            width: 13px;
            height: 13px;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-more {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-more svg {
            width: 12px;
            height: 12px;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-remove {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-row-tool .row-remove svg {
            width: 19px;
            height: 19px;
        }



        .is-builder[gray] .is-rowadd-tool {
            border-bottom: 1px solid rgba(222, 222, 222, 0.32);
        }
        .is-builder[gray] .is-rowadd-tool button {
            border: 1px solid rgba(0, 0, 0, 0.13);
        }


        /* Preferences */

        .is-tool.is-row-tool .row-grideditor {
            display: none;
        }
        
        .is-builder {
            /*
            &[grideditor] {
                & > div > div.cell-active {
                    outline: $ui-grideditor-cell-outline-active;
                } 
                .row-active {
                    outline: $ui-grideditor-row-outline-active;
                    z-index: 1;
                } 
                .row-active.row-outline {
                    outline: $ui-grideditor-rowoutline-row-outline-active;
                } 
            }
            */
        }
        .is-builder[minimal] .is-tool.is-row-tool .row-grideditor {
            display: block;
        }
        .is-builder[minimal] .is-tool.is-row-tool .row-more {
            display: none;
        }
        .is-builder[clean] .is-tool.is-row-tool {
            background: rgba(243, 243, 243, 0.9);
            outline: none;
        }
        .is-builder[clean] .is-tool.is-row-tool .row-grideditor {
            display: block;
            background: transparent;
        }
        .is-builder[clean] .is-tool.is-row-tool .row-grideditor svg {
            fill: #000;
            width: 13px;
            height: 13px;
            margin-left: -1px;
        }
        .is-builder[clean] .is-tool.is-row-tool .row-more {
            display: none;
        }
        .is-builder[clean] .is-tool.is-row-tool .row-handle {
            display: none;
        }
        .is-builder[clean] .is-tool.is-row-tool .row-remove {
            display: none;
        }
        .is-builder[clean] .row-outline {
            outline: none;
        }
        .is-builder[clean] .cell-active {
            outline: none;
        }
        .is-builder[clean] .row-active:not([data-protected]) {
            outline: 1px solid rgba(132, 132, 132, 0.2);
        }
        .is-builder[leftrowtool] .is-tool.is-row-tool {
            right: auto;
            left: -40px;
        }
        .is-builder[rowoutline] .row-outline {
            outline: none;
        }
        .is-builder[rowoutline] .cell-active {
            outline: none !important; /* ADDED IMPORTANT */
        }
        .is-builder[rowoutline] .row-active:not([data-protected]) {
            outline: 1px solid #00da89;
        }
        .is-builder[grayoutline] .row-outline {
            outline: none;
        }
        .is-builder[grayoutline] .cell-active:not([data-protected]) {
            outline: 1px solid rgba(132, 132, 132, 0.1);
        }
        .is-builder[grayoutline] .row-active:not([data-protected]) {
            outline: 1px solid rgba(132, 132, 132, 0.2);
        }
        .is-builder[rowoutline][grayoutline] .row-outline {
            outline: none;
        }
        .is-builder[rowoutline][grayoutline] .cell-active {
            outline: none;
        }
        .is-builder[rowoutline][grayoutline] .row-active:not([data-protected]) {
            outline: 1px solid rgba(132, 132, 132, 0.2);
        }
        .is-builder[hideoutline] .row-outline {
            outline: none !important;
        }
        .is-builder[hideoutline] .cell-active {
            outline: none !important;
        }
        .is-builder[hideoutline] .row-active {
            outline: none !important;
        }
        .is-builder[hideoutline] .row-active.row-outline {
            outline: none !important;
        }
        .is-builder[hidesnippetaddtool] .row-outline .is-rowadd-tool,
        .is-builder[hidesnippetaddtool] .row-active .is-rowadd-tool {
            display: none;
        }
        .is-builder[hideelementhighlight] .elm-active {
            background-color: transparent !important; /* ADDED IMPORTANT */
        }
        
        #_cbhtml[minimal] .is-tool.is-column-tool .cell-more {
            display: none;
        }
        #_cbhtml[clean] .is-tool.is-column-tool {
            display: none;
        }
        #_cbhtml[hidecolumntool] .is-tool.is-column-tool {
            display: none;
        }
        #_cbhtml[hideelementtool] .is-tool.is-element-tool {
            display: none !important;
        }
        #_cbhtml .is-element-tool .elm-settings {
            display: none;
        }
        #_cbhtml[emailmode] .is-element-tool .elm-add,
        #_cbhtml[emailmode] .is-element-tool .elm-more,
        #_cbhtml[emailmode] .is-element-tool .elm-remove {
            display: none !important;
        }
        #_cbhtml[emailmode] .is-element-tool .elm-settings {
            display: block;
        }


        /* Prevent css framework overide (Materialize) */
        .is-ui [type="checkbox"]:not(:checked), .is-ui [type="checkbox"]:checked {
            position: unset !important;
        }
        .is-ui input[type=range] {
            border: none;
        }
        .is-ui form {
            background: unset;
            margin: unset;
            padding: unset;
            border: unset;
        }
        .is-ui svg {
            max-width: unset;
        }
        
        /* Prevent css framework overide (Tailwind) */
        .is-ui svg {
            display: initial !important;
        }
        .is-section-tool svg,
        .is-row-tool svg,
        .is-col-tool svg {
            display: initial !important;
        }
        
        /* Make slider block resizable */
        .is-builder > div > div[data-module=slider-builder].cell-active {
            /*padding: 0 2px 4px !important;*/
            z-index: 1 !important;
        }
        
        /* Row Lock will hide row tool */
        .row-lock .is-row-tool,
        .row-lock .is-rowadd-tool {
            display: none !important;
        }
                
        div[data-html] {
            min-height: 70px;
        }
        
        [data-module="slider-builder"] *,
        [data-module="text-builder"] * {
            outline: none !important;
        }

        /* Make slider block resizable */
        .padding-0[data-module="slider-builder"],
        .padding-0[data-module="text-builder"] {
            padding: 0 2px 4px !important;
        }


        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) auto;
        }
        *::-webkit-scrollbar {
            width: 12px;
        }
        *::-webkit-scrollbar-track {
            background: rgba(200, 200, 200, 0.2);
        }
        *::-webkit-scrollbar-thumb {
            background-color:rgba(0, 0, 0, 0.2); 
        }
        
        ${this.builder.simpleEditingBreakpoint ? `
          
            @media all and (max-width: ${this.builder.simpleEditingBreakpoint}) {
                .is-tool:not(#divSpacerTool) {
                    display: none !important;
                }
                
                .is-builder .row-active:not([data-protected]).row-outline {
                    outline: none !important;
                }
            }
            
        ` : ''}


        `;
    builder.contentStuff.insertAdjacentHTML('afterbegin', `
        <style>
            ${css}
        </style>
        `);
  }
}

class MediaPicker {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const builderStuff = this.builder.builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    this.id = this.builder.util.makeId();
    const html = `
        <div class="is-modal mediasource" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="max-width:550px;">

                <label for="inpMediaSource" style="display:block">${util.out('Source')}:</label>
                <div class="image-src">
                    <input id="inpMediaSource" class="input-src" type="text">
                    <button title="${util.out('Select')}" class="input-select" style="flex:none;">
                        ${this.builder.opts.selectIcon}
                    </button>
                    <div class="input-upload" style="position: relative; flex: 0 0 auto;box-shadow: rgba(0, 0, 0, 0.32) 0px 3px 6px -6px;">
                        <form class="form-upload-larger" target="frameTarget${this.id}" method="post" action="${this.builder.opts.largerImageHandler}" enctype="multipart/form-data" style="position:absolute;display:flex;justify-content: center;align-items: center;top:0;left:0;width:100%;height:100%;">
                            <input name="hidRefId" class="input-ref-id" type="hidden" value="">
                            <svg class="is-icon-flex" style="width:18px;height:18px;"><use xlink:href="#ion-ios-cloud-upload-outline"></use></svg>
                            <input title="${util.out('Select')}" name="fileImage" class="input-file-select" type="file" accept="image/*,video/mp4" style="position:absolute;top:-30px;left:0;width:100%;height:80px;opacity: 0;cursor: pointer;">
                        </form>
                        <iframe tabIndex="0" id="frameTarget${this.id}" name="frameTarget${this.id}" src="about:blank" style="width:1px;height:1px;position:absolute;top:0;right:-100000px"></iframe>
                    </div>
                </div>

                <div style="text-align:right;margin-top:20px;">
                    <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                    <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                </div>

            </div>
        </div>
        `;
    dom.appendHtml(builderStuff, html);
    const modalMediaSelect = document.querySelector('.mediasource');
    this.modalMediaSelect = modalMediaSelect;
    if (this.builder.opts.largerImageHandler === '' && !this.builder.opts.onLargerImageUpload) {
      modalMediaSelect.querySelector('.input-upload').style.display = 'none';
    }
    if (!this.builder.opts.onImageSelectClick && this.builder.opts.imageselect === '') {
      modalMediaSelect.querySelector('.input-select').style.display = 'none';
    }
    if (this.builder.opts.onImageSelectClick || this.builder.opts.imageselect || this.builder.opts.onFileSelectClick || this.builder.opts.fileselect) {
      const inpSrc = modalMediaSelect.querySelector('.input-src');
      const elm = modalMediaSelect.querySelector('.input-select');
      if (elm) dom.addEventListener(elm, 'click', () => {
        let targetAssetType = this.builder.targetAssetType;
        let targetInput = inpSrc;
        let theTrigger = elm;

        //--- Same ass openAsset() in contentbuilder.js 2098

        if (targetAssetType === 'media' && (this.builder.opts.onMediaSelectClick || this.builder.opts.onImageSelectClick)) {
          if (this.builder.opts.onMediaSelectClick) {
            this.builder.opts.onMediaSelectClick({
              targetInput: targetInput,
              theTrigger: theTrigger
            });
          } else {
            this.builder.opts.onImageSelectClick({
              targetInput: targetInput,
              theTrigger: theTrigger
            });
          }
        } else if (targetAssetType === 'video' && this.builder.opts.onVideoSelectClick) {
          this.builder.opts.onVideoSelectClick({
            targetInput: targetInput,
            theTrigger: theTrigger
          });
        } else if (targetAssetType === 'image' && this.builder.opts.onImageSelectClick) {
          this.builder.opts.onImageSelectClick({
            targetInput: targetInput,
            theTrigger: theTrigger
          });
        } else if (targetAssetType === 'audio' && this.builder.opts.onAudioSelectClick) {
          this.builder.opts.onAudioSelectClick({
            targetInput: targetInput,
            theTrigger: theTrigger
          });
        } else if (targetAssetType === 'all' && this.builder.opts.onFileSelectClick) {
          this.builder.opts.onFileSelectClick({
            targetInput: targetInput,
            theTrigger: theTrigger
          });
        } else {
          let iframe;
          let modal;
          if (targetAssetType === 'media') {
            modal = this.builder.builderStuff.querySelector('.is-modal.mediaselect');
            iframe = modal.querySelector('iframe');
            if (iframe.src === 'about:blank') {
              if (this.builder.opts.mediaSelect) iframe.src = this.builder.opts.mediaSelect;else if (this.builder.opts.imageSelect) iframe.src = this.builder.opts.imageSelect;
            }
          } else if (targetAssetType === 'video') {
            modal = this.builder.builderStuff.querySelector('.is-modal.videoselect');
            iframe = modal.querySelector('iframe');
            if (iframe.src === 'about:blank') iframe.src = this.builder.opts.videoSelect;
          } else if (targetAssetType === 'image') {
            modal = this.builder.builderStuff.querySelector('.is-modal.imageselect');
            iframe = modal.querySelector('iframe');
            if (iframe.src === 'about:blank') iframe.src = this.builder.opts.imageSelect;
          } else if (targetAssetType === 'audio') {
            modal = this.builder.builderStuff.querySelector('.is-modal.audioselect');
            iframe = modal.querySelector('iframe');
            if (iframe.src === 'about:blank') iframe.src = this.builder.opts.audioSelect;
          } else if (targetAssetType === 'all') {
            modal = this.builder.builderStuff.querySelector('.is-modal.fileselect');
            iframe = modal.querySelector('iframe');
            if (iframe.src === 'about:blank') iframe.src = this.builder.opts.fileSelect;
          }

          // this.builder.util.showModal(modal);

          this.builder.util.showModal(modal, false, () => {
            elm.removeAttribute('data-focus');
            elm.focus();
          }, false, this.builder.assetPanelFullScreen);
          elm.setAttribute('data-focus', true);
          this.builder.targetInput = inpSrc; // used by selectAsset() (see contentbuilder.js)
          this.builder.targetCallback = null;
          // this.targetAssetType = targetAssetType;
        }

        //---

        // if(this.builder.opts.onFileSelectClick) {

        //     this.builder.opts.onFileSelectClick({targetInput: inpSrc, theTrigger: elm});

        // } else if (this.builder.opts.onImageSelectClick) {

        //     this.builder.opts.onImageSelectClick({targetInput: inpSrc, theTrigger: elm});

        // } else if(this.builder.opts.fileselect) {

        //     let modalFileSelect = builderStuff.querySelector('.is-modal.fileselect');
        //     let iframe = modalFileSelect.querySelector('iframe');
        //     if(this.builder.opts.assetRefresh) {
        //         iframe.src = this.builder.opts.fileselect;
        //         this.builder.opts.assetRefresh = false;
        //     }
        //     if(iframe.src === 'about:blank') {
        //         iframe.src = this.builder.opts.fileselect;
        //     }
        //     util.showModal(modalFileSelect, false, ()=>{

        //         elm.removeAttribute('data-focus');
        //         elm.focus();
        //     });

        //     elm.setAttribute('data-focus', true);

        //     this.builder.targetInput = inpSrc;
        //     this.builder.targetCallback = null;
        //     // this.builder.targetAssetType = 'media';

        // } else if(this.builder.opts.imageselect) {

        //     let modalImageSelect = builderStuff.querySelector('.is-modal.imageselect');
        //     let iframe = modalImageSelect.querySelector('iframe');
        //     if(this.builder.opts.assetRefresh) {
        //         iframe.src = this.builder.opts.imageselect;
        //         this.builder.opts.assetRefresh = false;
        //     }
        //     if(iframe.src === 'about:blank'){
        //         iframe.src = this.builder.opts.imageselect;
        //     }
        //     util.showModal(modalImageSelect, false, ()=>{

        //         elm.removeAttribute('data-focus');
        //         elm.focus();
        //     });

        //     elm.setAttribute('data-focus', true);

        //     this.builder.targetInput = inpSrc;
        //     this.builder.targetCallback = null;
        //     // this.builder.targetAssetType = 'media';
        // }
      });
    }

    let inputFileSelect = modalMediaSelect.querySelector('.input-file-select');
    let frm = modalMediaSelect.querySelector('.form-upload-larger');
    dom.addEventListener(inputFileSelect, 'change', e => {
      let element = inputFileSelect;
      while (element.nodeName.toLowerCase() !== 'form') {
        element = element.parentNode;
      }
      let frmUpload = element;
      dom.addClass(frmUpload, 'please-wait');
      modalMediaSelect.querySelector('.input-ref-id').value = this.builder.opts.customval;
      let targetAssetType = this.builder.targetAssetType;
      if (targetAssetType === 'media' && this.builder.opts.onMediaUpload) {
        this.builder.opts.onMediaUpload(e);
      } else if (targetAssetType === 'video' && this.builder.opts.onVideoUpload) {
        this.builder.opts.onVideoUpload(e);
      } else if (targetAssetType === 'image' && this.builder.opts.onLargerImageUpload) {
        this.builder.opts.onLargerImageUpload(e);
      } else if (targetAssetType === 'audio' && this.builder.opts.onAudioUpload) {
        this.builder.opts.onAudioUpload(e);
      } else if (targetAssetType === 'all' && this.builder.opts.onFileUpload) {
        this.builder.opts.onFileUpload(e);
      } else if (this.builder.opts.onLargerImageUpload) {
        // backward

        this.builder.opts.onLargerImageUpload(e);
      } else {
        if (targetAssetType === 'media') {
          frm.setAttribute('action', this.builder.opts.mediaHandler);
        } else if (targetAssetType === 'video') {
          frm.setAttribute('action', this.builder.opts.videoHandler);
        } else if (targetAssetType === 'image') {
          frm.setAttribute('action', this.builder.opts.largerImageHandler);
        } else if (targetAssetType === 'audio') {
          frm.setAttribute('action', this.builder.opts.audioHandler);
        } else if (targetAssetType === 'all') {
          frm.setAttribute('action', this.builder.opts.fileHandler);
          if (!this.builder.opts.fileHandler) frm.setAttribute('action', this.builder.opts.mediaHandler); //backward
        }

        frmUpload.submit();
      }

      // if(this.builder.opts.onLargerImageUpload) {

      //     this.builder.opts.onLargerImageUpload(e);

      // } else {

      //     frmUpload.submit();

      // }

      inputFileSelect.value = ''; // Clear Input
    });

    const btnImageOk = modalMediaSelect.querySelector('.input-ok');
    dom.addEventListener(btnImageOk, 'click', () => {
      const inpSrc = modalMediaSelect.querySelector('.input-src');
      const url = inpSrc.value;
      if (this.builder.mediaSelectedCallback) this.builder.mediaSelectedCallback(url);
      this.builder.hideModal(modalMediaSelect);
    });
    const btnImageCancel = modalMediaSelect.querySelector('.input-cancel');
    dom.addEventListener(btnImageCancel, 'click', () => {
      this.builder.hideModal(modalMediaSelect);
    });
  }
  openMediaPicker(currentUrl, assetType, callback, btn) {
    this.builder.targetAssetType = assetType;
    const modalMediaSelect = this.modalMediaSelect;
    let inputFileSelect = modalMediaSelect.querySelector('.input-file-select');
    if (assetType === 'all') {
      inputFileSelect.setAttribute('accept', '*');
    } else if (assetType === 'media') {
      inputFileSelect.setAttribute('accept', 'image/*,video/mp4');
    } else if (assetType === 'video') {
      inputFileSelect.setAttribute('accept', 'video/mp4');
    } else if (assetType === 'image') {
      inputFileSelect.setAttribute('accept', 'image/*');
    } else if (assetType === 'audio') {
      inputFileSelect.setAttribute('accept', 'audio/mp3');
    }

    //Current value
    const inpSrc = modalMediaSelect.querySelector('.input-src');
    inpSrc.value = currentUrl;

    //mediaSelectedCallback
    this.builder.mediaSelectedCallback = callback;

    //Show modal
    modalMediaSelect.style.zIndex = '10005';
    this.util.showModal(modalMediaSelect, false, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    }, false, this.builder.assetPanelFullScreen);
    if (btn) btn.setAttribute('data-focus', true);
  }
}

class Responsive {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
  }
  getVisibility(elm, target) {
    if (target === 'xs') return !elm.classList.contains('xs-hidden');
    if (target === 'sm') return !elm.classList.contains('sm-hidden');
    if (target === 'md') return !elm.classList.contains('md-hidden');
    if (target === '') return !elm.classList.contains('desktop-hidden');
  }
  setVisibility(visibility, elm, target) {
    if (target === 'xs') {
      if (visibility) elm.classList.remove('xs-hidden');else elm.classList.add('xs-hidden');
    }
    if (target === 'sm') {
      if (visibility) elm.classList.remove('sm-hidden');else elm.classList.add('sm-hidden');
    }
    if (target === 'md') {
      if (visibility) elm.classList.remove('md-hidden');else elm.classList.add('md-hidden');
    }
    if (target === '') {
      if (visibility) elm.classList.remove('desktop-hidden');else elm.classList.add('desktop-hidden');
    }
  }
  readTarget(area) {
    const inp = area.querySelector('.input-device.on');
    const target = inp.getAttribute('data-value');
    if (target === '') {
      this.builder.livePreview.resizePreview(1920);
    }
    if (target === 'md') {
      this.builder.livePreview.resizePreview(1024);
    }
    if (target === 'sm') {
      this.builder.livePreview.resizePreview(768);
    }
    if (target === 'xs') {
      this.builder.livePreview.resizePreview(375);
    }
    return inp.getAttribute('data-value');
  }
  showVisibility(area, visibility) {
    if (visibility) {
      area.querySelector('.input-visible').classList.add('on');
      area.querySelector('.input-hidden').classList.remove('on');
    } else {
      area.querySelector('.input-visible').classList.remove('on');
      area.querySelector('.input-hidden').classList.add('on');
    }
  }
}

class LivePreview {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    const builderStuff = this.builder.builderStuff;
    this.util = util;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
    let modal = builderStuff.querySelector('.content-preview');
    if (!modal) {
      let html = `
            <style>
            .is-modal.content-preview {
                transition: all 0.1s ease;
            }
            .is-modal.content-preview > div > div {
                transition: all 0.1s ease;
            }
            .is-modal.content-preview .is-modal-refresh,
            .is-modal.content-preview .is-modal-device,
            .is-modal.content-preview .is-modal-close {
                background:transparent !important;
                width:32px !important;
                height:32px !important;
                position:absolute !important;
                box-shadow:none !important;
            }
            .is-modal.content-preview .is-modal-device {
                top:2px;
                left:2px;
            }
            .is-modal.content-preview .is-modal-refresh {
                top:2px;
                right:34px;
            }
            .is-modal.content-preview .is-modal-close {
                top:2px;
                right:2px;
            }
    
            .is-screen-1920 { 
                width: 576px !important;
                height: 332px !important; 
            }
            .is-screen-1440 { 
                width: 431px !important; 
                height: 258px !important; 
            }
            .is-screen-768 { 
                width: 245px !important;
                height: 363px !important;
            }
            .is-screen-1024 { 
                width: 328px !important;
                height: 281px !important;
            }
            .is-screen-375 { 
                width: 167px !important; 
                height: 332px !important;
            }
    
            .is-screen-1920 .preview-screen {
                width: 1920px;height: 992px;transform: scale(0.3);
            }
            .is-screen-1440 .preview-screen {
                width: 1440px;height: 744px;transform: scale(0.3);
            }
            .is-screen-768 .preview-screen {
                width: 768px;height: 1024px;transform: scale(0.32);
            }
            .is-screen-1024 .preview-screen {
                width: 1024px;height: 768px;transform: scale(0.32);
            }
            .is-screen-375 .preview-screen {
                width: 375px;height: 667px;transform: scale(0.446);
            }
            .is-screen-375 .is-modal-bar > span {
                display: none;
            }
    
            .content-preview:focus-within {
                z-index:100021 !important
            }
            </style>
            <div style="z-index:10002;${this.builder.previewStyle}" class="is-modal is-modal-content content-preview is-screen-1920" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-bar is-draggable" draggable=""> 
                    <span>${util.out('Live Preview')}</span>
                    <button class="is-modal-device" tabindex="-1" style="user-select:none;cursor:default">
                        
                    </button>
                    <button class="is-modal-refresh" tabindex="-1" title="${util.out('Reload')}">
                        <svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#icon-reload"></use></svg>
                    </button>
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">
                        <svg class="is-icon-flex" style="width:23px;height:23px;"><use xlink:href="#ion-ios-close-empty"></use></svg>
                    </button>
                </div>
                <div style="position:relative;position:absolute;top:0;left:0;width:100%;height:100%;border-top:transparent 35px solid;">
                    <div class="preview-screen" style="padding:0;position: absolute;top: 0;left: 0;box-sizing: border-box;transform-origin: top left;">
                        <iframe src="about:blank" style="box-sizing:border-box;width: 100%;height: 100%;position:absolute;"></iframe>
                    </div>
                </div>
                <div style="position:absolute;left:3px;bottom:3px;border-radius:3px;display:flex;overflow:hidden;">
                    <button class="is-modal-size" tabindex="-1" title="${util.out('Screen Sizes')}" style="width:30px;height:30px;">
                        <svg class="is-icon-flex" style="width:23px;height:23px;"><use xlink:href="#icon-devices"></use></svg>
                    </button>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      const modal = builderStuff.querySelector('.is-modal.content-preview');
      this.modal = modal;
      const btnPreviewClose = modal.querySelector('.is-modal-close');
      btnPreviewClose.addEventListener('click', () => {
        this.closePreview();
      });
      const btnModalSize = modal.querySelector('.is-modal-size');
      btnModalSize.addEventListener('click', () => {
        if (modal.classList.contains('is-screen-1920')) {
          this.resizePreview(1440);
        } else if (modal.classList.contains('is-screen-1440')) {
          this.resizePreview(1024);
        } else if (modal.classList.contains('is-screen-1024')) {
          this.resizePreview(768);
        } else if (modal.classList.contains('is-screen-768')) {
          this.resizePreview(375);
        } else if (modal.classList.contains('is-screen-375')) {
          this.resizePreview(1920);
        }
      });
      const btnModalRefresh = modal.querySelector('.is-modal-refresh');
      btnModalRefresh.addEventListener('click', () => {
        this.previewRefresh(false, true);
      });

      //Extend onChange
      let old2 = this.builder.settings.onChange;
      this.builder.settings.onChange = () => {
        old2.call(this);
        if (!this.builder.doc.querySelector('.is-wrapper')) {
          // ContentBuilder
          this.previewRefresh();
        }
        // For ContentBox, this onChange will trigger ContentBox onChange (which has previewRefresh called)
      };
    }
  }

  resizePreview(size) {
    let modal = this.modal;
    let util = this.util;
    modal.classList.remove('is-screen-1920');
    modal.classList.remove('is-screen-1440');
    modal.classList.remove('is-screen-1920');
    modal.classList.remove('is-screen-1024');
    modal.classList.remove('is-screen-768');
    modal.classList.remove('is-screen-375');
    const infoDevice = modal.querySelector('.is-modal-device');
    const previewScreen = modal.querySelector('.preview-screen');
    previewScreen.style.transition = 'none';
    previewScreen.style.opacity = '0';
    if (size === 1440) {
      modal.classList.add('is-screen-1440');
      localStorage.setItem('_livepreviewscreen', 'is-screen-1440');
      infoDevice.setAttribute('title', util.out('Laptop'));
      infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:18px;height:18px"><use xlink:href="#icon-device-laptop"></use></svg>';
    } else if (size === 1024) {
      modal.classList.add('is-screen-1024');
      infoDevice.setAttribute('title', util.out('Tablet (Landscape)'));
      localStorage.setItem('_livepreviewscreen', 'is-screen-1024');
      infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>';
    } else if (size === 768) {
      modal.classList.add('is-screen-768');
      localStorage.setItem('_livepreviewscreen', 'is-screen-768');
      infoDevice.setAttribute('title', util.out('Tablet (Portrait)'));
      infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>';
    } else if (size === 375) {
      modal.classList.add('is-screen-375');
      localStorage.setItem('_livepreviewscreen', 'is-screen-375');
      infoDevice.setAttribute('title', util.out('Mobile'));
      infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-mobile"></use></svg>';
    } else if (size === 1920) {
      modal.classList.add('is-screen-1920');
      localStorage.setItem('_livepreviewscreen', 'is-screen-1920');
      infoDevice.setAttribute('title', util.out('Desktop'));
      infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>';
    }
    this.previewRefresh(true);
    setTimeout(() => {
      previewScreen.style.opacity = '';
      previewScreen.style.transition = '';
    }, 100);
  }
  previewRefresh(disableOnContentLoad, hardReload) {
    if (this.modal.classList.contains('active')) {
      // let html = this.builder.html();
      // localStorage.setItem('preview-html', html); 
      try {
        if (this.builder.onPreviewOpen) this.builder.onPreviewOpen();
      } catch (e) {
        return;
      }
      const iframe = this.modal.querySelector('iframe');
      if (!this.builder.doc.querySelector('.is-wrapper')) {
        // ContentBuilder

        if (this.builder.previewURL) {
          if (this.builder.livePreviewAlwaysReload || hardReload) {
            iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
          } else {
            let iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
            if (iframeDocument) {
              if (!iframeDocument.body) {
                iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
              } else {
                if (iframeDocument.body.innerHTML === '') {
                  iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
                } else {
                  // sync. html
                  let html = this.builder.html();
                  let container = iframeDocument.querySelector('.container');
                  if (!container) container = iframeDocument.querySelector('.is-container');
                  if (container) {
                    // container.innerHTML = html;
                    let range = this.builder.doc.createRange();
                    container.innerHTML = '';
                    container.appendChild(range.createContextualFragment(html));
                  } else {
                    iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
                  }
                }
              }
            } else {
              iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
            }
          }
        } else {
          try {
            this.writeHtml(iframe);
          } catch (e) {
            // Do Nothing
          }
        }
      } else {
        // ContentBox

        if (!this.builder.count) this.builder.count = 0;
        this.builder.count++;
        let oriVal = this.builder.livePreviewAlwaysReload;
        if (this.builder.count === this.builder.livePreviewReloadEvery) {
          this.builder.livePreviewAlwaysReload = true;
          this.builder.count = 0;
        }
        if (this.builder.livePreviewAlwaysReload || hardReload) {
          iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
        } else {
          let iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
          if (iframeDocument) {
            if (!iframeDocument.body) {
              iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
            } else {
              if (iframeDocument.body.innerHTML === '') {
                iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
              } else {
                // sync. html
                let html = localStorage.getItem('preview-html');
                let wrapper = iframeDocument.querySelector('.is-wrapper');
                // wrapper.innerHTML = html;
                let range = this.builder.doc.createRange();
                wrapper.innerHTML = '';
                wrapper.appendChild(range.createContextualFragment(html));

                // sync. styles
                // let mainCss = localStorage.getItem('preview-maincss'); 
                // let sectionCss = localStorage.getItem('preview-sectioncss');

                let elms = iframeDocument.querySelectorAll('link');
                let links = this.builder.doc.getElementsByTagName('link');
                Array.from(links).map(link => {
                  let href = link.href.toLowerCase();
                  if (href.indexOf('/basetype-') !== -1 || href.indexOf('/type-') !== -1) {
                    // check
                    let exist = false;
                    elms.forEach(elm => {
                      let elmHref = elm.href.toLowerCase();
                      if (elmHref) {
                        if (elmHref.indexOf('/basetype-') !== -1 || elmHref.indexOf('/type-') !== -1) {
                          if (href === elmHref) {
                            exist = true;
                          }
                        }
                      }
                    });
                    if (!exist) {
                      // clone is needed, otherwise, parent resource may dissapear when loading on iframe
                      const clone = link.cloneNode(true);
                      iframeDocument.head.appendChild(clone); // ADD
                    }
                  }
                });

                elms.forEach(elm => {
                  let href = elm.href.toLowerCase();
                  if (href.indexOf('/basetype-') !== -1 || href.indexOf('/type-') !== -1) {
                    // check
                    let exist = false;
                    Array.from(links).map(link => {
                      let elmHref = link.href.toLowerCase();
                      if (elmHref) {
                        if (elmHref.indexOf('/basetype-') !== -1 || elmHref.indexOf('/type-') !== -1) {
                          if (href === elmHref) {
                            exist = true;
                          }
                        }
                      }
                    });
                    if (!exist) {
                      iframeDocument.head.removeChild(elm); // REMOVE
                    }
                  }
                });

                // reload box js
                elms = iframeDocument.querySelectorAll('script');
                elms.forEach(elm => {
                  let src = elm.getAttribute('src');
                  if (src) {
                    if (src.indexOf('box-flex.js') !== -1 || src.indexOf('box.js') !== -1) {
                      elm.parentElement.removeChild(elm);
                      let scriptElm = document.createElement('script');
                      scriptElm.setAttribute('src', src);
                      iframeDocument.body.appendChild(scriptElm);
                    }
                  }
                });

                // Play Anim
                elms = wrapper.querySelectorAll('.is-animated');
                elms.forEach(elm => {
                  elm.style.opacity = '0';
                  elm.style.transition = 'none';
                });
                setTimeout(() => {
                  let elms = wrapper.querySelectorAll('.is-animated');
                  elms.forEach(elm => {
                    elm.classList.remove('is-inview');
                  });
                  setTimeout(() => {
                    elms = wrapper.querySelectorAll('.is-animated');
                    elms.forEach(elm => {
                      elm.style.opacity = '';
                      elm.style.transition = '';
                      elm.classList.add('is-inview');
                    });
                  }, 30);
                }, 200);
              }
            }
          } else {
            iframe.src = this.builder.previewURL + '?' + Math.floor(Date.now() / 1000);
          }
        }
        this.builder.livePreviewAlwaysReload = oriVal;
      }
      iframe.onload = () => {
        try {
          if (this.builder.onPreviewContentLoad && !disableOnContentLoad) this.builder.onPreviewContentLoad();
        } catch (e) {
          // Do Nothing
        }
        iframe.contentWindow.document.addEventListener('click', () => {
          iframe.focus();
        });
      };
    }
  }
  openPreview() {
    // if(!this.builder.previewURL) return;

    // if(this.modal.classList.contains('active')) return;

    const util = this.util;
    const modal = this.modal;
    modal.classList.add('active');
    if (localStorage.getItem('_livepreviewscreen') != null) {
      modal.classList.remove('is-screen-1920');
      modal.classList.remove('is-screen-1440');
      modal.classList.remove('is-screen-1024');
      modal.classList.remove('is-screen-768');
      modal.classList.remove('is-screen-375');
      modal.classList.add(localStorage.getItem('_livepreviewscreen'));
      const infoDevice = modal.querySelector('.is-modal-device');
      if (modal.classList.contains('is-screen-1920')) {
        infoDevice.setAttribute('title', util.out('Desktop'));
        infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>';
      } else if (modal.classList.contains('is-screen-1440')) {
        infoDevice.setAttribute('title', util.out('Laptop'));
        infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:18px;height:18px"><use xlink:href="#icon-device-laptop"></use></svg>';
      } else if (modal.classList.contains('is-screen-1024')) {
        infoDevice.setAttribute('title', util.out('Tablet (Landscape)'));
        infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>';
      } else if (modal.classList.contains('is-screen-768')) {
        infoDevice.setAttribute('title', util.out('Tablet (Portrait)'));
        infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>';
      } else if (modal.classList.contains('is-screen-375')) {
        infoDevice.setAttribute('title', util.out('Mobile'));
        infoDevice.innerHTML = '<svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-mobile"></use></svg>';
      }
    }
    this.previewRefresh();
    localStorage.setItem('_livepreview', '1');
  }
  closePreview() {
    const modal = this.modal;
    modal.classList.remove('active');
    if (this.builder.onPreviewClose) this.builder.onPreviewClose();
    localStorage.removeItem('_livepreview');
  }
  writeHtml(iframe) {
    let doc = this.builder.doc;
    let basehref = '';
    let base = doc.querySelectorAll('base[href]');
    if (base.length > 0) {
      basehref = '<base href="' + base[0].href + '" />';
    }
    let csslinks = '';
    let styles = doc.querySelectorAll('link[href]');
    for (let i = 0; i < styles.length; i++) {
      if (styles[i].href.indexOf('.css') != -1 && styles[i].href.indexOf('contentbox.css') == -1 && styles[i].href.indexOf('contentbuilder.css') == -1) {
        csslinks += '<link href="' + styles[i].href + '" rel="stylesheet">';
      }
    }
    let jsincludes1 = '';
    let scripts = doc.head.querySelectorAll('script[src]');
    for (let i = 0; i < scripts.length; i++) {
      if (scripts[i].src.indexOf('.js') != -1 && scripts[i].src.indexOf('_next/') == -1 &&
      //next
      scripts[i].src.indexOf('static/js/') == -1 &&
      //react
      scripts[i].src.indexOf('src/') == -1 &&
      //vue
      scripts[i].src.indexOf('index') == -1 && scripts[i].src.indexOf('contentbox.js') == -1 && scripts[i].src.indexOf('contentbox.min.js') == -1 && scripts[i].src.indexOf('contentbuilder.js') == -1 && scripts[i].src.indexOf('contentbuilder.min.js') == -1 && scripts[i].src.indexOf('plugin.js') == -1 && scripts[i].src.indexOf('config.js') == -1 && scripts[i].src.indexOf('en.js') == -1 && scripts[i].src.indexOf('rangy') == -1 && scripts[i].src.indexOf('monaco-editor') == -1 && scripts[i].src.indexOf('minimalist-blocks') == -1) {
        jsincludes1 += '<script src="' + scripts[i].src + '"></script>';
      }
    }
    let jsincludes2 = '';
    scripts = doc.body.querySelectorAll('script[src]');
    for (let i = 0; i < scripts.length; i++) {
      if (scripts[i].src.indexOf('.js') != -1 && scripts[i].src.indexOf('_next/') == -1 &&
      //next
      scripts[i].src.indexOf('static/js/') == -1 &&
      //react
      scripts[i].src.indexOf('src/') == -1 &&
      //vue
      scripts[i].src.indexOf('index') == -1 && scripts[i].src.indexOf('contentbox.js') == -1 && scripts[i].src.indexOf('contentbox.min.js') == -1 && scripts[i].src.indexOf('contentbuilder.js') == -1 && scripts[i].src.indexOf('contentbuilder.min.js') == -1 && scripts[i].src.indexOf('plugin.js') == -1 && scripts[i].src.indexOf('config.js') == -1 && scripts[i].src.indexOf('en.js') == -1 && scripts[i].src.indexOf('rangy') == -1 && scripts[i].src.indexOf('monaco-editor') == -1 && scripts[i].src.indexOf('minimalist-blocks') == -1) {
        jsincludes2 += '<script src="' + scripts[i].src + '"></script>';
      }
    }
    let maxwidth = '800px';
    let maxw = window.getComputedStyle(doc.querySelector('.is-builder')).getPropertyValue('max-width');
    if (!isNaN(parseInt(maxw))) maxwidth = maxw;
    let content = this.builder.html();
    let html = '<html>' + '<head>' + basehref + '<meta charset="utf-8">' + '<title></title>' + '<style>#_cbhtml > *:not(.is-lightbox) {display:none}</style>' + csslinks + (this.builder.useLightbox ? '<link href="' + this.builder.assetPath + 'scripts/lightbox/lightbox.css" rel="stylesheet">' : '') + '<style>' + '.slider-image { display:block !important; }' + '.container {margin:35px auto 0; max-width: ' + maxwidth + '; width:100%; padding:0 20px; box-sizing: border-box;}' + '</style>' + '<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>' + jsincludes1 + '</head>' + '<body>' + '<div class="container preview">' + content + '</div>' + jsincludes2 + (this.builder.useLightbox ? '<script src="' + this.builder.assetPath + 'scripts/lightbox/lightbox.js"></script><script>window.lightbox.init();</script>' : '') + '</body>' + '</html>';

    // doc = iframe.contentWindow.document;
    // doc.open();
    // doc.write(html);
    // doc.close();

    iframe.srcdoc = html;
  }
}

// Collection of common editing functions

class Lib {
  constructor(builder) {
    this.builder = builder;
  }
  getFunctions() {
    return [{
      name: 'get_intent',
      description: 'analyze user command to modify or create section/content',
      parameters: {
        type: 'object',
        properties: {
          asking_info: {
            type: 'boolean',
            description: 'User request an information.'
          },
          add_info: {
            // Without this, adding info will be considered as asking_info. Tha add_info should be the same as change_text
            type: 'boolean',
            description: 'User request an information to be added to the current content.'
          },
          // Add new Column or Block (in General Mode)
          add_column_or_block: {
            type: 'boolean',
            description: 'User requests to add a column or a block.'
          },
          new_content: {
            type: 'boolean',
            description: 'User requests to add a new content.'
          },
          redesign_layout: {
            type: 'boolean',
            description: 'If redesigning the layout is requested.'
          },
          change_text: {
            type: 'boolean',
            description: 'User explicitely requests to update text of the current content, rewrite, paraphrase, translate or change text.'
          },
          write_based_on_the_current_content: {
            type: 'boolean',
            description: 'User request to create new content based on the current content, such as to summarize, expand, make short, create a tweet or social media post, etc'
          },
          change_style: {
            type: 'boolean',
            description: 'If changing element style is requested.'
          },
          // section_background_color: {
          //     type: 'string',
          //     description: 'User request to add, adjust (lighter or darker) or remove section background color. Possible value: color value (convert to HTML supported), lighter, darker, remove'
          // },

          //-----
          add_headline: {
            type: 'boolean',
            description: 'If requested to add a headline.'
          },
          add_paragraph: {
            type: 'boolean',
            description: 'If requested to add a paragraph.'
          },
          add_space: {
            type: 'boolean',
            description: 'If requested to add a space.'
          },
          add_button: {
            type: 'boolean',
            description: 'If requested to add a button.'
          },
          add_youtube: {
            type: 'boolean',
            description: 'If requested to add a youtube/vimeo video.'
          },
          add_video: {
            type: 'boolean',
            description: 'If requested to add a video.'
          },
          add_audio: {
            type: 'boolean',
            description: 'If requested to add an audio.'
          },
          add_map: {
            type: 'boolean',
            description: 'If requested to add a google map.'
          },
          add_code: {
            type: 'boolean',
            description: 'If requested to add a custom code block.'
          },
          add_article: {
            type: 'boolean',
            description: 'If requested to add an article.'
          },
          add_image: {
            type: 'string',
            description: 'User request to add image or gallery. Possible value: image, gallery'
          },
          add_list: {
            type: 'boolean',
            description: 'If requested to add a list (eg. features, benefits, or list of items to explain).'
          },
          add_list_with_image: {
            type: 'boolean',
            description: 'If requested to add a list with an image for each list item.'
          },
          add_list_with_icon: {
            type: 'boolean',
            description: 'If requested to add a list with an icon.'
          },
          add_list_with_number: {
            type: 'boolean',
            description: 'If requested to add a list with numbering.'
          },
          //-----
          change_color_individual_text: {
            type: 'boolean',
            description: 'User requests to change the color of a headline, paragraph of specific element/text.'
          },
          align_individual_text: {
            type: 'boolean',
            description: 'If requested to align an individual text/element, such as a headline, a paragraph, buttons, etc to left, center or right'
          },
          align_whole_content: {
            type: 'string',
            description: 'User requests to align the whole text/content. Possible value: left, center or right'
          },
          // Block Mode (in General Mode)
          block_task: {
            type: 'string',
            description: 'User requests to move, duplicate, or delete block/row. Possible values: move-up, move-down, duplicate, remove'
          },
          column_task: {
            type: 'string',
            description: 'User requests to duplicate column, or delete column. Possible values: duplicate, remove'
          },
          move_column: {
            type: 'string',
            description: 'User requests to move column. Possible values: move-up, move-down, move-left, move-right'
          },
          increase_decrease_column: {
            type: 'string',
            description: 'User requests to increase/enlarge or decrease/reduce column size/width. Possible values: increase, decrease'
          },
          move_content_left: {
            type: 'boolean',
            description: 'Move content to the left'
          },
          move_content_center: {
            type: 'boolean',
            description: 'Move content to the center'
          },
          move_content_right: {
            type: 'boolean',
            description: 'Move content to the right'
          },
          move_content_top: {
            type: 'boolean',
            description: 'Move content to the top'
          },
          move_content_bottom: {
            type: 'boolean',
            description: 'Move content to the bottom'
          },
          line_height_individual_text: {
            type: 'boolean',
            description: 'User requests to increase/decrease the line height of an individual text/element (eg. headline).'
          },
          font_size_individual_text: {
            type: 'boolean',
            description: 'User requests to increase/decrease the font size of an individual text/element (eg. headline).'
          },
          select_block: {
            type: 'string',
            description: 'User requests to select a block. Value can be: block, headline, title, paragraph, image, next, previous, first, last'
          },
          unselect_block: {
            type: 'boolean',
            description: 'User requests to unselect block'
          }
        },
        required: ['image', 'article']
      }
    }];
  }
  getFunctions_block() {
    return [{
      name: 'get_intent',
      description: 'analyze user command to modify or create section/content',
      parameters: {
        type: 'object',
        properties: {
          enhance_writings: {
            type: 'boolean',
            description: 'User requests to enhance the writings, rewrite, paraphrase or change text.'
          },
          editing: {
            type: 'boolean',
            description: 'If requested to modify the current content or style.'
          },
          add_headline: {
            type: 'boolean',
            description: 'User requests to add a headline.'
          },
          add_space: {
            type: 'boolean',
            description: 'User requests to add a space.'
          },
          adjust_space: {
            type: 'boolean',
            description: 'User requests to increase or decrease a space.'
          },
          add_button: {
            type: 'boolean',
            description: 'User requests to add a button.'
          },
          add_youtube: {
            type: 'boolean',
            description: 'User requests to add a youtube/vimeo video.'
          },
          add_video: {
            type: 'boolean',
            description: 'User requests to add a video.'
          },
          add_audio: {
            type: 'boolean',
            description: 'User requests to add an audio.'
          },
          add_map: {
            type: 'boolean',
            description: 'User requests to add a google map.'
          },
          add_image: {
            type: 'boolean',
            description: 'User requests to add an image'
          },
          align_text: {
            type: 'boolean',
            description: 'User requests to align text'
          },
          line_height: {
            type: 'boolean',
            description: 'User requests to change or adjust line height'
          },
          font_size: {
            type: 'boolean',
            description: 'User requests to change or adjust font size'
          },
          new_block: {
            type: 'boolean',
            description: 'User requests to add a new block.'
          },
          block_task: {
            type: 'string',
            description: 'User requests to move, duplicate, or delete block/row. Possible values: move-up, move-down, duplicate, remove'
          },
          new_column_onright: {
            type: 'boolean',
            description: 'User requests to add a new column.'
          },
          new_column_onleft: {
            type: 'boolean',
            description: 'User requests to add a new column on the left.'
          },
          column_task: {
            type: 'string',
            description: 'User requests to duplicate column, or delete column. Possible values: duplicate, remove'
          },
          move_column: {
            type: 'string',
            description: 'User requests to move column. Possible values: move-up, move-down, move-left, move-right'
          },
          increase_decrease_column: {
            type: 'string',
            description: 'User requests to increase/enlarge or decrease/reduce column size/width. Possible values: increase, decrease'
          }
        }
      }
    }];
  }

  // Get complete/outer HTML of an element;
  getHtml(element) {
    const combineStrings = (outer, inner) => {
      // Find the opening tag of the first/parent element
      const openingTagRegex = /<([a-zA-Z]+\b[^>]*)>/;
      const openingTagMatch = outer.match(openingTagRegex);
      const openingTag = openingTagMatch[1];
      const combinedResult = `<${openingTag}>${inner}</div>`;
      return combinedResult;
    };
    let html = combineStrings(element.outerHTML, this.builder.readHtml(element, false, true));
    return html;
  }

  // Run functions based on short command
  processShortCommand(command) {
    command = command.toLowerCase();
    let shortCommandList = this.builder.shortCommandList;
    const getMatchingCommand = command => {
      for (const key in shortCommandList) {
        if (shortCommandList[key].includes(command)) {
          return key;
        }
      }
      return false;
    };
    const intent = getMatchingCommand(command);

    // Undo/Redo
    if (intent === 'undo') {
      this.builder.undo();
      return false;
    }
    if (intent === 'redo') {
      this.builder.redo();
      return false;
    }

    // The process below needs active element
    let elm = this.builder.activeElement;
    if (!elm) return command;

    // Size
    const isTextBlockElement = element => {
      const textBlockTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'PRE'];
      const tagName = element.tagName.toUpperCase();
      return textBlockTags.includes(tagName);
    };
    if (intent === 'increase') {
      if (elm.classList.contains('spacer')) {
        this.builder.saveForUndo();
        this.builder.lib.increaseElementHeight(elm);
        return false;
      } else if (isTextBlockElement(elm)) {
        this.builder.saveForUndo();
        this.builder.lib.increaseFontSize(elm);
        return false;
      }
    }
    if (intent === 'decrease') {
      if (elm.classList.contains('spacer')) {
        this.builder.saveForUndo();
        this.builder.lib.decreaseElementHeight(elm);
        return false;
      } else if (isTextBlockElement(elm)) {
        this.builder.saveForUndo();
        this.builder.lib.decreaseFontSize(elm);
        return false;
      }
    }

    // Text
    const formatText = s => {
      this.builder.saveForUndo();
      this.builder.util.restoreSelection();
      this.builder.formatTextNonToggle(s);
      this.builder.util.saveSelection();
    };
    if (intent === 'bold') {
      formatText('bold');
      return false;
    }
    if (intent === 'italic') {
      formatText('italic');
      return false;
    }
    if (intent === 'underline') {
      formatText('underline');
      return false;
    }
    if (intent === 'strikethrough') {
      formatText('strikethrough');
      return false;
    }
    if (intent === 'superscript') {
      formatText('superscript');
      return false;
    }
    if (intent === 'subscript') {
      formatText('subscript');
      return false;
    }
    if (intent === 'uppercase') {
      formatText('uppercase');
      return false;
    }
    if (intent === 'lowercase') {
      formatText('lowercase');
      return false;
    }
    if (intent === 'capitalize') {
      formatText('capitalize');
      return false;
    }
    if (intent === 'clean') {
      formatText('clean');
      return false;
    }
    return command;
  }
  getCurrentBackground(activeBox) {
    let currentImage = '';
    const overlayBgs = activeBox.querySelectorAll('.is-overlay-bg');
    overlayBgs.forEach(overlayBg => {
      if (overlayBg.style.backgroundImage) {
        if (overlayBg.style.backgroundImage.indexOf('url(') !== -1) {
          let url = overlayBg.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
          // let filename = url.substring(url.lastIndexOf('/') + 1);
          if (currentImage !== '') currentImage = ', ';
          // currentImage+= `${filename}`;
          currentImage += `${url}`;
        }
      }
    });
    return currentImage;
  }
  clearBackgroundColor(activeBox) {
    let overlayBg = activeBox.querySelector('.is-overlay');
    if (overlayBg) {
      overlayBg.style.backgroundColor = '';
    }
  }
  clearBackgroundImage(activeBox) {
    let overlayBg = activeBox.querySelector('.is-overlay-bg');
    if (overlayBg) {
      overlayBg.parentNode.removeChild(overlayBg);
    }
  }
  updateBackgroundImage(activeBox, url) {
    let overlay = activeBox.querySelector('.is-overlay');
    if (!overlay) {
      activeBox.insertAdjacentHTML('afterbegin', '<div class="is-overlay"></div>');
      overlay = activeBox.querySelector('.is-overlay');
    }
    if (activeBox.classList.contains('is-section')) {
      if (activeBox.classList.contains('min-height-20') || activeBox.classList.contains('min-height-25') || activeBox.classList.contains('min-height-30') || activeBox.classList.contains('min-height-40') || activeBox.classList.contains('min-height-50') || activeBox.classList.contains('min-height-60') || activeBox.classList.contains('min-height-70') || activeBox.classList.contains('min-height-75') || activeBox.classList.contains('min-height-80') || activeBox.classList.contains('min-height-90') || activeBox.classList.contains('min-height-100')) ; else {
        activeBox.classList.add('min-height-60');
      }
    }
    let overlayBg = overlay.querySelector('.is-overlay-bg');
    if (!overlayBg) {
      overlay.insertAdjacentHTML('beforeend', '<div class="is-overlay-bg"></div>');
      overlayBg = overlay.querySelector('.is-overlay-bg');
    }
    overlayBg.style.backgroundImage = 'url(\'' + url + '\')';
    overlayBg.style.backgroundPosition = 50 + '%' + ' ' + 60 + '%'; //default

    // Reset position & filter (grayscale)
    overlayBg.style.filter = '';
    overlay.style.filter = '';
  }
  moveContent(activeBox, val) {
    const container = activeBox.querySelector('.is-container');
    if (val === 'left' || val === 'center' || val === 'right') {
      container.classList.remove('is-content-left');
      container.classList.remove('is-content-right');
      container.classList.remove('edge-x--1');
      container.classList.remove('edge-x--0-75');
      container.classList.remove('edge-x--0-5');
      container.classList.remove('edge-x--0-25');
      container.classList.remove('edge-x-0');
      container.classList.remove('edge-x-0-25');
      container.classList.remove('edge-x-0-5');
      container.classList.remove('edge-x-0-75');
      container.classList.remove('edge-x-1');
      container.classList.remove('edge-x-2');
      container.classList.remove('edge-x-3');
      container.classList.remove('edge-x-4');
      container.classList.remove('edge-x-5');
      container.classList.remove('edge-x-6');
    }
    if (val === 'left') {
      container.classList.add('is-content-left');
      if (activeBox.querySelector('.glide')) {
        container.classList.add('edge-x-3'); // to give space for slider arrow
      } else {
        container.classList.add('edge-x-2');
      }
    }
    if (val === 'right') {
      container.classList.add('is-content-right');
      if (activeBox.querySelector('.glide')) {
        container.classList.add('edge-x-3'); // to give space for slider arrow
      } else {
        container.classList.add('edge-x-2');
      }
    }
    if (val === 'top' || val === 'middle' || val === 'bottom') {
      activeBox.classList.remove('is-content-top');
      activeBox.classList.remove('is-content-bottom');
      activeBox.classList.remove('edge-y--5');
      activeBox.classList.remove('edge-y--4');
      activeBox.classList.remove('edge-y--3');
      activeBox.classList.remove('edge-y--2');
      activeBox.classList.remove('edge-y--1');
      activeBox.classList.remove('edge-y-0');
      activeBox.classList.remove('edge-y-0-25');
      activeBox.classList.remove('edge-y-0-5');
      activeBox.classList.remove('edge-y-0-75');
      activeBox.classList.remove('edge-y-1');
      activeBox.classList.remove('edge-y-2');
      activeBox.classList.remove('edge-y-3');
      activeBox.classList.remove('edge-y-4');
      activeBox.classList.remove('edge-y-5');
      activeBox.classList.remove('edge-y-6');
      activeBox.classList.remove('edge-y-7');
      activeBox.classList.remove('edge-y-8');
    }
    if (val === 'top') {
      activeBox.classList.add('is-content-top');
      activeBox.classList.add('edge-y-2');
    }
    if (val === 'bottom') {
      activeBox.classList.add('is-content-bottom');
      activeBox.classList.add('edge-y-2');
    }
    this.builder.hideElementTools();
  }
  updateContentSize(activeBox, val) {
    const container = activeBox.querySelector('.is-container');
    // const contentSizes = this.builder.contentSizes;
    // const contentSizes = [300,320,360,400,440,480,520,560,600,640,680,720,760,800,840,880,920,960,1000,1040,1080,
    //     1120,1160,1200,1240,1280,1320,1360,1400,1440,1480,1520,1560,1600,1640,1680,1720,1760,1800,1840,1880,
    //     1920,1960,2000,2040,2080,2120,2160,2200,2240,2280,2320,2360,2400,2440,2480,2520,2560,2600,2640,2680,2700];
    const contentSizes = [320, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000];
    if (val === '') {
      container.style.maxWidth = '';
      container.classList.forEach(item => {
        if (item.indexOf('is-content-') !== -1 && item !== 'is-content-left' && item !== 'is-content-right') {
          container.classList.remove(item);
        }
      });
      container.classList.add('is-content-none');
      return;
    }
    let targetWidth;
    for (let i = 0; i < contentSizes.length; i++) {
      if (container.classList.contains(`is-content-${contentSizes[i]}`)) {
        if (val === '+') {
          if (i + 1 >= contentSizes.length) {
            targetWidth = contentSizes[i];
          } else {
            targetWidth = contentSizes[i + 1];
          }
          break;
        }
        if (val === '-') {
          if (i - 1 < 0) {
            targetWidth = contentSizes[i];
          } else {
            targetWidth = contentSizes[i - 1];
          }
          break;
        }
      }
    }
    if (!targetWidth) {
      const currentWidth = container.offsetWidth;
      // let targetWidth;

      for (let i = 0; i < contentSizes.length; i++) {
        if (contentSizes[i] <= currentWidth && currentWidth < contentSizes[i + 1]) {
          if (val === '+') {
            targetWidth = contentSizes[i + 1];
            break;
          }
        }
        if (contentSizes[i] < currentWidth && currentWidth <= contentSizes[i + 1]) {
          if (val === '-') {
            targetWidth = contentSizes[i];
            break;
          }
        }
      }
    }
    if (!targetWidth) targetWidth = 800;
    container.style.maxWidth = ''; //remove inline style

    container.classList.forEach(item => {
      if (item.indexOf('is-content-') !== -1 && item !== 'is-content-left' && item !== 'is-content-right') {
        container.classList.remove(item);
      }
    });
    container.classList.add('is-content-' + targetWidth);
  }
  updateContentColor(activeBox, val) {
    if (val == 'light') {
      activeBox.classList.remove('is-dark-text');
      activeBox.classList.add('is-light-text');
    }
    if (val == 'dark') {
      activeBox.classList.remove('is-light-text');
      activeBox.classList.add('is-dark-text');
    }
    if (val == '') {
      activeBox.classList.remove('is-light-text');
      activeBox.classList.remove('is-dark-text');
    }
  }
  chooseHeadline() {
    let list = this.builder.headlineList;
    let randomIndex = Math.floor(Math.random() * list.length);
    return list[randomIndex];
  }
  _addBlock(activeBox, html, pos) {
    /*
     let bSnippet = false;
    let attr;
    
    if(activeBox.querySelector('.cell-active')) {
         // This is needed before calling addSnippet()
        const builderStuff = this.builder.builderStuff;
        let quickadd = builderStuff.querySelector('.quickadd');
        quickadd.setAttribute('data-mode','row');
        // ----
         if(html!=='') this.builder.addSnippet(html, bSnippet);
        return;
    } 
    */

    let container = activeBox.querySelector('.is-container');
    if (!container) return;
    if (activeBox.classList.contains('is-container')) container = activeBox;
    let row;
    if (activeBox.querySelector('.row-active')) {
      row = activeBox.querySelector('.row-active');
    } else {
      const rows = this.builder.dom.elementChildren(container);
      row = rows[rows.length - 1]; // last row
    }

    if (!row) return;
    let rowElement, cellElement;
    if (this.builder.opts.row === '') {
      rowElement = this.htmlToElement(this.builder.opts.rowFormat);
      let s = this.builder.opts.cellFormat;
      let pos = s.indexOf('</');
      html = s.substring(0, pos) + html + s.substring(pos);

      // go to last deeper level
      let targetrow = this.builder.dom.elementChildren(rowElement);
      while (targetrow.length > 0) {
        targetrow = targetrow[0];
        if (this.builder.dom.elementChildren(targetrow).length > 0) {
          targetrow = this.builder.dom.elementChildren(targetrow);
        } else {
          break;
        }
      }
      targetrow.innerHTML = html;
      cellElement = targetrow.firstChild;
      // if(attr) {
      //     cellElement.setAttribute(attr,'');
      // }
    } else {
      cellElement = document.createElement('div');
      cellElement.classList.add(this.builder.opts.cols[this.builder.opts.cols.length - 1]);
      cellElement.innerHTML = html;

      // if(attr) {
      //     cellElement.setAttribute(attr,'');
      // }

      rowElement = document.createElement('div');
      rowElement.classList.add(this.builder.opts.row);
      rowElement.appendChild(cellElement);
    }
    row.parentNode.insertBefore(rowElement, row);
    if (pos === 'after') this.builder.dom.moveAfter(rowElement, row);
    this.builder.applyBehaviorOn(container);
    cellElement.click();
  }
  addBlock(activeBox, val, pos) {
    let html = '';
    // let bSnippet = true;

    if (val === 'headline') {
      html = `
            <h1 class="font-normal leading-11 size-54">${this.chooseHeadline()}</h1>
            `;
    }
    if (val === 'paragraph') {
      html = `
            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.
        Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
        when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
            `;
    }
    if (val === 'image') {
      html = `<img src="${this.builder.opts.snippetPath}example.png" alt="" />`;
      if (this.builder.opts.snippetSampleImage) {
        html = `<img src="${this.builder.opts.snippetSampleImage}" alt="" />`;
      }
    }
    if (val === 'space') {
      html = '<div class="spacer height-40"></div>';
    }
    if (val === 'button') {
      html = `
            <div>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Read More</a>
            </div>
            `;
    }
    if (val === 'twobuttons') {
      html = `
            <div>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">Read More</a>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 border-current hover:border-current font-normal leading-14 rounded tracking-wide">Get Started</a>
            </div>
            `;
    }
    if (val === 'icon') {
      html = `
            <div class="text-center">
                <i class="icon ion-android-alarm-clock size-80"></i>
            </div>
            `;
    }
    if (val === 'youtube') {
      html = `
            <div class="embed-responsive embed-responsive-16by9">
                <iframe width="560" height="315" src="https://www.youtube.com/embed/P5yHEKqx86U?rel=0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
            </div>
            `;
    }
    if (val === 'video') {
      html = `<video style="width: 100%;" loop="" autoplay="">
                <source src="${this.builder.opts.snippetPath}example.mp4" type="video/mp4"></video>`;
      if (this.builder.opts.snippetSampleVideo) {
        html = `<video style="width: 100%;" loop="" autoplay="">
                    <source src="${this.builder.opts.snippetSampleVideo}" type="video/mp4"></video>`;
      }
    }
    if (val === 'audio') {
      html = `<div style="display:flex;width:100%;position:relative;margin:15px 0;background:transparent;">
                    <audio controls="" style="width:100%">
                        <source src="${this.builder.opts.snippetPath}example.mp3" type="audio/mpeg">
                        Your browser does not support the audio element.
                    </audio>
                </div>`;
      if (this.builder.opts.snippetSampleAudio) {
        html = `<div style="display:flex;width:100%;position:relative;margin:15px 0;background:transparent;">
                        <audio controls="" style="width:100%">
                            <source src="${this.builder.opts.snippetSampleAudio}" type="audio/mpeg">
                            Your browser does not support the audio element.
                        </audio>
                </div>`;
      }
    }
    if (val === 'map') {
      html = `<div class="embed-responsive embed-responsive-16by9">
            <iframe width="100%" height="400" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" class="mg1" src="https://maps.google.com/maps?q=Melbourne,+Victoria,+Australia&amp;hl=en&amp;sll=-7.981898,112.626504&amp;sspn=0.009084,0.016512&amp;oq=melbourne&amp;hnear=Melbourne+Victoria,+Australia&amp;t=m&amp;z=10&amp;output=embed"></iframe>
            </div>`;
    }
    if (val === 'social') {
      html = `<div class="is-social" style="text-align: center;">
                <a href="https://twitter.com/"><i class="icon ion-social-twitter" style="margin-right: 1em"></i></a>
                <a href="https://www.facebook.com/"><i class="icon ion-social-facebook" style="margin-right: 1em"></i></a>
                <a href="mailto:you@example.com"><i class="icon ion-android-drafts"></i></a>
            </div>`;
    }
    if (val === 'table') {
      html = `<table class="default" style="border-collapse:collapse;width:100%;">
                <thead>
                <tr>
                    <td style="vertical-align:top;"><br></td>
                    <td style="vertical-align:top;"><br></td>
                </tr>
                </thead>
                <tr>
                    <td style="vertical-align:top;"><br></td>
                    <td style="vertical-align:top;"><br></td>
                </tr>
            </table>`;
    }
    this._addBlock(activeBox, html, pos);
  }
  alignContent(activeBox, command) {
    activeBox.classList.remove('is-align-left');
    activeBox.classList.remove('is-align-center');
    activeBox.classList.remove('is-align-right');
    activeBox.classList.remove('is-align-justify');
    if (command === 'left') activeBox.classList.add('is-align-left');
    if (command === 'center') activeBox.classList.add('is-align-center');
    if (command === 'right') activeBox.classList.add('is-align-right');
    if (command === 'justify') activeBox.classList.add('is-align-justify');
    let elms = activeBox.querySelectorAll('.is-builder > div > div, .is-builder > div > div > *');
    elms.forEach(elm => {
      if (elm.closest('.is-section-tool') || elm.closest('.is-box-tool') || elm.closest('.is-tool') || elm.closest('.is-rowadd-tool')) return;
      elm.style.textAlign = '';
      elm.classList.remove('left');
      elm.classList.remove('right');
      elm.classList.remove('center');
      elm.classList.remove(this.builder.cssClasses.textAlign.left);
      elm.classList.remove(this.builder.cssClasses.textAlign.center);
      elm.classList.remove(this.builder.cssClasses.textAlign.right);
      elm.classList.remove(this.builder.cssClasses.textAlign.justify);
      this.builder.dom.doFunction(elm, theEl => {
        if (theEl.closest('.is-section-tool') || theEl.closest('.is-box-tool') || theEl.closest('.is-tool') || theEl.closest('.is-rowadd-tool')) return;
        theEl.style.textAlign = '';
        elm.classList.remove('left');
        elm.classList.remove('right');
        elm.classList.remove('center');
        elm.classList.remove(this.builder.cssClasses.textAlign.left);
        elm.classList.remove(this.builder.cssClasses.textAlign.center);
        elm.classList.remove(this.builder.cssClasses.textAlign.right);
        elm.classList.remove(this.builder.cssClasses.textAlign.justify);
      }, true);
    });
  }
  alignText(element, command) {
    if (this.builder.useCssClasses) {
      element.style.textAlign = '';
      element.classList.remove(this.builder.cssClasses.textAlign.left);
      element.classList.remove(this.builder.cssClasses.textAlign.center);
      element.classList.remove(this.builder.cssClasses.textAlign.right);
      element.classList.remove(this.builder.cssClasses.textAlign.justify);
      if (command === 'left') element.classList.add(this.builder.cssClasses.textAlign.left);
      if (command === 'center') element.classList.add(this.builder.cssClasses.textAlign.center);
      if (command === 'right') element.classList.add(this.builder.cssClasses.textAlign.right);
      if (command === 'justify') element.classList.add(this.builder.cssClasses.textAlign.justify);
    } else {
      element.style.textAlign = command;
    }
  }
  increaseLineHeight(element, isContainer) {
    let lineHeightClasses = Object.values(this.builder.cssClasses.leading);
    if (isContainer) {
      const classList = this.builder.cssClasses.leading;
      lineHeightClasses = [classList.leading_10, classList.leading_11, classList.leading_12, classList.leading_13, classList.leading_14, 'leading-15', classList.leading_16, classList.leading_17, classList.leading_18, classList.leading_19, 'leading-20'];
    }
    const currentClass = this.getCurrentLineHeightClass(element, isContainer);
    const currentIndex = lineHeightClasses.indexOf(currentClass);
    if (currentIndex !== -1 && currentIndex < lineHeightClasses.length - 1) {
      const newClass = lineHeightClasses[currentIndex + 1];
      element.classList.remove(currentClass);
      element.classList.add(newClass);
    }
  }
  decreaseLineHeight(element, isContainer) {
    let lineHeightClasses = Object.values(this.builder.cssClasses.leading);
    if (isContainer) {
      const classList = this.builder.cssClasses.leading;
      lineHeightClasses = [classList.leading_10, classList.leading_11, classList.leading_12, classList.leading_13, classList.leading_14, 'leading-15', classList.leading_16, classList.leading_17, classList.leading_18, classList.leading_19, 'leading-20'];
    }
    const currentClass = this.getCurrentLineHeightClass(element, isContainer);
    const currentIndex = lineHeightClasses.indexOf(currentClass);
    if (currentIndex !== -1 && currentIndex > 0) {
      const newClass = lineHeightClasses[currentIndex - 1];
      element.classList.remove(currentClass);
      element.classList.add(newClass);
    }
  }
  getCurrentLineHeightClass(element, isContainer) {
    const classes = element.classList;
    for (let i = 0; i < classes.length; i++) {
      const classValue = classes[i];
      if (classValue.startsWith('leading-')) {
        return classValue;
      }
    }
    const computedStyle = window.getComputedStyle(element);
    let lineHeight = parseFloat(computedStyle.lineHeight);
    let fontSize = parseFloat(computedStyle.fontSize);
    let currentClassName = '';
    lineHeight = (lineHeight / fontSize).toFixed(1);
    const classList = this.builder.cssClasses.leading;
    if (isContainer) {
      if (lineHeight === '1') {
        currentClassName = classList.leading_10;
      } else if (lineHeight === '1.1') {
        currentClassName = classList.leading_11;
      } else if (lineHeight === '1.2') {
        currentClassName = classList.leading_12;
      } else if (lineHeight === '1.3') {
        currentClassName = classList.leading_13;
      } else if (lineHeight === '1.4') {
        currentClassName = classList.leading_14;
      } else if (lineHeight === '1.5') {
        currentClassName = 'leading-15';
      } else if (lineHeight === '1.6') {
        currentClassName = classList.leading_16;
      } else if (lineHeight === '1.7') {
        currentClassName = classList.leading_17;
      } else if (lineHeight === '1.8') {
        currentClassName = classList.leading_18;
      } else if (lineHeight === '1.9') {
        currentClassName = classList.leading_19;
      } else if (lineHeight === '2') {
        currentClassName = classList.leading_20;
      }
    } else {
      if (lineHeight === '0.5') {
        currentClassName = classList.leading_5;
      } else if (lineHeight === '0.6') {
        currentClassName = classList.leading_6;
      } else if (lineHeight === '0.7') {
        currentClassName = classList.leading_7;
      } else if (lineHeight === '0.8') {
        currentClassName = classList.leading_8;
      } else if (lineHeight === '0.9') {
        currentClassName = classList.leading_9;
      } else if (lineHeight === '1') {
        currentClassName = classList.leading_10;
      } else if (lineHeight === '1.1') {
        currentClassName = classList.leading_11;
      } else if (lineHeight === '1.2') {
        currentClassName = classList.leading_12;
      } else if (lineHeight === '1.3') {
        currentClassName = classList.leading_13;
      } else if (lineHeight === '1.4') {
        currentClassName = classList.leading_14;
      } else if (lineHeight === '1.5') {
        currentClassName = classList.leading_15;
      } else if (lineHeight === '1.6') {
        currentClassName = classList.leading_16;
      } else if (lineHeight === '1.7') {
        currentClassName = classList.leading_17;
      } else if (lineHeight === '1.8') {
        currentClassName = classList.leading_18;
      } else if (lineHeight === '1.9') {
        currentClassName = classList.leading_19;
      } else if (lineHeight === '2') {
        currentClassName = classList.leading_20;
      } else if (lineHeight === '2.1') {
        currentClassName = classList.leading_21;
      } else if (lineHeight === '2.2') {
        currentClassName = classList.leading_22;
      } else if (lineHeight === '2.3') {
        currentClassName = classList.leading_23;
      } else if (lineHeight === '2.4') {
        currentClassName = classList.leading_24;
      } else if (lineHeight === '2.5') {
        currentClassName = classList.leading_25;
      } else if (lineHeight === '2.6') {
        currentClassName = classList.leading_26;
      } else if (lineHeight === '2.7') {
        currentClassName = classList.leading_27;
      } else if (lineHeight === '2.8') {
        currentClassName = classList.leading_28;
      } else if (lineHeight === '2.9') {
        currentClassName = classList.leading_29;
      } else if (lineHeight === '3') {
        currentClassName = classList.leading_30;
      }
    }
    if (currentClassName !== '') return currentClassName;
    return classList.leading_14;
  }

  // Font Size Stuff
  increaseFontSize(activeElement, isDefaultSize) {
    const fontSizeClassValues = this.builder.opts.fontSizeClassValues;
    const currentFontSize = this.getCurrentFontSize(activeElement);
    const currentIndex = fontSizeClassValues.indexOf(currentFontSize);
    if (currentIndex < fontSizeClassValues.length - 1) {
      const nextFontSize = fontSizeClassValues[currentIndex + 1];
      const nextSizeClass = `size-${nextFontSize}`;
      if (isDefaultSize) if (nextSizeClass === 'size-24') return; // max for is-container font size is size-21

      if (this.hasSizeClass(activeElement)) {
        activeElement.classList.remove(this.getSizeClass(activeElement));
      }
      activeElement.classList.add(nextSizeClass);
    }
  }
  decreaseFontSize(activeElement, isDefaultSize) {
    const fontSizeClassValues = this.builder.opts.fontSizeClassValues;
    const currentFontSize = this.getCurrentFontSize(activeElement);
    const currentIndex = fontSizeClassValues.indexOf(currentFontSize);
    if (currentIndex > 0) {
      const previousFontSize = fontSizeClassValues[currentIndex - 1];
      const previousSizeClass = `size-${previousFontSize}`;
      if (isDefaultSize) if (previousFontSize === 'size-16') return; // min for is-container font size is size-15

      if (this.hasSizeClass(activeElement)) {
        activeElement.classList.remove(this.getSizeClass(activeElement));
      }
      activeElement.classList.add(previousSizeClass);
    }
  }
  clearFontSize(activeElement) {
    activeElement.classList.remove(this.getSizeClass(activeElement));
  }

  // Function to get the current font size dynamically
  getCurrentFontSize(activeElement) {
    const fontSizeClassValues = this.builder.opts.fontSizeClassValues;
    if (this.hasSizeClass(activeElement)) {
      const sizeClass = this.getSizeClass(activeElement);
      const fontSizeString = sizeClass.split('-')[1];
      return Number(fontSizeString);
    } else {
      const computedStyle = window.getComputedStyle(activeElement);
      const fontSizeString = computedStyle.getPropertyValue('font-size');
      const currentFontSize = Number(fontSizeString.match(/\d+/)[0]);

      // Check if the font size exists in the array
      if (fontSizeClassValues.includes(currentFontSize)) {
        return currentFontSize;
      } else {
        // Find the closest font size in the array
        const closestFontSize = this.findClosestFontSize(currentFontSize);
        return closestFontSize;
      }
    }
  }

  // Function to check if paragraph has 'size-' class
  hasSizeClass(element) {
    if (Array.from(element.classList).some(value => value.startsWith('size-'))) {
      return true;
    }

    // let currentElement = element.parentElement;

    // while (currentElement) {
    //     if (Array.from(currentElement.classList).some((value) => value.startsWith('size-'))) {
    //         return true;
    //     }
    //     currentElement = currentElement.parentElement;
    // }
    return false;
  }

  // Function to get the 'size-' class if present
  getSizeClass(activeElement) {
    return Array.from(activeElement.classList).find(value => value.startsWith('size-'));
  }
  // getSizeClass(activeElement) {
  //     let sizeClass = Array.from(activeElement.classList).find((value) => value.startsWith('size-'));

  //     if (!sizeClass) {
  //         let parentElement = activeElement.parentElement;

  //         while (parentElement) {
  //             sizeClass = Array.from(parentElement.classList).find((value) => value.startsWith('size-'));
  //             if (sizeClass) {
  //                 break;
  //             }
  //             parentElement = parentElement.parentElement;
  //         }
  //     }

  //     return sizeClass;
  // }

  // Function to find the closest font size in the array
  findClosestFontSize(currentFontSize) {
    const fontSizeClassValues = this.builder.opts.fontSizeClassValues;
    let closestFontSize = null;

    // Find the closest font size smaller than currentFontSize
    for (let i = fontSizeClassValues.length - 1; i >= 0; i--) {
      if (fontSizeClassValues[i] < currentFontSize) {
        closestFontSize = fontSizeClassValues[i];
        break;
      }
    }

    // If no smaller font size found, find the closest font size larger than currentFontSize
    if (closestFontSize === null) {
      for (let i = 0; i < fontSizeClassValues.length; i++) {
        if (fontSizeClassValues[i] > currentFontSize) {
          closestFontSize = fontSizeClassValues[i];
          break;
        }
      }
    }

    // If no closest font size found, use the first font size in the array
    if (closestFontSize === null) {
      closestFontSize = fontSizeClassValues[0];
    }
    return closestFontSize;
  }

  // Space Stuff

  // Increase the height of an element
  increaseElementHeight(element) {
    const currentHeightClass = this.getCurrentHeightClass(element);
    const nextHeightClass = this.getNextHeightClass(currentHeightClass, true);
    if (nextHeightClass) {
      element.classList.remove(currentHeightClass);
      element.classList.add(nextHeightClass);
    }
  }

  // Decrease the height of an element
  decreaseElementHeight(element) {
    const currentHeightClass = this.getCurrentHeightClass(element);
    const prevHeightClass = this.getNextHeightClass(currentHeightClass, false);
    if (prevHeightClass) {
      element.classList.remove(currentHeightClass);
      element.classList.add(prevHeightClass);
    }
  }

  // Get the current height class of an element
  getCurrentHeightClass(element) {
    const classes = Array.from(element.classList);
    return classes.find(className => className.startsWith('height-'));
  }

  // Get the next height class based on the current height class and direction
  getNextHeightClass(currentHeightClass, increase) {
    const heightClasses = ['height-20', 'height-40', 'height-60', 'height-80', 'height-100', 'height-120', 'height-140', 'height-160', 'height-180', 'height-200', 'height-220', 'height-240', 'height-260', 'height-280', 'height-300'];
    const currentIndex = heightClasses.indexOf(currentHeightClass);
    const nextIndex = increase ? currentIndex + 1 : currentIndex - 1;
    if (nextIndex >= 0 && nextIndex < heightClasses.length) {
      return heightClasses[nextIndex];
    }
    return null;
  }
  moveBlockContent(target) {
    const cell = this.builder.activeCol;
    if (!cell) return false;
    if (!(target === 'top' || target === 'bottom' || target === 'left' || target === 'right' || target === 'topleft' || target === 'topcenter' || target === 'topright' || target === 'bottomleft' || target === 'bottomcenter' || target === 'bottomright' || target === 'center')) return;
    this.builder.saveForUndo();
    const dom = this.builder.dom;
    let classes = this.builder.cssClasses.display;
    dom.addCssClass(cell, classes.flex, classes);
    classes = this.builder.cssClasses.flexDirection;
    dom.addCssClass(cell, classes.column, classes);
    if (target === 'top') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.start, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    } else if (target === 'bottom') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.end, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    } else if (target === 'left') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.center, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.start, classes);
    } else if (target === 'right') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.center, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.end, classes);
    } else if (target === 'topleft') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.start, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.start, classes);
    } else if (target === 'topcenter') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.start, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    } else if (target === 'topright') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.start, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.end, classes);
    } else if (target === 'bottomleft') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.end, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.start, classes);
    } else if (target === 'bottomcenter') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.end, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    } else if (target === 'bottomright') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.end, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.end, classes);
    } else if (target === 'center') {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.center, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    } else {
      let classes = this.builder.cssClasses.justifyContent;
      dom.addCssClass(cell, classes.center, classes);
      classes = this.builder.cssClasses.alignItems;
      dom.addCssClass(cell, classes.center, classes);
    }
    cell.style.justifyContent = '';
    cell.style.alignItems = '';
    this.builder.onChange();
  }
  elementContext(context, args) {
    if (args.add_headline) {
      let info = `- To add a headline or title, use this class: 'font-normal leading-11 size-64':
<h1 class="font-normal leading-11 size-64">Headline Text Here</h1>

`;
      context = context + '\n' + info;
    }
    if (args.add_paragraph) {
      let info = `- To add a paragraph (long or short), just add:
<p>Paragraph here</p>

`;
      context = context + '\n' + info;
    }
    if (args.add_space) {
      let info = `- To add a space, you must add 'div.spacer' element:

<div class="spacer height-40"></div

`;
      context = context + '\n' + info;
    }
    if (args.adjust_space) {
      let info = `- To increase or decrease a space, use one of these classes:
    - height-40
    - height-60
    - height-80
    - height-100
    - height-120
    - height-140
    - height-160
    - height-180
    - height-200

`;
      context = context + '\n' + info;
    }
    if (args.add_button) {
      let info = `- To add a buttons, use the example below as a template. Wrap the button in a <div> element.

Button Example:

    <div>
        <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-wide" title="" style="background-color: rgb(240, 240, 240);">Our Works</a>
        <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed rounded-full tracking-wide" title="">Get in Touch</a>
    </div>

`;
      context = context + '\n' + info;
    }
    if (args.add_youtube) {
      // Choose random youtube
      let videoList = this.builder.media.youtube_videos;
      let videoUrl = this.chooseMedia(videoList);
      let info = `- To embed a YouTube or Vimeo video, wrap the <iframe> element in a <div> element with the classes 'embed-responsive' and 'embed-responsive-16by9' and add add it inside a column (Youtube and Vimeo links are case sensitive):
<div class="embed-responsive embed-responsive-16by9">
<iframe width="560" height="315" src="${videoUrl}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_video) {
      // Choose random video
      let videoList = this.builder.media.videos;
      let videoUrl = this.chooseMedia(videoList);
      let info = `- To embed a video (MP4), use the <video> element, specify the source using the <source> element and add it inside a column:
<video style="width: 100%;" loop="" autoplay="">
<source src="${videoUrl}" type="video/mp4">
</video>
`;
      context = context + '\n' + info;
    }
    if (args.add_audio) {
      // Choose random audio
      let audioList = this.builder.media.audios;
      let audioUrl = this.chooseMedia(audioList);
      let info = `- To embed an audio (MP3), wrap the <audio> element in a <div> with the default style and class as shown below and add it inside a column:
<div style="width: 100%; position: relative; margin: 15px 0px; background: transparent;" class="flex">
<audio controls="" style="width:100%">
<source src="${audioUrl}" type="audio/mpeg">Your browser does not support the audio element.
</audio>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_map) {
      let info = `- To embed a google map, wrap the <iframe> element in a <div> element with the classes 'embed-responsive' and 'embed-responsive-16by9' and add add it inside a column:
<div class="embed-responsive embed-responsive-16by9">
<iframe width="100%" height="400" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" class="mg1" src="https://maps.google.com/maps?q=Melbourne,+Victoria,+Australia&amp;hl=en&amp;sll=-7.981898,112.626504&amp;sspn=0.009084,0.016512&amp;oq=melbourne&amp;hnear=Melbourne+Victoria,+Australia&amp;t=m&amp;z=10&amp;output=embed"></iframe>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_image) {
      // to differentiate from bg image
      let info = `- To add an image, just add <img> element inside 'div.columns' element:
            
<img src="{{IMAGEURL}}">

`;
      context = context + '\n' + info;
    }
    if (args.align_text) {
      let info = `- To align text or element, use one of these classes: 'text-left', text-center' or 'texr-right'.

`;
      context = context + '\n' + info;
    }
    if (args.line_height) {
      let info = `- To increase or decrease the line height of an individual text/element, apply this class on the requested element:
    
    - leading-08
    - leading-09
    - leading-none
    - leading-11
    - leading-12
    - leading-13
    - leading-14
    - leading-15
    - leading-16
    - leading-17
    - leading-18
    - leading-19
    - leading-20

`;
      context = context + '\n' + info;
    }
    if (args.font_size) {
      let info = `- To increase or decrease the font size, apply this class on the requested element:
    
    - size-12
    - size-13
    - size-14
    - size-15
    - size-16
    - size-17
    - size-18
    - size-19
    - size-20
    - size-21
    - size-24
    - size-28
    - size-32
    - size-35
    - size-38
    - size-42
    - size-46
    - size-48
    - size-50
    - size-54
    - size-60
    - size-64
    - size-68
    - size-72
    - size-76
    - size-80
    - size-84
    - size-88
    - size-92
    - size-96
    - size-100
    - size-104
    - size-108
    - size-112
    - size-116
    - size-120
    - size-124
    - size-128
    - size-132
    - size-136
    - size-140
    - size-144
    - size-148
    - size-152
    - size-156
    - size-160

`;
      context = context + '\n' + info;
    }
    return context;
  }
  addElementContext(context, args) {
    /*
    Check for elements: space, button, youtube, video, audio, map, code.
    Then add relevant context.
    
    Prompt Examples:
    - Embed a youtube video after the paragraph in a separate block. Also, add a space.
    - Add a google map showing mount Everest after the paragraph in separate block. Add a space.
    - Embed a video after the paragraph in a separate block. This is the video link: 
        http://media.w3.org/2010/05/sintel/trailer.mp4
        Also, add a space.
    - Embed an audio after the paragraph in a separate block. This is the audio link: 
        https://www.w3schools.com/html/horse.mp3
        Also, add a space.
    - Add a Google Map showing Mount Everest in a very close view. Add it after the paragraph in a separate block. Also, add a space.
    */

    //TODO: review
    // let info = '- Any element must be placed inside a column, and a column should be placed inside a row.';
    // context = context+'\n'+info;

    if (args.add_headline) {
      let info = `- To add a headline:
(1) Add a new row and columns separately from the other rows.
(2) Add a space between the headline and the other content.
(3) Use the example below as a template. 

Example:

<div class="row">
    <div class="column">
        <h1 class="font-normal leading-11 size-64">Headline Text Here</h1>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-60"></div>
    </div>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_space) {
      let info = `- To add a space, you must add 'div.spacer' element inside a column:

<div class="spacer height-60"></div

If requested to increase or decrease space, use one of these classes:
    - height-40
    - height-60
    - height-80
    - height-100
    - height-120
    - height-140
    - height-160
    - height-180
    - height-200

`;
      context = context + '\n' + info;
    }
    if (args.add_button) {
      //             let info = `- To add buttons, you must wrap the buttons in a 'div' element add add it inside a column. Use these buttons as an example and use same style, classes and attributes:
      // <div>
      // <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-wide" title="" style="background-color: rgb(240, 240, 240);">Our Works</a>
      // <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed rounded-full tracking-wide" title="">Get in Touch</a>
      // </div>`;
      let info = `- To add a buttons, follow these steps:
(1) Create the necessary rows and columns.
(2) Use the example below as a template.

Button Example:

<div class="row">
    <div class="column">
        <div>
            <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-wide" title="" style="background-color: rgb(240, 240, 240);">Our Works</a>
            <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed rounded-full tracking-wide" title="">Get in Touch</a>
        </div>
    </div>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_youtube) {
      // Choose random youtube
      let videoList = this.builder.media.youtube_videos;
      let videoUrl = this.chooseMedia(videoList);
      let info = `- To embed a YouTube or Vimeo video, wrap the <iframe> element in a <div> element with the classes 'embed-responsive' and 'embed-responsive-16by9' and add add it inside a column (Youtube and Vimeo links are case sensitive):
<div class="embed-responsive embed-responsive-16by9">
<iframe width="560" height="315" src="${videoUrl}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_video) {
      // Choose random video
      let videoList = this.builder.media.videos;
      let videoUrl = this.chooseMedia(videoList);
      let info = `- To embed a video (MP4), use the <video> element, specify the source using the <source> element and add it inside a column:
<video style="width: 100%;" loop="" autoplay="">
<source src="${videoUrl}" type="video/mp4">
</video>
`;
      context = context + '\n' + info;
    }
    if (args.add_audio) {
      // Choose random audio
      let audioList = this.builder.media.audios;
      let audioUrl = this.chooseMedia(audioList);
      let info = `- To embed an audio (MP3), wrap the <audio> element in a <div> with the default style and class as shown below and add it inside a column:
<div style="width: 100%; position: relative; margin: 15px 0px; background: transparent;" class="flex">
<audio controls="" style="width:100%">
<source src="${audioUrl}" type="audio/mpeg">Your browser does not support the audio element.
</audio>
</div>
`;
      context = context + '\n' + info;
    }
    if (args.add_map) {
      let info = `- To embed a google map, wrap the <iframe> element in a <div> element with the classes 'embed-responsive' and 'embed-responsive-16by9' and add add it inside a column:
<div class="embed-responsive embed-responsive-16by9">
<iframe width="100%" height="400" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" class="mg1" src="https://maps.google.com/maps?q=Melbourne,+Victoria,+Australia&amp;hl=en&amp;sll=-7.981898,112.626504&amp;sspn=0.009084,0.016512&amp;oq=melbourne&amp;hnear=Melbourne+Victoria,+Australia&amp;t=m&amp;z=10&amp;output=embed"></iframe>
</div>
`;
      context = context + '\n' + info;
    }

    // Replace {{CUSTOMCODE}}
    if (args.add_code) {
      let info = `- To add a custom code, add a row and column with attributes 'data-noedit' and 'data-html', and place the custom code between <!--CODESTART--> and <!--CODEEND--> inside the column:
<div class="row">
<div class="column" data-noedit data-html>
<!--CODESTART-->
Custom Code here
<!--CODEEND-->
</div>
</div>

- Note that the column must be placed inside a row within 'div.is-container' element.

`;
      context = context + '\n' + info;
    }
    if (args.add_image === 'image') {
      // to differentiate from bg image
      if (!context.includes('{{IMAGEURL}}')) {
        let info = `- To add an image, follow these steps:
(1) Create the necessary rows and column, or use the current column.
(2) Add <img> element inside the column.
(3) Use the example below as a template.
(4) Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.

Image Example:

<div class="row">
    <div class="column">
        <img src="{{IMAGEURL}}" alt="">
    </div>
</div>
                
- Important: for image, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`;

        // Choose random image
        const gallery = this.builder.media.images;
        const imageList = gallery.square;
        const imageUrl = this.chooseMedia(imageList);
        info = info.replaceAll('{{_IMAGEURL}}', imageUrl);
        context = context + '\n' + info;
      }
    }
    if (args.change_section_height) {
      let info = `- To specify section height, use one of these classes on 'div.is-section' element:
    - is-section-10
    - is-section-15
    - is-section-20
    - is-section-25
    - is-section-30
    - is-section-40
    - is-section-50
    - is-section-60
    - is-section-70
    - is-section-75
    - is-section-80
    - is-section-85
    - is-section-90
    - is-section-100 (section height 100%)
    - is-section-auto (Autofit content)

`;
      context = context + '\n' + info;
    }
    if (args.content_width) {
      let info = `- To increase or decrease content/container width, use one of these classes on 'div.is-container' element:

    - is-content-600
    - is-content-700
    - is-content-800
    - is-content-900
    - is-content-1000
    - is-content-1100
    - is-content-1200
    - is-content-1300
    - is-content-1400
    - is-content-1500
    - is-content-1600
    - is-content-1800
    - is-content-none (unset/full width)

`;
      context = context + '\n' + info;
    }
    if (args.section_background && args.section_background === 'image') {
      let info = `- Background image must be added in 'div.is-overlay-bg' element inside 'div.is-overlay' element.

Example:

<div class="is-overlay">
    <div class="is-overlay-bg" style="background-image: url('path/to/image.jpg'); background-position: 50% 60%;"></div>
</div>
           
`;
      context = context + '\n' + info;
    }
    if (args.section_background && args.section_background === 'slider') {
      let info = `- Background slider must be added in 'div.is-overlay-content' element inside 'div.is-overlay' element.

Example:

<div class="is-overlay">
    <div class="is-overlay-content"></div>
</div>

`;
      context = context + '\n' + info;
    }
    if (args.section_background && args.section_background === 'video') {
      let info = `- Background video must be added in 'div.is-overlay-content' element inside 'div.is-overlay' element.

Example:

<div class="is-overlay">
    <div class="is-overlay-content"></div>
</div>

`;
      context = context + '\n' + info;
    }
    if (args.align_individual_text) {
      let info = `- To align a certain text (eg. align the headline, align the paragraph, etc), use 'text-left', text-center' or 'texr-right' class on the headline or paragraph as requested.

`;
      context = context + '\n' + info;
    }
    if (args.align_whole_content && !args.align_individual_text) {
      let info = `- To align the whole content, follow these steps:
    (1) use 'is-align-left', 'is-align-center' or 'is-align-right' on the 'div.is-container' element.
    (2) Remove these classes: 'text-left', text-center' or 'texr-right' on every elements.

`;
      context = context + '\n' + info;
    }

    /* These are related to style change requests */
    /*
    if(args.change_content_dark) {
        let info = `- To change the text/content color to dark/black, add 'is-dark-text' class into the 'div.is-box' element.
    `;
         context = context+'\n'+info;
    }
     if(args.change_content_light) {
        let info = `- To change the text/content color to light/white, add 'is-light-text' class into the 'div.is-box' element.
    `;
         context = context+'\n'+info;
    }
    */

    if (args.line_height_paragraph) {
      let info = `- To increase or decrease the line height of paragraphs, use one of these classes on the 'div.is-container' element:

    - leading-none
    - leading-11
    - leading-12
    - leading-13
    - leading-14
    - leading-15
    - leading-16
    - leading-17
    - leading-18
    - leading-19
    - leading-20

Do not apply this on any other element except the 'div.is-container' element.

`;
      context = context + '\n' + info;
    }
    if (args.line_height_individual_text && !args.line_height_paragraph) {
      let info = `- To increase or decrease the line height of an individual text/element, apply this class on the requested element:
    
    - leading-08
    - leading-09
    - leading-none
    - leading-11
    - leading-12
    - leading-13
    - leading-14
    - leading-15
    - leading-16
    - leading-17
    - leading-18
    - leading-19
    - leading-20

Important: Do not change the 'div.is-container' element!

`;
      context = context + '\n' + info;
    }
    if (args.font_size_paragraph) {
      let info = `- To increase or decrease the font size of the paragraphs, use one of these classes on the 'div.is-container' element:
    
    - size-16
    - size-17
    - size-18
    - size-19
    - size-20
    - size-21

Do not apply this on any other element except the 'div.is-container' element.

`;
      context = context + '\n' + info;
    }
    if (args.font_size_individual_text && !args.font_size_paragraph) {
      let info = `- To increase or decrease the font size of an individual text/element, apply this class on the requested element:
    
    - size-12
    - size-13
    - size-14
    - size-15
    - size-16
    - size-17
    - size-18
    - size-19
    - size-20
    - size-21
    - size-24
    - size-28
    - size-32
    - size-35
    - size-38
    - size-42
    - size-46
    - size-48
    - size-50
    - size-54
    - size-60
    - size-64
    - size-68
    - size-72
    - size-76
    - size-80
    - size-84
    - size-88
    - size-92
    - size-96
    - size-100
    - size-104
    - size-108
    - size-112
    - size-116
    - size-120
    - size-124
    - size-128
    - size-132
    - size-136
    - size-140
    - size-144
    - size-148
    - size-152
    - size-156
    - size-160

Important: Do not change the 'div.is-container' element!

`;
      context = context + '\n' + info;
    }
    return context;
  }
  chooseMedia(mediaList) {
    let randomIndex;
    if (this.builder.currentMedia) {
      do {
        randomIndex = Math.floor(Math.random() * mediaList.length);
      } while (mediaList[randomIndex] === this.builder.currentMedia);
    } else {
      randomIndex = Math.floor(Math.random() * mediaList.length);
    }
    let newMedia = mediaList[randomIndex];
    this.builder.currentMedia = newMedia;
    return this.builder.mediaPath + newMedia;
  }
}

// import RecordRTC  from 'recordrtc';
// import Recorder from 'opus-recorder'; // Using Recorder
const dom = new Dom();
class Dictation {
  constructor(opts = {}, builder) {
    let defaults = {
      send: () => {},
      abort: () => {}
    };
    this.opts = Object.assign(this, defaults, opts);
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    if (localStorage.getItem('_mic') === null) {
      localStorage.setItem('_mic', '0'); // make mic disable by default
    }

    this.builder.isInProgress = false;
    let html = `
        <style>
            #_cbhtml .is-modal.page-command {
                width: 25vw;
                min-width: 500px;
                max-width: 600px;
                height: 230px; 
                top: auto; 
                bottom: 30px; 
                left: auto; 
                right: 30px; 
                z-index: 10005;
                font-size: 12px;
                border-radius: 6px;
                box-shadow: 5px 9px 14px 1px rgb(0 0 0 / 8%);
            }
            #_cbhtml .is-modal.page-command textarea {
                border:none;border-top: rgb(133 133 133 / 14%) 1px solid;resize:none;width:100%;
                height:170px;outline:none;background:transparent;line-height: 1.2;
                font-family: sans-serif;font-weight: 300;font-size: 17px;padding-top:12px;
            }
            .page-command-overlay {
                position: fixed;
                background: rgb(148 148 148 / 22%);
                display: none;
                z-index: 10004;
                justify-content: center;
                align-items:center;
                top:0;left:0;right:0;bottom:0;
            }
            #_cbhtml .div-assistant-mode button {
                padding: 0 17px;height:26px;border-radius:20px;box-shadow:none;
            }
            #_cbhtml .div-assistant-mode button[disabled] {
                pointer-events: none;
                opacity: 0.5;
                background: transparent;
            }
            /*
            .is-modal.commandconfig, 
            #_cbhtml .is-modal.commandconfig label {
                font-size: 14px;
            }
            */
            .is-modal.commandconfig ul {
                margin: 0;
                padding: 0 0 0 16px;
            }
            .is-modal.commandconfig ul li {
                font-size: inherit;
                line-height: 1.2;
            }
            .is-modal.commandlist {
                z-index: 10005 !important
            }
            .is-modal.commandlist .is-modal-content {
                max-width:calc(100% - 150px);
                height:calc(100% - 150px);
                padding:0 !important;
            }
            .is-modal.commandlist .is-modal-close {
                position: absolute !important;
                top: 5px;
                right: 15px;
                box-shadow: none !important;
            }
            .is-modal.commandlist .is-modal-close {
                background: transparent !important;
            }
            .is-modal.commandlist .is-modal-close svg {
                width:50px;height:50px;
            }
            .is-modal.commandlist .is-modal-content > div {
                display: flex;
                flex-flow: wrap;
                align-items: flex-start;
                /*align-items: inherits;*/
                justify-content: flex-start;
                padding: 2.2rem;
                box-sizing: border-box;
                overflow-y: auto;
                overflow-x: hidden;
                width: 100%;
                height: 100%;
            }
            .is-modal.commandlist .is-modal-content > div > h2 {
                display: block;
                width: 100%;
                flex: none;
                font-family: "Open Sans", sans-serif;
                font-weight: 300;
                margin-bottom: 10px;
                font-size: 28px;
            }
            .is-modal.commandlist .is-modal-content > div > p {
                display: block;
                width: 100%;
                flex: none;
                font-family: "Open Sans", sans-serif;
                font-weight: 300;
                font-size: 17px !important;
                margin: 0 0 30px;
            }
            .is-modal.commandlist .is-modal-content > div > div {
                margin-right: 2.2rem;
                margin-bottom: 2.2rem;
                display: flex;
                flex: none;
                width: 350px;
                height: auto;
                flex-direction: column;
                justify-content: space-between;
                border-radius: 0.25rem;
                border: 1px solid rgb(156 163 175/.75);
                padding: 1.5rem 2rem;
                box-sizing: border-box;
                letter-spacing: .025em;
                box-shadow: 5px 5px 0px rgb(0 0 0 / 3%);
                font-size: 19px;
                font-weight: 300;
                font-family: sans-serif;
                line-height: 1.3;
                cursor:pointer;
                transition: all 0.3s ease;
            }
            .is-modal.commandlist .is-modal-content > div > div:hover {
                background: rgba(0, 0, 0, 0.03);
            }
            .dark .is-modal.commandlist .is-modal-content > div > div:hover {
                background: rgba(255, 255, 255, 0.05);
            }

            .spinner {
                -webkit-animation: rotator 1.4s linear infinite;
                        animation: rotator 1.4s linear infinite;
            }
            @-webkit-keyframes rotator {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(270deg);
                }
            }
            @keyframes rotator {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(270deg);
                }
            }
            .path {
                stroke: #232323; /* #b7b7b7; */
                stroke-dasharray: 187;
                stroke-dashoffset: 0;
                transform-origin: center;
                -webkit-animation: dash 1.4s ease-in-out infinite;
                        animation: dash 1.4s ease-in-out infinite;
            }
            @-webkit-keyframes dash {
                0% {
                    stroke-dashoffset: 187;
                }
                50% {
                    stroke-dashoffset: 46.75;
                    transform: rotate(135deg);
                }
                100% {
                    stroke-dashoffset: 187;
                    transform: rotate(450deg);
                }
            }
            @keyframes dash {
                0% {
                    stroke-dashoffset: 187;
                }
                50% {
                    stroke-dashoffset: 46.75;
                    transform: rotate(135deg);
                }
                100% {
                    stroke-dashoffset: 187;
                    transform: rotate(450deg);
                }
            }
            .inp-command::placeholder {
                color: #aaa;
            }

            .label-chk-autosend-command,
            .label-input-autosend-command {
                display: none !important;
            }
        </style>
        <div class="is-modal ai-disclaimer" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="max-width:450px;padding:55px 40px 35px;font-size:16px;line-height:1.4;letter-spacing: 1px;">
                <div class="is-modal-bar is-draggable">
                    ${util.out('AI-Powered Features')}
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
                ${util.out('AI-Disclaimer', this.builder.disclaimerAI)}
                <div style="text-align:right;margin-top:20px;">
                    <button title="${util.out('Ok')}" class="input-ok classic-primary" style="width:100%;text-transform: uppercase;
                    font-size: 14px;">${util.out('Ok')}</button>
                </div>
            </div>
        </div>
        <div class="is-overlay page-command-overlay">
            <svg class="spinner" width="40px" height="40px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
                <circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
            </svg>
        </div>
        <div class="is-modal is-modal-content page-command" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true" style="${this.builder.AIModalStyle}">
            <div class="is-modal-bar is-draggable" draggable=""> 
                <span style="display: flex;
                justify-content: center;
                align-items: center;">
                    ${util.out('AI Assistant')}</span>
    
                <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">
                    <svg class="is-icon-flex"style="width:22px;height:22px"><use xlink:href="#ion-ios-close-empty"></use></svg>
                </button>
            </div>
            <div style="display:flex;flex-direction:column;justify-content:space-between;position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;border-top:transparent 35px solid;overflow-y:hidden;overflow-x:auto;">
                <div style="display:flex;align-items:center;justify-content:center;padding: 2px 13px 10px;">
                    <div class="div-assistant-mode" style="display:flex;align-items: center;">
                        <button class="scope-section on" title="${util.out('General')}" data-value="general" style="margin-right:5px">${util.out('General')}</button> 
                        <button class="scope-others" title="${util.out('Ask Questions')}" data-value="others">${util.out('Ask Questions')}</button>
                        <button class="scope-block" title="${util.out('Edit Selected Text')}" data-value="block" style="">${util.out('Edit Selected Text')}</button>
                        <button class="scope-image" title="${util.out('Image')}" data-value="image" style="display:none;margin-right:5px">${util.out('Image')}</button> 
                    </div>
                </div>
                <textarea class="inp-command" id="__inp_command"></textarea>
                <div style="display:flex;">
                    <button title="${util.out('Settings')}" class="cmd-command-config classic-secondary" style="width:40px;height:43px;flex:none;padding:0;outline-offset:-2px;">
                        <svg class="is-icon-flex" style="width:15px;height:15px;flex:none;"><use xlink:href="#icon-settings"></use></svg>
                    </button>
                    <button title="${util.out('Mic')}" class="cmd-enable-dictation classic-secondary" style="width:40px;height:43px;flex:none;padding:0;outline-offset:-2px;">
                        <svg class="is-icon-flex" style="width: 18px; height: 18px;"><use xlink:href="#icon-microphone"></use></svg> 
                    </button>
                    <button title="${util.out('Command Examples')}" class="cmd-command-list classic-secondary" style="width:40px;height:43px;flex:none;padding:0;outline-offset:-2px;">
                        <svg class="is-icon-flex" style="width: 18px; height: 18px;"><use xlink:href="#icon-message-search"></use></svg> 
                    </button>
                    <button title="${util.out('Clear')}" class="cmd-clear-command classic-secondary" style="width:40px;height:43px;flex:none;padding:0;outline-offset:-2px;">
                        <svg class="is-icon-flex" style="width: 18px; height: 18px;"><use xlink:href="#icon-eraser"></use></svg> 
                    </button>

                    <label class="label-chk-autosend-command" for="chkAutoSendCommand" style="margin:0;display:flex;padding-left:10px;padding-right:25px;white-space:nowrap;align-items:center;letter-spacing:0"><input id="chkAutoSendCommand" type="checkbox"> <span style="margin-left:3px">${util.out('Auto Send')}</span></label>
                    
                    <button title="${util.out('Send')}" class="cmd-send-command classic-primary" style="width:100%;padding-left:5px;padding-right:5px;height:43px;outline-offset:-2px;">Send</button>
                </div>
            </div>
        </div>

        <div class="is-modal commandlist" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="false">
            <div class="is-modal-overlay"></div>

            <div class="is-modal-content scroll-darker"">
                <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">
                    <svg class="is-icon-flex"><use xlink:href="#ion-ios-close-empty"></use></svg>
                </button>
                <div class="div-command-list">

                </div>
            </div>
        </div>

        <div class="is-modal commandconfig" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="max-width:380px;padding:55px 40px 35px;">
                <div class="is-modal-bar is-draggable">
                    ${util.out('Settings')}
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
              
                <div class="is-label"><span>${util.out('Temperature')}</span>: <span class="val-temp">0.6</span></div>
                <div style="padding-top:4px">
                    <input type="range" min="0" max="2" step="0.01" value="0.6" class="temperature-slider is-rangeslider" style="margin:0 !important;">
                </div>
                
                <div class="is-label" style="margin-top:15px"><span>${util.out('Top P')}</span>: <span class="val-top-p">0.9</span></div>
                <div style="padding-top:4px">
                    <input type="range" min="0" max="1" step="0.01" value="0.9" class="top-p-slider is-rangeslider" style="margin:0 !important;">
                </div>

                <div style="text-align:right">
                    <button title="${util.out('Reset')}" class="input-reset classic-secondary" style="text-decoration: underline;padding: 0;box-shadow: none;">${util.out('Reset')}</button>
                </div>

                <label for="chkAutoEditBlock" style="margin:0;display:flex;align-items:center;letter-spacing:0">
                    <input id="chkAutoEditBlock" type="checkbox" style="margin:0 5px 0 0;"> 
                    <span style="line-height: 1;">${util.out('Auto select \'Edit Selected Block\' mode.')}</span>
                </label>

                <label class="label-input-autosend-command" style="margin:18px 0 0 0;display:flex;align-items:center;letter-spacing:0">
                    <span>${util.out('Auto send command delay')}</soan>:
                    <input class="input-autosend-delay" id="__input_autosend_delay" style="width:60px;text-align:center;padding-left:0;height:33px;margin-right:3px;" type="text" value="4000"> <span>ms</span>
                </label>

                <div class="command-settings-info" style="display:none"></div>

                <label class="label-input-command-lang" style="display:none;flex-direction:column;letter-spacing:0;margin:18px 0 0 0;">
                    <span>${util.out('Language')}:</span>
                    <div style="display:flex; align-items: baseline;flex-direction: row;">
                        <input class="input-command-lang" id="__input_command_lang" style="width:70px;text-align:center;padding-left:0;height:33px;margin-top:5px;margin-right:10px" type="text" value="en-us">
                        <span>(${util.out('BCP-47 format')})</span>
                    </div>
                </label>

                <div style="text-align:right;margin-top:25px;">
                    <button title="${util.out('Ok')}" class="input-ok classic-primary" style="width:100%;">${util.out('Ok')}</button>
                </div>
            </div>
        </div>
        `;
    dom.appendHtml(builderStuff, html);
    const modalCommand = builderStuff.querySelector('.page-command');
    this.modalCommand = modalCommand;
    const modalCommandList = builderStuff.querySelector('.commandlist');
    this.modalCommandList = modalCommandList;
    const modalConfig = builderStuff.querySelector('.commandconfig');
    this.modalConfig = modalConfig;
    const btnConfig = builderStuff.querySelector('.cmd-command-config');
    const btnDictation = builderStuff.querySelector('.cmd-enable-dictation');
    const btnClear = builderStuff.querySelector('.cmd-clear-command');
    const chkAutoSend = builderStuff.querySelector('#chkAutoSendCommand');
    const btnCommandList = builderStuff.querySelector('.cmd-command-list');
    const divInfo = builderStuff.querySelector('.command-settings-info');
    this.modalDisclaimer = builderStuff.querySelector('.ai-disclaimer');
    const btnOk = this.modalDisclaimer.querySelector('.input-ok');
    btnOk.addEventListener('click', () => {
      this.builder.util.hideModal(this.modalDisclaimer);
      this.openDictation();
    });
    let info = `
        <div style="font-weight:500;margin: 25px 0 7px;">${util.out('Dictation')}</div>
        <div style="line-height: 1.4;margin: 0 0 7px;">${util.out('These words trigger command actions')}:</div>
        <ul>`;
    const triggerWords = this.builder.triggerWords;
    for (const key in triggerWords) {
      if (key === 'send') {
        let s = '';
        triggerWords[key].forEach(word => {
          s += `, ${word}`;
        });
        s = s.substring(1);
        info += `<li><span>${s}</span></li>`;
      }
      if (key === 'abort') {
        let s = '';
        triggerWords[key].forEach(word => {
          s += `, ${word}`;
        });
        s = s.substring(1);
        info += `<li><span>${s}</span></li>`;
      }
      if (key === 'clear') {
        let s = '';
        triggerWords[key].forEach(word => {
          s += `, ${word}`;
        });
        s = s.substring(1);
        info += `<li><span>${s}</span></li>`;
      }
    }
    info += '</ul>';
    divInfo.innerHTML = info;
    const inpCommand = this.builderStuff.querySelector('.inp-command');
    this.builder.commandText = '';
    this.builder.autoSendCommand = false;
    if (localStorage.getItem('_dictation') !== null) {
      if (localStorage.getItem('_dictation') === '1') {
        this.modalCommand.classList.add('active');
        this.doOpen();
        if (localStorage.getItem('_mic') !== null) {
          if (localStorage.getItem('_mic') === '1') {
            this.startDictation();
          }
        } else {
          this.startDictation();
        }
      }
    }
    if (localStorage.getItem('_mic') !== null) {
      if (localStorage.getItem('_mic') === '0') {
        btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
        chkAutoSend.parentNode.style.display = 'none';
      }
    }
    if (localStorage.getItem('_autosendcommand') !== null) {
      if (localStorage.getItem('_autosendcommand') === '1') {
        chkAutoSend.checked = true;
        this.builder.autoSendCommand = true;
        localStorage.setItem('_autosendcommand', '1');
      }
    }
    this.modalCommand.addEventListener('focus', () => {
      util.saveSelection(); // must be called in case used by formatText()
    });

    btnConfig.addEventListener('click', () => {
      this.config();

      // util.showModal(this.modalConfig, false, ()=>{

      //     btnConfig.removeAttribute('data-focus');
      //     btnConfig.focus();

      // }, false);

      // btnConfig.setAttribute('data-focus',true);
    });

    if (localStorage.getItem('_temp') !== null) {
      let val = localStorage.getItem('_temp');
      this.builder.temperature = val;
    }
    if (localStorage.getItem('_top_p') !== null) {
      let val = localStorage.getItem('_top_p');
      this.builder.topP = val;
    }
    if (localStorage.getItem('_autosend_delay') !== null) {
      let val = localStorage.getItem('_autosend_delay');
      this.builder.autoSendDelay = val;
    }
    if (localStorage.getItem('_auto_editblock') !== null) {
      let val = localStorage.getItem('_auto_editblock');
      this.builder.autoEditBlock = val;
    }
    if (localStorage.getItem('_command_lang') !== null) {
      let val = localStorage.getItem('_command_lang');
      this.builder.speechRecognitionLang = val;
    }
    const btnConfigOk = this.modalConfig.querySelector('.input-ok');
    btnConfigOk.addEventListener('click', () => {
      const tempSlider = this.modalConfig.querySelector('.temperature-slider');
      localStorage.setItem('_temp', tempSlider.value);
      this.builder.temperature = tempSlider.value;
      const topPSlider = this.modalConfig.querySelector('.top-p-slider');
      localStorage.setItem('_top_p', topPSlider.value);
      this.builder.topP = topPSlider.value;
      const chkAutoEditBlock = this.modalConfig.querySelector('#chkAutoEditBlock');
      if (chkAutoEditBlock.checked) {
        localStorage.setItem('_auto_editblock', 1);
        this.builder.autoEditBlock = true;
      } else {
        localStorage.setItem('_auto_editblock', 0);
        this.builder.autoEditBlock = false;
      }
      const inpAutoSendDelay = this.modalConfig.querySelector('.input-autosend-delay');
      localStorage.setItem('_autosend_delay', inpAutoSendDelay.value);
      this.builder.autoSendDelay = inpAutoSendDelay.value;
      const inpCommandLang = this.modalConfig.querySelector('.input-command-lang');
      localStorage.setItem('_command_lang', inpCommandLang.value);
      this.builder.speechRecognitionLang = inpCommandLang.value;
      this.builder.hideModal(this.modalConfig);
    });
    const btnConfigReset = this.modalConfig.querySelector('.input-reset');
    btnConfigReset.addEventListener('click', () => {
      this.resetConfig();
    });
    const valTemp = this.modalConfig.querySelector('.val-temp');
    const tempSlider = this.modalConfig.querySelector('.temperature-slider');
    tempSlider.oninput = () => {
      valTemp.innerHTML = tempSlider.value;
    };
    const valTopP = this.modalConfig.querySelector('.val-top-p');
    const topPSlider = this.modalConfig.querySelector('.top-p-slider');
    topPSlider.oninput = () => {
      valTopP.innerHTML = topPSlider.value;
    };
    btnCommandList.addEventListener('click', () => {
      let htmlList = '';
      let commandInfo;
      if (this.builder.isContentBox) {
        if (this.builder.canvas) {
          commandInfo = this.builder.commandInfoCanvasMode;
        } else {
          commandInfo = this.builder.commandInfo;
        }
      } else {
        if (this.builder.canvas) {
          commandInfo = this.builder.commandInfoCanvasMode;
        } else {
          commandInfo = this.builder.commandInfo;
        }
      }
      let bImageGeneration = false;
      if (this.builder.textToImageUrl) {
        bImageGeneration = true;
      }
      for (const key in commandInfo) {
        if (Object.prototype.hasOwnProperty.call(commandInfo, key)) {
          if (key !== 'image' || key === 'image' && bImageGeneration) {
            const {
              title,
              description,
              list,
              width
            } = commandInfo[key];
            if (!this.builder.enableShortCommands) {
              if (description) {
                htmlList += `<h2>${title}</h2>`;
                htmlList += `<p>${description}</p>`;
              } else {
                htmlList += `<h2 style="margin-bottom:30px">${title}</h2>`;
              }
              for (const item of list) {
                if (width) htmlList += `<div role="button" tabindex="0" class="command-item" style="width:${width}">${item}</div>`;else htmlList += `<div role="button" tabindex="0" class="command-item">${item}</div>`;
              }
            } else {
              htmlList += `<h2>${title}</h2>`;
              for (const item of list) {
                if (width) htmlList += `<div role="button" tabindex="0" class="command-item" style="width:${width}">${item}</div>`;else htmlList += `<div role="button" tabindex="0" class="command-item">${item}</div>`;
              }
            }
          }
        }
      }
      const divCommandList = this.modalCommandList.querySelector('.div-command-list');
      divCommandList.innerHTML = htmlList;
      const handleSelect = s => {
        const inpCommand = this.builderStuff.querySelector('.inp-command');
        inpCommand.value = s;
        this.builder.commandText = inpCommand.value;
        util.hideModal(this.modalCommandList);
      };
      let items = this.modalCommandList.querySelectorAll('.command-item');
      items.forEach(elm => {
        elm.addEventListener('click', () => {
          handleSelect(elm.innerText);
          inpCommand.focus();
        });
        elm.addEventListener('keydown', e => {
          if (e.which === 13 && !e.shiftKey) {
            e.preventDefault();
            e.stopImmediatePropagation();
            handleSelect(elm.innerText);
            setTimeout(() => {
              inpCommand.focus();
            }, 300);
          }
        });
      });
      util.showModal(this.modalCommandList, false, () => {
        btnCommandList.removeAttribute('data-focus');
        btnCommandList.focus();
      }, false);
      btnCommandList.setAttribute('data-focus', true);
    });
    btnDictation.addEventListener('click', () => {
      if (!this.checkMic()) {
        this.startDictation();
        btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone"></use></svg>';
        localStorage.setItem('_mic', '1');
        chkAutoSend.parentNode.style.display = 'flex';
      } else {
        this.stopDictation();
        btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
        localStorage.setItem('_mic', '0');
        chkAutoSend.parentNode.style.display = 'none';
      }
    });
    chkAutoSend.addEventListener('change', () => {
      if (chkAutoSend.checked) {
        this.builder.autoSendCommand = true;
        localStorage.setItem('_autosendcommand', '1');
      } else {
        this.builder.autoSendCommand = false;
        localStorage.setItem('_autosendcommand', '0');
      }
    });
    btnClear.addEventListener('click', () => {
      const inpCommand = this.builderStuff.querySelector('.inp-command');
      this.builder.commandText = '';
      inpCommand.value = '';
      inpCommand.focus();
    });
    const btnSend = builderStuff.querySelector('.cmd-send-command');
    btnSend.addEventListener('click', async () => {
      if (this.builder.isInProgress) {
        // Abort

        this.opts.abort();
        const inpCommand = this.builderStuff.querySelector('.inp-command');
        this.builder.commandText = inpCommand.value;
        return;
      }
      const inpCommand = this.modalCommand.querySelector('.inp-command');
      let question = inpCommand.value;
      question = question.trim();
      if (question === '') {
        return;
      }

      // this.startSending();

      // Clear
      this.builder.commandText = '';
      this.opts.send(question);
    });
    inpCommand.addEventListener('keydown', e => {
      if (e.keyCode === 13 && !e.shiftKey) {
        e.preventDefault();
        return;
      }
    });
    inpCommand.addEventListener('keyup', e => {
      if (e.keyCode === 13 && !e.shiftKey) {
        btnSend.click();
        e.preventDefault();
        return;
      }
      this.builder.commandText = inpCommand.value;
    });
    const btnClose = this.modalCommand.querySelector('.is-modal-close');
    btnClose.addEventListener('click', () => {
      this.modalCommand.classList.remove('active');
      this.stopDictation();
      localStorage.setItem('_dictation', '0');
    });
    const btnScopeSection = this.modalCommand.querySelector('.scope-section');
    const btnScopeBlock = this.modalCommand.querySelector('.scope-block');
    const btnScopeOthers = this.modalCommand.querySelector('.scope-others');
    const btnScopeImage = this.modalCommand.querySelector('.scope-image');
    btnScopeBlock.disabled = true;
    if (this.builder.textToImageUrl && !this.builder.hideImageGeneration) btnScopeImage.style.display = ''; // show generate image button

    const assistModeBtns = modalCommand.querySelectorAll('.div-assistant-mode button');
    assistModeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        assistModeBtns.forEach(item => {
          item.classList.remove('on');
        });
        btn.classList.add('on');
        const val = btn.getAttribute('data-value');
        this.builder.assistantMode = val; // general, block, others, image

        if (this.builder.hidePlaceholder) {
          inpCommand.setAttribute('placeholder', '');
        } else {
          if (val === 'general') {
            inpCommand.setAttribute('placeholder', this.builder.commandPlaceholders.general || '');
          } else if (val === 'block') {
            inpCommand.setAttribute('placeholder', this.builder.commandPlaceholders.edit_block || '');
          } else if (val === 'others') {
            inpCommand.setAttribute('placeholder', this.builder.commandPlaceholders.ask_questions || '');
          } else if (val === 'image') {
            inpCommand.setAttribute('placeholder', this.builder.commandPlaceholders.generate_image || '');
          }
        }

        /*
        // ContentBox
        if(val==='general') {
            if(!this.builder.activeCol) return;
            const box = this.builder.activeCol.closest('.is-box');
            const section = this.builder.activeCol.closest('.is-section');
            const wrapper = this.builder.activeCol.closest('.is-wrapper');
             if(!(box && section && wrapper)) return;
            
            box.click();
            
            if(!wrapper.classList.contains('hard-select')) box.click();
        }
        */
      });
    });

    //Extend onSelectionChange 
    let old = this.builder.settings.onSelectionChange;
    this.builder.settings.onSelectionChange = () => {
      if (old) old.call(this); // call user's defined onRender

      if (this.builder.activeCol) {
        if (this.builder.autoEditBlock && this.builder.autoEditBlock !== '0') {
          // change
          this.builder.assistantMode = 'block';
          btnScopeBlock.classList.add('on');
          btnScopeSection.classList.remove('on');
          btnScopeOthers.classList.remove('on');
          btnScopeImage.classList.remove('on');
        }
        btnScopeBlock.removeAttribute('disabled');
      } else {
        btnScopeBlock.disabled = true;
        if (btnScopeOthers.classList.contains('on')) return;
        if (btnScopeImage.classList.contains('on')) return;

        // change
        this.builder.assistantMode = 'general';
        btnScopeSection.classList.add('on');
        btnScopeBlock.classList.remove('on');
        btnScopeOthers.classList.remove('on');
        btnScopeImage.classList.remove('on');
      }
    };
    this.initialStart = false; // for Safari
  }

  resetConfig() {
    const tempSlider = this.modalConfig.querySelector('.temperature-slider');
    const valTemp = this.modalConfig.querySelector('.val-temp');
    tempSlider.value = this.builder.temperature;
    valTemp.innerHTML = this.builder.temperature;
    const topPSlider = this.modalConfig.querySelector('.top-p-slider');
    const valTopP = this.modalConfig.querySelector('.val-top-p');
    topPSlider.value = this.builder.topP;
    valTopP.innerHTML = this.builder.topP;
  }
  config() {
    this.builder.showModal(this.modalConfig, false);
    const tempSlider = this.modalConfig.querySelector('.temperature-slider');
    const valTemp = this.modalConfig.querySelector('.val-temp');
    if (localStorage.getItem('_temp') !== null) {
      let val = localStorage.getItem('_temp');
      tempSlider.value = val;
      valTemp.innerHTML = val;
    } else {
      tempSlider.value = this.builder.temperature;
      valTemp.innerHTML = this.builder.temperature;
    }
    const topPSlider = this.modalConfig.querySelector('.top-p-slider');
    const valTopP = this.modalConfig.querySelector('.val-top-p');
    if (localStorage.getItem('_top_p') !== null) {
      let val = localStorage.getItem('_top_p');
      topPSlider.value = val;
      valTopP.innerHTML = val;
    } else {
      topPSlider.value = this.builder.topP;
      valTopP.innerHTML = this.builder.topP;
    }
    const chkAutoEditBlock = this.modalConfig.querySelector('#chkAutoEditBlock');
    if (localStorage.getItem('_auto_editblock') !== null) {
      let val = localStorage.getItem('_auto_editblock');
      if (val === '1') {
        chkAutoEditBlock.checked = true;
      } else {
        chkAutoEditBlock.checked = false;
      }
    } else {
      chkAutoEditBlock.checked = this.builder.autoEditBlock;
    }
    const inpAutoSendDelay = this.modalConfig.querySelector('.input-autosend-delay');
    if (localStorage.getItem('_autosend_delay') !== null) {
      let val = localStorage.getItem('_autosend_delay');
      inpAutoSendDelay.value = val;
    } else {
      inpAutoSendDelay.value = this.builder.autoSendDelay;
    }
    const inpCommandLang = this.modalConfig.querySelector('.input-command-lang');
    if (localStorage.getItem('_command_lang') !== null) {
      let val = localStorage.getItem('_command_lang');
      inpCommandLang.value = val;
    } else {
      inpCommandLang.value = this.builder.speechRecognitionLang;
    }
  }
  checkMic() {
    if (localStorage.getItem('_mic') !== null) {
      if (localStorage.getItem('_mic') === '0') {
        return false;
      } else {
        return true;
      }
    } else {
      return true;
    }
  }
  doOpen() {
    this.builder.hidePlaceholder = false;
    const numeOfOpenToHidePlaceholderText = 4;
    if (localStorage.getItem('_ai_panel_open') === null) {
      localStorage.setItem('_ai_panel_open', 1);
    } else {
      let count = parseInt(localStorage.getItem('_ai_panel_open'));
      if (count < numeOfOpenToHidePlaceholderText) {
        count++;
        localStorage.setItem('_ai_panel_open', count);
      }
    }
    const inpCommand = this.builderStuff.querySelector('.inp-command');
    if (localStorage.getItem('_ai_panel_open') === `${numeOfOpenToHidePlaceholderText}`) {
      this.builder.hidePlaceholder = true;
      inpCommand.setAttribute('placeholder', '');
    } else {
      if (!this.builder.commandPlaceholders) {
        this.builder.commandPlaceholders = {};
        this.builder.commandPlaceholders.general = '';
      }
      inpCommand.setAttribute('placeholder', this.builder.commandPlaceholders.general || '');
    }
  }
  openDictation() {
    if (this.builder.showDisclaimer) {
      if (localStorage.getItem('_disclaimershown') === null) {
        this.builder.util.showModal(this.modalDisclaimer, true, () => {
          this.openDictation_();
        }, true);
        const btnOk = this.modalDisclaimer.querySelector('.input-ok');
        btnOk.focus();
        setTimeout(() => {
          // Needed if opens programmatically on builder start (wait until all loaded)
          const btnOk = this.modalDisclaimer.querySelector('.input-ok');
          btnOk.focus();
        }, 600);
        localStorage.setItem('_disclaimershown', true);
      } else {
        this.openDictation_();
      }
    } else {
      this.openDictation_();
    }
  }
  openDictation_() {
    this.doOpen();
    const inpCommand = this.modalCommand.querySelector('.inp-command');
    if (this.modalCommand.classList.contains('active')) {
      setTimeout(() => {
        // Needed if opens programmatically on builder start (wait until all loaded)
        inpCommand.focus();
      }, 600);
      return;
    }
    this.modalCommand.classList.add('active');
    inpCommand.focus();
    localStorage.setItem('_dictation', '1');
    const chkAutoSend = this.builderStuff.querySelector('#chkAutoSendCommand');
    if (this.checkMic()) {
      // Do Nothing
      chkAutoSend.parentNode.style.display = 'flex';
    } else {
      const btnDictation = this.builderStuff.querySelector('.cmd-enable-dictation');
      btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
      chkAutoSend.parentNode.style.display = 'none';
      return;
    }
    this.startDictation();
  }
  stopDictation() {
    if (this.recognition) this.recognition.abort();
    this.aborted = true;

    // Using RecordRTC
    // if(this.recorder) this.recorder.stopRecording(); 
    // if(this.localStream) this.localStream.getAudioTracks().forEach(track => {
    //     track.stop();
    // });

    if (this.builder.useMediaRecorder) {
      // Using mediaRecorder
      if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
        this.mediaRecorder.stop();
        this.localStream.getTracks().forEach(track => track.stop()); // Stop the tracks to release the resources
      }
    } /* else {
        // Using Recorder
        if(this.recorder) this.recorder.stop();
        if(this.localStream) this.localStream.getTracks().forEach(track => track.stop()); // Stop the tracks to release the resources
      } */

    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.close();
    }
  }
  async startDictation() {
    const inpCommand = this.modalCommand.querySelector('.inp-command');
    if (this.builder.onlineDemo) {
      setTimeout(() => {
        const btnDictation = this.builderStuff.querySelector('.cmd-enable-dictation');
        const chkAutoSend = this.builderStuff.querySelector('#chkAutoSendCommand');
        this.stopDictation();
        btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
        localStorage.setItem('_mic', '0');
        chkAutoSend.parentNode.style.display = 'none';
      }, 1); // to give delay from the btnDictation click

      //Show info
      this.util.showMessage(this.util.out('Speech recognition is disabled in this online demo. You can type your command/prompt in the textbox.'), true, () => {
        inpCommand.focus();
      });
      return;
    }
    if (this.builder.speechTranscribeUrl) {
      this.websocket = new WebSocket(this.builder.speechTranscribeUrl);
      try {
        this.localStream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
      } catch (e) {
        setTimeout(() => {
          const btnDictation = this.builderStuff.querySelector('.cmd-enable-dictation');
          const chkAutoSend = this.builderStuff.querySelector('#chkAutoSendCommand');
          this.stopDictation();
          btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
          localStorage.setItem('_mic', '0');
          chkAutoSend.parentNode.style.display = 'none';
        }, 1); // to give delay from the btnDictation click

        //Show info
        this.util.showMessage(this.util.out('No microphone found. Please activate your microphone and refresh the page.'));
        return;
      }
      const sampleRate = 16000;
      if (this.builder.useMediaRecorder) {
        // Using mediaRecorder
        navigator.mediaDevices.getUserMedia({
          audio: {
            sampleSize: 16,
            channelCount: 1,
            sampleRate: sampleRate
          }
        }).then(stream => {
          this.localStream = stream;
          this.mediaRecorder = new MediaRecorder(stream);
          this.mediaRecorder.addEventListener('dataavailable', event => {
            if (this.aborted) return;
            this.websocket.send(event.data);
          });

          // this.mediaRecorder.start(1000);
        }).catch(error => {
          console.log(error);
        });
      } /* else {
           // Using Recorder
          this.recorder = new Recorder({
              encoderPath: this.builder.encoderPath||
                  'https://cdnjs.cloudflare.com/ajax/libs/opus-recorder/8.0.5/encoderWorker.min.js',
              leaveStreamOpen: true,
              numberOfChannels: 1,
                           // OPUS options
              encoderSampleRate: sampleRate,
              streamPages: true,
              maxBuffersPerPage: 1,
          });
          this.recorder.ondataavailable = (e) => {
              if(this.aborted) return;
              this.websocket.send(e.buffer);
          };
        } */

      /*
      // Using RecordRTC
      this.recorder = new RecordRTC(this.localStream, {
          type: 'audio',
          // mimeType: 'audio/webm',
          // bufferSize: 16384,
          desiredSampRate: sampleRate,
          numberOfAudioChannels: 1,
          timeSlice: 1000,
          ondataavailable: (blob) => {
              this.websocket.send(blob);
          }
      });
      */

      const isSafari = /constructor/i.test(window.HTMLElement) || function (p) {
        return p.toString() === '[object SafariRemoteNotification]';
      }(!window['safari'] || typeof safari !== 'undefined' && window['safari'].pushNotification);
      if (isSafari && !this.initialStart) {
        // for Safari
        this.stopDictation();
        this.initialStart = true;
        setTimeout(() => {
          this.startDictation();
        }, 2000);
      }
      this.builder.commandText = '';
      let finalTranscripts = '';
      let speechTimeout;
      this.websocket.onmessage = event => {
        const message = JSON.parse(event.data);
        if (message.event === 'can-open-mic') {
          //this.recorder.startRecording(); // Using RecordRTC

          if (this.builder.useMediaRecorder) {
            this.mediaRecorder.start(1000); // Using mediaRecorder
          } /* else {
              this.recorder.start(); // Using Recorder
            } */

          this.aborted = false;
        }
        if (message.event === 'transcript-result') {
          const transcript = message.data.channel.alternatives[0].transcript;

          // Actions
          const triggerWords = this.builder.triggerWords;
          const findMatchingTrigger = transcript => {
            transcript = transcript.toLowerCase();
            transcript = transcript.replace('.', '');
            for (const key in triggerWords) {
              if (triggerWords[key].some(word => transcript.includes(word))) {
                return key;
              }
              let result;
              triggerWords[key].forEach(word => {
                const similarity = this.builder.similarity.checkSimilarity(transcript, word);
                if (similarity > 0.5) {
                  result = key;
                  return;
                }
              });
              if (result) return result;
            }
            return null; // No match found
          };

          if (transcript && message.data.is_final) {
            const matchingKey = findMatchingTrigger(transcript);
            if (matchingKey) {
              if (matchingKey === 'send') {
                if (inpCommand.value.trim() === '') return;
                const btnSend = this.modalCommand.querySelector('.cmd-send-command');
                btnSend.click();
                return;
              } else if (matchingKey === 'abort') {
                if (this.builder.isInProgress) {
                  // Abort
                  this.opts.abort();
                  const inpCommand = this.builderStuff.querySelector('.inp-command');
                  this.builder.commandText = inpCommand.value;
                }
                return;
              } else if (matchingKey === 'clear') {
                this.builder.commandText = '';
                inpCommand.value = '';
                return;
              }
            }
          }
          if (this.builder.isInProgress || this.aborted) {
            return;
          }
          finalTranscripts = this.builder.commandText;
          if (transcript && message.data.is_final) {
            finalTranscripts += ' ' + transcript.trim();
          }

          // Format
          finalTranscripts = finalTranscripts.charAt(0).toUpperCase() + finalTranscripts.slice(1);
          finalTranscripts = finalTranscripts.trim();
          this.builder.commandText = finalTranscripts;
          if (transcript && message.data.is_final) {
            this.builder.commandText = finalTranscripts;
            inpCommand.value = finalTranscripts;
          }
          clearTimeout(speechTimeout);
          speechTimeout = setTimeout(() => {
            if (this.builder.autoSendCommand) {
              if (inpCommand.value.trim() === '') return;
              const btnSend = this.modalCommand.querySelector('.cmd-send-command');
              btnSend.click();
            }
          }, this.builder.autoSendDelay);
        }
      };
    } else {
      if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window || 'mozSpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition;
        this.recognition = new SpeechRecognition();
        this.recognition.continuous = true;
        this.recognition.interimResults = true;
        let lang = this.builder.speechRecognitionLang;
        this.recognition.lang = lang;
        this.recognition.start();

        // this.speechTimeout;

        this.builder.commandText = '';
        let finalTranscripts = '';
        this.recognition.onresult = event => {
          let transcript = '';
          for (var i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
              transcript = event.results[i][0].transcript;
            }
          }
          if (!transcript) return;

          // Actions
          const triggerWords = this.builder.triggerWords;
          const findMatchingTrigger = transcript => {
            transcript = transcript.toLowerCase();
            for (const key in triggerWords) {
              if (triggerWords[key].some(word => transcript.includes(word))) {
                return key;
              }
              let result;
              triggerWords[key].forEach(word => {
                const similarity = this.builder.similarity.checkSimilarity(transcript, word);
                if (similarity > 0.5) {
                  result = key;
                  return;
                }
              });
              if (result) return result;
            }
            return null; // No match found
          };

          const matchingKey = findMatchingTrigger(transcript);
          if (matchingKey) {
            if (matchingKey === 'send') {
              if (inpCommand.value.trim() === '') return;
              const btnSend = this.modalCommand.querySelector('.cmd-send-command');
              btnSend.click();
              return;
            } else if (matchingKey === 'abort') {
              if (this.builder.isInProgress) {
                // Abort
                this.opts.abort();
                const inpCommand = this.builderStuff.querySelector('.inp-command');
                this.builder.commandText = inpCommand.value;
              }
              return;
            } else if (matchingKey === 'clear') {
              this.builder.commandText = '';
              inpCommand.value = '';
              return;
            }
          }
          if (this.builder.isInProgress) {
            return;
          }
          finalTranscripts = this.builder.commandText;
          finalTranscripts += ' ' + transcript.trim();

          // Format
          finalTranscripts = finalTranscripts.trim();
          finalTranscripts = finalTranscripts.charAt(0).toUpperCase() + finalTranscripts.slice(1);
          this.builder.commandText = finalTranscripts;
          inpCommand.value = finalTranscripts;
          clearTimeout(this.speechTimeout);
          this.speechTimeout = setTimeout(() => {
            if (this.builder.autoSendCommand) {
              if (inpCommand.value.trim() === '') return;
              const btnSend = this.modalCommand.querySelector('.cmd-send-command');
              btnSend.click();
            }
          }, this.builder.autoSendDelay);
        };
        this.recognition.onend = () => {
          if (!this.aborted) this.startDictation();
        };
        this.recognition.onstart = () => {
          this.aborted = false;
        };
        this.recognition.onerror = e => {
          console.log(e.message);
        };
      } else {
        // See btnDictation click
        setTimeout(() => {
          const btnDictation = this.builderStuff.querySelector('.cmd-enable-dictation');
          const chkAutoSend = this.builderStuff.querySelector('#chkAutoSendCommand');
          this.stopDictation();
          btnDictation.innerHTML = '<svg class="is-icon-flex" style="width:18px; height:18px;"><use xlink:href="#icon-microphone-off"></use></svg>';
          localStorage.setItem('_mic', '0');
          chkAutoSend.parentNode.style.display = 'none';
        }, 1); // to give delay from the btnDictation click

        //Show info
        this.util.showMessage(this.util.out('Speech recognition not supported in this browser.'));
      }
    }
  }
  startSending() {
    const btnSend = this.modalCommand.querySelector('.cmd-send-command');
    btnSend.innerHTML = `
        <svg class="spinner" width="14px" height="14px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
            <circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
        </svg>
        <span style="margin-left:5px">${this.util.out('Abort')}</span>
        `;
    const ovl = this.builderStuff.querySelector('.page-command-overlay');
    if (ovl) ovl.style.display = 'flex';
    this.builder.isInProgress = true;
  }
  finish() {
    this.builder.isInProgress = false;
    const btnSend = this.modalCommand.querySelector('.cmd-send-command');
    btnSend.innerText = this.util.out('Send');
    const ovl = this.builderStuff.querySelector('.page-command-overlay');
    if (ovl) ovl.style.display = 'none';
  }
}

const contextBlockList = {
  new_section_with_list: `
To create a section with a list:
- Use the example below as a template.
- Replace all the text in the example with the requested content.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.
    
Example:

<div class="is-container v2 size-18 leading-12 is-content-1200">
    <div class="row">
        <div class="column">
            <h2 class="font-medium size-60">Title here</h2>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h3 class="size-28 font-normal">Point One</h3>
            <div class="spacer height-20"></div>
            <p>Paragraph content here</p>
        </div>
        <div class="column">
            <h3 class="size-28 font-normal">Point Two</h3>
            <div class="spacer height-20"></div>
            <p>Paragraph content here</p>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <div class="spacer height-40"></div>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <h3 class="size-28 font-normal">Point Three</h3>
            <div class="spacer height-20"></div>
            <p>Paragraph content here</p>
        </div>
        <div class="column">
            <h3 class="size-28 font-normal">Point Four</h3>
            <div class="spacer height-20"></div>
            <p>Paragraph content here</p>
        </div>
    </div>

</div>

`,
  new_section_with_list_numbering: [`
To create a section with a list and numbering:
- Use the example below as a template.
- Replace all the text in the example with the requested content.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.

Example:

<div class="is-container v2 leading-13 size-19 is-content-1540">
    <div class="row">
        <div class="xs-hidden column">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 50%; flex: 0 0 auto;">
            <h1 class="text-center tracking-tight size-50 leading-none">Title Here</h1>
        </div>
        <div class="xs-hidden column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-140"></div>
        </div>
    </div>
    <div class="row">
        <div class="column text-center">
            <p class="size-32 font-medium">1.</p>
            <h3 class="tracking-75 text-center size-21 font-normal">First Highlight</h3>
            <p class="text-center">Experience the power of innovative designs.</p>
        </div>
        <div class="column">
            <p class="size-32 font-medium text-center">2.</p>
            <h3 class="tracking-75 text-center size-21 font-normal">Second Highlight</h3>
            <p class="text-center">Discover the magic of exceptional creativity.</p>
        </div>
        <div class="column">
            <p class="text-center size-32 font-medium">3.</p>
            <h3 class="tracking-75 text-center size-21 font-normal">Third Highlight</h3>
            <p class="text-center">Unleash your imagination with outstanding designs.</p>
        </div>
    </div>
</div>

`, `
To create a section with a list and numbering:
- Use the example below as a template.
- Replace all the text in the example with the requested content.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.

Example:

<div class="is-container v2 is-content-1540 size-19 leading-13">
    <div class="row">
        <div class="column">
            <h1 class="tracking-tight size-50 text-left">Title Here</h1>
        </div>
        <div class="xs-hidden column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-120"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p class="size-76">01</p>
            <div class="spacer height-20"></div>
            <h3 class="size-24 leading-12 font-normal">First Highlight</h3>
            <p>Experience the power of innovative designs.&nbsp;</p>
        </div>
        <div class="column">
            <p class="size-76">02</p>
            <div class="spacer height-20"></div>
            <h3 class="size-24 leading-12 font-normal">Second Highlight</h3>
            <p>Discover the magic of exceptional creativity.&nbsp;</p>
        </div>
        <div class="column">
            <p class="size-76">03</p>
            <div class="spacer height-20"></div>
            <h3 class="size-24 leading-12 font-normal">Third Highlight</h3>
            <p>Unleash your imagination with outstanding designs.&nbsp;</p>
        </div>

    </div>
</div>

`],
  new_section_with_list_icons: `
To create a section with list icons:
- Use the example below as a template.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.
- Replace all the text in the example with the requested content.
        
Example:

<div class="is-container v2 leading-13 size-19 is-content-1540">
    <div class="row">
        <div class="xs-hidden column">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 50%; flex: 0 0 auto;">
            <h1 class="text-center tracking-tight size-50 leading-none">Title Here</h1>
        </div>
        <div class="xs-hidden column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="text-center">
                <i class="icon {{ICONCLASS}} size-32"></i>
            </div>
            <h3 class="tracking-75 text-center size-21 font-normal">Point One</h3>
            <p class="text-center">Paragraph content here</p>
        </div>
        <div class="column">
            <div class="text-center">
                <i class="icon {{ICONCLASS}} size-32"></i>
            </div>
            <h3 class="tracking-75 text-center size-21 font-normal">Point Two</h3>
            <p class="text-center">Paragraph content here</p>
        </div>
        <div class="column">
            <div class="text-center">
                <i class="icon {{ICONCLASS}} size-32"></i>
            </div>
            <h3 class="tracking-75 text-center size-21 font-normal">Point Three</h3>
            <p class="text-center">Paragraph content here</p>
        </div>
    </div>
</div>

- Important: for icons, replace {{ICONCLASS}} with 'ion-checkmark'.

`,
  new_section_with_list_images: `
To create a section with a list of photos or a photo gallery:
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.
    
Example:
    
<div class="is-container v2 size-19 leading-13 content-pt-60 content-pb-60 is-content-1300">
    <div class="row">
        <div class="column">
            <h1 class="tracking-tight size-50 text-center">Title Here</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row relative sm-items-1">
        <div class="column flex flex-col justify-center items-start py-2">
            <h2 class="font-normal leading-none size-32">Item One</h2>

            <p>At our web studio, we combine our passion for design, technology, and innovation to build stunning and functional websites that make your brand stand out in the digital world.</p>
        </div>
        <div class="column" style="width: 5%; flex: 0 0 auto;">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 53%; flex: 0 0 auto;">
            <img src="{{IMAGEURL}}" alt="">
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-100"></div>
        </div>
    </div>
    <div class="row relative sm-items-1">
        <div class="column" style="width: 53%; flex: 0 0 auto;">
            <img src="{{IMAGEURL}}" alt="">
        </div>
        <div class="column" style="width: 5%; flex: 0 0 auto;">
            <div class="spacer height-60"></div>
        </div>
        <div class="column flex flex-col justify-center items-start py-2" style="width: 41.9836%; flex: 0 0 auto;">
            <h2 class="font-normal leading-none size-32">Item Two</h2>

            <p>At our web studio, we combine our passion for design, technology, and innovation to build stunning and functional websites that make your brand stand out in the digital world.</p>
        </div>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  new_section_with_image: `
To create a section: 
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example:

<div class="is-container v2 is-content-1500 size-19 leading-13">
    <div class="row relative sm-items-1">
        <div class="column flex flex-col justify-center items-start py-2">
            <h1 class="font-normal leading-none size-60">Empowering businesses with AI-integrated web solutions.</h1>
            <div class="spacer height-40"></div>
            <p>We are a full-stack web development studio that brings the power of Artificial Intelligence into our web solutions.</p>

            <div class="spacer height-20"></div>

            <div>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mb-1 py-2 size-18 px-9 text-black leading-relaxed rounded-full border-transparent hover:border-transparent font-normal tracking-wide mt-3" title="" style="background-color: rgb(240, 240, 240);">Our Works</a>
                <a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mb-1 py-2 size-18 px-9 border-current hover:border-current font-normal leading-relaxed rounded-full tracking-wide mt-3" title="">Get in Touch</a>
            </div>
        </div>
        <div class="column" style="width: 5%; flex: 0 0 auto;">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 53%; flex: 0 0 auto;">
            <img src="{{IMAGEURL}}" alt="">
        </div>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  new_section_with_gallery: `
To create a section with a list of photos or a photo gallery:
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example:

<div class="is-container v2 leading-13 is-content-1640 size-16">
    <div class="row">
        <div class="column">
            <h1 class="font-light size-54 leading-none">We deliver extraordinary things.</h1>
        </div>
        <div class="column">
            <div class="spacer height-40"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
    <div class="row">
        <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-024.jpg">
            <h3 class="font-normal leading-11 size-36 size-24">Image title</h3>
            <p>Paragraph here</p>
        </div>
        <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-083.jpg">
            <h3 class="font-normal leading-11 size-36 size-24">Image title</h3>
            <p>Paragraph here</p>
        </div>
        <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-190.jpg">
            <h3 class="font-normal leading-11 size-36 size-24">Image title</h3>
            <p>Paragraph here</p>
        </div>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  new_section: [`
To create a section: 
- Use the example below as a template.
- Replace all the text in the example with the requested content.

Example:

<div class="is-container v2 leading-13 size-19 is-content-800 is-content-left edge-x-2">
    <div class="row">
        <div class="column">
            <h1 class="font-normal leading-11 size-64">A forward thinking studio delivering digital solutions that help your business.</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.</p>
        </div>
    </div>
</div>

`],
  short_content: `This is the template:

<div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <p class="size-32">{{CONTENT}}</p>
        </div>
    </div>
</div>
    
`,
  new_section_answer: `This is the template:

<div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="font-normal leading-11 size-64">{{TITLE}}</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>{{CONTENT}}</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h2>{{SUBTITLE}}</h2>
            <p>{{CONTENT}}</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h2>{{SUBTITLE}}</h2>
            <p>{{CONTENT}}</p>
        </div>
    </div>
</div>

`,
  new_section_others: `Use one of these templates that is more suitable:


Template 1: (Suitable for one short paragraph content, a tweet, quick information.)

    <div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
        <div class="row">
            <div class="column">
                <p class="size-32">{{CONTENT}}</p>
            </div>
        </div>
    </div>

Template 2: (Suitable for short content with a title and paragraph content. Ensure that there is a space between the title and the content.)

    <div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
        <div class="row">
            <div class="column">
                <h1 class="font-normal leading-11 size-64">{{TITLE}}</h1>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-20"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <p>{{CONTENT}}</p>
            </div>
        </div>
    </div>


Template 3:  (Suitable for long content with multiple subtopics. Ensure that there is a space between subtopics.)

    <div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
        <div class="row">
            <div class="column">
                <h1 class="font-normal leading-11 size-64">{{TITLE}}</h1>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-20"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <p>{{CONTENT}}</p>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-20"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <h2>{{SUBTITLE}}</h2>
                <p>{{CONTENT}}</p>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-20"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <h2>{{SUBTITLE}}</h2>
                <p>{{CONTENT}}</p>
            </div>
        </div>
    </div>

`,
  // same as new_section_others (Ensure that there is a space between subtopics.)
  new_section_article: [`This is the template:

<div class="is-container v2 leading-13 size-19 is-content-800 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="font-normal leading-11 size-64">{{TITLE}}</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>{{CONTENT}}</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h2>{{SUBTITLE}}</h2>
            <p>{{CONTENT}}</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h2>{{SUBTITLE}}</h2>
            <p>{{CONTENT}}</p>
        </div>
    </div>
</div>
                
`],
  new_section_article_with_image: [`To create a section: 
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example:

<div class="is-container v2 leading-13 size-19 is-content-800 content-pt-50 content-pb-50">
    <div class="row">
        <div class="column">
            <h1 class="font-normal leading-11 size-64">Title here</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <img src="{{IMAGEURL}}" alt="">
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.</p>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <h2 class="size-28 font-normal">Sub Topic Title here</h2>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-20"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.</p>
        </div>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`, `
To create a section: 
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example:

<div class="is-container v2 leading-13 size-19 is-content-1100">
    <div class="row">
        <div class="column">
            <h1 class="font-normal leading-none size-60">A forward thinking studio delivering digital solutions that help your business<br></h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
        <div class="column" style="width: 75%; flex: 0 0 auto;"><img src="{{IMAGEURL}}" alt=""></div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column" style="width: 75%; flex: 0 0 auto;">
            <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
                when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
        </div>
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-40"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
        <div class="column" style="width: 75%; flex: 0 0 auto;">
            <h2 class="size-28 font-normal">Sub Topic 1</h2>
            <div class="spacer height-20"></div>
            <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
                when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-40"></div>
        </div>
    </div>
    <div class="row">
        <div class="column" style="width: 75%; flex: 0 0 auto;">
            <h2 class="size-28 font-normal">Sub Topic 2</h2>
            <div class="spacer height-20"></div>
            <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
                when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
        </div>
        <div class="column">
            <div class="spacer height-80"></div>
        </div>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`],
  redesign_layout2: [`To redesign the provided section:
- Decide the best placement of each content element (title, paragraph, images, etc) and change the position based on the template below.

This is the template:

<div class="is-container v2 is-content-1400 size-19 leading-13 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 60%; flex: 0 0 auto;">
            <h1 class="leading-09 size-116 font-extrabold">{{TITLE}}</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column" style="width: 65%; flex: 0 0 auto;">
            <p>{{CONTENT}}</p>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
        <div class="column" style="width: 65%; flex: 0 0 auto;">
            <p>{{CONTENT}}</p>
        </div>
    </div>
</div>

`, `To redesign the provided section:
- Decide the best placement of each content element (title, paragraph, images, etc) and change the position based on the template below.
- You must update the title class with 'tracking-tight leading-09 size-120 font-normal'.
    
This is the template:
    
<div class="is-container v2 leading-14 size-19 content-pt-60 content-pb-60 is-content-1200">
    <div class="row">
        <div class="column">
            <h1 class="tracking-tight leading-09 size-120 font-normal">{{Place title here}}</h1>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <p>{{CONTENT}}</p>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
        <div class="column">
            <p>{{CONTENT}}</p>
        </div>
        <div class="column">
            <p>{{CONTENT}}</p>
        </div>
    </div>
</div>

Important: include all images from the original section in the returned result!

`],
  redesign_layout: [/* 1 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 leading-14 is-content-1100 size-18 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-54 font-medium leading-none">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 2 */

  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 is-content-1100 size-18 leading-13 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-116 font-medium leading-09">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 3 (very good) */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 is-content-1100 size-18 leading-13 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-76 font-normal leading-none">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 4 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

    <div class="is-container v2 h-full flex flex-col justify-between size-19 leading-none is-content-1000 content-pt-60 content-pb-60">
        <div class="row">
            <div class="column">
                <h1 class="uppercase size-72 font-semibold leading-09">{{TITLE}}</h1>
            </div>
            <div class="column">
                <div class="spacer height-60"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-60"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                {{CONTENT}}
            </div>
            <div class="column">
                {{CONTENT}}
            </div>
        </div>
        <div class="row">
            <div class="column">
                <div class="spacer height-60"></div>
            </div>
        </div>
        <div class="row">
            <div class="column">
                {{CONTENT}}
            </div>
            <div class="column">
                {{CONTENT}}
            </div>
            <div class="column">
                {{CONTENT}}
            </div>
        </div>
    </div>

`, /* 5 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 leading-13 size-18 is-content-1000 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-76 font-normal leading-none">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 6 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 size-18 leading-12 is-content-1000 is-content-left edge-x-1">
    <div class="row">
        <div class="column">
            <h1 class="text-left size-64 font-medium leading-none tracking-tight">{{TITLE}}</h1>
            <p style="border-bottom: 2px solid #333; width: 80px;"></p>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 7 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 is-content-1300 size-18 leading-13 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-88 font-medium leading-09">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 08 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 is-content-1100 leading-12 size-19 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-68 font-normal leading-09 tracking-tighter">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 09 (very good) */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 is-content-1000 size-19 leading-12 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-68 font-normal leading-none tracking-tighter">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 10 (very good) */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 size-17 is-content-1000 leading-12 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="size-76 font-normal leading-09">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`, /* 11 */
  `Re-arrange the placement of the title, paragraph, spaces, or images based the grid template below.
Feel free to change the layout to create a visually appealing design and enhance readability. 
Important: group all image columns together in a single row.

This is the template:

<div class="is-container v2 h-full flex flex-col justify-between size-19 leading-none is-content-1000 content-pt-60 content-pb-60">
    <div class="row">
        <div class="column">
            <h1 class="uppercase size-84 font-normal leading-09">{{TITLE}}</h1>
        </div>
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="spacer height-60"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
        <div class="column">
            {{CONTENT}}
        </div>
    </div>
</div>

`],
  update_section_with_image: `To add a headline or paragraph and an image, follow these steps:
- Create the necessary rows and columns.
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example:

<div class="row relative sm-items-1">
    <div class="column flex flex-col justify-center items-start py-2">
        <h1 class="font-normal leading-none size-60">Empowering businesses with AI-integrated web solutions.</h1>
        <div class="spacer height-40"></div>
        <p>We are a full-stack web development studio that brings the power of Artificial Intelligence into our web solutions.</p>
    </div>
    <div class="column" style="width: 5%; flex: 0 0 auto;">
        <div class="spacer height-60"></div>
    </div>
    <div class="column" style="width: 53%; flex: 0 0 auto;">
        <img src="{{IMAGEURL}}" alt="">
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  update_section_with_gallery: `To add a list of photos or a photo gallery, follow these steps:
- Create the necessary rows and columns.
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Replace all the text in the example with the requested content.

Example :

<div class="row">
    <div class="column">
        <h1 class="font-light size-54 leading-none">We deliver extraordinary things.</h1>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>
<div class="row">
    <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-024.jpg">
        <p>Image Caption</p>
    </div>
    <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-083.jpg">
        <p>Image Caption</p>
    </div>
    <div class="column"><img src="{{IMAGEURL}}" alt="" data-filename="img-190.jpg">
        <p>Image Caption</p>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  update_section_with_list: `To add a list, follow these steps:
- Create the necessary rows and columns.
- Use the example below as a template.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.
- Each list item has <h3> as item title. Use example below.
- Replace all the text in the example with the requested content.

Example:

<div class="row">
    <div class="column">
        <h2 class="font-medium size-60">List Title</h2>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <h3 class="size-28 font-normal">List Item 1</h3>
        <div class="spacer height-20"></div>
        <p>Experience the power and flexibility of our innovative cloud solutions that can transform your business.
            With our expertise, you can stay one step ahead of your competition in a rapidly changing digital landscape.</p>
    </div>
    <div class="column">
        <h3 class="size-28 font-normal">List Item 2</h3>
        <div class="spacer height-20"></div>
        <p>Leave your IT operations to us and focus on what really matters - your core business.
            Our managed IT services enable you to optimize your technology infrastructure and improve efficiency,
            ensuring smooth operations and maximum productivity.</p>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-40"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <h3 class="size-28 font-normal">List Item 3</h3>
        <div class="spacer height-20"></div>
        <p>No matter the size of your organization, we have the network solutions you need to optimize your connectivity
            and ensure reliable and secure communication. Our experts will design and implement a tailored network infrastructure,
            keeping your business connected and functioning seamlessly.</p>
    </div>
    <div class="column">
        <h3 class="size-28 font-normal">List Item 4</h3>
        <div class="spacer height-20"></div>
        <p>Our support and consulting services are designed to provide you with the expertise and guidance you need
            to overcome any technology challenges you may face. From troubleshooting to strategic planning,
            our team of professionals is here to assist you every step of the way.</p>
    </div>
</div>

`,
  update_section_with_list_images: `To add a list with images, follow these steps:
- Create the necessary rows and columns.
- Use the example below as a template.
- Images must use this image URL: '{{_IMAGEURL}}'. Replace the {{IMAGEURL}} with this URL.
- Each list item has <h3> as item title.
- Replace all the text in the example with the requested content.
    
Example result (Use it as the template):
    
<div class="row">
    <div class="column">
        <h2 class="tracking-tight size-50 text-center">Title Here</h2>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-100"></div>
    </div>
</div>
<div class="row relative sm-items-1">
    <div class="column flex flex-col justify-center items-start py-2">
        <h3 class="font-normal leading-none size-32">Item One</h3>

        <p>At our web studio, we combine our passion for design, technology, and innovation to build stunning and functional websites that make your brand stand out in the digital world.</p>
    </div>
    <div class="column" style="width: 5%; flex: 0 0 auto;">
        <div class="spacer height-60"></div>
    </div>
    <div class="column" style="width: 53%; flex: 0 0 auto;">
        <img src="{{IMAGEURL}}" alt="">
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-100"></div>
    </div>
</div>
<div class="row relative sm-items-1">
    <div class="column" style="width: 53%; flex: 0 0 auto;">
        <img src="{{IMAGEURL}}" alt="">
    </div>
    <div class="column" style="width: 5%; flex: 0 0 auto;">
        <div class="spacer height-60"></div>
    </div>
    <div class="column flex flex-col justify-center items-start py-2" style="width: 41.9836%; flex: 0 0 auto;">
        <h3 class="font-normal leading-none size-32">Item Two</h3>

        <p>At our web studio, we combine our passion for design, technology, and innovation to build stunning and functional websites that make your brand stand out in the digital world.</p>
    </div>
</div>

- Important: for images, replace {{IMAGEURL}} with '{{_IMAGEURL}}'.

`,
  update_section_with_list_icons: `To add a list with icons, follow these steps:
- Create the necessary rows and columns.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.
- Use the example below as a template.
- Each list item has <h3> as item title.
- Replace all the text in the example with the requested content.

Example:

<div class="row">
    <div class="column">
        <h1 class="text-center tracking-tight size-50 leading-none">Title Here</h1>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="text-center">
            <i class="icon {{ICONCLASS}} size-32"></i>
        </div>
        <h3 class="tracking-75 text-center size-21 font-normal">Point One</h3>
        <p class="text-center">Paragraph content here</p>
    </div>
    <div class="column">
        <div class="text-center">
            <i class="icon {{ICONCLASS}} size-32"></i>
        </div>
        <h3 class="tracking-75 text-center size-21 font-normal">Point Two</h3>
        <p class="text-center">Paragraph content here</p>
    </div>
    <div class="column">
        <div class="text-center">
            <i class="icon {{ICONCLASS}} size-32"></i>
        </div>
        <h3 class="tracking-75 text-center size-21 font-normal">Point Three</h3>
        <p class="text-center">Paragraph content here</p>
    </div>
</div>

- Important: for icons, replace {{ICONCLASS}} with 'ion-checkmark'.

`,
  // INFO: The {{ICONCLASS}} replacement works well. No processing required.

  update_section_with_list_numbering: [`To add a list and numbering:
- Create the required rows and column and add them inside the current 'div.is-container'.
- Replace all the text in the example with the requested content.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.

Example:

<div class="row">
    <div class="xs-hidden column">
        <div class="spacer height-60"></div>
    </div>
    <div class="column" style="width: 50%; flex: 0 0 auto;">
        <h1 class="text-center tracking-tight size-50 leading-none">Title Here</h1>
    </div>
    <div class="xs-hidden column">
        <div class="spacer height-60"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-140"></div>
    </div>
</div>
<div class="row">
    <div class="column text-center">
        <p class="size-32 font-medium">1.</p>
        <h3 class="tracking-75 text-center size-21 font-normal">First Highlight</h3>
        <p class="text-center">Experience the power of innovative designs.</p>
    </div>
    <div class="column">
        <p class="size-32 font-medium text-center">2.</p>
        <h3 class="tracking-75 text-center size-21 font-normal">Second Highlight</h3>
        <p class="text-center">Discover the magic of exceptional creativity.</p>
    </div>
    <div class="column">
        <p class="text-center size-32 font-medium">3.</p>
        <h3 class="tracking-75 text-center size-21 font-normal">Third Highlight</h3>
        <p class="text-center">Unleash your imagination with outstanding designs.</p>
    </div>
</div>

`, `To add a list and numbering:
- Create the required rows and column and add them inside the current 'div.is-container'.
- Replace all the text in the example with the requested content.
- For 3 list items, use 3 columns in a row. For 2 or 4 list items, use 2 columns per row.

Example:

<div class="row">
    <div class="column">
        <h1 class="tracking-tight size-50 text-left">Title Here</h1>
    </div>
    <div class="xs-hidden column">
        <div class="spacer height-60"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-120"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <p class="size-76">01</p>
        <div class="spacer height-20"></div>
        <h3 class="size-24 leading-12 font-normal">First Highlight</h3>
        <p>Experience the power of innovative designs.&nbsp;</p>
    </div>
    <div class="column">
        <p class="size-76">02</p>
        <div class="spacer height-20"></div>
        <h3 class="size-24 leading-12 font-normal">Second Highlight</h3>
        <p>Discover the magic of exceptional creativity.&nbsp;</p>
    </div>
    <div class="column">
        <p class="size-76">03</p>
        <div class="spacer height-20"></div>
        <h3 class="size-24 leading-12 font-normal">Third Highlight</h3>
        <p>Unleash your imagination with outstanding designs.&nbsp;</p>
    </div>
</div>

`],
  update_section_article_with_image: `To add an article: 
- Create the required rows and column and add them inside the current 'div.is-container'.
- Replace all the text in the example with the requested content.

Example:

<div class="row">
    <div class="column">
        <h1 class="font-normal leading-none size-60">A forward thinking studio delivering digital solutions that help your business<br></h1>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
    <div class="column" style="width: 75%; flex: 0 0 auto;"><img src="{{IMAGEURL}}" alt=""></div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-60"></div>
    </div>
</div>
<div class="row">
    <div class="column" style="width: 75%; flex: 0 0 auto;">
        <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
            when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
    </div>
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-40"></div>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
    <div class="column" style="width: 75%; flex: 0 0 auto;">
        <h2 class="size-28 font-normal">Sub Topic 1</h2>
        <div class="spacer height-20"></div>
        <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
            when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
    </div>
</div>
<div class="row">
    <div class="column">
        <div class="spacer height-40"></div>
    </div>
</div>
<div class="row">
    <div class="column" style="width: 75%; flex: 0 0 auto;">
        <h2 class="size-28 font-normal">Sub Topic 2</h2>
        <div class="spacer height-20"></div>
        <p>Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
            when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
    </div>
    <div class="column">
        <div class="spacer height-80"></div>
    </div>
</div>

`,
  text_size: `- To increase or decrease text/font size, use one of these classes:
    - size-12
    - size-13
    - size-14
    - size-15
    - size-16
    - size-17
    - size-18
    - size-19
    - size-20
    - size-21
    - size-24
    - size-28
    - size-32
    - size-35
    - size-38
    - size-42
    - size-46
    - size-48
    - size-50
    - size-54
    - size-60
    - size-64
    - size-68
    - size-72
    - size-76
    - size-80
    - size-84
    - size-88
    - size-92
    - size-96
    - size-100
    - size-104
    - size-108
    - size-112
    - size-116
    - size-120
    - size-124
    - size-128
    - size-132
    - size-136
    - size-140
    - size-144
    - size-148
    - size-152
    - size-156
    - size-160
    - size-164
    - size-168
    - size-172
    - size-176
    - size-180
    - size-184
    - size-188
    - size-192
    - size-196
    - size-200
`
};

class Command {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    this.lib = new Lib(builder);
    let html = `
        <div class="is-modal ai-disclaimer" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="is-modal-content" style="max-width:450px;padding:55px 40px 35px;font-size:16px;line-height:1.4;letter-spacing: 1px;">
                <div class="is-modal-bar is-draggable">
                    ${util.out('AI-Powered Features')}
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
                ${util.out('AI-Disclaimer', this.builder.disclaimerAI)}
                <div style="text-align:right;margin-top:20px;">
                    <button title="${util.out('Ok')}" class="input-ok classic-primary" style="width:100%;text-transform: uppercase;
                    font-size: 14px;">${util.out('Ok')}</button>
                </div>
            </div>
        </div>`;
    builderStuff.insertAdjacentHTML('beforeend', html);
    this.modalDisclaimer = builderStuff.querySelector('.ai-disclaimer');
    let cl = contextBlockList;
    if (this.builder.contextList) cl = this.builder.contextList;
    const localProcess = question => {
      if (this.builder.enableShortCommands) {
        // Process Short Commands

        question = this.builder.lib.processShortCommand(question); // Process the shortCommandList
        if (!question) return false;
        question = this.processPrompt(question); // Process the commandList
        if (!question) return false;
      }
      return question;
    };
    const sendRewriteCommand = async question => {
      let container = this.getContainer();
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      if (!container && !docContainer) {
        this.util.showMessage(this.util.out('No text container found.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      let currentHtml = '';
      if (container) currentHtml = this.builder.readHtml(container, false, false);

      // Update prompt
      question = `${question}.

This is my current content:

${currentHtml}
`;
      let systemCmd = '';
      let context = 'You are a helpful assistant. You will provide direct answers without a prologue.';
      const callback = answer => {
        if (this.builder.consoleLog) console.log(answer);
        systemCmd = 'You will be provided with a text content and your task is to put the content (completely) as it is in the provided template.';
        let question = `Place my content in the provided template. Ensure that all the content are placed in the result. Feel free to add more rows/columns if needed, but don't change/add/reduce the content.

This is my content:

${answer}
`;
        const containsSingleSentence = text => {
          const dotCount = (text.match(/\./g) || []).length;
          return dotCount === 1;
        };
        const countWords = str => {
          const wordsArray = str.trim().split(/\s+/);
          return wordsArray.length;
        };
        let context;
        if (this.builder.consoleLog) console.log(containsSingleSentence(answer), countWords(answer));
        if (containsSingleSentence(answer) || countWords(answer) <= 100) {
          context = cl.short_content;
        } else {
          context = cl.new_section_answer;
        }
        const callback = html => {
          if (this.builder.consoleLog) console.log(html);
          html = this.fixHtml(html);
          if (!html) {
            this.dictation.finish(true);
            return false;
          }

          // html = this.fixNewSection(html); // for new section only => Not needed (no icons or images here on the template)

          // Render
          this.renderResult(html);
          this.dictation.finish();
        };
        if (this.builder.consoleLog) {
          console.log(systemCmd);
          console.log(question);
          console.log(context);
        }
        this.sendCommand('html', question, context, systemCmd, [], callback);
      };
      if (this.builder.consoleLog) {
        console.log(systemCmd);
        console.log(question);
        console.log(context);
      }
      this.sendCommand('assistant', question, context, systemCmd, [], callback);
    };
    const sendGeneralCommand = async question => {
      let container = this.getContainer();
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      if (!container && !docContainer) {
        this.util.showMessage(this.util.out('No text container found.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      this.sendCommand('analyze', `This is the command: "${question}"`, '', 'You will analyze the user\'s command and return what the user needs.', this.lib.getFunctions(), response => {
        const args = JSON.parse(response);
        if (this.builder.consoleLog) console.log(args);
        if (args.asking_info && !args.add_info) {
          if (this.builder.consoleLog) console.log('asking_info');
          sendOtherCommand(question);
          return;
        }
        if (args.write_based_on_the_current_content && !args.new_content) {
          // summarize, expand, make short, add more info, etc'
          if (this.builder.consoleLog) console.log('write_based_on_the_current_content');
          sendRewriteCommand(question);
          return;
        }
        const numberOfIntents = Object.keys(args).length;

        // SIMPLE (1 or 2) INTENTS
        const activeCol = this.builder.activeCol;
        if (activeCol) {
          // && numberOfIntents<=2) {

          // Update Column or Block (in General Mode)
          if (args.align_individual_text || args.font_size_individual_text || args.line_height_individual_text) {
            sendUpdateBlockCommand(question, args);
            return;
          }

          // Add new Column or Block (in General Mode)
          if (args.add_column_or_block) {
            sendBlockCommand(question);
            return;
          }
        }

        // SIMPLE/SINGLE INTENT (like Short Commands)
        if (numberOfIntents === 1) {
          // Block Mode (in General Mode)
          let result = this.blockAction(args);
          if (result) {
            this.dictation.finish();
            return;
          }
          result = this.quickAction(args);
          if (result) {
            this.dictation.finish();
            return;
          }
        }

        // Get relevant context
        let context = '';
        let currentContent = '';
        let container = this.getContainer();
        if (container) currentContent = this.builder.readHtml(container, false, false);
        if (args.new_content || currentContent.trim() === '') {
          if (args.new_content) {
            if (args.add_image === 'gallery') {
              context = cl.new_section_with_gallery;
            } else if (args.add_list_with_image) {
              context = cl.new_section_with_list_images;
            } else if (args.add_list_with_icon) {
              context = cl.new_section_with_list_icons;
            } else if (args.add_list_with_number) {
              context = this.chooseContext(cl.new_section_with_list_numbering);
            } else if (args.add_list && !args.add_article) {
              context = cl.new_section_with_list;
            } else if (args.add_article && args.add_image === 'image') {
              context = this.chooseContext(cl.new_section_article_with_image);
            } else if (args.add_article) {
              context = this.chooseContext(cl.new_section_article);
            } else if ((args.add_headline || args.add_paragraph) && args.add_image === 'image') {
              context = cl.new_section_with_image;
            } else {
              context = cl.new_section_others;
            }

            /*
            Handle Unrelated Request
            */
            if (args.others) {
              context = cl.new_section_others;
              // Update prompt
              question = `Add a new section containing your response on this user request: ${question}`;
            }

            // Replace {{_IMAGEURL}}
            if (context.includes('{{_IMAGEURL}}')) {
              const gallery = this.builder.media.images;
              const imageList = gallery.square;
              const imageUrl = this.lib.chooseMedia(imageList);
              context = context.replaceAll('{{_IMAGEURL}}', imageUrl);
            }
          } else {
            context = this.chooseContext(cl.new_section_article);
            // Or use: context = cl.new_section_others;
          }
        } else {
          //if(args.redesign_layout || args.change_text || args.change_style || args.add_info) {

          let currentHtml = '<div class="is-container">' + currentContent + '</div>';
          let redesign_request = '';
          if (args.redesign_layout) {
            // get title tag
            let titleElm, titleTag;
            if (container) {
              titleElm = container.querySelector('h1,h2');
              if (titleElm) titleTag = titleElm.tagName.toLowerCase();
            }

            // Update prompt
            redesign_request = 'Change the placement of the title, paragraph and all elements in my section based on the layout template. ';

            // Update context
            let val;
            if (localStorage.getItem('_context_num') !== null) {
              val = localStorage.getItem('_context_num');
            } else {
              val = 'random';
            }
            if (val === '') {
              context = '';
            } else if (val === 'random') {
              context = this.chooseContext(cl.redesign_layout);
            } else {
              context = this.chooseContext(cl.redesign_layout, val);
            }

            // set title tag
            if (titleTag === 'h2') {
              context = context.replaceAll('h1', 'h2');
            }
          }

          // Update prompt
          question = `${redesign_request}${question}. Modify my section according to this instruction and returns the modified section HTML.

This is my section:
            
${currentHtml}
`;
          if (args.change_text) ; else {
            if ((args.add_headline || args.add_paragraph) && args.add_image === 'image') {
              context += '\n' + cl.update_section_with_image;
            } else if (args.add_image === 'gallery') {
              context += '\n' + cl.update_section_with_gallery;
            } else if (args.add_list_with_image) {
              context += '\n' + cl.update_section_with_list_images;
            } else if (args.add_list_with_icon) {
              context += '\n' + cl.update_section_with_list_icons;
            } else if (args.add_list_with_number) {
              context += '\n' + this.chooseContext(cl.update_section_with_list_numbering);
            } else if (args.add_list) {
              context += '\n' + cl.update_section_with_list;
            } else if (args.add_article && args.add_image === 'image') {
              context += '\n' + cl.update_section_article_with_image;
            } else if (args.add_article) {
              context += '\n' + cl.update_section_article_with_image;
            } else ;
          }
          if (context.includes('{{_IMAGEURL}}')) {
            //Replace {{_IMAGEURL}}
            const gallery = this.builder.media.images;
            const imageList = gallery.square;
            const imageUrl = this.lib.chooseMedia(imageList);
            context = context.replaceAll('{{_IMAGEURL}}', imageUrl);
          }
        }

        // Check elements and add relevant context
        context = this.lib.addElementContext(context, args);

        // Send

        let systemCmd = `You will be provided with HTML code to modify, and your task is to return only the modified HTML code, excluding any introductions or explanations
`;
        if (args.new_content) {
          systemCmd = 'Your task it to create and return HTML content, excluding any introductions or explanations.';
        }
        const callback = html => {
          if (this.builder.consoleLog) console.log(html);
          html = this.fixHtml(html);
          if (!html) {
            this.dictation.finish(true);
            return false;
          }
          if (!args.new_content) {
            // Redesign & Editing (text or style)

            html = this.fixButtons(html);
            html = this.fixCustomCode(html);
            html = this.analyzeTitle(html, context);

            // Render
            this.renderResult(html);
          } else {
            // New Section

            html = this.fixButtons(html);
            html = this.fixNewSection(html); // for new section only

            // Render
            this.renderResult(html);
          }
          this.dictation.finish(); // Must be called after finished
        };

        if (this.builder.consoleLog) {
          console.log(systemCmd);
          console.log(question);
          console.log(context);
        }
        this.sendCommand('html', question, context, systemCmd, [], callback);
      });
    };
    const sendBlockCommand = async question => {
      let block = this.builder.activeCol;
      if (!block) {
        this.util.showMessage(this.util.out('Please select a block or content.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      let blockContent = block.innerHTML;
      let context = '';
      this.sendCommand('analyze', `This is the command: "${question}"`, '', 'You will analyze the user\'s command and return what the user needs.', this.lib.getFunctions_block(), response => {
        const args = JSON.parse(response);
        if (this.builder.consoleLog) console.log(args);
        const numberOfIntents = Object.keys(args).length;
        if (numberOfIntents === 1) {
          let result = this.blockAction(args);
          if (result) {
            this.dictation.finish();
            return;
          }
        }
        let systemCmd;
        if (args.new_block) {
          systemCmd = 'You will be asked to create content (in HTML) and return the HTML without any additional explanation.';
          context = `To add a content/block:
- Create the required rows and column and add them inside the 'div.column' element:

    <div class="row">
        <div class="column">
            {{CONTENT}}
        </div>
    </div>

Example: To create a block with a headline and a paragraph:

    <div class="row">
        <div class="column">
            <h2 class="font-normal leading-none size-48">Heading here</h2>
            <p>Paragraph here.</p>
        </div>
    </div>
                        
`;
        } else if (numberOfIntents === 1 && (args.new_column_onright || args.new_column_onleft)) {
          // single intent => no content details

          systemCmd = 'You will be asked to create a single HTML block/column and return the HTML without any additional explanation.';
          context = `To create a column, create single 'div.column' element and add a paragraph inside it.

Example:

    <div class="column">
        <p>Paragraph here.</p>
    </div>
  
`;
          question = `${question}.  No talk; just do. You must return only one 'div.column'.`;
        } else if (args.new_column_onright || args.new_column_onleft) {
          systemCmd = 'You will be asked to create content (in HTML) and return the HTML without any additional explanation.';
          context = `To add a column that contains a content:
- Create one 'div.column' element and add the content inside it:

    <div class="column">
        {{CONTENT}}
    </div>

Example 1: To create a column with a headline and a paragraph:

    <div class="column">
        <h2 class="font-normal leading-none size-48">Heading here</h2>
        <p>Paragraph here.</p>
    </div>


Example 2: To create a column with an image:

    <div class="column">
        <img src="{{IMAGEURL}}">
    </div>
  
`;
        } else {
          systemCmd = 'You will be asked to modify content (in HTML) and return only the modified HTML without any additional explanation.';

          // Update prompt
          question = `${question}. Modify my content according to this instruction and returns the modified content HTML.

This is my content:
            
${blockContent}
`;
        }
        context = this.lib.elementContext(context, args);
        if (this.builder.consoleLog) {
          console.log(systemCmd);
          console.log(question);
          console.log(context);
        }
        const callback = answer => {
          if (this.builder.consoleLog) console.log(answer);

          // if(args.new_block||args.new_column_onright||args.new_column_onleft) {
          //     html = this.fixHtmlBlock(answer, true); // wrap = true
          // } else {
          //     html = this.fixHtmlBlock(answer);
          // }

          html = this.fixHtmlBlock(answer);
          if (!html) {
            this.dictation.finish(true);
            return false;
          }
          if (args.new_column_onright || args.new_column_onleft) {
            html = this.fixNewBlock(answer);
          }
          this.builder.saveForUndo();
          if (args.new_block) {
            if (block) {
              const row = block.parentNode;
              if (row) {
                row.insertAdjacentHTML('afterend', html);
                setTimeout(() => {
                  row.nextElementSibling.firstElementChild.click();
                }, 300);
              }
            }
          } else if (args.new_column_onright) {
            if (block) {
              const row = block.parentNode;
              block.insertAdjacentHTML('afterend', html);
              this.builder.util.fixLayout(row);
              setTimeout(() => {
                block.nextElementSibling.click();
              }, 300);
            }
          } else if (args.new_column_onleft) {
            if (block) {
              const row = block.parentNode;
              block.insertAdjacentHTML('beforebegin', html);
              this.builder.util.fixLayout(row);
              setTimeout(() => {
                block.previousElementSibling.click();
              }, 300);
            }
          } else {
            // if(this.builder.consoleLog) console.log('sendBlockCommand => update cell content');

            block.innerHTML = html;
            let elmActive = block.querySelector('.elm-active');
            if (elmActive) {
              this.builder.activeElement = elmActive;
              elmActive.focus();
            }
          }

          // See addContent() in ContentBuilder's util.js
          let builderActive = this.builder.doc.querySelector('.builder-active');
          if (builderActive) this.builder.applyBehaviorOn(builderActive);
          this.builder.hideElementTools();
          this.builder.settings.onChange();
          this.builder.settings.onRender();
          this.dictation.finish();
        };
        this.sendCommand('assistant', question, context, systemCmd, [], callback);
      });
    };

    // Update Column or Block (in General Mode)
    const sendUpdateBlockCommand = async (question, args) => {
      let block = this.builder.activeCol;
      if (!block) {
        this.builder.showMessage(this.util.out('Please select a block or content.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      let blockContent = block.innerHTML;
      const systemCmd = 'You will be asked to modify content (in HTML) and return only the modified HTML without any additional explanation.';

      // Update prompt
      question = `${question}. Modify my content according to this instruction and returns the modified content HTML.
            
This is my content:
                
${blockContent}
`;
      let context = this.lib.addElementContext('', args);
      if (this.builder.consoleLog) {
        console.log(systemCmd);
        console.log(question);
        console.log(context);
      }
      const callback = answer => {
        if (this.builder.consoleLog) console.log(answer);
        html = this.fixHtmlBlock(answer); // wrap = false
        if (!html) {
          this.dictation.finish(true);
          return false;
        }
        this.builder.saveForUndo();

        // if(this.builder.consoleLog) console.log('sendUpdateBlockCommand => update cell content');

        block.innerHTML = html;
        let elmActive = block.querySelector('.elm-active');
        if (elmActive) {
          this.builder.activeElement = elmActive;
          elmActive.focus();
        }

        // See addContent() in ContentBuilder's util.js
        let builderActive = this.builder.doc.querySelector('.builder-active');
        if (builderActive) this.builder.applyBehaviorOn(builderActive);
        this.builder.hideElementTools();
        this.builder.settings.onChange();
        this.builder.settings.onRender();
        this.dictation.finish();
      };
      this.sendCommand('assistant', question, context, systemCmd, [], callback);
    };
    const sendOtherCommand = async question => {
      let container = this.getContainer();
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      if (!container && !docContainer) {
        this.util.showMessage(this.util.out('No text container found.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      let systemCmd = '';
      let context = 'You are a helpful assistant. You don\'t need to answer \'Sure!\' or \'Certainly\'. You will just provide direct answers without a prologue. No talk; just do.';
      const callback = answer => {
        if (this.builder.consoleLog) console.log(answer);
        let systemCmd = 'You will be provided with a text content and your task is to put the content (completely) as it is in the provided template.';
        let question = `Place my content in the provided template. Ensure that all the content are placed in the result. Feel free to add more rows/columns if needed, but don't change/add/reduce the content.

This is my content:

${answer}
`;
        const containsSingleSentence = text => {
          // Count the occurrences of dots (periods)
          const dotCount = (text.match(/\./g) || []).length;
          // If there's exactly one dot, it's likely a single sentence
          return dotCount === 1;
        };
        const countWords = str => {
          // Remove extra whitespaces and split the string into words
          const wordsArray = str.trim().split(/\s+/);
          // Return the count of words
          return wordsArray.length;
        };
        let context;
        if (this.builder.consoleLog) console.log(containsSingleSentence(answer), countWords(answer));
        if (containsSingleSentence(answer) || countWords(answer) <= 100) {
          context = cl.short_content;
        } else {
          context = cl.new_section_answer;
        }
        const callback = html => {
          if (this.builder.consoleLog) console.log(html);
          html = this.fixHtml(html);
          if (!html) {
            this.dictation.finish(true);
            return false;
          }

          // html = this.fixNewSection(html); // for new section only => Not needed (no icons or images here on the template)

          // Render
          this.renderResult(html);
          this.dictation.finish();
        };
        if (this.builder.consoleLog) {
          console.log(systemCmd);
          console.log(question);
          console.log(context);
        }
        this.sendCommand('html', question, context, systemCmd, [], callback);
      };
      if (this.builder.consoleLog) {
        console.log(systemCmd);
        console.log(question);
        console.log(context);
      }
      this.sendCommand('assistant', question, context, systemCmd, [], callback);
    };
    const sendImageCommand = async prompt => {
      this.dictation.startSending(); // Shows sending status & Abort button

      const displayImage = src => {
        this.builder.saveForUndo();
        let elm = this.builder.activeElement;
        if (elm && elm.tagName) {
          const tagName = elm.tagName.toLowerCase();
          if (tagName === 'img') {
            this.builder.saveForUndo();
            elm.onload = async () => {
              let divImageResizer = document.querySelector('#divImageResizer');
              if (divImageResizer) divImageResizer.click();
            };
            elm.setAttribute('src', src);
            this.builder.onChange();
          } else {
            this.renderImage(src);
          }
        } else {
          this.renderImage(src);
        }
        this.dictation.finish();
      };
      this.builder.generateImage(prompt, displayImage);
    };

    // Dictation Panel 
    this.dictation = this.builder.dictation;
    this.dictation.opts.send = question => {
      if (this.builder.assistantMode === 'image') {
        sendImageCommand(question);
        return;
      }

      // Local Process
      question = localProcess(question);
      if (!question) return;

      // Go to OpenAI
      if (this.builder.assistantMode === 'general') {
        sendGeneralCommand(question);
      } else if (this.builder.assistantMode === 'others') {
        sendOtherCommand(question);
      } else if (this.builder.assistantMode === 'block') {
        sendBlockCommand(question);
      }
    };
    this.dictation.opts.abort = () => {
      if (this.controller) this.controller.abort();
      if (this.builder.controller) {
        // Abort for image
        this.builder.controller.abort();
      }
      this.dictation.finish(true); // Must be called after finished (true = do not clear command text)
    };
  }

  getContainer() {
    let container, builderActive;
    builderActive = this.builder.doc.querySelector('.builder-active');
    if (builderActive) container = builderActive;else {
      if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
        // canvas mode
        let activeBlock = this.builder.doc.querySelector('.is-block.cloned');
        if (!activeBlock) activeBlock = this.builder.doc.querySelector('.is-block.active');
        if (activeBlock) {
          container = activeBlock.querySelector(this.builder.container);
          if (!container) container = this.builder.doc.querySelector(this.builder.container);
        } else {
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          let blockContainer = docContainer.querySelector('.box-select');
          if (!blockContainer) {
            blockContainer = docContainer.querySelector(this.builder.blockContainer);
          }
          if (blockContainer) {
            container = blockContainer.querySelector(this.builder.container);
          } else {
            container = this.builder.doc.querySelector(this.builder.container);
          }
        }
      } else {
        // standard mode
        container = this.builder.doc.querySelector(this.builder.container);
      }
    }
    return container;
  }
  renderImage(src) {
    this.builder.saveForUndo();
    if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      let blockContainer = docContainer.querySelector('.box-select');
      if (!blockContainer) {
        blockContainer = docContainer.querySelector(this.builder.blockContainer);
      }
      if (!blockContainer) {
        this.builder.addPage();
        blockContainer = docContainer.querySelector(this.builder.blockContainer);
      }
      let html = `
            <div class="is-block" style="top:15%;left:30%;width:760px;height:760px;">
                <div class="is-block-overlay" style="background-image: url(&quot;${src}&quot;);"></div>
            </div>
            `;
      this.builder.addBlock(html, blockContainer);
      this.builder.settings.onChange();
      this.builder.settings.onRender();
      return;
    }
    let container = this.getContainer();
    if (!container) {
      /*
      if(this.builder.canvas) {
           // Canvas Mode
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          if(docContainer) {
              
              // <div class="is-block block-steady height-auto" style="top: calc(24.4455% - 37.646px);left: calc(50% - 332px);width: 664px;">
              //     <div class="is-container leading-12 size-17">
              //         <div class="row"><div class="column"><img src="${src}"></div></div>
              //     </div>
              // </div>
              let html = `
              <div class="is-block" style="top:15%;left:30%;width:760px;height:760px;">
                  <div class="is-block-overlay" style="background-image: url(&quot;${src}&quot;);"></div>
              </div>
              `;
               const blockContainer = docContainer.querySelector(this.builder.blockContainer);
              this.builder.addBlock(html, blockContainer);
          }
       } else {
          this.util.showMessage(this.util.out('No text container found.'));
          this.dictation.finish(); // Must be called after finished
          return;
      }
      */
      this.util.showMessage(this.util.out('No text container found.'));
      this.dictation.finish(); // Must be called after finished
      return;
    } else {
      /*
      if(this.builder.canvas) {
           // Canvas Mode
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          if(docContainer) {
              
              let html = `
              <div class="is-block" style="top:15%;left:30%;width:760px;height:760px;">
                  <div class="is-block-overlay" style="background-image: url(&quot;${src}&quot;);"></div>
              </div>
              `;
               const blockContainer = docContainer.querySelector(this.builder.blockContainer);
              this.builder.addBlock(html, blockContainer);
          }
        } else {
          // Normal
          let html = `
                  <div class="row"><div class="column"><img src="${src}"></div></div>
          `;
          container.insertAdjacentHTML('afterBegin', html);
          setTimeout(()=>{
              container.firstElementChild.click();
          }, 300);
          this.builder.applyBehaviorOn(container);
      }
      */
      // Normal
      let html = `
                    <div class="row"><div class="column"><img src="${src}"></div></div>
            `;
      container.insertAdjacentHTML('afterBegin', html);
      setTimeout(() => {
        container.firstElementChild.click();
      }, 300);
      this.builder.applyBehaviorOn(container);
    }
    this.builder.settings.onChange();
    this.builder.settings.onRender();
  }
  renderResult(html) {
    this.builder.saveForUndo();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const elm = doc.querySelector('.is-container');
    if (elm) {
      html = elm.innerHTML;
    }
    if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer) {
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      let blockContainer = docContainer.querySelector('.box-select');
      if (!blockContainer) {
        blockContainer = docContainer.querySelector(this.builder.blockContainer);
      }
      if (!blockContainer) {
        this.builder.addPage();
        blockContainer = docContainer.querySelector(this.builder.blockContainer);
      }
      html = `
            <div class="is-block block-steady height-auto" style="top: calc(24.4455% - 37.646px);left: calc(50% - 332px);width: 664px;">
                <div class="is-container leading-12 size-17">
                    ${html}
                </div>
            </div>
            `;
      this.builder.addBlock(html, blockContainer);
      this.builder.settings.onChange();
      this.builder.settings.onRender();
      return;
    }
    let container = this.getContainer();
    if (!container) {
      /*
      if(this.builder.canvas) {
           // Canvas Mode
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          if(docContainer) {
              
              html = `
              <div class="is-block block-steady height-auto" style="top: calc(24.4455% - 37.646px);left: calc(50% - 332px);width: 664px;">
                  <div class="is-container leading-12 size-17">
                      ${html}
                  </div>
              </div>
              `;
               const blockContainer = docContainer.querySelector(this.builder.blockContainer);
              this.builder.addBlock(html, blockContainer);
          }
       } else {
          this.util.showMessage(this.util.out('No text container found.'));
          this.dictation.finish(); // Must be called after finished
          return;
      }
      */
      this.util.showMessage(this.util.out('No text container found.'));
      this.dictation.finish(); // Must be called after finished
      return;
    } else {
      /*
      if(this.builder.canvas) {
           // Canvas Mode
          const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
          if(docContainer) {
              
              html = `
              <div class="is-block block-steady height-auto" style="top: calc(24.4455% - 37.646px);left: calc(50% - 332px);width: 664px;">
                  <div class="is-container leading-12 size-17">
                      ${html}
                  </div>
              </div>
              `;
               const blockContainer = docContainer.querySelector(this.builder.blockContainer);
              this.builder.addBlock(html, blockContainer);
          }
        } else {
          // Normal
          container.insertAdjacentHTML('afterBegin', html);
          setTimeout(()=>{
              container.firstElementChild.click();
          }, 300);
          this.builder.applyBehaviorOn(container);
      }
      */
      // Normal
      container.insertAdjacentHTML('afterBegin', html);
      setTimeout(() => {
        container.firstElementChild.click();
      }, 300);
      this.builder.applyBehaviorOn(container);
    }
    this.builder.settings.onChange();
    this.builder.settings.onRender();
  }
  async sendCommand(mode, question, context, system, functs, callback) {
    this.dictation.startSending(); // Shows sending status & Abort button

    this.controller = new AbortController(); // Create a new AbortController
    this.signal = this.controller.signal; // Get a new signal object

    let temperature = localStorage.getItem('_temp') || this.builder.temperature;
    let topP = localStorage.getItem('_top_p') || this.builder.topP;
    let num = 1;
    const messages = {
      question,
      context,
      system,
      functs,
      temperature,
      topP,
      num
    };
    try {
      /*
      const response = await fetch(this.builder.sendCommandUrl, {
          signal: this.signal, // Abort
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify(messages),
      });
       const data = await response.json();
      */

      let data;
      if (this.builder.sendCommand) {
        data = await this.builder.sendCommand(messages);
      } else {
        const response = await fetch(this.builder.sendCommandUrl, {
          signal: this.signal,
          // Abort
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(messages)
        });
        data = await response.json();
      }
      if (data.error) {
        // Error response from OpenAI goes here.
        console.log('Error:\n' + data.error);

        // ex. wrong API Key => Request failed with status code 401
        this.util.showMessage(this.util.out('Request failed.'));
        this.dictation.finish(); // Must be called after finished
        return;
      }
      if (mode === 'html') {
        // console.log(data.answer.usage);

        data.answer.choices.forEach(item => {
          let html = item.message.content;
          html = this.getHtmlResult(html);
          if (!html) {
            this.util.showMessage(this.util.out('Oops! The response received is insufficient. Please try again.'));
            this.dictation.finish(); // Must be called after finished

            return;
          }
          callback(html);
        });
      } else if (mode === 'assistant') {
        data.answer.choices.forEach(item => {
          let answer = item.message.content;
          callback(answer);
        });
      } else {
        // mode===analyze
        /*
            Handle Unrelated Request
             If OpenAI Function Call stopped (when user is asking unrelated things), it returns:
            { 
                role: 'assistant', 
                content: 'The user is asking for information.'
            }
        */
        if (data.answer.role && data.answer.content) {
          callback(JSON.stringify({
            new_section: true,
            others: true
          })); // Just create a new section
          return;
        }
        callback(data.answer);
      }
    } catch (error) {
      if (error.name === 'AbortError') ; else {
        // CORS or code errors goes here
        console.error('Error:', error);
        // console.log('Error:\n'+error);

        this.dictation.finish(); // Must be called after finished

        // Debug
        if (this.builder.consoleLog) {
          if (!(error + '').includes('Failed to fetch')) {
            // Only if not CORS error
            const response = await fetch(this.builder.sendCommandUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(messages)
            });
            const data = await response.text();
            console.log('Response:\n' + data); // Shows code error
          }
        }

        this.util.showMessage(this.util.out('Service Unavailable.'));
      }
    }
  }

  //-------------------

  processPrompt(question) {
    let intent = this.builder.similarity.check(question);
    // console.log(intent);

    if (!intent) return question;
    if (intent === 'move_row_up') {
      this.builder.saveForUndo();
      this.builder.moveRowUp();
      this.builder.settings.onChange();
    } else if (intent === 'move_row_down') {
      this.builder.saveForUndo();
      this.builder.moveRowDown();
      this.builder.settings.onChange();
    } else if (intent === 'duplicate_row') {
      this.builder.saveForUndo();
      this.builder.duplicateRow();
      this.builder.settings.onChange();
    } else if (intent === 'remove_row') {
      this.builder.saveForUndo();
      this.builder.removeRow();
      this.builder.settings.onChange();
    } else if (intent === 'move_col_left') {
      this.builder.saveForUndo();
      this.builder.moveColumnLeft();
      this.builder.settings.onChange();
    } else if (intent === 'move_col_right') {
      this.builder.saveForUndo();
      this.builder.moveColumnRight();
      this.builder.settings.onChange();
    } else if (intent === 'duplicate_col') {
      this.builder.saveForUndo();
      this.builder.duplicateColumn();
      this.builder.settings.onChange();
    } else if (intent === 'remove_col') {
      this.builder.saveForUndo();
      this.builder.removeColumn();
      this.builder.settings.onChange();
    } else if (intent === 'move_column_up') {
      this.builder.saveForUndo();
      this.builder.moveColumnUp();
      this.builder.settings.onChange();
    } else if (intent === 'move_column_down') {
      this.builder.saveForUndo();
      this.builder.moveColumnDown();
      this.builder.settings.onChange();
    } else if (intent === 'increase_font_size') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.increaseFontSize(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'decrease_font_size') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.decreaseFontSize(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'clear_font_size') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.clearFontSize(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'align_left') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.alignText(elm, 'left');
        this.builder.settings.onChange();
      }
    } else if (intent === 'align_center') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.alignText(elm, 'center');
        this.builder.settings.onChange();
      }
    } else if (intent === 'align_right') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.alignText(elm, 'right');
        this.builder.settings.onChange();
      }
    } else if (intent === 'align_full') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.alignText(elm, 'justify');
        this.builder.settings.onChange();
      }
    } else if (intent === 'clear_alignment') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.alignText(elm, '');
        this.builder.settings.onChange();
      }
    } else if (intent === 'increase_space') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.increaseElementHeight(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'decrease_space') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.decreaseElementHeight(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'increase_line_height') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.increaseLineHeight(elm);
        this.builder.settings.onChange();
      }
    } else if (intent === 'decrease_line_height') {
      let elm = this.builder.activeElement;
      if (elm) {
        this.builder.saveForUndo();
        this.builder.lib.decreaseLineHeight(elm);
        this.builder.settings.onChange();
      }
    } else {
      return question; // Pass to ChatGPT
    }
  }

  //-------------------

  openDictation() {
    this.dictation.openDictation();
  }
  getHtmlResult(html) {
    if (html.indexOf('```') !== -1) {
      const regex = /<div[^>]*>[\s\S]*<\/div>/;
      const matches = html.match(regex);
      const extractedString = matches && matches[0];
      html = extractedString;
    }
    return html;
  }
  getHtmlBlock(html, wrap) {
    const startIndex = html.indexOf('<');
    const endIndex = html.lastIndexOf('>') + 1;
    if (startIndex !== -1 && endIndex !== -1) {
      const extractedHTML = html.substring(startIndex, endIndex);
      html = extractedHTML;
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    html = doc.body.innerHTML;
    if (wrap) {
      if (!html.includes('<div class="row">') && !html.includes('<p>')) {
        html = `<div class="row">
                    <div class="column">
                        <p>${html}</p>
                    </div>
                </div>`;
      } else if (!html.includes('<div class="row">')) {
        html = `<div class="row">
                    <div class="column">
                        ${html}
                    </div>
                </div>`;
      }
    }
    return html;
  }
  fixNewBlock(html) {
    // Fix icons
    const replacementClass = 'ion-checkmark';
    const regexPattern = /(<i class="icon )(ion-\S+)/g;
    html = html.replace(regexPattern, `$1${replacementClass}`);
    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');

    // Fix embedded images
    const gallery = this.builder.media.images;
    const imageList = gallery.square;
    const imageUrl = this.lib.chooseMedia(imageList);
    const imgs = doc.querySelectorAll('img');
    imgs.forEach(img => {
      img.setAttribute('src', imageUrl);
    });
    const cols = doc.querySelectorAll('.column');
    cols.forEach(col => {
      // Add spacer in an empty column
      if (col.innerHTML.trim() === '') {
        const spacer = document.createElement('div');
        spacer.classList.add('spacer');
        spacer.classList.add('height-40');
        col.appendChild(spacer);
      }
    });
    return doc.documentElement.innerHTML;
  }
  fixHtmlBlock(html, wrap) {
    html = this.getHtmlBlock(html, wrap);
    if (!html) {
      this.util.showMessage(this.util.out('Oops! The response received is insufficient. Please try again.'));
      return false;
    }
    if (html.includes('{{IMAGEURL}}')) {
      // Fix {{IMAGEURL}} that failed to replace
      const gallery = this.builder.media.images;
      const imageList = gallery.square;
      const imageUrl = this.lib.chooseMedia(imageList);
      html = html.replaceAll('{{IMAGEURL}}', imageUrl);
    }

    // Fix {{ICONCLASS}} that failed to replace
    html = html.replaceAll('{{ICONCLASS}}', 'ion-checkmark');
    html = this.replaceButtonsWithAnchorTags(html);
    html = this.replaceStrongTag(html);
    html = this.replaceEmTag(html);
    html = this.replaceUnderlineTag(html);
    html = this.replaceLineThroughTag(html);
    html = this.fixCommonBlock(html);
    html = this.fixButtons(html);
    if (!html) return false;
    return html;
  }
  fixHtml(html) {
    if (html.includes('{{_IMAGEURL}}')) {
      // Fix {{IMAGEURL}} that failed to replace
      const gallery = this.builder.media.images;
      const imageList = gallery.square;
      const imageUrl = this.lib.chooseMedia(imageList);
      html = html.replaceAll('{{IMAGEURL}}', imageUrl);
    }

    // Fix {{ICONCLASS}} that failed to replace
    html = html.replaceAll('{{ICONCLASS}}', 'ion-checkmark');
    html = this.replaceButtonsWithAnchorTags(html);
    html = this.replaceStrongTag(html);
    html = this.replaceEmTag(html);
    html = this.replaceUnderlineTag(html);
    html = this.replaceLineThroughTag(html);
    html = this.fixCommon(html);
    if (!html) return false;
    return html;
  }
  fixCustomCode(html) {
    const regex = /<!--CODESTART-->([\s\S]*?)<!--CODEEND-->/gm;
    const matches = html.match(regex);
    const extractedContent = [];
    if (matches) {
      matches.forEach(match => {
        const innerContent = match.replace(/<!--CODESTART-->|<!--CODEEND-->/g, '').trim();
        extractedContent.push(innerContent);
      });
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    let n = 0;
    const cols = doc.querySelectorAll('[data-html]');
    cols.forEach(col => {
      const customCode = encodeURIComponent(extractedContent[n]);
      col.setAttribute('data-html', customCode);
      col.innerHTML = '';
      n++;
    });
    if (extractedContent.length > 0) {
      return doc.documentElement.innerHTML;
    } else {
      return html;
    }
  }
  analyzeTitle(html, context) {
    let fontWeight = ['font-thin', 'font-extralight', 'font-light', 'font-normal', 'font-medium', 'font-semibold', 'font-bold', 'font-extrabold', 'font-black'];
    let contextWeightClass = '';
    for (const weightClass of fontWeight) {
      if (context.includes(weightClass)) {
        contextWeightClass = weightClass;
        break;
      }
    }
    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');
    const resultHeadline = doc.querySelector('h1, h2');
    if (resultHeadline && contextWeightClass) {
      for (const weightClass of fontWeight) {
        resultHeadline.classList.remove(weightClass);
      }
      resultHeadline.classList.add(contextWeightClass);
      return doc.body.innerHTML;
    }
    return html;
  }
  replaceButtonsWithAnchorTags(html) {
    const buttonRegex = /<button\b[^>]*>(.*?)<\/button>/g;
    const anchorRegex = /<a\b[^>]*class="button[^>]*>(.*?)<\/a>/g;
    html = html.replace(buttonRegex, '<a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">$1</a>');
    html = html.replace(anchorRegex, '<a href="#" role="button" class="transition-all inline-block whitespace-nowrap cursor-pointer no-underline border-2 border-solid mr-2 mt-2 mb-1 py-2 size-17 px-6 text-black leading-14 rounded border-transparent hover:border-transparent font-normal tracking-wide" style="background-color: rgb(240, 240, 240);">$1</a>');
    return html;
  }
  replaceStrongTag(html) {
    const strongRegex = /<strong\b[^>]*>(.*?)<\/strong>/g;
    const replacement = '<span class="font-semibold">$1</span>';
    return html.replace(strongRegex, replacement);
  }
  replaceEmTag(html) {
    const emRegex = /<em\b[^>]*>(.*?)<\/em>/g;
    const replacement = '<span class="italic">$1</span>';
    return html.replace(emRegex, replacement);
  }
  replaceUnderlineTag(html) {
    const regex = /<u>(.*?)<\/u>/gi;
    const replacedHTML = html.replace(regex, '<span class="underline">$1</span>');
    return replacedHTML;
  }
  replaceLineThroughTag(html) {
    const regex = /<(del|strike|s)>(.*?)<\/(del|strike|s)>/gi;
    const replacedHTML = html.replace(regex, '<span class="line-through">$2</span>');
    return replacedHTML;
  }
  fixCommonBlock(html) {
    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');

    // Replace element style with class
    const elements = doc.querySelectorAll('*');
    elements.forEach(element => {
      if (element.style.textDecoration === 'line-through') {
        element.classList.add('line-through');
        element.style.textDecoration = '';
      }
      if (element.style.textDecoration === 'underline') {
        element.classList.add('underline');
        element.style.textDecoration = '';
      }
    });
    return doc.documentElement.innerHTML;
  }
  fixNewSection(html) {
    // Fix icons
    const replacementClass = 'ion-checkmark';
    const regexPattern = /(<i class="icon )(ion-\S+)/g;
    html = html.replace(regexPattern, `$1${replacementClass}`);
    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');

    // Fix embedded images
    const gallery = this.builder.media.images;
    const imageList = gallery.square;
    const imageUrl = this.lib.chooseMedia(imageList);
    const imgs = doc.querySelectorAll('img');
    imgs.forEach(img => {
      img.setAttribute('src', imageUrl);
    });
    return doc.documentElement.innerHTML;
  }
  fixButtons(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const btns = doc.querySelectorAll('a.border-transparent');
    btns.forEach(btn => {
      if (!btn.style.backgroundColor) {
        btn.style.backgroundColor = 'rgb(240, 240, 240)';
      }
    });
    return doc.documentElement.innerHTML;
  }
  fixCommon(html) {
    html = html.replaceAll('{{CONTENT}}', '');
    html = html.replaceAll('{{TITLE}}', '');
    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');
    try {
      if (doc.body.innerText.trim() === '') {
        this.builder.showMessage(this.util.out('Oops! The response received is insufficient. Please try again.'));
        return false;
      }
      const container = doc.querySelector('.is-container');
      const cols = container.querySelectorAll('.column');
      cols.forEach(col => {
        // Remove column inline width=100%
        if (col.style.width === '100%') {
          col.style.width = '';
          col.style.flex = '';
        }

        /*
        Fix incorrect structure:
            <div class="column">
                <div class="flex flex-col justify-end items-start" style="width: 43.915%; flex: 0 0 auto;">
                    ...
                </div>
            </div>
        */
        if (col.firstElementChild) {
          if (col.firstElementChild.style.width && col.firstElementChild.style.flex === '0 0 auto') {
            col.firstElementChild.outerHTML = col.firstElementChild.innerHTML;
          } /*else if(col.firstElementChild.classList.contains('flex')) {
              col.firstElementChild.outerHTML = col.firstElementChild.innerHTML;
            }*/
        }

        // Fix column inside column
        const colsInside = col.querySelectorAll('.column');
        colsInside.forEach(item => {
          item.outerHTML = item.innerHTML;
        });

        /*
        Fix:
            <div class="column" style="width: 30%;">
        */
        if (col.style.width && col.style.flex !== '0 0 auto') {
          col.style.width = '';
        }

        // Remove data-filename attr
        const imgs = col.querySelectorAll('[data-filename]');
        imgs.forEach(img => {
          img.removeAttribute('data-filename');
        });

        // Default headings' class
        let headings = col.querySelectorAll('h1');
        headings.forEach(heading => {
          if (!heading.getAttribute('class')) {
            heading.classList.add('font-normal');
            heading.classList.add('size-35');
          }
        });
        headings = col.querySelectorAll('h2');
        headings.forEach(heading => {
          if (!heading.getAttribute('class')) {
            heading.classList.add('font-normal');
            heading.classList.add('size-28');
          }
        });
      });

      // Fix grid (width)
      const rows = container.querySelectorAll('.row');
      rows.forEach(row => {
        let totalWidth = 0;
        let hasAutoWidthCol = false;
        let lastCol;
        const cols = row.querySelectorAll('.column');
        cols.forEach(col => {
          if (col.style.width && col.style.width.includes('%')) {
            totalWidth += parseFloat(col.style.width);
          } else {
            hasAutoWidthCol = true;
          }
          lastCol = col;
        });
        if (totalWidth > 100) {
          // console.log('FIX: clear width. Total: ' + totalWidth);
          cols.forEach(col => {
            col.style.width = '';
            col.style.flex = '';
          });
        } else if (totalWidth < 100 && !hasAutoWidthCol) {
          // console.log('FIX: add col. Total: ' + totalWidth);
          if (lastCol) lastCol.insertAdjacentHTML('afterend', '<div class="column"><div class="spacer height-60"></div></div>');
        }
      });

      // Replace element style with class
      const elements = doc.querySelectorAll('*');
      elements.forEach(element => {
        if (element.style.textDecoration === 'line-through') {
          element.classList.add('line-through');
          element.style.textDecoration = '';
        }
        if (element.style.textDecoration === 'underline') {
          element.classList.add('underline');
          element.style.textDecoration = '';
        }
      });
      if (container) {
        const childElements = container.children;
        for (let i = childElements.length - 1; i >= 0; i--) {
          const row = childElements[i];

          // Remove incorrect spacer placement
          if (row.classList.contains('spacer')) {
            row.parentNode.removeChild(row);
          } else {
            const cols = row.children;
            for (let j = cols.length - 1; j >= 0; j--) {
              const col = cols[j];

              // Add spacer in an empty column
              if (col.innerHTML.trim() === '') {
                const spacer = document.createElement('div');
                spacer.classList.add('spacer');
                spacer.classList.add('height-40');
                col.appendChild(spacer);
              }

              // Fix built-in grid (column inside column)
              if (col.firstElementChild && col.firstElementChild.classList.contains('column')) {
                col.innerHTML = col.firstElementChild.innerHTML;
              }
            }
          }
        }
      }
    } catch (e) {
      if (this.builder.consoleLog) {
        console.log(doc.documentElement.innerHTML);
        console.log('Unable to proceed. Error: fixCommon.');
      }
      // console.log('Unable to proceed. Error: fixCommon.');

      // return false;
      return html;
    }
    return doc.documentElement.innerHTML;
  }
  blockAction(args) {
    const activeCol = this.builder.activeCol;
    if (!activeCol) return false;
    if (args.block_task) {
      const val = args.block_task;
      if (val === 'move-up' || val === 'move-down' || val === 'duplicate' || val === 'remove') {
        this.builder.saveForUndo();
        const grid = this.builder._rowTool.grid;
        if (val === 'move-up') grid.moveRowUp();
        if (val === 'move-down') grid.moveRowDown();
        if (val === 'duplicate') grid.duplicateRow();
        if (val === 'remove') {
          grid.removeRow();
          this.builder.doc.body.click();
        }
        this.builder.settings.onChange();
        this.dictation.finish(); // Must be called after finished
        return true;
      }
    }
    if (args.move_column) {
      const val = args.move_column;
      if (val === 'move-up' || val === 'move-down' || val === 'move-left' || val === 'move-right') {
        this.builder.saveForUndo();
        const grid = this.builder._rowTool.grid;
        if (val === 'move-up') grid.moveColumnUp();
        if (val === 'move-down') grid.moveColumnDown();
        if (val === 'move-left') grid.moveColumnPrevious();
        if (val === 'move-right') grid.moveColumnNext();
        this.builder.settings.onChange();
        this.dictation.finish(); // Must be called after finished
        return true;
      }
    }
    if (args.column_task) {
      const val = args.column_task;
      if (val === 'duplicate' || val === 'remove') {
        this.builder.saveForUndo();
        const grid = this.builder._rowTool.grid;
        if (val === 'duplicate') grid.duplicateColumn();
        if (val === 'remove') {
          grid.removeColumn();
          this.builder.doc.body.click();
        }
        this.builder.settings.onChange();
        this.dictation.finish(); // Must be called after finished
        return true;
      }
    }
    if (args.increase_decrease_column) {
      const val = args.increase_decrease_column;
      if (val === 'increase' || val === 'decrease') {
        this.builder.saveForUndo();
        const grid = this.builder._rowTool.grid;
        if (val === 'increase') grid.increaseColumn();
        if (val === 'decrease') grid.decreaseColumn();
        this.builder.settings.onChange();
        this.dictation.finish(); // Must be called after finished
        return true;
      }
    }
    return false;
  }
  quickAction(args) {
    let container = this.builder.doc.querySelector(this.builder.container);
    if (!container) return true;
    if (args.select_block) {
      if (this.builder.canvas) return;
      const selectElement = row => {
        if (!row) return;
        let col, elm;
        if (row) col = row.querySelector(':first-child');
        if (col) col.click(); // select column 

        if (col) elm = col.querySelector(':first-child');
        if (elm) elm.click(); // select element 
      };

      const selectFirst = () => {
        let row = container.querySelector(':first-child');
        selectElement(row);
      };
      const selectLast = () => {
        let lastRow;
        const childElements = container.children;
        for (let i = childElements.length - 1; i >= 0; i--) {
          const childElement = childElements[i];

          // Check if the child element has at least one grandchild element
          if (childElement.querySelector(':first-child')) {
            // Found a child element with a grandchild
            lastRow = childElement;
            break; // Exit the loop after finding the last one
          }
        }

        if (lastRow) {
          selectElement(lastRow);
        }
      };
      if (args.select_block === 'block') {
        let elm = container.querySelector('h1, p, h2, h3');
        if (elm) elm.click();else {
          elm = container.querySelector('.is-container > div > div');
          if (elm) elm.click();
        }
        return true;
      } else if (args.select_block === 'headline' || args.select_block === 'title') {
        const elm = container.querySelector('h1,h2,h3');
        if (elm) elm.click();
        return true;
      } else if (args.select_block === 'paragraph') {
        const elm = container.querySelector('p');
        if (elm) elm.click();
        return true;
      } else if (args.select_block === 'image') {
        const elm = container.querySelector('img');
        if (elm) elm.click();
        return true;
      } else if (args.select_block === 'space') {
        const elm = container.querySelector('div.spacer');
        if (elm) elm.click();
        return true;
      } else if (args.select_block === 'button') {
        const elm = container.querySelector('a[role="button"]');
        if (elm) elm.click();
        return true;
      } else if (args.select_block === 'next') {
        let row = container.querySelector('.row-active');
        if (row) row = row.nextElementSibling;
        selectElement(row);
        return true;
      } else if (args.select_block === 'previous') {
        let row = container.querySelector('.row-active');
        if (row) row = row.previousElementSibling;
        selectElement(row);
        return true;
      } else if (args.select_block === 'first') {
        selectFirst();
        return true;
      } else if (args.select_block === 'last') {
        selectLast();
        return true;
      }
    }
    if (args.unselect_block) {
      this.builder.doc.body.click();
      return true;
    }
    return false;
  }
  chooseContext(list, num) {
    // random, but will be different from two previous results.
    if (typeof num !== 'undefined') {
      return list[num];
    }
    if (!this.previousIndexes) this.previousIndexes = [];
    let randomIndex = Math.floor(Math.random() * list.length);
    if (this.previousIndexes.includes(randomIndex) && this.previousIndexes.length < list.length) {
      return this.chooseContext(list);
    }
    this.previousIndexes.push(randomIndex);
    if (this.previousIndexes.length > 2) {
      this.previousIndexes.shift();
    }
    return list[randomIndex];
  }
}

var stringSimilarity = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringSimilarity = void 0;
/* global exports, Map */
/**
 * Calculate similarity between two strings
 * @param {string} str1 First string to match
 * @param {string} str2 Second string to match
 * @param {number} [substringLength=2] Optional. Length of substring to be used in calculating similarity. Default 2.
 * @param {boolean} [caseSensitive=false] Optional. Whether you want to consider case in string matching. Default false;
 * @returns Number between 0 and 1, with 0 being a low match score.
 */
var stringSimilarity = function (str1, str2, substringLength, caseSensitive) {
    if (substringLength === void 0) { substringLength = 2; }
    if (caseSensitive === void 0) { caseSensitive = false; }
    if (!caseSensitive) {
        str1 = str1.toLowerCase();
        str2 = str2.toLowerCase();
    }
    if (str1.length < substringLength || str2.length < substringLength)
        return 0;
    var map = new Map();
    for (var i = 0; i < str1.length - (substringLength - 1); i++) {
        var substr1 = str1.substr(i, substringLength);
        map.set(substr1, map.has(substr1) ? map.get(substr1) + 1 : 1);
    }
    var match = 0;
    for (var j = 0; j < str2.length - (substringLength - 1); j++) {
        var substr2 = str2.substr(j, substringLength);
        var count = map.has(substr2) ? map.get(substr2) : 0;
        if (count > 0) {
            map.set(substr2, count - 1);
            match++;
        }
    }
    return (match * 2) / (str1.length + str2.length - ((substringLength - 1) * 2));
};
exports.stringSimilarity = stringSimilarity;
exports.default = exports.stringSimilarity;

}(stringSimilarity));

class Similarity {
  constructor(builder) {
    this.builder = builder;
  }
  checkSimilarity(word1, word2) {
    word1 = word1.toLowerCase();
    word2 = word2.toLowerCase();
    const similarity = stringSimilarity.stringSimilarity(word1, word2);
    return similarity;
  }
  check(command) {
    const {
      commandList
    } = this.builder.settings;
    let maxSimilarity = 0;
    let maxKey = '';
    for (const [key, value] of Object.entries(commandList)) {
      const similarity = this.calculate(command, value);
      if (similarity > maxSimilarity) {
        maxSimilarity = similarity;
        maxKey = key;
      }
    }
    const similarityThreshold = this.builder.similarityThreshold; //0.65;
    if (maxSimilarity >= similarityThreshold) {
      return maxKey;
    }
    return false;
  }
  calculate(command, list) {
    const normalizedCommand = command.toLowerCase();
    let maxSimilarity = 0;
    for (const cmd of list) {
      const similarity = stringSimilarity.stringSimilarity(normalizedCommand, cmd);
      if (similarity > maxSimilarity) {
        maxSimilarity = similarity;
      }
    }
    return maxSimilarity;
  }
}

class Common {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.onDuplicate = options && options.onDuplicate || null;
  }
  transform2d(block, x1, y1, x2, y2, x3, y3, x4, y4) {
    this.matrix3d = new Matrix3D();
    return this.matrix3d.transform2d(block, x1, y1, x2, y2, x3, y3, x4, y4);
  }
  setZoom(scale) {
    this.zoom = scale;
  }
  applyPercentage(block) {
    const zoom = this.zoom;
    const rect = this.getRect(block);
    let container = block.closest('.box-canvas');
    if (block.parentNode.closest(this.selector)) {
      // block is in  group
      container = block.parentNode.closest(this.selector);
    }
    const containerRect = this.getRect(container); // if container has top/left

    this.horizontalRulerTop = container.querySelector('.h-ruler-top'); // no rulers in group
    this.horizontalRulerBottom = container.querySelector('.h-ruler-bottom');
    this.horizontalRulerMiddle = container.querySelector('.h-ruler-middle');
    this.verticalRulerLeft = container.querySelector('.v-ruler-left');
    this.verticalRulerRight = container.querySelector('.v-ruler-right');
    this.verticalRulerCenter = container.querySelector('.v-ruler-center');

    // Check Edges
    let topTouched = false;
    let bottomTouched = false;
    let leftTouched = false;
    let rightTouched = false;
    if (this.horizontalRulerTop && this.horizontalRulerTop.hasAttribute('data-topTouched')) topTouched = true;
    if (this.horizontalRulerBottom && this.horizontalRulerBottom.hasAttribute('data-bottomTouched')) bottomTouched = true;
    if (this.verticalRulerLeft && this.verticalRulerLeft.hasAttribute('data-leftTouched')) leftTouched = true;
    if (this.verticalRulerRight && this.verticalRulerRight.hasAttribute('data-rightTouched')) rightTouched = true;
    let isChildBlock = false;
    if (block.parentNode.matches(this.selector)) {
      // child block
      isChildBlock = true;
    }

    // const containerRect = container.getBoundingClientRect(); // if container has top/left
    // const containerRect = this.getRect(container); // if container has top/left
    let left = (rect.left - containerRect.left) / container.offsetWidth * 100;
    let top = (rect.top - containerRect.top) / container.offsetHeight * 100;
    let isBlockFixed = block.classList.contains('block-steady');
    if (isBlockFixed) {
      let dividerTop = (container.offsetHeight - block.offsetHeight) / (rect.top - containerRect.top) * zoom;
      if (isNaN(dividerTop)) {
        // there is possibility of 0/0
        dividerTop = 1;
      }
      block.style.top = `calc((100% - ${block.offsetHeight}px)/${dividerTop})`;
      if (isChildBlock) {
        block.style.top = top + '%';
      }
      let dividerLeft = (container.offsetWidth - block.offsetWidth) / (rect.left - containerRect.left) * zoom;
      if (isNaN(dividerLeft)) {
        // there is possibility of 0/0
        dividerLeft = 1;
      }
      // if(rect.left-containerRect.left===0) { // dividerLeft = Infinity
      //     dividerLeft=1; 
      // }
      block.style.left = `calc((100% - ${block.offsetWidth}px)/${dividerLeft})`;
      if (isChildBlock) {
        block.style.left = left + '%';
      }

      // fix
      if (dividerTop === 0) block.style.top = top + '%';
      if (dividerLeft === 0) block.style.left = left + '%';
    } else {
      const width = block.offsetWidth / container.offsetWidth * 100;
      const height = block.offsetHeight / container.offsetHeight * 100;
      block.style.width = width + '%';
      block.style.height = height + '%';
      block.style.top = top / zoom + '%';
      block.style.left = left / zoom + '%';
      if (block.classList.contains('height-auto')) block.style.height = '';
    }

    // Check

    block.style.right = ''; //reset
    block.style.bottom = ''; //reset

    if (topTouched) block.style.top = 0;
    // if(topTouched && bottomTouched) block.style.height = '100%';
    if (leftTouched) block.style.left = 0;
    // if(leftTouched && rightTouched) block.style.width = '100%';

    if (topTouched && bottomTouched) {
      block.style.top = 0;
      if (!block.classList.contains('height-auto')) block.style.bottom = 0; // height-auto should not have bottom=0
      block.style.height = '';
    }
    if (leftTouched && rightTouched) {
      block.style.left = 0;
      block.style.right = 0;
      block.style.width = '';
    }
    if (bottomTouched && !topTouched) {
      if (!block.classList.contains('height-auto')) block.style.bottom = 0; // height-auto should not have bottom=0
      block.style.height = '';
    }
    if (rightTouched && !leftTouched) {
      block.style.right = 0;
      block.style.width = '';
    }

    // reset
    setTimeout(() => {
      if (this.horizontalRulerTop) this.horizontalRulerTop.removeAttribute('data-topTouched');
      if (this.horizontalRulerBottom) this.horizontalRulerBottom.removeAttribute('data-bottomTouched');
      if (this.verticalRulerLeft) this.verticalRulerLeft.removeAttribute('data-leftTouched');
      if (this.verticalRulerRight) this.verticalRulerRight.removeAttribute('data-rightTouched');
    }, 10);
  }
  applyPixels(block) {
    const zoom = this.zoom;
    const rect = this.getRect(block);
    const containerRect = this.getRect(block.parentNode); // if container has top/left
    block.style.left = (rect.left - containerRect.left) / zoom + 'px';
    block.style.top = (rect.top - containerRect.top) / zoom + 'px';
    block.style.width = block.offsetWidth + 'px';
  }
  updateHeight(block) {
    if (!block.parentNode) return;
    let clonedDiv = block.cloneNode(true);
    clonedDiv.style.position = 'absolute';
    clonedDiv.style.top = '-9999px';
    clonedDiv.style.left = '-9999px';
    block.parentNode.appendChild(clonedDiv);
    clonedDiv.style.height = '';
    setTimeout(() => {
      let clonedDivHeight = clonedDiv.offsetHeight;
      if (block.offsetHeight <= clonedDivHeight) {
        block.style.height = clonedDivHeight + 'px';
        setTimeout(() => {
          block.parentNode.removeChild(clonedDiv);
        }, 10);
      } else {
        block.parentNode.removeChild(clonedDiv);
      }
    }, 10);
  }
  duplicate() {
    const block = this.doc.querySelector(this.selector + '.active');
    if (!block) return;
    if (this.onDuplicate) this.onDuplicate(block);
  }
  getRect(element) {
    let group = element.parentNode.closest(this.selector);
    if (element.closest(this.selector) && group) {
      let transform = group.style.transform;
      if (transform.includes('rotate')) {
        // Create a temporary element with the same dimensions and position
        const tempGroup = this.doc.createElement('div');
        tempGroup.style.position = 'absolute';
        tempGroup.style.width = group.offsetWidth + 'px';
        tempGroup.style.height = group.offsetHeight + 'px';
        tempGroup.style.left = group.style.left;
        tempGroup.style.top = group.style.top;
        // tempGroup.style.border ='red 1px solid';
        group.parentNode.appendChild(tempGroup);
        // const wrapperRect = tempGroup.getBoundingClientRect(); // Get the unrotated position

        // Create a temporary element with the same dimensions and position
        const tempElement = this.doc.createElement('div');
        tempElement.style.position = 'absolute';
        tempElement.style.width = element.offsetWidth + 'px';
        tempElement.style.height = element.offsetHeight + 'px';
        tempElement.style.left = element.style.left;
        tempElement.style.top = element.style.top;
        // tempElement.style.border ='green 1px solid';
        tempGroup.appendChild(tempElement);
        const tempRect = tempElement.getBoundingClientRect(); // Get the unrotated position

        // let top = tempRect.top - wrapperRect.top;
        // let left = tempRect.left - wrapperRect.left;

        setTimeout(() => {
          tempElement.parentNode.removeChild(tempElement);
          tempGroup.parentNode.removeChild(tempGroup);
        }, 0);
        return tempRect;
      }
    }
    const rect = element.getBoundingClientRect();
    const transform = this.win.getComputedStyle(element).getPropertyValue('transform');
    if (transform !== 'none') {
      // Create a temporary element with the same dimensions and position
      const tempElement = this.doc.createElement('div');
      tempElement.style.position = 'absolute';
      tempElement.style.width = element.offsetWidth + 'px';
      tempElement.style.height = element.offsetHeight + 'px';
      tempElement.style.left = element.style.left;
      tempElement.style.top = element.style.top;
      // tempElement.style.border ='green 1px solid';
      element.parentNode.appendChild(tempElement);

      // Get the unrotated position of the temporary element
      const tempRect = tempElement.getBoundingClientRect();
      setTimeout(() => {
        tempElement.parentNode.removeChild(tempElement);
      }, 1);
      return tempRect;
    } else {
      return rect;
    }
  }
  getTranslateValues(transformString) {
    // Regular expression to match the translate values in the transform string
    const regex = /translate\((-?\d+\.?\d*)px, (-?\d+\.?\d*)px\)/;

    // Use the regular expression to extract x and y values
    const match = transformString.match(regex);

    // If there's a match, return an object with x and y values
    if (match) {
      const [, x, y] = match.map(parseFloat);
      return {
        x,
        y
      };
    }

    // If no match, return null or handle it as needed
    return null;
  }
  group(className = 'is-block', groupClassName = 'is-group') {
    let top = Infinity;
    let left = Infinity;
    let bottom = -Infinity;
    let right = -Infinity;

    // Check group
    let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active'));
    if (blocks.length <= 1) return;

    // Check if there is selected block that is part of other group
    let ok = true;
    blocks.forEach(block => {
      if (block.parentNode.matches(this.selector)) {
        // TODO: detach block
        alert('One or more blocks belong to another group.');
        ok = false;
      }
    });
    if (!ok) return;
    blocks.forEach(block => {
      let elms = block.querySelectorAll(this.selector);
      if (elms.length > 0) {
        elms.forEach(elm => elm.classList.add('active'));
        this.unGroup(block);
      }
    });
    blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active'));
    blocks.forEach(block => {
      if (!block.parentNode.matches(this.selector)) {
        const rect = this.getRect(block);
        let blockTop = rect.top;
        let blockLeft = rect.left;
        let blockWidth = block.offsetWidth;
        let blockHeight = block.offsetHeight;
        top = Math.min(top, blockTop);
        left = Math.min(left, blockLeft);
        bottom = Math.max(bottom, blockTop + blockHeight);
        right = Math.max(right, blockLeft + blockWidth);
      }
    });
    const container = blocks[0].parentNode;
    const containerRect = this.getRect(container);
    const group = this.doc.createElement('div');
    group.classList.add(className);
    group.classList.add(groupClassName);
    group.classList.add('block-steady');
    group.style.top = top - containerRect.top + 'px';
    group.style.left = left - containerRect.left + 'px';
    group.style.width = right + 1 - left + 'px';
    group.style.height = bottom + 1 - top + 'px';
    container.appendChild(group);
    blocks.forEach(block => {
      if (!block.parentNode.matches(this.selector)) {
        this.applyPixels(block);
        let blockTop = parseFloat(block.style.top) || 0;
        let blockLeft = parseFloat(block.style.left) || 0;

        // Adjust position relative to the group div
        block.style.top = blockTop - top + containerRect.top + 'px';
        block.style.left = blockLeft - left + containerRect.left + 'px';
        group.appendChild(block);
        this.applyPercentage(block);
      }
    });
    this.applyPercentage(group);
    blocks.forEach(block => {
      block.classList.remove('active');
    });
    group.classList.add('active');
    blocks = group.querySelectorAll(this.selector);
    blocks.forEach(target => {
      // Remove all breakpoints
      let attributesToRemove = [];
      const attributes = target.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attributeName = attributes[i].name;
        if (attributeName.includes('data--t-') || attributeName.includes('data--l-') || attributeName.includes('data--b-') || attributeName.includes('data--r-') || attributeName.includes('data--w-') || attributeName.includes('data--h-')) {
          attributesToRemove.push(attributeName);
        }
      }
      attributesToRemove.forEach(attr => {
        target.removeAttribute(attr);
      });

      // Make/save current inline style as default
      target.removeAttribute('data-breakpoint');
      target.setAttribute('data--t', target.style.top);
      target.setAttribute('data--l', target.style.left);
      target.setAttribute('data--b', target.style.bottom); // if target.style.bottom not exists, data--b attribute is created without value = ""
      target.setAttribute('data--r', target.style.right);
      target.setAttribute('data--w', target.style.width);
      target.setAttribute('data--h', target.style.height);
    });
    return group;
  }
  unGroup(element) {
    let group;
    if (element) group = element;else {
      let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active'));
      blocks.forEach(block => {
        if (block.querySelector(this.selector)) {
          // this block is a group
          this.unGroup(block);
        }
      });
      return;
    }
    if (!group) return;
    if (!group.querySelector(this.selector)) return;
    this.applyPixels(group);
    const rect = this.getRect(group);
    const top = rect.top;
    const left = rect.left;
    const container = group.parentNode;
    const containerRect = this.getRect(container);
    group.querySelectorAll(this.selector).forEach(block => {
      this.applyPixels(block);
      let blockTop = parseFloat(block.style.top) || 0;
      let blockLeft = parseFloat(block.style.left) || 0;

      // Adjust position relative to the group div
      block.style.top = blockTop + top - containerRect.top + 'px';
      block.style.left = blockLeft + left - containerRect.left + 'px';
      container.appendChild(block);

      // Remove all breakpoints
      let attributesToRemove = [];
      const attributes = block.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attributeName = attributes[i].name;
        if (attributeName.includes('data--t-') || attributeName.includes('data--l-') || attributeName.includes('data--b-') || attributeName.includes('data--r-') || attributeName.includes('data--w-') || attributeName.includes('data--h-')) {
          attributesToRemove.push(attributeName);
        }
      }
      attributesToRemove.forEach(attr => {
        block.removeAttribute(attr);
      });
      // Make/save current inline style as default
      block.removeAttribute('data-breakpoint');
      block.setAttribute('data--t', block.style.top);
      block.setAttribute('data--l', block.style.left);
      block.setAttribute('data--b', block.style.bottom);
      block.setAttribute('data--r', block.style.right);
      block.setAttribute('data--w', block.style.width);
      block.setAttribute('data--h', block.style.height);
      this.applyPercentage(block);
    });
    group.parentElement.removeChild(group);
  }
  addBreakpoint() {
    const viewportWidth = this.win.innerWidth;
    this.doc.body.setAttribute('data-breakpoint', viewportWidth);
  }
  clearBreakpoint(target) {
    let attributesToRemove = [];
    const attributes = target.attributes;
    for (let i = 0; i < attributes.length; i++) {
      const attributeName = attributes[i].name;
      if (attributeName.includes('data--t-') || attributeName.includes('data--l-') || attributeName.includes('data--b-') || attributeName.includes('data--r-') || attributeName.includes('data--w-') || attributeName.includes('data--h-') || attributeName.includes('data--transform-') || attributeName.includes('data--matrix-')) {
        attributesToRemove.push(attributeName);
      }
    }
    attributesToRemove.forEach(attr => {
      target.removeAttribute(attr);
    });
    target.removeAttribute('data-breakpoint');

    // reset
    let top = target.getAttribute('data--t');
    if (top) target.style.top = top;
    let left = target.getAttribute('data--l');
    if (left) target.style.left = left;
    let bottom = target.getAttribute('data--b');
    if (bottom) target.style.bottom = bottom;
    let right = target.getAttribute('data--r');
    if (right) target.style.right = right;
    let width = target.getAttribute('data--w');
    if (width) target.style.width = width;
    let height = target.getAttribute('data--h');
    if (height) target.style.height = height;
    if (left && !right) target.style.right = '';
    if (right && !left) target.style.left = '';
    if (top && !bottom) target.style.bottom = '';
    if (bottom && !top) target.style.top = '';
  }
  clearAllBreakpoints(container) {
    // REVIEW (Currently not used)
    const elements = container.querySelectorAll(this.selector);
    elements.forEach(target => {
      let attributesToRemove = [];
      const attributes = target.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attributeName = attributes[i].name;
        if (attributeName.includes('data--t-') || attributeName.includes('data--l-') || attributeName.includes('data--b-') || attributeName.includes('data--r-') || attributeName.includes('data--w-') || attributeName.includes('data--h-') || attributeName.includes('data--transform-') || attributeName.includes('data--matrix-')) {
          attributesToRemove.push(attributeName);
        }
      }
      attributesToRemove.forEach(attr => {
        target.removeAttribute(attr);
      });
    });
    elements.forEach(target => {
      let t = target.getAttribute('data--t');
      let l = target.getAttribute('data--l');
      let b = target.getAttribute('data--b');
      let r = target.getAttribute('data--r');
      let w = target.getAttribute('data--w');
      let h = target.getAttribute('data--h');
      if (t) target.style.top = t;
      if (l) target.style.left = l;
      if (b) target.style.bottom = b;
      if (r) target.style.right = r;
      if (w) target.style.width = w;
      if (h) target.style.height = h;
      if (l && !r) target.style.right = '';
      if (r && !l) target.style.left = '';
      if (t && !b) target.style.bottom = '';
      if (b && !t) target.style.top = '';
    });
  }
  getBreakpoints(target) {
    let breakpoints = [];
    const attributes = target.attributes;
    for (let i = 0; i < attributes.length; i++) {
      const attributeName = attributes[i].name;
      if (attributeName.includes('data--t-') || attributeName.includes('data--l-') || attributeName.includes('data--b-') || attributeName.includes('data--r-') || attributeName.includes('data--w-') || attributeName.includes('data--h-')) {
        let val = attributeName.replace('data--t-', '');
        val = val.replace('data--l-', '');
        val = val.replace('data--b-', '');
        val = val.replace('data--r-', '');
        val = val.replace('data--w-', '');
        val = val.replace('data--h-', '');
        if (!breakpoints.includes(val)) breakpoints.push(val);
      }
    }
    return breakpoints;
  }
  getSelectedBlock() {
    const blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && !elm.classList.contains('cloned'));
    if (blocks.length === 1) {
      const block = blocks[0];
      return block;
    }
    return false;
  }
  checkOverlap(target) {
    const targetRect = target.getBoundingClientRect();
    const blocks = Array.from(target.parentNode.querySelectorAll(this.selector)).filter(elm => !elm.classList.contains('cloned'));
    let overlappedBlocks = [];
    for (const block of blocks) {
      if (block !== target) {
        const blockRect = block.getBoundingClientRect();
        if (targetRect.top < blockRect.bottom && targetRect.bottom > blockRect.top && targetRect.left < blockRect.right && targetRect.right > blockRect.left) {
          overlappedBlocks.push(block);
        }
      }
    }
    return overlappedBlocks;
  }
}
class Matrix3D {
  adj(m) {
    return [m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4], m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5], m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]];
  }
  multmm(a, b) {
    const c = Array(9);
    for (var i = 0; i != 3; ++i) {
      for (var j = 0; j != 3; ++j) {
        var cij = 0;
        for (var k = 0; k != 3; ++k) {
          cij += a[3 * i + k] * b[3 * k + j];
        }
        c[3 * i + j] = cij;
      }
    }
    return c;
  }
  multmv(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }
  pdbg(m, v) {
    const r = this.multmv(m, v);
    return r + ' (' + r[0] / r[2] + ', ' + r[1] / r[2] + ')';
  }
  basisToPoints(x1, y1, x2, y2, x3, y3, x4, y4) {
    const m = [x1, x2, x3, y1, y2, y3, 1, 1, 1];
    const v = this.multmv(this.adj(m), [x4, y4, 1]);
    return this.multmm(m, [v[0], 0, 0, 0, v[1], 0, 0, 0, v[2]]);
  }
  general2DProjection(x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    const s = this.basisToPoints(x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
    const d = this.basisToPoints(x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
    return this.multmm(d, this.adj(s));
  }
  project(m, x, y) {
    const v = this.multmv(m, [x, y, 1]);
    return [v[0] / v[2], v[1] / v[2]];
  }
  transform2d(element, x1, y1, x2, y2, x3, y3, x4, y4) {
    const w = element.offsetWidth,
      h = element.offsetHeight;
    let t = this.general2DProjection(0, 0, x1, y1, w, 0, x2, y2, 0, h, x3, y3, w, h, x4, y4);
    for (let i = 0; i != 9; ++i) t[i] = t[i] / t[8];
    t = [t[0], t[3], 0, t[6], t[1], t[4], 0, t[7], 0, 0, 1, 0, t[2], t[5], 0, t[8]];
    t = 'matrix3d(' + t.join(', ') + ')';
    return t;
  }
}
class Ruler {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    const rulerHTML = `
            <div class="ruler horizontal-ruler" id="horizontal-ruler-top"></div>
            <div class="ruler horizontal-ruler" id="horizontal-ruler-bottom"></div>
            <div class="ruler horizontal-ruler" id="horizontal-ruler-middle"></div>
            <div class="ruler vertical-ruler" id="vertical-ruler-left"></div>
            <div class="ruler vertical-ruler" id="vertical-ruler-right"></div>
            <div class="ruler vertical-ruler" id="vertical-ruler-center"></div>
        `;
    if (!this.doc.getElementById('horizontal-ruler-top')) this.doc.body.insertAdjacentHTML('beforeend', rulerHTML);
    this.horizontalRulerTop = this.doc.getElementById('horizontal-ruler-top');
    this.horizontalRulerBottom = this.doc.getElementById('horizontal-ruler-bottom');
    this.horizontalRulerMiddle = this.doc.getElementById('horizontal-ruler-middle');
    this.verticalRulerLeft = this.doc.getElementById('vertical-ruler-left');
    this.verticalRulerRight = this.doc.getElementById('vertical-ruler-right');
    this.verticalRulerCenter = this.doc.getElementById('vertical-ruler-center');
    this.setup();
  }
  setZoom(scale) {
    this.zoom = scale;
  }
  setup() {
    // this.elements = this.doc.querySelectorAll(this.selector);
    this.refresh();
  }
  refresh() {
    this.elements = this.doc.querySelectorAll(this.selector);
    const rulerHTML = `
            <div class="ruler h-ruler h-ruler-top""></div>
            <div class="ruler h-ruler h-ruler-bottom"></div>
            <div class="ruler h-ruler h-ruler-middle"></div>
            <div class="ruler v-ruler v-ruler-left"></div>
            <div class="ruler v-ruler v-ruler-right"></div>
            <div class="ruler v-ruler v-ruler-center"></div>
        `;
    const containers = this.doc.querySelectorAll('.box-canvas');
    containers.forEach(container => {
      if (!container.querySelector('.h-ruler-top')) container.insertAdjacentHTML('beforeend', rulerHTML);
    });
  }
  destroy() {
    [this.horizontalRulerTop, this.horizontalRulerBottom, this.verticalRulerLeft, this.verticalRulerRight].forEach(elm => {
      if (elm.parentNode) elm.parentNode.removeChild(elm);
    });
  }
  hideRulers() {
    this.horizontalRulerTop.classList.remove('active');
    this.horizontalRulerBottom.classList.remove('active');
    this.horizontalRulerMiddle.classList.remove('active');
    this.verticalRulerLeft.classList.remove('active');
    this.verticalRulerRight.classList.remove('active');
    this.verticalRulerCenter.classList.remove('active');
    this.rulerTop = null;
    this.rulerBottom = null; //new
    this.rulerLeft = null;
    this.rulerRight = null;
  }
  hideRulers_bak() {
    this.horizontalRulerTop.style.top = '-1000px';
    this.horizontalRulerBottom.style.top = '-1000px';
    this.horizontalRulerMiddle.style.top = '-1000px';
    this.verticalRulerLeft.style.left = '-1000px';
    this.verticalRulerRight.style.left = '-1000px';
    this.verticalRulerCenter.style.left = '-1000px';
    this.rulerTop = null;
    this.rulerBottom = null; //new
    this.rulerLeft = null;
    this.rulerRight = null;
  }
  updateRulers(block) {
    if (block.parentNode.closest(this.selector)) return; // block is in  group

    const container = block.closest('.box-canvas');
    this.horizontalRulerTop = container.querySelector('.h-ruler-top');
    this.horizontalRulerBottom = container.querySelector('.h-ruler-bottom');
    this.horizontalRulerMiddle = container.querySelector('.h-ruler-middle');
    this.verticalRulerLeft = container.querySelector('.v-ruler-left');
    this.verticalRulerRight = container.querySelector('.v-ruler-right');
    this.verticalRulerCenter = container.querySelector('.v-ruler-center');
    let transform = block.style.transform;
    if (transform.includes('rotate') || transform.includes('matrix3d')) return;
    let parentTransform = block.parentNode.style.transform;
    if (parentTransform.includes('rotate')) return;
    this.hideRulers();
    const top = block.offsetTop;
    const bottom = top + block.offsetHeight;
    const left = block.offsetLeft;
    const right = left + block.offsetWidth;
    const center = left + block.offsetWidth / 2;
    const middle = top + block.offsetHeight / 2;
    this.rulerTop = null;
    this.rulerBottom = null; //new
    this.rulerLeft = null;
    this.rulerRight = null;
    this.elements = container.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      if (element.parentNode.closest(this.selector)) return; // block is in  group

      if (!this.doc.body.contains(element)) return; // in case element removed (eg. unGroup, block deleted)

      if (block.contains(element)) return; // In case of group moving

      let transform = element.style.transform;
      let parentTransform = element.parentNode.style.transform;
      if (!transform.includes('rotate') && !parentTransform.includes('rotate') && !transform.includes('matrix3d') && !parentTransform.includes('matrix3d') && element !== block && !element.classList.contains('cloned')) {
        const otherTop = element.offsetTop;
        const otherBottom = otherTop + element.offsetHeight;
        const otherLeft = element.offsetLeft;
        const otherRight = otherLeft + element.offsetWidth;
        const otherMiddle = otherTop + element.offsetHeight / 2;
        const otherCenter = otherLeft + element.offsetWidth / 2;

        // block top
        if (otherTop - 4 <= top && top <= otherTop + 4) {
          this.horizontalRulerTop.style.top = otherTop + 'px';
          this.horizontalRulerTop.classList.add('active');
          let val = otherTop;
          if (this.rulerTop === null) this.rulerTop = val;
        }
        if (otherBottom - 4 <= top && top <= otherBottom + 4) {
          this.horizontalRulerTop.style.top = otherBottom + 'px';
          this.horizontalRulerTop.classList.add('active');
          let val = otherBottom;
          if (this.rulerTop === null) this.rulerTop = val;
        }

        // block bottom
        if (otherTop - 4 <= bottom && bottom <= otherTop + 4) {
          /*
                              _____
          ___________________|__x__|__ rulerBottom
          | other |
           */
          this.horizontalRulerBottom.style.top = otherTop + 'px';
          this.horizontalRulerBottom.classList.add('active');
          if (this.rulerBottom === null) this.rulerBottom = element.offsetTop; // new
        }

        if (otherBottom - 4 <= bottom && bottom <= otherBottom + 4) {
          /*
                              _____
          | other |__________|__x__|__ rulerBottom
          
          */
          this.horizontalRulerBottom.style.top = otherBottom + 'px';
          this.horizontalRulerBottom.classList.add('active');
          if (this.rulerBottom === null) this.rulerBottom = element.offsetTop + element.offsetHeight; // new
        }

        // block middle
        if (this.rulerTop === null && this.rulerBottom === null) {
          if (otherMiddle - 4 <= middle && middle <= otherMiddle + 4) {
            this.horizontalRulerMiddle.style.top = otherTop + (element.offsetHeight - block.offsetHeight) / 2 + block.offsetHeight / 2 + 'px';
            this.horizontalRulerMiddle.classList.add('active');
            let val = otherTop + (element.offsetHeight - block.offsetHeight) / 2;
            if (this.rulerTop === null) this.rulerTop = val;
          }
        }

        // block left
        if (otherLeft - 4 <= left && left <= otherLeft + 4) {
          this.verticalRulerLeft.style.left = otherLeft + 'px';
          this.verticalRulerLeft.classList.add('active');
          let val = otherLeft;
          if (this.rulerLeft === null) this.rulerLeft = val;
        }
        if (otherRight - 4 <= left && left <= otherRight + 4) {
          this.verticalRulerLeft.style.left = otherRight + 'px';
          this.verticalRulerLeft.classList.add('active');
          let val = otherRight;
          if (this.rulerLeft === null) this.rulerLeft = val;
        }

        // block right
        if (otherLeft - 4 <= right && right <= otherLeft + 4) {
          this.verticalRulerRight.style.left = otherLeft + 'px';
          this.verticalRulerRight.classList.add('active');
          let val = otherLeft;
          if (this.rulerRight === null) this.rulerRight = val;
        }
        if (otherRight - 4 <= right && right <= otherRight + 4) {
          this.verticalRulerRight.style.left = otherRight + 'px';
          this.verticalRulerRight.classList.add('active');
          let val = otherRight;
          if (this.rulerRight === null) this.rulerRight = val;
        }

        // block center
        if (this.rulerLeft === null && this.rulerRight === null) {
          if (otherCenter - 4 <= center && center <= otherCenter + 4) {
            this.verticalRulerCenter.style.left = otherLeft + (element.offsetWidth - block.offsetWidth) / 2 + block.offsetWidth / 2 + 'px';
            this.verticalRulerCenter.classList.add('active');
            let val = otherLeft + (element.offsetWidth - block.offsetWidth) / 2;
            if (this.rulerLeft === null) this.rulerLeft = val;
          }
        }
      }
    });

    // Edges
    const conTop = 0;
    const conBottom = container.offsetHeight;
    const conLeft = 0;
    const conRight = container.offsetWidth;
    const conCenter = container.offsetWidth / 2;
    const conMiddle = container.offsetHeight / 2;

    // block top
    this.horizontalRulerTop.removeAttribute('data-topTouched');
    if (conTop - 4 <= top && top <= conTop + 4) {
      this.horizontalRulerTop.style.top = conTop + 'px';
      this.horizontalRulerTop.classList.add('active');
      let val = conTop;
      if (this.rulerTop === null) this.rulerTop = val;
      this.topTouched = true;
      this.horizontalRulerTop.setAttribute('data-topTouched', 1);
    }

    // block bottom
    this.horizontalRulerBottom.removeAttribute('data-bottomTouched');
    if (conBottom - 4 <= bottom && bottom <= conBottom + 4) {
      this.horizontalRulerBottom.style.top = conBottom - 2 + 'px'; // -2 is an adjustment to make the line visible
      this.horizontalRulerBottom.classList.add('active');
      if (this.rulerBottom === null) this.rulerBottom = conBottom; //conRect.height;// or block.parentNode.offsetHeight; // new

      this.bottomTouched = true;
      this.horizontalRulerBottom.setAttribute('data-bottomTouched', 1);
    }

    // block middle
    if (this.rulerTop === null && this.rulerBottom === null) {
      if (conMiddle - 4 <= middle && middle <= conMiddle + 4) {
        this.horizontalRulerMiddle.style.top = conTop + (block.parentNode.offsetHeight - block.offsetHeight) / 2 + block.offsetHeight / 2 + 'px';
        this.horizontalRulerMiddle.classList.add('active');
        let val = conTop + (block.parentNode.offsetHeight - block.offsetHeight) / 2;
        if (this.rulerTop === null) this.rulerTop = val;
      }
    }

    // block left
    this.verticalRulerLeft.removeAttribute('data-leftTouched');
    if (conLeft - 4 <= left && left <= conLeft + 4) {
      this.verticalRulerLeft.style.left = conLeft + 0 + 'px'; // +0 is an adjustment
      this.verticalRulerLeft.classList.add('active');
      let val = conLeft;
      if (this.rulerLeft === null) this.rulerLeft = val;
      this.verticalRulerLeft.setAttribute('data-leftTouched', 1);
    }

    // block right
    this.verticalRulerRight.removeAttribute('data-rightTouched');
    if (conRight - 4 <= right && right <= conRight + 4) {
      this.verticalRulerRight.style.left = conRight - 2 + 'px'; // -2 is an adjustment
      this.verticalRulerRight.classList.add('active');
      let val = conRight;
      if (this.rulerRight === null) this.rulerRight = val;
      this.verticalRulerRight.setAttribute('data-rightTouched', 1);
    }

    // block center
    if (this.rulerLeft === null && this.rulerRight === null) {
      if (conCenter - 4 <= center && center <= conCenter + 4) {
        this.verticalRulerCenter.style.left = conLeft + (block.parentNode.offsetWidth - block.offsetWidth) / 2 + block.offsetWidth / 2 + 'px';
        this.verticalRulerCenter.classList.add('active');
        let val = conLeft + (block.parentNode.offsetWidth - block.offsetWidth) / 2;
        if (this.rulerLeft === null) this.rulerLeft = val;
      }
    }
  }
  updateRulers_bak(block) {
    // if(block.querySelector(this.selector)) return; // group (because updateRules also calls parent group if child block is dragged)

    let transform = block.style.transform;
    if (transform.includes('rotate') || transform.includes('matrix3d')) return;
    let parentTransform = block.parentNode.style.transform;
    if (parentTransform.includes('rotate')) return;
    if (this.zoom * 1 !== 1) return; // disable rulers on zoomed page

    this.hideRulers();
    const rect = block.getBoundingClientRect();
    const top = rect.top;
    const bottom = top + block.offsetHeight;
    const left = rect.left;
    const right = left + block.offsetWidth;
    const center = left + block.offsetWidth / 2;
    const middle = top + block.offsetHeight / 2;
    this.rulerTop = null;
    this.rulerBottom = null; //new
    this.rulerLeft = null;
    this.rulerRight = null;
    let containerTop = 0;
    const container = block.parentNode;
    if (container) {
      this.elements = container.querySelectorAll(this.selector);
      containerTop = this.win.scrollY;
    }
    this.elements.forEach(element => {
      if (!this.doc.body.contains(element)) return; // in case element removed (eg. unGroup, block deleted)

      if (block.contains(element)) return; // In case of group moving

      let transform = element.style.transform;
      let parentTransform = element.parentNode.style.transform;
      if (!transform.includes('rotate') && !parentTransform.includes('rotate') && !transform.includes('matrix3d') && !parentTransform.includes('matrix3d') && element !== block && !element.classList.contains('cloned')) {
        const rect = element.getBoundingClientRect();
        const otherTop = rect.top;
        const otherBottom = rect.top + element.offsetHeight;
        const otherLeft = rect.left;
        const otherRight = rect.left + element.offsetWidth;
        const otherMiddle = rect.top + element.offsetHeight / 2;
        const otherCenter = rect.left + element.offsetWidth / 2;

        // block top
        if (otherTop - 4 <= top && top <= otherTop + 4) {
          this.horizontalRulerTop.style.top = containerTop + otherTop + 'px';
          let val = otherTop;
          if (this.rulerTop === null) this.rulerTop = val;
        }
        if (otherBottom - 4 <= top && top <= otherBottom + 4) {
          this.horizontalRulerTop.style.top = containerTop + otherBottom + 'px';
          let val = otherBottom;
          if (this.rulerTop === null) this.rulerTop = val;
        }

        // block bottom
        if (otherTop - 4 <= bottom && bottom <= otherTop + 4) {
          /*
                              _____
          ___________________|__x__|__ rulerBottom
          | other |
           */
          this.horizontalRulerBottom.style.top = containerTop + otherTop + 'px';

          // let val = otherTop - block.offsetHeight;
          // if(this.rulerTop===null) this.rulerTop = val;
          if (this.rulerBottom === null) this.rulerBottom = element.offsetTop; // new
        }

        if (otherBottom - 4 <= bottom && bottom <= otherBottom + 4) {
          /*
                              _____
          | other |__________|__x__|__ rulerBottom
          
          */
          this.horizontalRulerBottom.style.top = containerTop + otherBottom + 'px';

          // let val = otherBottom - block.offsetHeight;
          // if(this.rulerTop===null) this.rulerTop = val;
          if (this.rulerBottom === null) this.rulerBottom = element.offsetTop + element.offsetHeight; // new
        }

        // block middle
        if (this.rulerTop === null && this.rulerBottom === null) {
          if (otherMiddle - 4 <= middle && middle <= otherMiddle + 4) {
            this.horizontalRulerMiddle.style.top = containerTop + otherTop + (element.offsetHeight - block.offsetHeight) / 2 + block.offsetHeight / 2 + 'px';
            let val = otherTop + (element.offsetHeight - block.offsetHeight) / 2;
            if (this.rulerTop === null) this.rulerTop = val;
          }
        }

        // block left
        if (otherLeft - 4 <= left && left <= otherLeft + 4) {
          this.verticalRulerLeft.style.left = otherLeft + 'px';
          this.verticalRulerLeft.style.top = containerTop + 'px'; // adj

          let val = otherLeft;
          if (this.rulerLeft === null) this.rulerLeft = val;
        }
        if (otherRight - 4 <= left && left <= otherRight + 4) {
          this.verticalRulerLeft.style.left = otherRight + 'px';
          this.verticalRulerLeft.style.top = containerTop + 'px'; // adj

          let val = otherRight;
          if (this.rulerLeft === null) this.rulerLeft = val;
        }

        // block right
        if (otherLeft - 4 <= right && right <= otherLeft + 4) {
          this.verticalRulerRight.style.left = otherLeft + 'px';
          this.verticalRulerRight.style.top = containerTop + 'px'; // adj

          let val = otherLeft;
          if (this.rulerRight === null) this.rulerRight = val;
        }
        if (otherRight - 4 <= right && right <= otherRight + 4) {
          this.verticalRulerRight.style.left = otherRight + 'px';
          this.verticalRulerRight.style.top = containerTop + 'px'; // adj

          let val = otherRight;
          if (this.rulerRight === null) this.rulerRight = val;
        }

        // block center
        if (this.rulerLeft === null && this.rulerRight === null) {
          if (otherCenter - 4 <= center && center <= otherCenter + 4) {
            this.verticalRulerCenter.style.left = otherLeft + (element.offsetWidth - block.offsetWidth) / 2 + block.offsetWidth / 2 + 'px';
            this.verticalRulerCenter.style.top = containerTop + 'px'; // adj

            let val = otherLeft + (element.offsetWidth - block.offsetWidth) / 2;
            if (this.rulerLeft === null) this.rulerLeft = val;
          }
        }
      }
    });

    // Edges
    const conRect = block.parentNode.getBoundingClientRect();
    const conTop = conRect.top;
    const conBottom = conRect.top + block.parentNode.offsetHeight;
    const conLeft = conRect.left;
    const conRight = conRect.left + block.parentNode.offsetWidth;
    const conCenter = conRect.left + block.parentNode.offsetWidth / 2;
    const conMiddle = conRect.top + block.parentNode.offsetHeight / 2;

    // block top
    this.horizontalRulerTop.removeAttribute('data-topTouched');
    if (conTop - 4 <= top && top <= conTop + 4) {
      this.horizontalRulerTop.style.top = containerTop + conTop + 'px';
      let val = conTop;
      if (this.rulerTop === null) this.rulerTop = val;
      this.topTouched = true;
      this.horizontalRulerTop.setAttribute('data-topTouched', 1);
    }

    // block bottom
    this.horizontalRulerBottom.removeAttribute('data-bottomTouched');
    if (conBottom - 4 <= bottom && bottom <= conBottom + 4) {
      this.horizontalRulerBottom.style.top = containerTop + conBottom - 2 + 'px'; // -2 is an adjustment to make the line visible

      // let val = conBottom - block.offsetHeight;
      // if(this.rulerTop===null) this.rulerTop = val;
      if (this.rulerBottom === null) this.rulerBottom = conRect.height; // or block.parentNode.offsetHeight; // new

      this.bottomTouched = true;
      this.horizontalRulerBottom.setAttribute('data-bottomTouched', 1);
    }

    // block middle
    if (this.rulerTop === null && this.rulerBottom === null) {
      if (conMiddle - 4 <= middle && middle <= conMiddle + 4) {
        this.horizontalRulerMiddle.style.top = containerTop + conTop + (block.parentNode.offsetHeight - block.offsetHeight) / 2 + block.offsetHeight / 2 + 'px';
        let val = conTop + (block.parentNode.offsetHeight - block.offsetHeight) / 2;
        if (this.rulerTop === null) this.rulerTop = val;
      }
    }

    // block left
    this.verticalRulerLeft.removeAttribute('data-leftTouched');
    if (conLeft - 4 <= left && left <= conLeft + 4) {
      this.verticalRulerLeft.style.left = conLeft + 0 + 'px'; // +0 is an adjustment
      this.verticalRulerLeft.style.top = containerTop + 'px'; // adj

      let val = conLeft;
      if (this.rulerLeft === null) this.rulerLeft = val;
      this.verticalRulerLeft.setAttribute('data-leftTouched', 1);
    }

    // block right
    this.verticalRulerRight.removeAttribute('data-rightTouched');
    if (conRight - 4 <= right && right <= conRight + 4) {
      this.verticalRulerRight.style.left = conRight - 2 + 'px'; // -2 is an adjustment
      this.verticalRulerRight.style.top = containerTop + 'px'; // adj

      let val = conRight;
      if (this.rulerRight === null) this.rulerRight = val;
      this.verticalRulerRight.setAttribute('data-rightTouched', 1);
    }

    // block center
    if (this.rulerLeft === null && this.rulerRight === null) {
      if (conCenter - 4 <= center && center <= conCenter + 4) {
        this.verticalRulerCenter.style.left = conLeft + (block.parentNode.offsetWidth - block.offsetWidth) / 2 + block.offsetWidth / 2 + 'px';
        this.verticalRulerCenter.style.top = containerTop + 'px';
        let val = conLeft + (block.parentNode.offsetWidth - block.offsetWidth) / 2;
        if (this.rulerLeft === null) this.rulerLeft = val;
      }
    }
  }
}
class Rotatable {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.onBeforeChange = options && options.onBeforeChange || null;
    this.onChange = options && options.onChange || null;
    this.disableOnMobile = options && options.disableOnMobile || 0;
    this.centerX = 0;
    this.centerY = 0;
    this.initialRotation = 0;
    this.handleRotateStart = this.handleRotateStart.bind(this);
    this.handleDblClick = this.handleDblClick.bind(this);
    this.handleRotateMove = this.handleRotateMove.bind(this);
    this.handleRotateEnd = this.handleRotateEnd.bind(this);
    this.setup();
    this.common = new Common({
      selector: this.selector
    });
  }
  setup() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      element.querySelectorAll('.rotate-handle').forEach(elm => elm.parentNode.removeChild(elm));
      const handleHTML = '<div class="rotate-handle" contentEditable="false"><div></div></div>';
      element.insertAdjacentHTML('afterbegin', handleHTML);
      const handles = Array.from(element.querySelectorAll('.rotate-handle')).filter(handle => handle.parentElement === element);
      handles.forEach(handle => {
        handle.addEventListener('mousedown', this.handleRotateStart);
        handle.addEventListener('touchstart', this.handleRotateStart, {
          passive: false
        });
        handle.addEventListener('dblclick', this.handleDblClick);
      });
    });
  }
  refresh() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      let handles = Array.from(element.querySelectorAll('.rotate-handle')).filter(handle => handle.parentElement === element); // only one handle
      handles.forEach(handle => {
        handle.removeEventListener('mousedown', this.handleRotateStart);
        handle.removeEventListener('touchstart', this.handleRotateStart);
        handle.removeEventListener('dblclick', this.handleDblClick);
        handle.parentNode.removeChild(handle);
      });
      const handleHTML = '<div class="rotate-handle" contentEditable="false"><div></div></div>';
      element.insertAdjacentHTML('afterbegin', handleHTML);
      handles = Array.from(element.querySelectorAll('.rotate-handle')).filter(handle => handle.parentElement === element); // only one handle
      handles.forEach(handle => {
        handle.addEventListener('mousedown', this.handleRotateStart);
        handle.addEventListener('touchstart', this.handleRotateStart, {
          passive: false
        });
        handle.addEventListener('dblclick', this.handleDblClick);
      });
    });
  }
  destroy(block) {
    if (block) {
      this.elements = this.doc.querySelectorAll(this.selector);
      this.elements.forEach(element => {
        if (element === block) {
          const handles = Array.from(element.querySelectorAll('.rotate-handle')).filter(handle => handle.parentElement === element);
          handles.forEach(handle => {
            handle.removeEventListener('mousedown', this.handleRotateStart);
            handle.removeEventListener('touchstart', this.handleRotateStart);
            handle.removeEventListener('dblclick', this.handleDblClick);
            handle.parentNode.removeChild(handle);
          });
        }
      });
    } else {
      this.elements = this.doc.querySelectorAll(this.selector);
      this.elements.forEach(element => {
        const handles = Array.from(element.querySelectorAll('.rotate-handle')).filter(handle => handle.parentElement === element);
        handles.forEach(handle => {
          handle.removeEventListener('mousedown', this.handleRotateStart);
          handle.removeEventListener('touchstart', this.handleRotateStart);
          handle.removeEventListener('dblclick', this.handleDblClick);
          handle.parentNode.removeChild(handle);
        });
      });
    }
  }
  handleDblClick(event) {
    if (this.onBeforeChange) this.onBeforeChange();
    event.preventDefault();
    event.stopImmediatePropagation();
    const block = event.target.parentNode;
    const transform = block.style.transform;
    if (transform.includes('rotate')) block.style.transform = '';
    this.clonedTarget = this.doc.querySelector(this.selector + '.cloned');
    if (this.clonedTarget) this.clonedTarget.style.transform = '';
    if (this.onChange) this.onChange();
  }
  handleRotateStart(event) {
    const viewportWidth = this.win.innerWidth;
    if (viewportWidth <= this.disableOnMobile) return;
    if (event.type === 'touchstart' && event.touches.length !== 1) {
      return; // Do nothing if more than one touch point is detected
    }

    if (event.type === 'mousedown' && event.button !== 0) {
      return; // Do nothing if the right mouse button is clicked
    }

    event.preventDefault();
    this.target = event.target.parentNode; // block

    this.clonedTarget = this.doc.querySelector(this.selector + '.cloned');
    this.dragStartTimeout = setTimeout(() => {
      // Set a timeout before starting the drag (to differentiate from click)

      if (event.type === 'mousedown') {
        this.startRotation(event.clientX, event.clientY);
      } else if (event.type === 'touchstart') {
        const touch = event.touches[0];
        this.startRotation(touch.clientX, touch.clientY);
      }
      this.doc.addEventListener('mousemove', this.handleRotateMove);
      this.doc.addEventListener('touchmove', this.handleRotateMove);
    }, 120);
    this.doc.addEventListener('mouseup', this.handleRotateEnd);
    this.doc.addEventListener('touchend', this.handleRotateEnd);
  }
  handleRotateMove() {
    let clientX, clientY;
    if (event.type === 'mousemove') {
      clientX = event.clientX;
      clientY = event.clientY;
    } else if (event.type === 'touchmove') {
      const touch = event.touches[0];
      clientX = touch.clientX;
      clientY = touch.clientY;
    }
    this.updateRotation(clientX, clientY);
  }
  handleRotateEnd() {
    clearTimeout(this.dragStartTimeout);
    this.doc.removeEventListener('mousemove', this.handleRotateMove);
    this.doc.removeEventListener('touchmove', this.handleRotateMove);
    this.doc.removeEventListener('mouseup', this.handleRotateEnd);
    this.doc.removeEventListener('touchend', this.handleRotateEnd);
    if (this.onChange) this.onChange();
  }
  getCurrentRotation(transform) {
    const match = transform.match(/rotate\(([-+]?\d*\.?\d*)deg\)/);
    return match ? parseFloat(match[1]) : 0;
  }
  startRotation() {
    if (this.onBeforeChange) this.onBeforeChange();
    const target = this.target;
    const rect = target.getBoundingClientRect();
    this.centerX = rect.left + rect.width / 2;
    this.centerY = rect.top + rect.height / 2;

    // Store the initial rotation
    if (target.parentNode.matches(this.selector)) {
      const currentTransform = target.style.transform;
      let currentRotation = this.getCurrentRotation(currentTransform);
      this.initialRotation = currentRotation;
      const parentTransform = target.parentNode.style.transform;
      let parentRotation = this.getCurrentRotation(parentTransform);
      if (parentRotation) {
        this.initialRotation = parentRotation;
      }
    } else {
      this.initialRotation = 0; // If no child blocks
    }
  }

  updateRotation(x, y) {
    const target = this.target;
    const angle = Math.atan2(y - this.centerY, x - this.centerX);
    const degrees = angle * (180 / Math.PI);
    const initialRotation = this.initialRotation || 0;
    target.style.transform = `rotate(${degrees - initialRotation}deg)`;
    if (this.clonedTarget) this.clonedTarget.style.transform = `rotate(${degrees - initialRotation}deg)`;
  }
}
class Resizable {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.onBeforeChange = options && options.onBeforeChange || null;
    this.onChange = options && options.onChange || null;
    this.disableOnMobile = options && options.disableOnMobile || 0;
    this.isResizing = false;
    this.resizeHandle = null;
    this.startX = 0;
    this.startY = 0;
    this.elements = this.doc.querySelectorAll(this.selector);
    this.startResizing = this.startResizing.bind(this);
    this.handleResizeMove = this.handleResizeMove.bind(this);
    this.handleResizeEnd = this.handleResizeEnd.bind(this);
    this.setup();
    this.ruler = new Ruler({
      selector: this.selector,
      doc: this.doc,
      win: this.win
    });
    this.common = new Common({
      selector: this.selector,
      doc: this.doc,
      win: this.win
    });
  }
  setZoom(scale) {
    this.zoom = scale;
    this.common.setZoom(scale);
    this.ruler.setZoom(scale);
  }
  setup() {
    this.elements.forEach(element => {
      element.querySelectorAll('.handle').forEach(elm => elm.parentNode.removeChild(elm));
      const handleHTML = `
            <div class="handle top-left"></div>
            <div class="handle top-right"></div>
            <div class="handle bottom-left"></div>
            <div class="handle bottom-right"></div>
            
            <div class="handle top"></div>
            <div class="handle bottom"></div>
            <div class="handle left"></div>
            <div class="handle right"></div>`;
      element.insertAdjacentHTML('afterbegin', handleHTML);
      const handles = Array.from(element.querySelectorAll('.handle')).filter(handle => handle.parentElement === element);
      handles.forEach(handle => {
        handle.addEventListener('mousedown', this.startResizing);
        handle.addEventListener('touchstart', this.startResizing, {
          passive: false
        });
      });
    });
  }
  refresh() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      let handles = Array.from(element.querySelectorAll('.handle')).filter(handle => handle.parentElement === element);
      handles.forEach(handle => {
        handle.removeEventListener('mousedown', this.startResizing);
        handle.removeEventListener('touchstart', this.startResizing);
        handle.parentNode.removeChild(handle);
      });
      const handleHTML = `
                <div class="handle top-left"></div>
                <div class="handle top-right"></div>
                <div class="handle bottom-left"></div>
                <div class="handle bottom-right"></div>
            
                <div class="handle top"></div>
                <div class="handle bottom"></div>
                <div class="handle left"></div>
                <div class="handle right"></div>`;
      element.insertAdjacentHTML('afterbegin', handleHTML);
      handles = Array.from(element.querySelectorAll('.handle')).filter(handle => handle.parentElement === element);
      handles.forEach(handle => {
        handle.addEventListener('mousedown', this.startResizing);
        handle.addEventListener('touchstart', this.startResizing, {
          passive: false
        });
      });
    });
    this.ruler.refresh();
  }
  destroy(block) {
    if (block) {
      const handles = Array.from(block.querySelectorAll('.handle')).filter(handle => handle.parentElement === block);
      handles.forEach(handle => {
        handle.removeEventListener('mousedown', this.startResizing);
        handle.removeEventListener('touchstart', this.startResizing);
        handle.parentNode.removeChild(handle);
      });
    } else {
      const handles = this.doc.querySelectorAll('.handle');
      handles.forEach(handle => {
        handle.removeEventListener('mousedown', this.startResizing);
        handle.removeEventListener('touchstart', this.startResizing);
        handle.parentNode.removeChild(handle);
      });
      this.ruler.destroy();
    }
  }
  startResizing(event) {
    const viewportWidth = this.win.innerWidth;
    if (viewportWidth <= this.disableOnMobile) return;
    if (event.type === 'touchstart' && event.touches.length !== 1) {
      return; // Do nothing if more than one touch point is detected
    }

    if (event.type === 'mousedown' && event.button !== 0) {
      return; // Do nothing if the right mouse button is clicked
    }

    this.target = event.target.parentNode; // block
    this.clonedTarget = this.doc.querySelector(this.selector + '.cloned');
    event.preventDefault();
    event.stopPropagation();
    this.dragStartTimeout = setTimeout(() => {
      // Set a timeout before starting the drag (to differentiate from click)

      if (this.onBeforeChange) this.onBeforeChange();
      const handle = event.target.closest('.handle');
      this.isResizing = true;
      this.resizeHandle = handle.classList[1];
      if (event.type === 'mousedown') {
        this.startX = event.clientX;
        this.startY = event.clientY;
      } else if (event.type === 'touchstart') {
        const touch = event.touches[0];
        this.startX = touch.clientX;
        this.startY = touch.clientY;
      }
      this.target.style.transition = ''; // prevent anim/delay while dragging (in case a block has animation transition)
      if (this.clonedTarget) this.clonedTarget.style.transition = '';

      //Initial
      this.initialWidth = parseFloat(getComputedStyle(this.target).width);
      this.initialHeight = parseFloat(getComputedStyle(this.target).height);
      const containerRect = this.common.getRect(this.target.parentNode);
      const rect = this.common.getRect(this.target);
      this.initialLeft = rect.left - containerRect.left;
      this.initialTop = rect.top - containerRect.top;
      this.common.applyPixels(this.target);
    }, 120);
    this.doc.addEventListener('mousemove', this.handleResizeMove);
    this.doc.addEventListener('mouseup', this.handleResizeEnd);
    this.doc.addEventListener('touchmove', this.handleResizeMove);
    this.doc.addEventListener('touchend', this.handleResizeEnd);
    document.addEventListener('mouseup', this.handleResizeEnd); // in iframe, mouseup can be triggered outside the iframe (during resizing)
    document.addEventListener('touchend', this.handleResizeEnd);
  }
  handleResizeMove(event) {
    if (this.isResizing) {
      let deltaX, deltaY;
      if (event.type === 'mousemove') {
        deltaX = event.clientX - this.startX;
        deltaY = event.clientY - this.startY;
      } else if (event.type === 'touchmove') {
        const touch = event.touches[0];
        deltaX = touch.clientX - this.startX;
        deltaY = touch.clientY - this.startY;
      }
      this.target.style.minWidth = ''; // to ensure no resize limit
      if (this.clonedTarget) this.clonedTarget.style.minWidth = '';
      switch (this.resizeHandle) {
        case 'top-left':
          this.resizeTopLeft(deltaX, deltaY);
          break;
        case 'top-right':
          this.resizeTopRight(deltaX, deltaY);
          break;
        case 'bottom-left':
          this.resizeBottomLeft(deltaX, deltaY);
          break;
        case 'bottom-right':
          this.resizeBottomRight(deltaX, deltaY);
          break;
        case 'top':
          this.resizeTop(deltaY);
          break;
        case 'left':
          this.resizeLeft(deltaX);
          break;
        case 'bottom':
          this.resizeBottom(deltaY);
          break;
        case 'right':
          this.resizeRight(deltaX);
          break;
      }
      this.ruler.updateRulers(this.target);
    }
  }
  handleResizeEnd() {
    clearTimeout(this.dragStartTimeout);
    this.stopResizing();
    this.doc.removeEventListener('mousemove', this.handleResizeMove);
    this.doc.removeEventListener('mouseup', this.handleResizeEnd);
    this.doc.removeEventListener('touchmove', this.handleResizeMove);
    this.doc.removeEventListener('touchend', this.handleResizeEnd);
    document.removeEventListener('mouseup', this.handleResizeEnd); // in iframe, mouseup can be triggered outside the iframe (during resizing)
    document.removeEventListener('touchend', this.handleResizeEnd);
    this.ruler.hideRulers();
  }
  resizeTopLeft(deltaX, deltaY) {
    const zoom = this.zoom;
    this.target.style.left = this.initialLeft / zoom + deltaX + 'px';
    this.target.style.top = this.initialTop / zoom + deltaY + 'px';
    this.target.style.width = this.initialWidth - deltaX + 'px';
    this.target.style.height = this.initialHeight - deltaY + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.left = this.initialLeft / zoom + deltaX + 'px';
      this.clonedTarget.style.top = this.initialTop / zoom + deltaY + 'px';
      this.clonedTarget.style.width = this.initialWidth - deltaX + 'px';
      this.clonedTarget.style.height = this.initialHeight - deltaY + 'px';
    }
  }
  resizeTopRight(deltaX, deltaY) {
    const zoom = this.zoom;
    this.target.style.width = this.initialWidth + deltaX + 'px';
    this.target.style.top = this.initialTop / zoom + deltaY + 'px';
    this.target.style.height = this.initialHeight - deltaY + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.width = this.initialWidth + deltaX + 'px';
      this.clonedTarget.style.top = this.initialTop / zoom + deltaY + 'px';
      this.clonedTarget.style.height = this.initialHeight - deltaY + 'px';
    }
  }
  resizeBottomLeft(deltaX, deltaY) {
    const zoom = this.zoom;
    this.target.style.width = this.initialWidth - deltaX + 'px';
    this.target.style.height = this.initialHeight + deltaY + 'px';
    this.target.style.left = this.initialLeft / zoom + deltaX + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.width = this.initialWidth - deltaX + 'px';
      this.clonedTarget.style.height = this.initialHeight + deltaY + 'px';
      this.clonedTarget.style.left = this.initialLeft / zoom + deltaX + 'px';
    }
  }
  resizeBottomRight(deltaX, deltaY) {
    this.target.style.width = this.initialWidth + deltaX + 'px';
    this.target.style.height = this.initialHeight + deltaY + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.width = this.initialWidth + deltaX + 'px';
      this.clonedTarget.style.height = this.initialHeight + deltaY + 'px';
    }
  }
  resizeTop(deltaY) {
    const zoom = this.zoom;
    this.target.style.top = this.initialTop / zoom + deltaY + 'px';
    this.target.style.height = this.initialHeight - deltaY + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.top = this.initialTop / zoom + deltaY + 'px';
      this.clonedTarget.style.height = this.initialHeight - deltaY + 'px';
    }
  }
  resizeBottom(deltaY) {
    this.target.style.height = this.initialHeight + deltaY + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.height = this.initialHeight + deltaY + 'px';
    }
  }
  resizeLeft(deltaX) {
    const zoom = this.zoom;
    this.target.style.width = this.initialWidth - deltaX + 'px';
    this.target.style.left = this.initialLeft / zoom + deltaX + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.width = this.initialWidth - deltaX + 'px';
      this.clonedTarget.style.left = this.initialLeft / zoom + deltaX + 'px';
    }
  }
  resizeRight(deltaX) {
    this.target.style.width = this.initialWidth + deltaX + 'px';
    if (this.clonedTarget) {
      this.clonedTarget.style.width = this.initialWidth + deltaX + 'px';
    }
  }
  stopResizing() {
    if (this.isResizing) {
      if (this.target) {
        this.updateBlockStyle(this.target);
        if (this.clonedTarget) this.updateBlockStyle(this.clonedTarget);
      }
      this.isResizing = false;
    }
  }
  updateBlockStyle(target) {
    if (target.querySelector(this.selector)) ; else {
      // this.common.updateHeight(target);
      if (target.classList.contains('height-auto')) target.style.height = '';
    }

    // Replace with ruler's alignment

    if (this.resizeHandle.includes('top')) {
      if (this.ruler.rulerTop !== null) {
        //bottom fixed
        let targetBottom = target.offsetTop + target.offsetHeight;
        target.style.top = this.ruler.rulerTop + 'px';
        target.style.height = targetBottom - this.ruler.rulerTop + 'px';
      }
    }
    if (this.resizeHandle.includes('bottom')) {
      if (this.ruler.rulerBottom !== null) {
        // top fixed
        target.style.height = this.ruler.rulerBottom - target.offsetTop + 'px';
      }
    }
    if (this.resizeHandle.includes('left')) {
      if (this.ruler.rulerLeft !== null) {
        //right fixed
        let targetRight = target.offsetLeft + target.offsetWidth;
        target.style.left = this.ruler.rulerLeft + 'px';
        target.style.width = targetRight - this.ruler.rulerLeft + 'px';
      }
    }
    if (this.resizeHandle.includes('right')) {
      if (this.ruler.rulerRight !== null) {
        //left fixed
        target.style.width = this.ruler.rulerRight - target.offsetLeft + 'px';
      }
    }

    // Convert px to %
    this.common.applyPercentage(target);
    setTimeout(() => {
      const breakpoint = this.doc.body.getAttribute('data-breakpoint');

      // const screenWidth = window.innerWidth;
      // let defaultPoint;
      // if(screenWidth<=1920) {
      //     defaultPoint = 1366;
      // } else {
      //     defaultPoint = 1900;
      // }

      let largeScreenBreakpoint = 1280; //1920
      largeScreenBreakpoint = window.innerWidth - 360; //351
      if (largeScreenBreakpoint < 1280) largeScreenBreakpoint = 1280;
      let isPrint = false;
      let elmBox = target.closest('[data-pagesize]');
      if (elmBox) {
        if (elmBox.getAttribute('data-pagesize').includes('web')) ; else {
          isPrint = true;
        }
      }
      if (isPrint) {
        target.setAttribute('data--t', target.style.top);
        target.setAttribute('data--l', target.style.left);
        target.setAttribute('data--b', target.style.bottom);
        target.setAttribute('data--r', target.style.right);
        target.setAttribute('data--w', target.style.width);
        target.setAttribute('data--h', target.style.height);
      } else {
        if (breakpoint && breakpoint < largeScreenBreakpoint) {
          target.setAttribute('data--t-' + breakpoint, target.style.top);
          target.setAttribute('data--l-' + breakpoint, target.style.left);
          target.setAttribute('data--b-' + breakpoint, target.style.bottom);
          target.setAttribute('data--r-' + breakpoint, target.style.right);
          if (!(target.classList.contains('fluid') && target.closest('.autolayout'))) {
            target.setAttribute('data--w-' + breakpoint, target.style.width);
          }
          target.setAttribute('data--h-' + breakpoint, target.style.height);
        } else {
          target.setAttribute('data--t', target.style.top);
          target.setAttribute('data--l', target.style.left);
          target.setAttribute('data--b', target.style.bottom);
          target.setAttribute('data--r', target.style.right);
          target.setAttribute('data--w', target.style.width);
          target.setAttribute('data--h', target.style.height);
        }
      }
      target.removeAttribute('data-prev'); // reset
      target.removeAttribute('data-fluid');
    }, 30); // delay needed since we use updateHeight() previously that has 20ms process

    if (this.onChange) this.onChange();
  }
  updateBlockStyle_bak(target) {
    if (target.querySelector(this.selector)) ; else {
      // this.common.updateHeight(target);
      if (target.classList.contains('height-auto')) target.style.height = '';
    }

    // Replace with ruler's alignment
    const containerRect = this.common.getRect(target.parentNode); // if container has top/left

    if (this.resizeHandle.includes('top')) {
      if (this.ruler.rulerTop !== null) {
        //bottom fixed
        const rect = target.getBoundingClientRect();
        let targetBottom = rect.top + rect.height;
        target.style.top = this.ruler.rulerTop - containerRect.top + 'px';
        target.style.height = targetBottom - this.ruler.rulerTop + 'px';
      }
    }
    if (this.resizeHandle.includes('bottom')) {
      if (this.ruler.rulerBottom !== null) {
        // top fixed
        // const rect = target.getBoundingClientRect();
        // target.style.height = this.ruler.rulerBottom - rect.top + containerRect.top + 'px'; 
        target.style.height = this.ruler.rulerBottom - target.offsetTop + 'px';
      }
    }
    if (this.resizeHandle.includes('left')) {
      if (this.ruler.rulerLeft !== null) {
        //right fixed
        const rect = target.getBoundingClientRect();
        let targetRight = rect.left + rect.width;
        target.style.left = this.ruler.rulerLeft - containerRect.left + 'px';
        target.style.width = targetRight - this.ruler.rulerLeft + 'px';
      }
    }
    if (this.resizeHandle.includes('right')) {
      if (this.ruler.rulerRight !== null) {
        //left fixed
        const rect = target.getBoundingClientRect();
        target.style.width = this.ruler.rulerRight - rect.left + 'px';
      }
    }

    // Convert px to %
    this.common.applyPercentage(target);
    setTimeout(() => {
      const breakpoint = this.doc.body.getAttribute('data-breakpoint');

      // const screenWidth = window.innerWidth;
      // let defaultPoint;
      // if(screenWidth<=1920) {
      //     defaultPoint = 1366;
      // } else {
      //     defaultPoint = 1900;
      // }

      let largeScreenBreakpoint = 1280; //1920
      largeScreenBreakpoint = window.innerWidth - 360; //351
      if (largeScreenBreakpoint < 1280) largeScreenBreakpoint = 1280;
      let isPrint = false;
      let elmBox = target.closest('[data-pagesize]');
      if (elmBox) {
        if (elmBox.getAttribute('data-pagesize').includes('web')) ; else {
          isPrint = true;
        }
      }
      if (isPrint) {
        target.setAttribute('data--t', target.style.top);
        target.setAttribute('data--l', target.style.left);
        target.setAttribute('data--b', target.style.bottom);
        target.setAttribute('data--r', target.style.right);
        target.setAttribute('data--w', target.style.width);
        target.setAttribute('data--h', target.style.height);
      } else {
        if (breakpoint && breakpoint < largeScreenBreakpoint) {
          target.setAttribute('data--t-' + breakpoint, target.style.top);
          target.setAttribute('data--l-' + breakpoint, target.style.left);
          target.setAttribute('data--b-' + breakpoint, target.style.bottom);
          target.setAttribute('data--r-' + breakpoint, target.style.right);
          if (!target.classList.contains('fluid')) target.setAttribute('data--w-' + breakpoint, target.style.width);
          target.setAttribute('data--h-' + breakpoint, target.style.height);
        } else {
          target.setAttribute('data--t', target.style.top);
          target.setAttribute('data--l', target.style.left);
          target.setAttribute('data--b', target.style.bottom);
          target.setAttribute('data--r', target.style.right);
          target.setAttribute('data--w', target.style.width);
          target.setAttribute('data--h', target.style.height);
        }
      }
      target.removeAttribute('data-prev'); // reset
      target.removeAttribute('data-fluid');
    }, 30); // delay needed since we use updateHeight() previously that has 20ms process

    if (this.onChange) this.onChange();
  }
}
class Draggable {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.controlSelector = options && options.controlSelector || null;
    this.onDelete = options && options.onDelete || null;
    this.onBeforeChange = options && options.onBeforeChange || null;
    this.onChange = options && options.onChange || null;
    this.onSelectStart = options && options.onSelectStart || null;
    this.onSelectClear = options && options.onSelectClear || null;
    this.disableOnMobile = options && options.disableOnMobile || 0;
    this.onMultipleSelect = options && options.onMultipleSelect || null;
    this.onSelectBlock = options && options.onSelectBlock || null;
    this.isDragging = false;
    this.startX = 0;
    this.startY = 0;
    this.handleDragStart = this.handleDragStart.bind(this);
    this.handleDragMove = this.handleDragMove.bind(this);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.handleSelect = this.handleSelect.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.setup();
    this.ruler = new Ruler({
      selector: this.selector,
      doc: this.doc,
      win: this.win
    });
    this.common = new Common({
      selector: this.selector,
      doc: this.doc,
      win: this.win
    });
  }
  setZoom(scale) {
    this.zoom = scale;
    this.common.setZoom(scale);
    this.ruler.setZoom(scale);
  }
  setup() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      element.addEventListener('mousedown', this.handleDragStart);
      element.addEventListener('touchstart', this.handleDragStart, {
        passive: false
      });
    });
    this.doc.addEventListener('mousedown', this.handleSelect);
    this.doc.addEventListener('touchstart', this.handleSelect, {
      passive: false
    });
    this.doc.addEventListener('keydown', this.handleKeyDown);
  }
  refresh() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      element.removeEventListener('mousedown', this.handleDragStart);
      element.removeEventListener('touchstart', this.handleDragStart);
    });
    this.elements.forEach(element => {
      if (element.classList.contains('locked')) return;
      element.addEventListener('mousedown', this.handleDragStart);
      element.addEventListener('touchstart', this.handleDragStart, {
        passive: false
      });
    });
    this.ruler.refresh();
  }
  destroy() {
    this.ruler.destroy();
    this.elements.forEach(element => {
      element.removeEventListener('mousedown', this.handleDragStart);
      element.removeEventListener('touchstart', this.handleDragStart);
    });
    this.doc.removeEventListener('mousedown', this.handleSelect);
    this.doc.removeEventListener('touchstart', this.handleSelect);
    this.doc.removeEventListener('keydown', this.handleKeyDown);
    const blocks = this.doc.querySelectorAll(this.selector);
    blocks.forEach(elm => elm.classList.remove('active'));
  }
  disableDrag(block) {
    this.elements.forEach(element => {
      if (block === element) {
        element.removeEventListener('mousedown', this.handleDragStart);
        element.removeEventListener('touchstart', this.handleDragStart);
      }
    });
  }
  enableDrag(block) {
    this.elements.forEach(element => {
      if (block === element) {
        element.addEventListener('mousedown', this.handleDragStart);
        element.addEventListener('touchstart', this.handleDragStart, {
          passive: false
        });
      }
    });
  }
  handleDragStart(event) {
    const viewportWidth = this.win.innerWidth;
    if (viewportWidth <= this.disableOnMobile) return;
    if (event.target.classList.contains('rotate-handle')) return;
    if (event.type === 'touchstart' && event.touches.length !== 1) {
      return; // Do nothing if more than one touch point is detected
    }

    if (event.type === 'mousedown' && event.button !== 0) {
      return; // Do nothing if the right mouse button is clicked
    }

    const currentTarget = event.currentTarget;
    const clickedBlock = event.target.closest(this.selector);
    if (currentTarget !== clickedBlock) {
      // Triggered Group click by child block click
      return; // Return here, so that when block events are working, group events won't
    }

    this.clickedBlock = clickedBlock;
    this.dragStartTimeout = setTimeout(() => {
      // Set a timeout before starting the drag (to differentiate from click)

      if (event.type === 'mousedown') {
        this.startDragging(event.clientX, event.clientY, currentTarget);
      } else if (event.type === 'touchstart') {
        const touch = event.touches[0];
        this.startDragging(touch.clientX, touch.clientY, currentTarget);
      }
      this.doc.addEventListener('mousemove', this.handleDragMove);
      this.doc.addEventListener('touchmove', this.handleDragMove);
    }, 120);
    this.doc.addEventListener('mouseup', this.handleDragEnd);
    this.doc.addEventListener('touchend', this.handleDragEnd);
  }
  startDragging(startX, startY) {
    if (this.onBeforeChange) this.onBeforeChange();
    this.isDragging = true;
    const blocks = this.doc.querySelectorAll(this.selector + '.active');
    blocks.forEach(target => {
      // const containerRect = target.parentNode.getBoundingClientRect(); // if container has top/left
      const containerRect = this.common.getRect(target.parentNode); // if container has top/left
      const rect = this.common.getRect(target);
      const x = startX - rect.left + containerRect.left;
      const y = startY - rect.top + containerRect.top;
      target.setAttribute('data-startx', x);
      target.setAttribute('data-starty', y);
      target.style.transition = ''; // prevent anim/delay while dragging (in case a block has animation transition)

      // reset (from applyPercentage bottomTouched)
      if (target.style.bottom) {
        if (!target.classList.contains('height-auto')) {
          target.style.height = target.offsetHeight + 'px';
        }
        target.style.bottom = '';
      }
      this.common.applyPixels(target);
    });
    this.clickedBlock = this.common.getSelectedBlock();
  }
  handleDragMove(event) {
    let clientX, clientY;
    if (event.type === 'mousemove') {
      clientX = event.clientX;
      clientY = event.clientY;
    } else if (event.type === 'touchmove') {
      const touch = event.touches[0];
      clientX = touch.clientX;
      clientY = touch.clientY;
    }
    if (this.isDragging) {
      // Allows dragging multiple selected blocks

      let blocks = this.doc.querySelectorAll(this.selector + '.active');
      blocks.forEach(target => {
        this.updatePosition(clientX, clientY, target);
      });

      // Ruler works for single block selection only
      if (this.clickedBlock) this.ruler.updateRulers(this.clickedBlock);
    }
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  updatePosition(x, y, target) {
    if (this.isDragging) {
      const startX = target.getAttribute('data-startx');
      const startY = target.getAttribute('data-starty');
      const newX = x - startX;
      const newY = y - startY;
      const zoom = this.zoom;
      target.style.left = newX / zoom + 'px';
      target.style.top = newY / zoom + 'px';
    }
  }
  handleDragEnd() {
    clearTimeout(this.dragStartTimeout);
    if (this.isDragging) {
      this.doc.removeEventListener('mousemove', this.handleDragMove);
      this.doc.removeEventListener('touchmove', this.handleDragMove);
    }
    this.doc.removeEventListener('mouseup', this.handleDragEnd);
    this.doc.removeEventListener('touchend', this.handleDragEnd);
    this.stopDragging();
    this.ruler.hideRulers();
    let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && !elm.classList.contains('multi'));
    if (blocks.length === 1) {
      const block = blocks[0];
      if (this.onSelectStart) this.onSelectStart(block); // on first block select (before clone) 
    }
  }

  stopDragging() {
    if (this.isDragging) {
      const blocks = this.doc.querySelectorAll(this.selector + '.active');
      blocks.forEach(target => {
        this.updateBlockStyle(target);
      });
      this.isDragging = false;
    }
  }
  updateBlockStyle(target) {
    // Block placement should must not 50% outside the container
    const container = target.closest('.box-canvas');
    if (!target.parentNode.closest('.is-group')) {
      let containerHeight = container.offsetHeight;
      let containerWidth = container.offsetWidth;
      /*
      if(target.offsetTop + target.offsetHeight>=containerHeight) {
          target.style.top = containerHeight-target.offsetHeight +'px';
      }
      if(target.offsetTop<=0) {
          target.style.top = '0px';
      }
      if(target.offsetLeft + target.offsetWidth>=containerWidth) {
          target.style.left = (containerWidth-target.offsetWidth) +'px';
      }
      if(target.offsetLeft<=0) {
          target.style.left = '0px';
      }
      */
      if (target.offsetTop + target.offsetHeight <= target.offsetHeight / 2) {
        target.style.top = '0px';
      }
      if (containerHeight - target.offsetTop <= target.offsetHeight / 2) {
        target.style.top = containerHeight - target.offsetHeight + 'px';
      }
      if (target.offsetLeft + target.offsetWidth <= target.offsetWidth / 2) {
        target.style.left = '0px';
      }
      if (containerWidth - target.offsetLeft <= target.offsetWidth / 2) {
        target.style.left = containerWidth - target.offsetWidth + 'px';
      }
    }

    // Replace with ruler's alignment
    if (this.ruler.rulerTop !== null) target.style.top = this.ruler.rulerTop + 'px';
    if (this.ruler.rulerBottom !== null) target.style.top = this.ruler.rulerBottom - target.offsetHeight + 'px'; //new
    if (this.ruler.rulerLeft !== null) target.style.left = this.ruler.rulerLeft + 'px';else if (this.ruler.rulerRight !== null) target.style.left = this.ruler.rulerRight - target.offsetWidth + 'px';
    this.doc.querySelectorAll('[data-startx]').forEach(elm => elm.removeAttribute('data-startx'));
    this.doc.querySelectorAll('[data-starty]').forEach(elm => elm.removeAttribute('data-starty'));
    this.common.applyPercentage(target);
    const breakpoint = this.doc.body.getAttribute('data-breakpoint');

    // const screenWidth = window.innerWidth;
    // let defaultPoint;
    // if(screenWidth<=1920) {
    //     defaultPoint = 1366;
    // } else {
    //     defaultPoint = 1900;
    // }

    let largeScreenBreakpoint = 1280; //1920
    largeScreenBreakpoint = window.innerWidth - 360; //351
    if (largeScreenBreakpoint < 1280) largeScreenBreakpoint = 1280;
    let isPrint = false;
    let elmBox = target.closest('[data-pagesize]');
    if (elmBox) {
      if (elmBox.getAttribute('data-pagesize').includes('web')) ; else {
        isPrint = true;
      }
    }
    if (isPrint) {
      target.setAttribute('data--t', target.style.top);
      target.setAttribute('data--l', target.style.left);
      target.setAttribute('data--b', target.style.bottom);
      target.setAttribute('data--r', target.style.right);
      target.setAttribute('data--w', target.style.width);
      target.setAttribute('data--h', target.style.height);
    } else {
      if (breakpoint && breakpoint < largeScreenBreakpoint) {
        target.setAttribute('data--t-' + breakpoint, target.style.top);
        target.setAttribute('data--l-' + breakpoint, target.style.left);
        target.setAttribute('data--b-' + breakpoint, target.style.bottom);
        target.setAttribute('data--r-' + breakpoint, target.style.right);
        if (!target.classList.contains('fluid')) target.setAttribute('data--w-' + breakpoint, target.style.width);
        target.setAttribute('data--h-' + breakpoint, target.style.height);
      } else {
        target.setAttribute('data--t', target.style.top);
        target.setAttribute('data--l', target.style.left);
        target.setAttribute('data--b', target.style.bottom);
        target.setAttribute('data--r', target.style.right);
        target.setAttribute('data--w', target.style.width);
        target.setAttribute('data--h', target.style.height);
      }
    }
    target.removeAttribute('data-prev'); // reset
    target.removeAttribute('data-fluid');
    if (this.onChange) this.onChange();
  }
  handleSelect(event) {
    if (!this.doc.querySelector(this.selector + '.active')) {
      // Make the current scrollbar state (visible or not) to stay during the block select (drag or resize)
      let scrollbar = this.doc.documentElement.scrollHeight > this.doc.documentElement.clientHeight;
      if (!scrollbar) {
        this.doc.body.style.overflowY = 'hidden';
      } else {
        this.doc.body.style.overflowY = 'scroll';
      }
    }
    const element = event.target;
    if (element.classList.contains('rotate-handle')) return;
    const block = element.closest(this.selector);
    if (block) {
      if (block.classList.contains('active')) {
        let actualBlock = block.classList.contains('clone') ? this.doc.querySelector(this.selector + '.cloned') : null;
        if (!actualBlock) actualBlock = block;
        if (this.onSelectBlock) this.onSelectBlock(actualBlock);
        return; // if clicked block is active
      }
      // if(block.parentNode.classList.contains('active')) return; // if group is active

      if (block.matches(this.selector) && block.querySelector(this.selector)) {
        // if group is clicked, remove active childe's blocks
        block.querySelectorAll(this.selector).forEach(elm => elm.classList.remove('active'));
      }
      if (event.shiftKey || this.doc.body.classList.contains('multi-select')) {
        // multi select
        block.classList.add('active');
        if (this.onMultipleSelect) this.onMultipleSelect();
      } else {
        if (this.onSelectClear) this.onSelectClear();
        this.doc.querySelectorAll(this.selector + '.active').forEach(elm => elm.classList.remove('active'));
        block.classList.add('active');
        let actualBlock = block.classList.contains('clone') ? this.doc.querySelector(this.selector + '.cloned') : null;
        if (!actualBlock) actualBlock = block;
        if (this.onSelectBlock) this.onSelectBlock(actualBlock);
      }
      if (!block.parentNode) return; // just in case

      // Higlight parent group if current child block is clicked
      if (block.parentNode.matches(this.selector)) {
        block.parentNode.classList.add('block-active');
      } else {
        this.doc.querySelectorAll('.block-active').forEach(elm => elm.classList.remove('block-active'));
      }
    } else {
      if (event.target.closest('.keep-selection') || this.controlSelector && event.target.closest(this.controlSelector)) return;

      // // Make empty height set with value
      // // if(this.clickedBlock) this.common.updateHeight(this.clickedBlock);
      // // Check
      // if(this.clickedBlock && !this.clickedBlock.classList.contains('clone')) {
      //     this.common.updateHeight(this.clickedBlock);
      // }

      this.doc.querySelectorAll(this.selector + '.active').forEach(elm => elm.classList.remove('active'));
      this.doc.querySelectorAll('.block-active').forEach(elm => elm.classList.remove('block-active'));
      if (this.onSelectClear) this.onSelectClear();

      // Return back the scrollbar state when clicking on page (not block)
      this.doc.body.style.overflowY = ''; // see handleSelect()
    }

    // Check if multiple selection occurs. If so, add 'multi' class to hide all the handles
    let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && !elm.classList.contains('clone'));
    if (blocks.length > 1) {
      blocks.forEach(block => {
        block.classList.add('multi');
      });
    } else {
      const elms = this.doc.querySelectorAll('.multi');
      elms.forEach(elm => elm.classList.remove('multi'));
    }
  }
  delete() {
    let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && elm.classList.contains('editable'));
    if (blocks.length > 0) return;
    if (this.onBeforeChange) this.onBeforeChange();
    blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active'));
    blocks.forEach(element => {
      element.removeEventListener('mousedown', this.handleDragStart);
      element.removeEventListener('touchstart', this.handleDragStart);
      if (this.onDelete) this.onDelete(element);
      element.parentNode.removeChild(element);
    });
    if (this.onChange) this.onChange();
  }
  handleKeyDown(event) {
    if (event.key === 'Delete' || event.key === 'Backspace' || event.keyCode === 46) {
      if (document.activeElement.tagName.toLowerCase() === 'input' || document.activeElement.tagName.toLowerCase() === 'textarea') ; else {
        this.delete();
      }
    }
  }
}
class Editable {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.controlSelector = options && options.controlSelector || null;
    this.onEditStart = options && options.onEditStart || null;
    this.onEditEnd = options && options.onEditEnd || null;
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.onContentClick = options && options.onContentClick || null;
    this.elements = this.doc.querySelectorAll(this.selector);
    this.handleEditStart = this.handleEditStart.bind(this);
    this.handleMouseClick = this.handleMouseClick.bind(this);
    this.handleTouchStart = this.handleTouchStart.bind(this);
    this.setup();
  }
  setup() {
    this.elements.forEach(element => {
      element.addEventListener('dblclick', this.handleEditStart);
      element.addEventListener('touchstart', this.handleTouchStart, {
        passive: false
      });
    });
  }
  refresh() {
    this.elements = this.doc.querySelectorAll(this.selector);
    this.elements.forEach(element => {
      element.removeEventListener('dblclick', this.handleEditStart);
      element.removeEventListener('touchstart', this.handleTouchStart);
    });
    this.elements.forEach(element => {
      element.addEventListener('dblclick', this.handleEditStart);
      element.addEventListener('touchstart', this.handleTouchStart, {
        passive: false
      });
    });
  }
  destroy(element) {
    if (element) {
      element.removeEventListener('dblclick', this.handleEditStart);
      element.removeEventListener('touchstart', this.handleTouchStart);
    } else {
      this.elements = this.doc.querySelectorAll(this.selector);
      this.elements.forEach(element => {
        element.removeEventListener('dblclick', this.handleEditStart);
        element.removeEventListener('touchstart', this.handleTouchStart);
      });
    }
  }
  handleEditStart(event) {
    const currentTarget = event.currentTarget;
    if (currentTarget.querySelector(this.selector)) {
      // if group, no edit needed
      return;
    }
    const block = event.target.closest(this.selector);
    if (currentTarget !== block) {
      // Triggered Group click by child block click
      return; // Return here, so that when block events are working, group events won't
    }

    if (block.parentNode.matches(this.selector) && block.parentNode.classList.contains('active')) {
      // if group is active, no edit needed
      return;
    }
    this.clickedBlock = currentTarget;

    // currentTarget.classList.add('editable');
    // currentTarget.setAttribute('contentEditable', true);
    // currentTarget.style.cursor = 'auto'; // Change cursor to normal
    // currentTarget.focus();
    // this.placeCursorAtEnd(currentTarget);

    this.elements.forEach(element => {
      if (currentTarget === element) {
        element.removeEventListener('dblclick', this.handleEditStart);
        element.removeEventListener('touchstart', this.handleTouchStart);
        const clonedTarget = this.doc.querySelector(this.selector + '.cloned');
        if (clonedTarget) {
          clonedTarget.removeEventListener('dblclick', this.handleEditStart);
          clonedTarget.removeEventListener('touchstart', this.handleTouchStart);
          this.clickedBlock = clonedTarget;
        }
      }
    });
    this.doc.addEventListener('mousedown', this.handleMouseClick);
    this.doc.addEventListener('touchstart', this.handleMouseClick, {
      passive: false
    });
    if (this.onEditStart) this.onEditStart(event, currentTarget);
  }
  handleTouchStart(event) {
    // Handle Double Tab
    if (event.touches.length === 1) {
      const now = new Date().getTime();
      const lastTouchTime = this.lastTouchTime || now;
      const timeDiff = now - lastTouchTime;
      if (timeDiff < 300 && timeDiff > 0) {
        // Less than 300ms since the last touch, consider it a double-tap
        this.handleDoubleTap(event);
      }
      this.lastTouchTime = now;
    }
  }
  handleDoubleTap(event) {
    this.handleEditStart(event);
  }
  handleMouseClick(event) {
    const element = event.target;
    if (element.closest(this.selector) === this.clickedBlock || this.controlSelector && element.closest(this.controlSelector)) {
      // Do Nothing
      // Continue editing
      if (element.parentNode.matches(this.selector)) {
        if (this.onContentClick) this.onContentClick(event);
        // this.doc.querySelectorAll('.elm-active').forEach(elm=>elm.classList.remove('elm-active'));
        // element.classList.add('elm-active');
      }
    } else {
      let clickedBlock = this.clickedBlock;

      // currentTarget.classList.remove('editable');
      // clickedBlock.removeAttribute('contentEditable');
      // clickedBlock.style.cursor = '';

      if (this.onEditEnd) this.onEditEnd(this.clickedBlock);
      this.elements.forEach(element => {
        if (clickedBlock === element) {
          element.addEventListener('dblclick', this.handleEditStart);
          element.addEventListener('touchstart', this.handleTouchStart, {
            passive: false
          });
        }
      });
      this.doc.removeEventListener('mousedown', this.handleMouseClick);
      this.doc.removeEventListener('touchstart', this.handleMouseClick);

      // this.doc.querySelectorAll('.elm-active').forEach(elm=>elm.classList.remove('elm-active'));
    }
  }

  quitEditable(block) {
    if (this.onEditEnd) this.onEditEnd(block);
    block.addEventListener('dblclick', this.handleEditStart);
    block.addEventListener('touchstart', this.handleTouchStart, {
      passive: false
    });
    this.doc.removeEventListener('mousedown', this.handleMouseClick);
    this.doc.removeEventListener('touchstart', this.handleMouseClick);
  }
  placeCursorAtEnd(element) {
    const range = this.doc.createRange();
    const sel = this.win.getSelection();
    range.setStart(element, element.childNodes.length);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }
}
class BlockSelector {
  constructor(options) {
    this.selector = options && options.selector || '.is-block';
    this.parentSelector = options && options.parentSelector || 'body';
    this.doc = options && options.doc || document;
    this.win = options && options.win || window;
    this.disableOnMobile = options && options.disableOnMobile || 0;
    this.onMultipleSelect = options && options.onMultipleSelect || null;
    this.isDragging = false;
    this.startCoords = {
      x: 0,
      y: 0
    };
    const handleHTML = `
        <div class="selection-rectangle"></div>`;
    this.doc.body.insertAdjacentHTML('afterbegin', handleHTML);
    this.selectionRect = this.doc.querySelector('.selection-rectangle');
    const styleHTML = `
        <style id="styleSelector">
            .selection-rectangle {
                position: absolute;
                border: 1px solid #c2e2ff;
                pointer-events: none;
                display: none;
                background-color: #a9c4e442;
                z-index:1
            }
        <style>
        `;
    const elmStyle = this.doc.querySelector('#styleSelector');
    if (!elmStyle) this.doc.head.insertAdjacentHTML('beforeend', styleHTML);
    this.handleDragStart = this.handleDragStart.bind(this);
    this.handleDragMove = this.handleDragMove.bind(this);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.doc.addEventListener('mousedown', this.handleDragStart);
    this.doc.addEventListener('touchstart', this.handleDragStart, {
      passive: false
    });
  }
  destroy() {
    const elmStyle = this.doc.querySelector('#styleSelector');
    if (elmStyle) elmStyle.parentNode.removeChild(elmStyle);
    const selectionRect = this.doc.querySelector('.selection-rectangle');
    if (selectionRect) selectionRect.parentNode.removeChild(selectionRect);
    this.doc.removeEventListener('mousedown', this.handleDragStart);
    this.doc.removeEventListener('touchstart', this.handleDragStart);
  }
  handleDragStart(event) {
    const viewportWidth = this.win.innerWidth;
    if (viewportWidth <= this.disableOnMobile) return;
    if (event.type === 'touchstart' && event.touches.length !== 1) {
      return; // Do nothing if more than one touch point is detected
    }

    if (event.type === 'mousedown' && event.button !== 0) {
      return; // Do nothing if the right mouse button is clicked
    }

    if (event.target.closest(this.selector)) return;
    if (!event.target.closest(this.parentSelector)) return;
    if (event.target.closest('.keep-selection')) return;
    this.dragStartTimeout = setTimeout(() => {
      // Set a timeout before starting the drag (to differentiate from click)

      this.isDragging = true;
      let clientX, clientY;
      if (event.type === 'mousedown') {
        clientX = event.clientX;
        clientY = event.clientY;
      } else if (event.type === 'touchstart') {
        const touch = event.touches[0];
        clientX = touch.clientX;
        clientY = touch.clientY;
      }
      this.startCoords = {
        x: clientX,
        y: clientY
      };
      this.updateSelectionRect(this.startCoords, this.startCoords);
      this.doc.addEventListener('mousemove', this.handleDragMove);
      this.doc.addEventListener('touchmove', this.handleDragMove);
      this.doc.body.style.userSelect = 'none';
    }, 100);
    this.doc.addEventListener('mouseup', this.handleDragEnd);
    this.doc.addEventListener('touchend', this.handleDragEnd);
  }
  handleDragMove(event) {
    if (!this.isDragging) return;
    if (event.target.closest('.keep-selection')) return;
    let clientX, clientY;
    if (event.type === 'mousemove') {
      clientX = event.clientX;
      clientY = event.clientY;
    } else if (event.type === 'touchmove') {
      const touch = event.touches[0];
      clientX = touch.clientX;
      clientY = touch.clientY;
    }
    this.updateSelectionRect(this.startCoords, {
      x: clientX,
      y: clientY
    });
    this.selectBlocksInArea(this.startCoords, {
      x: clientX,
      y: clientY
    });
  }
  handleDragEnd() {
    clearTimeout(this.dragStartTimeout);
    this.isDragging = false;
    this.selectionRect.style.display = 'none';
    this.doc.removeEventListener('mousemove', this.handleDragMove);
    this.doc.removeEventListener('touchmove', this.handleDragMove);
    this.doc.removeEventListener('mouseup', this.handleDragEnd);
    this.doc.removeEventListener('touchend', this.handleDragEnd);
    this.doc.body.style.userSelect = '';
    const elms = this.doc.querySelectorAll(this.selector + '.active');
    if (elms.length > 1) this.onMultipleSelect();
  }
  updateSelectionRect(start, end) {
    const minX = Math.min(start.x, end.x);
    const minY = Math.min(start.y, end.y) + this.win.scrollY;
    const width = Math.abs(start.x - end.x);
    const height = Math.abs(start.y - end.y);
    this.selectionRect.style.left = `${minX}px`;
    this.selectionRect.style.top = `${minY}px`;
    this.selectionRect.style.width = `${width}px`;
    this.selectionRect.style.height = `${height}px`;
    this.selectionRect.style.display = 'block';
  }
  selectBlocksInArea(start, end) {
    const blocks = this.doc.querySelectorAll(this.selector);
    blocks.forEach(block => {
      const rect = block.getBoundingClientRect();
      if (rect.left < Math.max(start.x, end.x) && rect.right > Math.min(start.x, end.x) && rect.top < Math.max(start.y, end.y) && rect.bottom > Math.min(start.y, end.y)) {
        if (block.parentNode.matches(this.selector)) ; else {
          block.classList.add('active');
          let elms = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && !elm.classList.contains('clone'));
          if (elms.length > 1) block.classList.add('multi');
        }
      } else {
        block.classList.remove('active');
        block.classList.remove('multi');
      }
    });
  }
  unSelect() {
    const blocks = this.doc.querySelectorAll(this.selector);
    blocks.forEach(elm => elm.classList.remove('active'));
  }
}
class EditableBlocks {
  constructor(options = {}) {
    const defaults = {
      selector: '.is-block',
      parentSelector: 'body',
      // controlSelector: '.is-tool',
      doc: document,
      win: window,
      // onBeforeChange: () => {},
      // onChange: () => {},
      // onContentClick: () => {},
      // onEditStart: () => {},
      // onEditEnd: () => {},
      // onDuplicate: () => {},
      // onSelectBlock:  (block) => {},
      // onUnSelectBlock: () => {},
      // onMultipleSelect: () => {},
      disableOnMobile: 0,
      rotate: true,
      clone: true,
      zoom: 1
      // onDelete: () = {}
    };

    Object.assign(this, defaults, options);
    this.init();
  }
  checkOverlap(target) {
    return this.common.checkOverlap(target);
  }
  forward(target) {
    let newZIndex;
    if (!target.style.zIndex) {
      newZIndex = 1;
    } else {
      newZIndex = parseInt(target.style.zIndex) + 1;
    }
    target.style.zIndex = newZIndex;
  }
  backward(target) {
    let newZIndex;
    if (!target.style.zIndex) {
      newZIndex = 0;
    } else {
      if (parseInt(target.style.zIndex) - 1 < 0) newZIndex = 0;else newZIndex = parseInt(target.style.zIndex) - 1;
    }
    target.style.zIndex = newZIndex;
  }
  selectStart(block) {
    if (block.classList.contains('is-shape')) return; // do not clone if block is shape

    if (!this.clone) return;
    const viewportWidth = this.win.innerWidth;
    if (block.closest('.autolayout') && viewportWidth <= 760) {
      return;
    }
    if (block.classList.contains('is-group')) return; // do not clone if block is shape

    if (!block.classList.contains('clone')) {
      let clonedDiv = block.cloneNode(true);
      clonedDiv.classList.add('clone');
      block.parentNode.appendChild(clonedDiv);
      block.classList.add('cloned');
      this.refresh();
    }
  }
  selectClear() {
    this.doc.querySelectorAll('.clone').forEach(elm => elm.parentNode.removeChild(elm));
    this.doc.querySelectorAll('.cloned').forEach(elm => elm.classList.remove('cloned'));
  }
  setMultiSelect(multiSelect) {
    if (multiSelect) this.doc.body.classList.add('multi-select');else this.doc.body.classList.remove('multi-select');
  }
  generateRandom() {
    let text = '';
    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    for (let i = 0; i < 2; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    let text2 = '';
    let possible2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 5; i++) text2 += possible2.charAt(Math.floor(Math.random() * possible2.length));
    return text + text2;
  }
  getElmClass(elm) {
    let elmClassName = '';
    elm.classList.forEach(item => {
      if (item.includes('g-')) {
        elmClassName = item;
      }
    });
    if (elmClassName === '') {
      elmClassName = 'g-' + this.generateRandom();
      elm.classList.add(elmClassName);
    }
    return elmClassName;
  }
  readCss() {
    let css = '';
    const elms = this.doc.querySelectorAll(this.selector);
    elms.forEach(elm => {
      if (elm.classList.contains('clone')) return;
      const elmClassName = this.getElmClass(elm);
      const baseWidth = elm.getAttribute('data--w');
      const baseHeight = elm.getAttribute('data--h');
      const baseTop = elm.getAttribute('data--t');
      const baseLeft = elm.getAttribute('data--l');
      const baseBottom = elm.getAttribute('data--b');
      const baseRight = elm.getAttribute('data--r');
      const mediaQueries = [];
      let breakpoints = this.getBreakpoints(elm);
      breakpoints.sort(function (a, b) {
        return b - a;
      });
      for (let i = 0; i < breakpoints.length; i++) {
        const num = breakpoints[i];
        let s = '';
        const width = elm.getAttribute('data--w-' + num);
        if (width) s += `width: ${width};`;
        const height = elm.getAttribute('data--h-' + num);
        if (height) s += `height: ${height};`;
        const top = elm.getAttribute('data--t-' + num);
        if (top) s += `top: ${top};`;
        const left = elm.getAttribute('data--l-' + num);
        if (left) s += `left: ${left};`;
        const bottom = elm.getAttribute('data--b-' + num);
        if (bottom) s += `bottom: ${bottom};`;
        const right = elm.getAttribute('data--r-' + num);
        if (right) s += `right: ${right};`;
        mediaQueries.push(`@media (max-width: ${num}px) {
                    .${elmClassName} {
                        ${s}
                    }
                }`);
      }
      css += `
                .${elmClassName} {
                    ${baseWidth ? `width: ${baseWidth};` : ''}${baseHeight ? `height: ${baseHeight};` : ''}
                    ${baseTop ? `top: ${baseTop};` : ''}${baseBottom ? `bottom: ${baseBottom};` : ''}
                    ${baseLeft ? `left: ${baseLeft};` : ''}${baseRight ? `right: ${baseRight};` : ''}
                }
                ${mediaQueries.join('\n')}
            `;
    });
    return css;
  }
  updateCss() {
    const css = this.readCss();
    localStorage.setItem('_cssblock', css);
    let cssBlock = this.doc.querySelector('#_cssBlock');
    if (!cssBlock) {
      this.doc.head.insertAdjacentHTML('beforeend', '<style id="_cssBlock"></style>');
      cssBlock = this.doc.querySelector('#_cssBlock');
    }
    if (cssBlock) {
      cssBlock.innerHTML = css; // apply css

      // clear inline css
      const elms = this.doc.querySelectorAll(this.selector);
      elms.forEach(elm => {
        elm.style.width = '';
        elm.style.height = '';
        elm.style.top = '';
        elm.style.left = '';
        elm.style.bottom = '';
        elm.style.right = '';
      });
    }
  }
  init() {
    // // load css
    // let css = localStorage.getItem('_cssblock');
    // let cssBlock = this.doc.querySelector('#_cssBlock');
    // if(!cssBlock) {
    //     this.doc.head.insertAdjacentHTML('beforeend','<style id="_cssBlock"></style>');
    //     cssBlock = this.doc.querySelector('#_cssBlock');
    // }
    // if(css) cssBlock.innerHTML = css;

    this.doc.body.classList.add('editableblocks');
    this.draggable = new Draggable({
      selector: this.selector,
      disableOnMobile: this.disableOnMobile,
      doc: this.doc,
      win: this.win,
      controlSelector: this.controlSelector,
      onDelete: element => {
        if (this.rotatable) this.rotatable.destroy(element);
        this.resizable.destroy(element);
        this.editable.destroy(element);
        if (this.onDelete) this.onDelete();
      },
      onBeforeChange: () => {
        if (this.onBeforeChange) this.onBeforeChange();
      },
      onChange: () => {
        if (this.onChange) this.onChange();

        // this.updateCss();
      },

      onMultipleSelect: this.onMultipleSelect,
      onSelectStart: block => {
        // for cloning
        this.selectStart(block);
      },
      onSelectClear: () => {
        // for removing clones
        this.selectClear();
        if (this.onUnselectBlock) this.onUnselectBlock();
      },
      onSelectBlock: this.onSelectBlock
    });
    this.resizable = new Resizable({
      selector: this.selector,
      disableOnMobile: this.disableOnMobile,
      doc: this.doc,
      win: this.win,
      onBeforeChange: () => {
        if (this.onBeforeChange) this.onBeforeChange();
      },
      onChange: () => {
        if (this.onChange) this.onChange();

        // this.updateCss();
      }
    });

    if (this.rotate) {
      this.rotatable = new Rotatable({
        selector: this.selector,
        disableOnMobile: this.disableOnMobile,
        doc: this.doc,
        win: this.win,
        onBeforeChange: () => {
          if (this.onBeforeChange) this.onBeforeChange();
        },
        onChange: () => {
          if (this.onChange) this.onChange();
        }
      });
    }
    this.editable = new Editable({
      selector: this.selector,
      controlSelector: this.controlSelector,
      doc: this.doc,
      win: this.win,
      onContentClick: this.onContentClick,
      onEditStart: (event, block) => {
        const container = block.querySelector('.is-container');
        if (!container) return; // if block is empty, no edit required

        if (block.classList.contains('clone')) {
          const clonedTarget = this.doc.querySelector(this.selector + '.cloned');
          this.onEditStart(event, clonedTarget);
          this.selectClear();

          // Disable drag during editing
          if (!this.draggable) return;
          this.draggable.disableDrag(clonedTarget);
          return;
        }
        this.onEditStart(event, block);

        // Disable drag during editing
        if (!this.draggable) return;
        this.draggable.disableDrag(block);
      },
      onEditEnd: block => {
        this.onEditEnd(block);

        // Enable drag
        if (!this.draggable) return;
        this.draggable.enableDrag(block);
      }
    });
    this.blockSelector = new BlockSelector({
      selector: this.selector,
      parentSelector: this.parentSelector,
      disableOnMobile: this.disableOnMobile,
      onMultipleSelect: this.onMultipleSelect,
      doc: this.doc,
      win: this.win
    });
    this.common = new Common({
      selector: this.selector,
      doc: this.doc,
      win: this.win,
      onDuplicate: this.onDuplicate
    });
    this.setZoom(this.zoom);
  }
  setZoom(scale) {
    this.common.setZoom(scale);
    this.draggable.setZoom(scale);
    this.resizable.setZoom(scale);
  }
  duplicate() {
    this.common.duplicate();
    this.refresh();
  }
  delete() {
    this.draggable.delete();
  }
  getBreakpoints(block) {
    return this.common.getBreakpoints(block);
  }
  placeCursorAtEnd(block) {
    this.editable.placeCursorAtEnd(block);
  }
  quitEditable(block) {
    this.editable.quitEditable(block);
  }
  destroy() {
    if (!this.draggable) return;
    this.draggable.destroy();
    this.resizable.destroy();
    if (this.rotatable) this.rotatable.destroy();
    this.editable.destroy();
    this.blockSelector.destroy();
    this.draggable = null;
    this.doc.body.classList.remove('editableblocks');
  }
  refresh() {
    // Call refresh() whenever blocks are added 
    this.draggable.refresh();
    this.resizable.refresh();
    if (this.rotatable) this.rotatable.refresh();
    this.editable.refresh();
  }
  addBlock(html, container) {
    this.selectClear(); // clear clones
    this.blockSelector.unSelect(); // clear active

    const parser = new DOMParser();
    let doc = parser.parseFromString(html, 'text/html');
    const block = doc.querySelector('.is-block');
    block.classList.add('block-dummy');
    html = doc.body.innerHTML;
    container.insertAdjacentHTML('beforeend', html);
    const newBlock = container.querySelector('.block-dummy');
    if (newBlock) {
      newBlock.classList.remove('block-dummy');
      if (this.onAddBlock) this.onAddBlock(newBlock);
      newBlock.classList.add('active');
    }
    this.refresh();
  }
  group() {
    const group = this.common.group('is-block', 'is-group');
    this.refresh();
    return group;
  }
  unGroup() {
    this.common.unGroup();
  }
  addBreakpoint() {
    this.common.addBreakpoint();
  }
  clearBreakpoint(target) {
    this.common.clearBreakpoint(target);
    if (target.classList.contains('cloned')) {
      const cloneTarget = this.doc.querySelector(this.selector + '.clone');
      this.common.clearBreakpoint(cloneTarget);
    }
  }
  clearAllBreakpoints(container) {
    this.common.clearAllBreakpoints(container);
  }
  isMultiSelect() {
    // Check if multiple selection occurs. If so, add 'multi' class to hide all the handles
    let blocks = Array.from(this.doc.querySelectorAll(this.selector)).filter(elm => elm.classList.contains('active') && !elm.classList.contains('clone'));
    if (blocks.length > 1) return true;
    return false;
  }
}

class BlockModal {
  constructor(builder) {
    this.builder = builder;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    const util = this.builder.util;
    this.util = util;
    const dom = this.builder.dom;
    this.dom = dom;
    let modal = builderStuff.querySelector('.is-modal.editblock');
    if (!modal) {
      let html = `
            <div class="is-modal is-modal-content editblock" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-bar is-draggable">
                    <span class="modal-title"></span>
                    <button class="is-modal-close" tabindex="-1" title="${util.out('Close')}">&#10005;</button>
                </div>
                <div class="modal-none" style="display:none;padding-bottom:28px;">
                
                    <div>${util.out('Please select a block or page.')}</div>

                </div>

                <div class="modal-page-content" style="display:none;padding-bottom:28px;">

                    <div style="padding-bottom: 3px;">${util.out('Background Color')}:</div>
                    <div style="display:flex;">
                        <button title="${util.out('Background Color')}" class="input-page-bgcolor is-btn-color" style="margin-right:15px"></button>
                        <button title="${util.out('Gradient')}" class="btn-page-gradient classic" data-value="+"> ${util.out('Gradient')} </button>
                    </div>

                    <div style="padding-top:20px;padding-bottom: 3px;">${util.out('Background Image')}:</div>
                    <div>
                        <div class="asset-page-preview" style="display:none"></div>
                        <div style="display: flex">
                            <button title="${util.out('Image')}" class="btn-page-bgimage">
                                <svg class="is-icon-flex"><use xlink:href="#ion-image"></use></svg>
                                <span>${util.out('Image')}</span>
                            </button>
                            <button title="${util.out('Select')}" class="btn-page-asset">${this.builder.opts.selectIcon}</button>
                            <button title="${util.out('Remove')}" class="btn-page-clear"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                            <button title="${util.out('Adjust')}" class="btn-page-adjust" style="width:40px"><svg class="is-icon-flex"><use xlink:href="#ion-wrench"></use></svg></button>
                        </div>
                    </div>

                    <div class="label-page-grayscale label checkbox grayscale" style="padding:30px 0 10px;">
                        <label class="label-checkbox" for="chkPageGrayscale"><input id="chkPageGrayscale" class="chk-grayscale" type="checkbox" /> ${util.out('Grayscale')}</label>
                    </div>

                    <div style="padding-top:30px;padding-bottom:3px;">${util.out('Auto layout on mobile')}:</div>

                    <label class="switch"><input id="inpAutoLayout" type="checkbox" checked=""><span class="slider round"></span></label>

                </div>

                <div class="modal-content" style="padding:0">

                    <div class="is-tabs" data-group="blocksettings" style="background-color:transparent">
                        <a title="${util.out('General')}" id="tabBlockGeneral" href="#" data-content="divBlockGeneral" class="active">${util.out('General')}</a>
                        <a title="${util.out('More')}" id="tabBlockMore" href="#" data-content="divBlockMore">${util.out('More')}</a>
                    </div>

                    <div id="divBlockMore" class="is-tab-content" data-group="blocksettings" tabindex="-1" style="padding:25px 25px 28px">

                        <div class="div-target" style="display: flex;justify-content: flex-end;padding: 5px 0 0;">
                            <button title="${util.out('Desktop')}" class="input-device on" data-value="" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-desktop"></use></svg>
                            </button>
                            <button title="${util.out('Laptop/Tablet (Landscape)')}" class="input-device" data-value="md" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px;transform:rotate(-90deg)"><use xlink:href="#icon-device-tablet"></use></svg>
                            </button>
                            <button title="${util.out('Tablet (Portrait)')}" class="input-device" data-value="sm" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-device-tablet"></use></svg>
                            </button>
                            <button title="${util.out('Mobile')}" class="input-device" data-value="xs" style="width:40px;height:25px;">
                                <svg class="is-icon-flex" style="width:13px;height:13px"><use xlink:href="#icon-device-mobile"></use></svg>
                            </button>
                        </div>

                        <div style="padding-top:0;padding-bottom:3px;">${util.out('Visibility')}:</div>
                        <div class="div-visibility" style="display:flex;">
                            <button title="${util.out('Visible')}" class="input-visible on" data-value="sm" style="width:100px;height:34px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye"></use></svg>
                                <span>${util.out('Visible')}</span>
                            </button>
                            <button title="${util.out('Hidden')}" class="input-hidden" data-value="xs" style="width:100px;height:34px;">
                                <svg class="is-icon-flex" style="width:16px;height:16px"><use xlink:href="#icon-eye-off"></use></svg>
                                <span>${util.out('Hidden')}</span>
                            </button>
                        </div>
                        
                    </div>

                    <div id="divBlockGeneral" class="is-tab-content active" data-group="blocksettings" style="display:flex" tabindex="-1" style="padding:25px 25px 28px">

                        <div style="padding-bottom: 3px;">${util.out('Background Color')}:</div>
                        <div style="display:flex;">
                            <button title="${util.out('Background Color')}" class="input-block-bgcolor is-btn-color" style="margin-right:15px"></button>
                            <button title="${util.out('Gradient')}" class="btn-block-gradient classic" data-value="+"> ${util.out('Gradient')} </button>
                        </div>

                        <div style="padding-top:20px;padding-bottom: 3px;">${util.out('Background Image')}:</div>
                        <div>
                            <div class="asset-block-preview" style="display:none"></div>
                            <div style="display: flex">
                                <button title="${util.out('Image')}" class="btn-block-bgimage">
                                    <svg class="is-icon-flex"><use xlink:href="#ion-image"></use></svg>
                                    <span>${util.out('Image')}</span>
                                </button>
                                <button title="${util.out('Select')}" class="btn-block-asset">${this.builder.opts.selectIcon}</button>
                                <button title="${util.out('Remove')}" class="btn-block-clear"><svg class="is-icon-flex" style="width:11px;height:11px;"><use xlink:href="#icon-clean"></use></svg></button>
                                <button title="${util.out('Adjust')}" class="btn-block-adjust" style="width:40px"><svg class="is-icon-flex"><use xlink:href="#ion-wrench"></use></svg></button>
                            </div>
                        </div>

                        <div class="div-content-textcolor flex flex-col">
                            <div style="padding-top:20px;padding-bottom:3px;">${util.out('Text Color')}:</div>
                            <div class="flex flex-row">
                                <button title="0" data-textcolor="dark">${util.out('Dark')}</button>
                                <button title="10" data-textcolor="light">${util.out('Light')}</button>
                                
                                <button title="${util.out('Clear')}" data-textcolor=""><svg class="is-icon-flex" style="flex:none;width:18px;height:18px;margin-top: 2px;"><use xlink:href="#ion-ios-close-empty"></use></svg></button>
                            </div>
                        </div>

                        <div class="label-block-grayscale label checkbox grayscale" style="padding:30px 0 10px;">
                            <label class="label-checkbox" for="chkBlockGrayscale"><input id="chkBlockGrayscale" class="chk-grayscale" type="checkbox" /> ${util.out('Grayscale')}</label>
                        </div>

                        <button title="${util.out('Remove Content/Text')}" class="btn-clear-text" style="margin-top:20px">
                            <svg class="is-icon-flex"><use xlink:href="#icon-trash"></use></svg>
                            <span>${util.out('Remove Content/Text')}</span>
                        </button>

                        <button title="${util.out('Clear Breakpoints')}" class="btn-clear-breakpoint" style="margin-top:20px">
                            <svg class="is-icon-flex"><use xlink:href="#icon-trash"></use></svg>
                            <span>${util.out('Clear Breakpoints')}</span>
                        </button>

                        <div style="padding-top:23px;padding-bottom:3px;">${util.out('Lock')}:</div>

                        <label class="switch"><input id="inpLockBlock" type="checkbox" checked=""><span class="slider round"></span></label>

                        <div id="divBlockPos">

                            <div class="flex" style="gap:10px">
                                <div>
                                    <label for="inpBlockTop" class="flex" style="padding:10px 0 3px;">${util.out('Top')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockTop" class="inp-block-top" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockTopUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                                <div>
                                    <label for="inpBlockBottom" class="flex" style="padding:10px 0 3px;">${util.out('Bottom')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockBottom" class="inp-block-top" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockBottomUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div class="flex" style="gap:10px">
                                <div>
                                    <label for="inpBlockLeft" class="flex" style="padding:10px 0 3px;">${util.out('Left')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockLeft" class="inp-block-left" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockLeftUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                                <div>
                                    <label for="inpBlockRight" class="flex" style="padding:10px 0 3px;">${util.out('Right')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockRight" class="inp-block-left" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockRightUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div class="flex" style="gap:10px">
                                <div>
                                    <label for="inpBlockWidth" class="flex" style="padding:10px 0 3px;">${util.out('Width')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockWidth" class="inp-block-left" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockWidthUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                                <div>
                                    <label for="inpBlockHeight" class="flex" style="padding:10px 0 3px;">${util.out('Height')}:</label>
                                    <div style="display:flex">
                                        <input id="inpBlockHeight" class="inp-block-left" type="text" style="width:74px;height:35px">
                                        <select id="inpBlockHeightUnit">
                                            <option></option>
                                            <option>px</option>
                                            <option>%</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                        </div>

                    </div>

                </div>
            </div>`;
      dom.appendHtml(builderStuff, html);
      modal = builderStuff.querySelector('.is-modal.editblock');
    }
    this.modal = modal;
    let btnClose = modal.querySelector('.is-modal-close');
    dom.addEventListener(btnClose, 'click', () => {
      this.hide();
    });

    // Page Background color

    const btnPageGradient = modal.querySelector('.btn-page-gradient');
    const btnPageColorPick = modal.querySelector('.input-page-bgcolor');
    btnPageColorPick.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let page = this.getPage();
      let bgcolor = btnPageColorPick.style.backgroundColor;
      this.builder.colorPicker.open(s => {
        page.style.backgroundColor = s;
        if (page.style.backgroundImage && page.style.backgroundImage.includes('gradient')) {
          page.style.backgroundImage = ''; // remove gradient
          btnPageGradient.style.backgroundImage = ''; // preview
        }

        btnPageColorPick.style.backgroundColor = s; // preview

        this.builder.onChange();
      }, bgcolor, () => {
        btnPageColorPick.removeAttribute('data-focus');
        btnPageColorPick.focus();
      });
      btnPageColorPick.setAttribute('data-focus', true);
    });
    btnPageGradient.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let page = this.getPage();
      let gradientPicker = this.builder.gradientpicker();
      gradientPicker.open(page, () => {
        page.style.backgroundColor = '';
        btnPageColorPick.style.backgroundColor = ''; // preview

        this.updatePanelImage('');
        this.builder.onChange();
        btnPageGradient.style.backgroundImage = page.style.backgroundImage; // preview
      });
    });

    // Block Background color

    const btnGradient = modal.querySelector('.btn-block-gradient');
    const btnColorPick = modal.querySelector('.input-block-bgcolor');
    btnColorPick.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let blockOverlay = this.blockOverlay();
      let bgcolor = btnColorPick.style.backgroundColor;
      this.builder.colorPicker.open(s => {
        blockOverlay.style.backgroundColor = s;
        if (blockOverlay.style.backgroundImage && blockOverlay.style.backgroundImage.includes('gradient')) {
          blockOverlay.style.backgroundImage = ''; // remove gradient
          btnGradient.style.backgroundImage = ''; // preview
        }

        btnColorPick.style.backgroundColor = s; // preview

        this.builder.onChange();
      }, bgcolor, () => {
        btnColorPick.removeAttribute('data-focus');
        btnColorPick.focus();
      });
      btnColorPick.setAttribute('data-focus', true);
    });
    btnGradient.addEventListener('click', () => {
      this.builder.uo.saveForUndo(true); // checkLater = true

      let blockOverlay = this.blockOverlay();
      let gradientPicker = this.builder.gradientpicker();
      gradientPicker.open(blockOverlay, () => {
        blockOverlay.style.backgroundColor = '';
        btnColorPick.style.backgroundColor = ''; // preview

        this.updatePanelImage('');
        this.builder.onChange();
        btnGradient.style.backgroundImage = blockOverlay.style.backgroundImage; // preview
      });
    });

    // Page Background Image

    this.pageImagePreview = modal.querySelector('.asset-page-preview');
    const btnPageBgImage = modal.querySelector('.btn-page-bgimage');
    if (btnPageBgImage) dom.addEventListener(btnPageBgImage, 'click', () => {
      // Background image
      let pageOverlay = this.pageOverlay();
      let src = '';
      if (pageOverlay) if (pageOverlay.style.backgroundImage) {
        if (pageOverlay.style.backgroundImage.indexOf('url(') !== -1) {
          src = pageOverlay.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      }
      this.openImagePicker(src, url => {
        let pageOverlay = this.pageOverlay();
        this.builder.uo.saveForUndo();
        pageOverlay.style.backgroundImage = `url("${url}")`;
        pageOverlay.style.backgroundSize = 'cover';
        pageOverlay.style.backgroundRepeat = 'no-repeat';
        const div = this.pageImagePreview;
        const btnPageAdjust = modal.querySelector('.btn-page-adjust');
        const btnPageClear = modal.querySelector('.btn-page-clear');
        btnPageAdjust.style.display = 'none';
        btnPageClear.style.display = 'none';
        if (url !== '') {
          div.innerHTML = `<img src="${url}">`;
          btnPageAdjust.style.display = 'flex';
          btnPageClear.style.display = 'flex';
        } else {
          div.innerHTML = '';
        }
        this.builder.onChange();
      }, btnPageBgImage);
    });
    const btnPageOpenAsset = modal.querySelector('.btn-page-asset');
    btnPageOpenAsset.addEventListener('click', () => {
      this.builder.openAssetSelect('image', src => {
        this.updatePageImage(src);
      }, btnPageOpenAsset);
    });

    // Show/hide button
    if (!(this.builder.onImageSelectClick || this.builder.imageSelect)) btnPageOpenAsset.style.display = 'none';
    const btnPageClear = modal.querySelector('.btn-page-clear');
    btnPageClear.addEventListener('click', () => {
      this.updatePageImage('');
    });
    const btnPageAdjust = modal.querySelector('.btn-page-adjust');
    btnPageAdjust.addEventListener('click', () => {
      let pageOverlay = this.pageOverlay();
      this.builder.colTool.openImageAdjust(pageOverlay, btnPageAdjust);
    });
    const chkPageGrayscale = modal.querySelector('#chkPageGrayscale');
    chkPageGrayscale.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      let pageOverlay = this.pageOverlay();
      const checked = chkPageGrayscale.checked;
      if (checked) {
        pageOverlay.style.filter = 'grayscale(1)';
      } else {
        if (pageOverlay.style.filter) pageOverlay.style.filter = pageOverlay.style.filter.replace('grayscale(1)', '');
      }
      this.builder.onChange();
    });

    // Page Auto Layout
    const chkAutoLayout = modal.querySelector('#inpAutoLayout');
    chkAutoLayout.addEventListener(this.builder.isTouchSupport ? 'touchstart' : 'click', () => {
      const page = this.getPage();
      if (chkAutoLayout.checked) {
        page.classList.add('autolayout');
      } else {
        page.classList.remove('autolayout');
      }
    });
    if (this.builder.isTouchSupport) {
      let chkAutoLayoutLabel = chkAutoLayout.parentNode;
      chkAutoLayoutLabel.addEventListener('touchstart', () => {
        const page = this.getPage();
        if (chkAutoLayout.checked) {
          page.classList.add('autolayout');
        } else {
          page.classList.remove('autolayout');
        }
      });
    }

    // Block Background Image

    this.imagePreview = modal.querySelector('.asset-block-preview');
    const btnBgImage = modal.querySelector('.btn-block-bgimage');
    if (btnBgImage) dom.addEventListener(btnBgImage, 'click', () => {
      // Background image
      const blockOverlay = this.blockOverlay();
      let src = '';
      if (blockOverlay) if (blockOverlay.style.backgroundImage) {
        if (blockOverlay.style.backgroundImage.indexOf('url(') !== -1) {
          src = blockOverlay.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      }
      this.openImagePicker(src, url => {
        const blockOverlay = this.blockOverlay();
        this.builder.uo.saveForUndo();
        blockOverlay.style.backgroundImage = `url("${url}")`;
        blockOverlay.style.backgroundSize = 'cover';
        blockOverlay.style.backgroundRepeat = 'no-repeat';
        const div = this.imagePreview;
        const btnAdjust = modal.querySelector('.btn-block-adjust');
        const btnClear = modal.querySelector('.btn-block-clear');
        btnAdjust.style.display = 'none';
        btnClear.style.display = 'none';
        if (url !== '') {
          div.innerHTML = `<img src="${url}">`;
          btnAdjust.style.display = 'flex';
          btnClear.style.display = 'flex';
        } else {
          div.innerHTML = '';
        }
        this.builder.onChange();
      }, btnBgImage);
    });
    const btnOpenAsset = modal.querySelector('.btn-block-asset');
    btnOpenAsset.addEventListener('click', () => {
      this.builder.openAssetSelect('image', src => {
        this.updateImage(src);
      }, btnOpenAsset);
    });

    // Show/hide button
    if (!(this.builder.onImageSelectClick || this.builder.imageSelect)) btnOpenAsset.style.display = 'none';
    const btnClear = modal.querySelector('.btn-block-clear');
    btnClear.addEventListener('click', () => {
      this.updateImage('');
    });
    const btnAdjust = modal.querySelector('.btn-block-adjust');
    btnAdjust.addEventListener('click', () => {
      let blockOverlay = this.blockOverlay();
      this.builder.colTool.openImageAdjust(blockOverlay, btnAdjust);
    });
    const chkGrayscale = modal.querySelector('#chkBlockGrayscale');
    chkGrayscale.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      let blockOverlay = this.blockOverlay();
      const checked = chkGrayscale.checked;
      if (checked) {
        blockOverlay.style.filter = 'grayscale(1)';
      } else {
        if (blockOverlay.style.filter) blockOverlay.style.filter = blockOverlay.style.filter.replace('grayscale(1)', '');
      }
      this.builder.onChange();
    });

    // Text Color

    const btnTextColor = modal.querySelectorAll('[data-textcolor]');
    btnTextColor.forEach(btn => {
      btn.addEventListener('click', () => {
        let s = btn.getAttribute('data-textcolor');
        this.builder.uo.saveForUndo();
        const block = this.builder.doc.querySelector('.is-block.active:not(.multi)');
        if (s === 'light') {
          block.classList.remove('is-dark-text');
          block.classList.add('is-light-text');
        }
        if (s === 'dark') {
          block.classList.remove('is-light-text');
          block.classList.add('is-dark-text');
        }
        if (s === '') {
          block.classList.remove('is-light-text');
          block.classList.remove('is-dark-text');
        }
        this.builder.onChange();
        btnTextColor.forEach(btn => btn.classList.remove('on'));
        if (s !== '') btn.classList.add('on');
      });
    });

    // Remove Content/Text

    const btnClearText = modal.querySelector('.btn-clear-text');
    btnClearText.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      this.builder.doc.querySelectorAll('.is-block.active').forEach(block => {
        block.classList.remove('height-auto');
        block.style.height = block.offsetHeight + 'px';
        const container = block.querySelector('.is-container');
        if (container) container.parentNode.removeChild(container);
      });
      this.realtime();
      this.builder.onChange();
    });

    // Breakpoints

    const btnClearBreakpoint = modal.querySelector('.btn-clear-breakpoint');
    btnClearBreakpoint.addEventListener('click', () => {
      this.builder.uo.saveForUndo();
      const block = this.blockSelected();
      this.builder.eb.clearBreakpoint(block);
      this.realtime();
      this.builder.onChange();
    });

    //  Lock

    let timer;
    const inpTop = modal.querySelector('#inpBlockTop');
    const inpTopUnit = modal.querySelector('#inpBlockTopUnit');
    const inpLeft = modal.querySelector('#inpBlockLeft');
    const inpLeftUnit = modal.querySelector('#inpBlockLeftUnit');
    const inpWidth = modal.querySelector('#inpBlockWidth');
    const inpWidthUnit = modal.querySelector('#inpBlockWidthUnit');
    const inpHeight = modal.querySelector('#inpBlockHeight');
    const inpHeightUnit = modal.querySelector('#inpBlockHeightUnit');

    // extra
    const inpBottom = modal.querySelector('#inpBlockBottom');
    const inpBottomUnit = modal.querySelector('#inpBlockBottomUnit');
    const inpRight = modal.querySelector('#inpBlockRight');
    const inpRightUnit = modal.querySelector('#inpBlockRightUnit');
    const setBlock = (s, val, unit) => {
      if (val === '') unit = '';
      const breakpoint = this.builder.doc.body.getAttribute('data-breakpoint');
      const elms = this.builder.doc.querySelectorAll('.is-block.active');
      elms.forEach(target => {
        target.style[s] = val + unit;
        target.classList.remove('fluid');
        if (breakpoint && breakpoint < 1920) {
          if (s === 'top') target.setAttribute('data--t-' + breakpoint, target.style.top);
          if (s === 'left') target.setAttribute('data--l-' + breakpoint, target.style.left);
          if (s === 'bottom') target.setAttribute('data--b-' + breakpoint, target.style.bottom);
          if (s === 'right') target.setAttribute('data--r-' + breakpoint, target.style.right);
          if (s === 'width') target.setAttribute('data--w-' + breakpoint, target.style.width);
          if (s === 'height') target.setAttribute('data--h-' + breakpoint, target.style.height);
        } else {
          if (s === 'top') target.setAttribute('data--t', target.style.top);
          if (s === 'left') target.setAttribute('data--l', target.style.left);
          if (s === 'bottom') target.setAttribute('data--b', target.style.bottom);
          if (s === 'right') target.setAttribute('data--r', target.style.right);
          if (s === 'width') target.setAttribute('data--w', target.style.width);
          if (s === 'height') target.setAttribute('data--h', target.style.height);
        }
        target.removeAttribute('data-prev'); // reset
        target.removeAttribute('data-fluid');
      });
    };
    const setBlockBreakpoint = () => {
      this.builder.saveForUndo();
      setBlock('top', inpTop.value, inpTopUnit.value);
      setBlock('left', inpLeft.value, inpLeftUnit.value);
      setBlock('bottom', inpBottom.value, inpBottomUnit.value);
      setBlock('right', inpRight.value, inpRightUnit.value);
      setBlock('width', inpWidth.value, inpWidthUnit.value);
      setBlock('height', inpHeight.value, inpHeightUnit.value);
      this.builder.onChange();
    };
    inpTop.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpLeft.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpBottom.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpRight.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpWidth.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpHeight.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpTopUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpLeftUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpBottomUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpRightUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpWidthUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    inpHeightUnit.addEventListener('change', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        setBlockBreakpoint();
      }, 600);
    });
    const chkLockBlock = modal.querySelector('#inpLockBlock');
    chkLockBlock.addEventListener(this.builder.isTouchSupport ? 'touchstart' : 'click', () => {
      const elms = this.builder.doc.querySelectorAll('.is-block.active');
      if (chkLockBlock.checked) {
        elms.forEach(target => {
          target.classList.add('locked');
          this.builder.eb.draggable.disableDrag(target);
          this.lock(target);
          this.realtime();
        });
      } else {
        elms.forEach(target => {
          target.classList.remove('locked');
          this.builder.eb.refresh();
          this.unLock(target);
        });
      }
    });
    if (this.builder.isTouchSupport) {
      let chkLockBlockLabel = chkLockBlock.parentNode;
      chkLockBlockLabel.addEventListener('touchstart', () => {
        const elms = this.builder.doc.querySelectorAll('.is-block.active');
        if (chkLockBlock.checked) {
          elms.forEach(target => {
            target.classList.add('locked');
            this.builder.eb.draggable.disableDrag(target);
            this.lock(target);
          });
        } else {
          elms.forEach(target => {
            target.classList.remove('locked');
            this.builder.eb.refresh();
            this.unLock(target);
          });
        }
      });
    }

    // Responsive Visibility

    let btns = modal.querySelectorAll('.input-device');
    btns.forEach(btn => {
      btn.addEventListener('click', () => {
        const block = this.blockSelected();
        let elms = modal.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        btn.classList.add('on');
        this.realtimeVisibility(block);
      });
    });
    let btnVisible = modal.querySelector('.input-visible');
    let btnHidden = modal.querySelector('.input-hidden');
    btnVisible.addEventListener('click', () => {
      const block = this.blockSelected();
      this.builder.uo.saveForUndo();
      let divTarget = modal.querySelector('.div-target');
      let target = this.builder.responsive.readTarget(divTarget);
      if (target === 'xs') {
        block.classList.remove('xs-hidden');
      } else if (target === 'sm') {
        block.classList.remove('sm-hidden');
      } else if (target === 'md') {
        block.classList.remove('md-hidden');
      } else if (target === '') {
        block.classList.remove('desktop-hidden');
      }
      btnVisible.classList.add('on');
      btnHidden.classList.remove('on');
      this.builder.opts.onChange();
    });
    btnHidden.addEventListener('click', () => {
      const block = this.blockSelected();
      this.builder.uo.saveForUndo();
      let divTarget = modal.querySelector('.div-target');
      let target = this.builder.responsive.readTarget(divTarget);
      if (target === 'xs') {
        block.classList.add('xs-hidden');
      } else if (target === 'sm') {
        block.classList.add('sm-hidden');
      } else if (target === 'md') {
        block.classList.add('md-hidden');
      } else if (target === '') {
        block.classList.add('desktop-hidden');
      }
      btnVisible.classList.remove('on');
      btnHidden.classList.add('on');
      this.builder.opts.onChange();
    });
    new Tabs({
      element: modal
    });
  } // constructor

  getPage() {
    const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
    const page = docContainer.querySelector('.box-select');
    return page;
  }
  lock() {
    // target
    const modal = this.modal;
    const divBlockPos = modal.querySelector('#divBlockPos');
    divBlockPos.style.display = '';

    // if(target.style.left && target.style.left.includes('calc')) {
    //     const rect = target.getBoundingClientRect();
    //     target.style.top = (rect.top + this.builder.win.scrollY) + 'px';
    //     target.style.left = (rect.left + this.builder.win.scrollX) + 'px';
    //     target.style.width = target.offsetWidth + 'px';
    //     target.style.height = target.offsetHeight + 'px';
    // }
  }

  unLock() {
    // target
    const modal = this.modal;
    const divBlockPos = modal.querySelector('#divBlockPos');
    divBlockPos.style.display = 'none';

    // this.builder.eb.common.applyPercentage(target);
  }

  pageOverlay() {
    const page = this.getPage();
    if (!page) return false;
    let pageOverlay = page.querySelector('.is-page-overlay');
    if (!pageOverlay) {
      page.insertAdjacentHTML('afterbegin', '<div class="is-page-overlay"></div>');
      pageOverlay = page.querySelector('.is-page-overlay');
    }
    return pageOverlay;
  }
  blockOverlay() {
    const block = this.builder.doc.querySelector('.is-block.active:not(.multi)');
    if (!block) return false;
    let blockOverlay = block.querySelector('.is-block-overlay');
    if (!blockOverlay) {
      block.insertAdjacentHTML('beforeend', '<div class="is-block-overlay"></div>');
      blockOverlay = block.querySelector('.is-block-overlay');
    }
    return blockOverlay;
  }
  blockSelected() {
    const block = this.builder.doc.querySelector('.is-block.active:not(.multi)');
    return block;
  }
  realtime() {
    const modal = this.modal;
    if (!modal.classList.contains('active')) return;
    const page = this.getPage();
    const block = this.blockSelected();
    if (block) {
      const btnClearBreakpoints = modal.querySelector('.btn-clear-breakpoint');
      let hasBreakpoints = false;
      var attributes = block.attributes;
      for (var i = 0; i < attributes.length; i++) {
        let item = attributes[i].name;
        if (item.includes('data--t-') || item.includes('data--b-'   )) {
          // has breakpoints
          hasBreakpoints = true;
        }
      }
      if (hasBreakpoints) {
        btnClearBreakpoints.style.display = '';
      } else {
        btnClearBreakpoints.style.display = 'none';
      }

      // Background image
      const blockOverlay = this.blockOverlay();
      let src = '';
      if (blockOverlay) if (blockOverlay.style.backgroundImage) {
        if (blockOverlay.style.backgroundImage.indexOf('url(') !== -1) {
          src = blockOverlay.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      }

      // Update preview
      this.updatePanelImage(src);

      // Show/hide grayscale
      const divGrayscale = modal.querySelector('.label.grayscale');
      if (src === '') {
        this.imagePreview.style.display = 'none';
        divGrayscale.style.display = 'none';
      } else {
        this.imagePreview.style.display = '';
        divGrayscale.style.display = '';
      }

      // Grayscale
      const chkGrayscale = modal.querySelector('#chkBlockGrayscale');
      chkGrayscale.checked = false;
      if (blockOverlay) {
        if (blockOverlay.style.filter) {
          if (blockOverlay.style.filter.indexOf('grayscale') !== -1) {
            chkGrayscale.checked = true;
          }
        }
      }

      // Background color
      const btnColorPick = modal.querySelector('.input-block-bgcolor');
      if (blockOverlay) {
        let bgcolor = blockOverlay.style.backgroundColor;
        btnColorPick.style.backgroundColor = bgcolor; //preview
      } else {
        btnColorPick.style.backgroundColor = ''; //preview
      }

      // Gradient
      const btnGradient = modal.querySelector('.btn-block-gradient');
      if (blockOverlay) {
        if (blockOverlay.style.backgroundImage && blockOverlay.style.backgroundImage.includes('gradient')) {
          btnGradient.style.backgroundImage = blockOverlay.style.backgroundImage;
        } else {
          btnGradient.style.backgroundImage = '';
        }
      } else {
        btnGradient.style.backgroundImage = '';
      }
      const btnClearText = modal.querySelector('.btn-clear-text');
      btnClearText.style.display = 'none';
      const divContentColor = modal.querySelector('.div-content-textcolor');
      divContentColor.style.display = 'none';
      if (block.querySelector('.is-container')) {
        btnClearText.style.display = '';
        divContentColor.style.display = '';
      }

      // Lock
      const divBlockPos = modal.querySelector('#divBlockPos');
      const chkLockBlock = modal.querySelector('#inpLockBlock');
      const inpTop = modal.querySelector('#inpBlockTop');
      const inpTopUnit = modal.querySelector('#inpBlockTopUnit');
      const inpLeft = modal.querySelector('#inpBlockLeft');
      const inpLeftUnit = modal.querySelector('#inpBlockLeftUnit');
      const inpBottom = modal.querySelector('#inpBlockBottom');
      const inpBottomUnit = modal.querySelector('#inpBlockBottomUnit');
      const inpRight = modal.querySelector('#inpBlockRight');
      const inpRightUnit = modal.querySelector('#inpBlockRightUnit');
      const inpWidth = modal.querySelector('#inpBlockWidth');
      const inpWidthUnit = modal.querySelector('#inpBlockWidthUnit');
      const inpHeight = modal.querySelector('#inpBlockHeight');
      const inpHeightUnit = modal.querySelector('#inpBlockHeightUnit');
      if (block.classList.contains('locked')) {
        chkLockBlock.checked = true;
        divBlockPos.style.display = '';
        let top = block.style.top;
        let left = block.style.left;
        let bottom = block.style.bottom;
        let right = block.style.right;
        let width = block.style.width;
        let height = block.style.height;
        let topUnit = '';
        let leftUnit = '';
        let bottomUnit = '';
        let rightUnit = '';
        let widthUnit = '';
        let heightUnit = '';
        if (top.includes('calc')) {
          topUnit = '';
        } else if (top.includes('px')) {
          topUnit = 'px';
          top = top.replace('px', '');
        } else if (top.includes('%')) {
          topUnit = '%';
          top = top.replace('%', '');
        }
        if (left.includes('calc')) {
          leftUnit = '';
        } else if (left.includes('px')) {
          leftUnit = 'px';
          left = left.replace('px', '');
        } else if (left.includes('%')) {
          leftUnit = '%';
          left = left.replace('%', '');
        }
        if (bottom.includes('calc')) {
          bottomUnit = '';
        } else if (bottom.includes('px')) {
          bottomUnit = 'px';
          bottom = bottom.replace('px', '');
        } else if (bottom.includes('%')) {
          bottomUnit = '%';
          bottom = bottom.replace('%', '');
        }
        if (right.includes('calc')) {
          rightUnit = '';
        } else if (right.includes('px')) {
          rightUnit = 'px';
          right = right.replace('px', '');
        } else if (right.includes('%')) {
          rightUnit = '%';
          right = right.replace('%', '');
        }
        if (width.includes('calc')) {
          widthUnit = '';
        } else if (width.includes('px')) {
          widthUnit = 'px';
          width = width.replace('px', '');
        } else if (width.includes('%')) {
          widthUnit = '%';
          width = width.replace('%', '');
        }
        if (height.includes('calc')) {
          heightUnit = '';
        } else if (height.includes('px')) {
          heightUnit = 'px';
          height = height.replace('px', '');
        } else if (height.includes('%')) {
          heightUnit = '%';
          height = height.replace('%', '');
        }
        inpTop.value = top;
        inpTopUnit.value = topUnit;
        inpLeft.value = left;
        inpLeftUnit.value = leftUnit;
        inpBottom.value = bottom;
        inpBottomUnit.value = bottomUnit;
        inpRight.value = right;
        inpRightUnit.value = rightUnit;
        inpWidth.value = width;
        inpWidthUnit.value = widthUnit;
        inpHeight.value = height;
        inpHeightUnit.value = heightUnit;
      } else {
        chkLockBlock.checked = false;
        divBlockPos.style.display = 'none';
        inpTop.value = '';
        inpTopUnit.value = '%';
        inpLeft.value = '';
        inpLeftUnit.value = '%';
        inpBottom.value = '';
        inpBottomUnit.value = '%';
        inpRight.value = '';
        inpRightUnit.value = '%';
        inpWidth.value = '';
        inpWidthUnit.value = '%';
        inpHeight.value = '';
        inpHeightUnit.value = '%';
      }
      this.realtimeVisibility(block);
    } else if (page) {
      let pageOverlay = this.pageOverlay();

      // Background image
      let src = '';
      if (pageOverlay) if (pageOverlay.style.backgroundImage) {
        if (pageOverlay.style.backgroundImage.indexOf('url(') !== -1) {
          src = pageOverlay.style.backgroundImage.slice(4, -1).replace(/["']/g, '');
        }
      }

      // Update preview
      this.updatePanelPageImage(src);

      // Show/hide grayscale
      const divPageGrayscale = modal.querySelector('.label-page-grayscale');
      if (src === '') {
        this.pageImagePreview.style.display = 'none';
        divPageGrayscale.style.display = 'none';
      } else {
        this.pageImagePreview.style.display = '';
        divPageGrayscale.style.display = '';
      }

      // Grayscale
      const chkPageGrayscale = modal.querySelector('#chkPageGrayscale');
      chkPageGrayscale.checked = false;
      if (pageOverlay.style.filter) {
        if (pageOverlay.style.filter.indexOf('grayscale') !== -1) {
          chkPageGrayscale.checked = true;
        }
      }

      // Background color
      const btnPageColorPick = modal.querySelector('.input-page-bgcolor');
      if (page) {
        let bgcolor = page.style.backgroundColor;
        btnPageColorPick.style.backgroundColor = bgcolor; //preview
      } else {
        btnPageColorPick.style.backgroundColor = ''; //preview
      }

      // Gradient
      const btnPageGradient = modal.querySelector('.btn-page-gradient');
      if (page) {
        if (page.style.backgroundImage && page.style.backgroundImage.includes('gradient')) {
          btnPageGradient.style.backgroundImage = page.style.backgroundImage;
        } else {
          btnPageGradient.style.backgroundImage = '';
        }
      } else {
        btnPageGradient.style.backgroundImage = '';
      }

      // Page Auto Layout
      const chkAutoLayout = modal.querySelector('#inpAutoLayout');
      if (page.classList.contains('autolayout')) {
        chkAutoLayout.checked = true;
      } else {
        chkAutoLayout.checked = false;
      }
    }
  }
  realtimeVisibility(row, initialOpen) {
    if (!this.modal) return;
    if (initialOpen) {
      const builderStuff = this.builder.builderStuff;
      const modal = builderStuff.querySelector('.is-modal.content-preview.active');
      if (modal) {
        let elms = this.modal.querySelectorAll('.input-device');
        elms.forEach(elm => {
          elm.classList.remove('on');
        });
        if (modal.classList.contains('is-screen-1920')) {
          this.modal.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1440')) {
          this.modal.querySelector('.input-device[data-value=""]').classList.add('on');
        } else if (modal.classList.contains('is-screen-1024')) {
          this.modal.querySelector('.input-device[data-value="md"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-768')) {
          this.modal.querySelector('.input-device[data-value="sm"]').classList.add('on');
        } else if (modal.classList.contains('is-screen-375')) {
          this.modal.querySelector('.input-device[data-value="xs"]').classList.add('on');
        }
      }
    }
    let divTarget = this.modal.querySelector('.div-target');
    let divVisibility = this.modal.querySelector('.div-visibility');
    let target = this.builder.responsive.readTarget(divTarget);
    let valVisibility = this.builder.responsive.getVisibility(row, target);
    this.builder.responsive.showVisibility(divVisibility, valVisibility);

    // const divColsPerLine = this.modal.querySelector('.div-colsperline');
    let btns = this.modal.querySelectorAll('.input-colsperline');
    btns.forEach(btn => {
      btn.classList.remove('on');
    });
    if (target === 'xs') {
      if (!initialOpen) this.builder.livePreview.resizePreview(375);
    } else if (target === 'sm') {
      if (!initialOpen) this.builder.livePreview.resizePreview(768);
    } else if (target === 'md') {
      if (!initialOpen) this.builder.livePreview.resizePreview(1024);
    } else {
      if (!initialOpen) this.builder.livePreview.resizePreview(1920);
    }
  }
  openImagePicker(currentUrl, callback, btn) {
    //Current value
    const imageSource = document.querySelector('.is-modal.imagesource');
    const inpSrc = imageSource.querySelector('.input-src');
    inpSrc.value = currentUrl;

    //imageSelectedCallback
    this.builder.imageSelectedCallback = callback;

    //Show modal
    imageSource.style.zIndex = '10005';
    this.util.showModal(imageSource, false, () => {
      if (btn) {
        btn.removeAttribute('data-focus');
        btn.focus();
      }
    }, false, this.builder.assetPanelFullScreen);
    if (btn) btn.setAttribute('data-focus', true);
  }
  updatePageImage(src) {
    this.builder.uo.saveForUndo();
    let pageOverlay = this.pageOverlay();
    pageOverlay.style.backgroundImage = 'url(\'' + src + '\')';

    // Reset position & filter (grayscale)
    pageOverlay.style.filter = '';
    pageOverlay.style.backgroundSize = '';
    pageOverlay.style.backgroundPosition = '50% 60%';
    pageOverlay.removeAttribute('data-bg-xs');
    pageOverlay.removeAttribute('data-bg-sm');
    pageOverlay.removeAttribute('data-bg-md');
    pageOverlay.removeAttribute('data-bg-lg');
    this.updatePanelPageImage(src);
    this.builder.onChange();
  }
  updatePanelPageImage(src) {
    const modal = this.modal;
    let previewHtml;
    if (!src) previewHtml = '';else previewHtml = `
        <img src="${src}">
        `;
    this.pageImagePreview.innerHTML = previewHtml;

    // Show/hide image-related controls
    const btnPageClear = modal.querySelector('.btn-page-clear');
    const btnPageAdjust = modal.querySelector('.btn-page-adjust');
    if (src === '') {
      btnPageClear.style.display = 'none';
      btnPageAdjust.style.display = 'none';
    } else {
      btnPageClear.style.display = '';
      btnPageAdjust.style.display = '';
    }
    const btnPageGradient = modal.querySelector('.btn-page-gradient');
    btnPageGradient.style.backgroundImage = '';

    // Show/hide grayscale
    const divPageGrayscale = modal.querySelector('.label-page-grayscale');
    if (src === '') {
      this.pageImagePreview.style.display = 'none';
      divPageGrayscale.style.display = 'none';
    } else {
      this.pageImagePreview.style.display = '';
      divPageGrayscale.style.display = '';
    }
  }
  updateImage(src) {
    this.builder.uo.saveForUndo();
    let blockOverlay = this.blockOverlay();
    blockOverlay.style.backgroundImage = 'url(\'' + src + '\')';

    // Reset position & filter (grayscale)
    blockOverlay.style.filter = '';
    blockOverlay.style.backgroundSize = '';
    blockOverlay.style.backgroundPosition = '50% 60%';
    blockOverlay.removeAttribute('data-bg-xs');
    blockOverlay.removeAttribute('data-bg-sm');
    blockOverlay.removeAttribute('data-bg-md');
    blockOverlay.removeAttribute('data-bg-lg');
    this.updatePanelImage(src);
    this.realtime();
    this.builder.onChange();
  }
  updatePanelImage(src) {
    const modal = this.modal;
    let previewHtml;
    if (!src) previewHtml = '';else previewHtml = `
        <img src="${src}">
        `;
    this.imagePreview.innerHTML = previewHtml;

    // Show/hide image-related controls
    const btnClear = modal.querySelector('.btn-block-clear');
    const btnAdjust = modal.querySelector('.btn-block-adjust');
    if (src === '') {
      btnClear.style.display = 'none';
      btnAdjust.style.display = 'none';
    } else {
      btnClear.style.display = '';
      btnAdjust.style.display = '';
    }
    const btnGradient = modal.querySelector('.btn-block-gradient');
    btnGradient.style.backgroundImage = '';

    // Show/hide grayscale
    const divGrayscale = modal.querySelector('.label-block-grayscale');
    if (src === '') {
      this.imagePreview.style.display = 'none';
      divGrayscale.style.display = 'none';
    } else {
      this.imagePreview.style.display = '';
      divGrayscale.style.display = '';
    }
  }
  show() {
    const modal = this.modal;
    if (document.querySelector('.snippetwindow.left.active')) {
      modal.style.left = 'auto';
      modal.style.right = '40px';
    } else if (document.querySelector('.snippetwindow.active')) {
      modal.style.left = '40px';
      modal.style.right = 'auto';
    } else if (this.builder.sidePanel === 'right' && this.builder.snippetList === '#divSnippetList') {
      modal.style.left = '40px';
      modal.style.right = 'auto';
    } else if (this.builder.sidePanel === 'left' && this.builder.snippetList === '#divSnippetList') {
      modal.style.left = 'auto';
      modal.style.right = '40px';
    }
    this.util.showModal(modal);
    this.realtime();
    this.handleBlockClick = () => {
      this.showHideControls();
    };
    const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
    docContainer.addEventListener('click', this.handleBlockClick);
    if (this.builder.iframe) {
      docContainer.addEventListener('click', this.handleBlockClick);
    }
    this.showHideControls();
  }
  showHideControls() {
    const modal = this.modal;
    if (!modal.classList.contains('active')) return;
    const content1 = modal.querySelector('.modal-none');
    const content2 = modal.querySelector('.modal-content');
    const content3 = modal.querySelector('.modal-page-content');
    const activeBlock = this.builder.doc.querySelector('.is-block.active');
    const page = this.getPage();
    const modalTitle = modal.querySelector('.modal-title');
    if (activeBlock) {
      if (!activeBlock.closest('.multi')) {
        content1.style.display = 'none';
        content2.style.display = '';
        content3.style.display = 'none';
        modalTitle.innerHTML = this.util.out('Block');
        this.realtime();
      } else {
        content1.style.display = 'none';
        content2.style.display = 'none';
        content3.style.display = '';
        modalTitle.innerHTML = this.util.out('Page');
        this.realtime();
      }
    } else if (page) {
      content1.style.display = 'none';
      content2.style.display = 'none';
      content3.style.display = '';
      modalTitle.innerHTML = this.util.out('Page');
      this.realtime();
    } else {
      content1.style.display = '';
      content2.style.display = 'none';
      content3.style.display = 'none';
    }
  }
  hide() {
    const modal = this.modal;
    this.util.hideModal(modal);
    document.removeEventListener('click', this.handleBlockClick);
    if (this.builder.iframe) {
      this.builder.doc.removeEventListener('click', this.handleBlockClick);
    }
  }
  position() {
    const dom = this.dom;
    let elementTool = this.elementTool;
    let elementMore = this.elementMore;
    dom.addClass(elementMore, 'transition1');
    let elmMore = elementTool.querySelector('.elm-more');
    const viewportHeight = window.innerHeight;

    /*
    let top, left;
    if(!this.builder.iframe) {
        top = elmMore.getBoundingClientRect().top;
        left = elmMore.getBoundingClientRect().left;
    } else {
        let adjY = this.builder.iframe.getBoundingClientRect().top;
        let adjX = this.builder.iframe.getBoundingClientRect().left;
         top = elmMore.getBoundingClientRect().top;
        left = elmMore.getBoundingClientRect().left;
        top = top + adjY;
        left = left + adjX;
    }
    */
    const newPos = this.builder.util.getElementPosition(elmMore);
    let top = newPos.top;
    let left = newPos.left;

    // elementMore.style.display = 'flex';
    const btnMore = elementTool.querySelector('.elm-more');
    this.util.showPop(elementMore, false, btnMore);
    const w = elementMore.offsetWidth; //to get value, element must not hidden (display:none). So set display:flex before this.
    const h = elementMore.offsetHeight;
    if (viewportHeight - top > h) {
      elementMore.style.top = top + window.pageYOffset + 27 + 'px';
      elementMore.style.left = left - w / 2 + 10 + 'px';
      dom.removeClass(elementMore, 'arrow-bottom');
      dom.removeClass(elementMore, 'arrow-right');
      dom.removeClass(elementMore, 'arrow-left');
      dom.removeClass(elementMore, 'center');
      dom.addClass(elementMore, 'arrow-top');
      dom.addClass(elementMore, 'center');
    } else {
      elementMore.style.top = top + window.pageYOffset - h - 8 + 'px';
      elementMore.style.left = left - w / 2 + 10 + 'px';
      dom.removeClass(elementMore, 'arrow-top');
      dom.removeClass(elementMore, 'arrow-right');
      dom.removeClass(elementMore, 'arrow-left');
      dom.removeClass(elementMore, 'center');
      dom.addClass(elementMore, 'arrow-bottom');
      dom.addClass(elementMore, 'center');
    }
    setTimeout(() => {
      dom.removeClass(elementMore, 'transition1');
    }, 300);
  }
}

class PageSize {
  constructor(builder) {
    this.builder = builder;
    const util = this.builder.util;
    this.util = util;
    const builderStuff = this.builder.builderStuff;
    this.builderStuff = builderStuff;
    const dom = this.builder.dom;
    this.dom = dom;
  }
  open() {
    const builderStuff = this.builderStuff;
    const util = this.util;
    const dom = this.dom;
    const pageSizes = this.builder.pageSizes;
    let modal = builderStuff.querySelector('.is-modal.pagesize');
    if (!modal) {
      const html = `
            <div class="is-modal pagesize" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content">
    
                    <div class="div-page-sizes">
                        ${pageSizes.map(item => `<button title="${item.title}" data-pagesize="${item.pagesize}" style="${item.style}" class="paper-item">${item.title}</button>`).join('')}
                    </div>
    
                    <div class="flex" style="gap:10px;justify-content:center;margin-top:15px;">
                        <div>
                            <label for="inpPageWidth" style="display:block">${util.out('Width')}:</label>
                            <input id="inpPageWidth" class="input-width" type="text">
                        </div>
                        <div>
                            <label for="inpPageWidth" style="display:block">${util.out('Height')}:</label>
                            <input id="inpPageHeight" class="input-height" type="text">
                        </div>
                    </div>
    
                    <div style="text-align:right;margin-top:20px;display:none">
                        <button title="${util.out('Cancel')}" class="input-cancel classic-secondary">${util.out('Cancel')}</button>
                        <button title="${util.out('Ok')}" class="input-ok classic-primary">${util.out('Ok')}</button>
                    </div>
    
                </div>
            </div>
            <div class="is-modal viewprint" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="width:100%;height:100vh;padding:0;">
                    <iframe tabindex="0" style="width:100vw;height:100vh;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            `;
      dom.appendHtml(builderStuff, html);
      modal = builderStuff.querySelector('.pagesize');
      this.modal = modal;
      const inpWidth = modal.querySelector('.input-width');
      const inpHeight = modal.querySelector('.input-height');
      const current = localStorage.getItem('_pagesize');
      if (current) {
        const arrCurrent = current.split(',');
        inpWidth.value = arrCurrent[0].trim();
        inpHeight.value = arrCurrent[1].trim();
      }
      const btnPageSize = modal.querySelectorAll('[data-pagesize]');
      btnPageSize.forEach(btn => {
        btn.addEventListener('click', () => {
          const elmCss = document.querySelector('#__css_pagesize');
          if (elmCss) elmCss.remove();
          const s = btn.getAttribute('data-pagesize');
          this.setPageSize(s);
          inpWidth.value = '';
          inpHeight.value = '';
          const arr = s.split(',');
          inpWidth.value = arr[0].trim();
          inpHeight.value = arr[1].trim();
        });
      });
      let timer;
      inpWidth.addEventListener('input', () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          const current = localStorage.getItem('_pagesize');
          let isWeb = false;
          const arrCurrent = current.split(',');
          if (arrCurrent.length === 3) isWeb = true;
          let s = inpWidth.value + ',' + inpHeight.value + (isWeb ? ',web' : '');
          this.setPageSize(s);
        }, 600);
      });
      inpHeight.addEventListener('input', () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          const current = localStorage.getItem('_pagesize');
          let isWeb = false;
          const arrCurrent = current.split(',');
          if (arrCurrent.length === 3) isWeb = true;
          let s = inpWidth.value + ',' + inpHeight.value + (isWeb ? ',web' : '');
          this.setPageSize(s);
        }, 600);
      });
      const btnImageOk = modal.querySelector('.input-ok');
      dom.addEventListener(btnImageOk, 'click', () => {
        // const inpSrc = modal.querySelector('.input-src');
        // const url = inpSrc.value;

        this.builder.hideModal(modal);
      });
      const btnImageCancel = modal.querySelector('.input-cancel');
      dom.addEventListener(btnImageCancel, 'click', () => {
        this.builder.hideModal(modal);
      });
    }
    this.util.showModal(modal, false);
  }
  setPageSize(s) {
    if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer && !this.builder.iframe) {
      localStorage.setItem('_pagesize', s);
      const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
      const elms = docContainer.querySelectorAll('.is-box');
      elms.forEach(elm => {
        elm.setAttribute('data-pagesize', s);
      });
      const elmCss = document.querySelector('#__css_pagesize');
      if (elmCss) elmCss.remove();
      let css = this.getPageCss();
      document.head.insertAdjacentHTML('beforeend', css);

      // for the tools position
      const arr = s.split(',');
      // let w = arr[0].trim();
      // let h = arr[1].trim();
      if (arr.length === 3) {
        // web
        let box = docContainer.querySelector('.is-box');
        if (box) {
          const boxWidth = box.offsetWidth;
          const viewportWidth = this.builder.win.innerWidth;
          if (boxWidth < viewportWidth - 50) {
            // web (container)
            docContainer.classList.remove('page-web');
            docContainer.classList.add('page-web-container');
          } else {
            // web (full)
            docContainer.classList.remove('page-web-container');
            docContainer.classList.add('page-web');
          }
        } else {
          // web (full)
          docContainer.classList.remove('page-web-container');
          docContainer.classList.add('page-web');
        }
      } else {
        // print
        docContainer.classList.remove('page-web');
        docContainer.classList.remove('page-web-container');
      }
    } else {
      alert('This function works in Canvas mode only.');
    }
  }
  print() {
    const builderStuff = this.builderStuff;
    const dom = this.dom;
    let modalIframe = builderStuff.querySelector('.viewprint');
    if (!modalIframe) {
      let html = `
            <div class="viewprint" style="display:none">
                <iframe tabindex="0" style="width:2000px;height:2000px;border: none;display: block;" src="about:blank"></iframe>
            </div>`;
      dom.appendHtml(builderStuff, html);
      modalIframe = builderStuff.querySelector('.viewprint');
    }
    if (this.builder.canvas && !this.builder.isContentBox && this.builder.docContainer && !this.builder.iframe) {
      const ifr = modalIframe.querySelector('iframe');
      ifr.srcdoc = this.getPrintHtml();
    } else {
      alert('This function works in Canvas mode only.');
    }
  }
  getPrintHtml() {
    let css = this.getPrintCss();
    let html = this.builder.html();
    return `
        <!DOCTYPE HTML>
        <html>
        <head>
            <meta charset="utf-8">
            <title></title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <meta name="description" content="">

            <link href="${this.builder.snippetPath}print.css" rel="stylesheet">
            
            <style>

            /* block.css */
            /* box-canvas */
            .is-box {
                position: relative;
                flex:none;
            }
            .is-block {
                position: absolute;
                box-sizing: border-box;
                padding: 0;
            }
            .is-block .is-container {
                max-width: unset !important;
                width: 100%;
                padding: 0;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }
            .is-box.autolayout .is-block.block-steady.fluid {
                padding: 0;
                width: 100% !important;
                min-width: unset !important;
                left: auto !important
            }
            .is-block-overlay { background-size: cover; background-repeat: no-repeat; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; user-select: none; }
            
            
            body {
                background: #eee;
            }
            .is-page {
                position: relative;
                transform-origin: top;
            }
            .is-box {
                position: relative;
                flex:none;
                background: #fff;
                /* overflow: hidden;*/
                box-shadow: none;
            }
            ${css}
            </style>

            ${html.includes('data-module="codeview"') ? `
                <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet">
                <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-coy.min.css" rel="stylesheet">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
                <style>
                    :not(pre)>code[class*=language-], pre[class*=language-] {
                        background-color: #f4f4f4 !important;
                        padding: 12px 16px !important;
                    }
                    pre[class*=language-]:after, pre[class*=language-]:before {
                        box-shadow: none;
                    }
                    :not(pre)>code[class*=language-], pre[class*=language-] {
                        margin-bottom: 1.2rem;
                    }
                    div[data-html] {
                        min-height: 40px;
                    }
                    code[class*=language-], pre[class*=language-] {
                        text-shadow: none;
                    }
                </style>
            ` : ''}
        </head>
        <body class="print">

            <div class="is-page">${html}</div>

            <script>
                var docReady = function(fn) {
                    var stateCheck = setInterval(function() {
                        if (document.readyState !== "complete") return;
                        clearInterval(stateCheck);
                        try {
                            fn()
                        } catch (e) {}
                    }, 1);
                };
                docReady(function() {
                    window.print();
                });
            </script>
        </body>
        </html>
        `;
  }
  getPageCss() {
    let s;
    if (localStorage.getItem('_pagesize') === '' || localStorage.getItem('_pagesize')) {
      s = localStorage.getItem('_pagesize');
    } else {
      s = this.pageSize || '';
    }
    let w, h;
    let css;
    if (s) {
      const arr = s.split(',');
      w = arr[0].trim();
      h = arr[1].trim();
      if (arr.length === 3) {
        // web
        css = `
                <style id="__css_pagesize">
                .is-page {
                    ${(w === '100%' || w === '100vw') && (h === '100%' || h === '100vh') ? '' : 'margin-top: 150px;'}
                }
                .is-box {
                    width: 100%;
                    max-width: ${w};
                    height: ${h};
                    margin: 0 auto;
                }
                </style>
                `;
      } else {
        // print
        css = `
                <style id="__css_pagesize">
                .is-page {
                    margin-top:150px;
                    gap: 45px;
                }
                .is-box {
                    width: ${w};
                    height: ${h};
                }
                </style>
                `;
      }
    }
    return css;
  }
  getPrintCss() {
    let s;
    if (localStorage.getItem('_pagesize') === '' || localStorage.getItem('_pagesize')) {
      s = localStorage.getItem('_pagesize');
    } else {
      s = this.pageSize || '';
    }
    let w, h;
    let css;
    if (s) {
      const arr = s.split(',');
      w = arr[0].trim();
      h = arr[1].trim();
      if (arr.length === 3) {
        // web
        const docContainer = this.builder.doc.querySelector(this.builder.docContainer);
        const box = docContainer.querySelector('.is-box');
        if (!box) return '';
        const docWidth = box.offsetWidth + 'px';
        const docHeight = box.offsetHeight + 'px';
        css = `
                <style id="__css_pagesize">
                .is-box {
                    width: 100%;
                    max-width: ${docWidth};
                    height: ${docHeight};
                    margin: 0 auto;
                }
                @media print { 
                    .is-box {
                        width: ${docWidth};
                        height: ${docHeight};
                    } 
                    .hide-on-print {
                        display: none !important;
                    }
                }
                @page {
                    size:${docWidth} ${docHeight};; 
                    margin: 0; 
                }
                </style>
                `;
      } else {
        // print
        css = `
                <style id="__css_pagesize">
                .is-box {
                    width: ${w};
                    height: ${h};
                }
                @media print { 
                    .is-box {
                        width: ${w}; 
                        height: ${h};
                    } 
                    .hide-on-print {
                        display: none !important;
                    }
                }
                @page {
                    size:${w} ${h};
                    margin: 0; 
                }
                </style>
                `;
      }
    }
    return css;
  }
}

class ContentBuilder {
  constructor(opts = {}) {
    let defaults = {
      page: '',
      container: '.is-container',
      row: '',
      cols: [],
      colequal: [],
      colsizes: [],
      imageQuality: 0.92,
      elementSelection: true,
      paste: 'text',
      snippetJSON: {
        'snippets': []
      },
      screenMode: 'desktop',
      // Live Preview
      // previewURL: 'preview.html',
      onPreviewOpen: () => {
        let html = this.html();
        localStorage.setItem('preview-html', html);
      },
      // onPreviewClose: ()=>{},
      previewStyle: 'top:auto;bottom:50px;left:50px;right:auto;',
      livePreviewOpen: false,
      livePreviewAlwaysReload: false,
      livePreviewReloadEvery: 30,
      // always reload every 30 onChange triggered (to clearup iframe resource for faster performance)

      scriptPath: '',
      // Deprecated
      // Old way:
      //      For the location of config.js. Used as pluginPath (if pluginPath empty).
      //      scriptPath = '' means the path will be autoset/autodetected (see currentScriptPath())
      //      This is not reliable and so will be deprecated.

      plugins: [],
      // pluginPath: '', 
      pluginPath: 'contentbuilder/',
      // Old way:
      //      If pluginPath is not empty, pluginPath will be used instead of scriptPath
      //      But scriptPath is still needed for the location of config.js
      // Now the new way is by specifying the plugins and pluginPath parameters. 
      // (If plugins has value [{..}], then config file won't be loaded. No need to use the scriptPath.)
      // For example:
      // plugins: [
      //     { name: 'preview', showInMainToolbar: true, showInElementToolbar: true },
      //     { name: 'wordcount', showInMainToolbar: true, showInElementToolbar: true },
      //     { name: 'symbols', showInMainToolbar: true, showInElementToolbar: false },
      //     { name: 'buttoneditor', showInMainToolbar: false, showInElementToolbar: false },
      // ],
      // pluginPath: 'contentbuilder/', // Location of the plugin scripts
      disableConfig: false,
      // If you don't specify the plugins param and set the disableConfig to true, then no plugins will be loaded.

      modulePath: 'assets/modules/',
      assetPath: 'assets/',
      // Used for the location of ionicons/ (see rte.js 2788) & scripts/ (see plugins/preview/plugin.js 237)
      fontAssetPath: 'assets/fonts/',
      // Option for self-hosted fonts:
      // fontPath: 'assets/cssfonts/', // If set, will be used

      snippetModal: false,
      snippetModalLeft: false,
      snippetData: 'assets/minimalist-blocks/snippetlist.html',
      // Deprecated
      snippetUrl: 'assets/minimalist-blocks/content.js',
      //new
      // snippetUrl: 'https://innovastudio.com/builderdemo/assets/minimalist-blocks/content.js',

      // snippetPath: '',  // Old
      // if snippetPath is specified (not empty), then use the specified. 
      // Otherwise, use the one generated from snippet file (_snippets_path)
      snippetPath: 'assets/minimalist-blocks/',
      // New: now snippetPath is specified
      snippetPathReplace: [],
      // ['',''],

      // Another Example:
      //      snippetPath: 'https://innovastudio.com/builderdemo/assets/minimalist-blocks/',
      //      snippetPathReplace: ['assets/','https://innovastudio.com/builderdemo/assets/'],

      // snippetSampleImage: 'uploads/office2.png', // if enabled, will be used to insert image block
      // snippetSampleVideo: 'uploads/person1.mp4', // if enabled, will be used to insert video block
      // snippetSampleAudio: 'uploads/intro.mp4', // if enabled, will be used to insert audio block

      snippetCategories: [[120, 'Basic'], [118, 'Article'], [101, 'Headline'], [119, 'Buttons'], [102, 'Photos'], [103, 'Profile'], [116, 'Contact'], [104, 'Products, Services'], [105, 'Features'], [108, 'Skills'], [109, 'Achievements'], [106, 'Process'], [107, 'Pricing'], [110, 'Quotes'], [111, 'Partners'], [112, 'As Featured On'], [113, 'Page Not Found'], [114, 'Coming Soon'], [115, 'Help, FAQ']],
      defaultSnippetCategory: 120,
      snippetHandle: true,
      sidePanel: 'right',
      snippetList: '#divSnippetList',
      onRender: function () {},
      // onContentClick: function(){},
      onChange: function () {},
      // onAdd: function(){},
      largerImageHandler: '',
      // onLargerImageUpload: function(){},

      imageHandler: '',
      // NEW: for image
      // onImageUpload: function(){}, // NEW: for image
      fileHandler: '',
      // NEW: for file/document
      // onFileUpload: function(){}, // NEW: for file/document

      mediaHandler: '',
      // onMediaUpload: function(){},
      videoHandler: '',
      // onVideoUpload: function(){},
      audioHandler: '',
      // onAudioUpload: function(){},
      colors: ['#ff8f00', '#ef6c00', '#d84315', '#c62828', '#58362f', '#37474f', '#353535', '#f9a825', '#9e9d24', '#558b2f', '#ad1457', '#6a1b9a', '#4527a0', '#616161', '#00b8c9', '#009666', '#2e7d32', '#0277bd', '#1565c0', '#283593', '#9e9e9e'],
      builderMode: '',
      rowTool: 'right',
      rowcolOutline: true,
      columnTool: true,
      outlineMode: '',
      toolStyle: '',
      outlineStyle: '',
      snippetAddTool: true,
      elementTool: true,
      elementHighlight: true,
      columnHtmlEditor: true,
      rowHtmlEditor: true,
      htmlSyntaxHighlighting: true,
      snippetOpen: false,
      toolbar: 'top',
      toolbarDisplay: 'auto',
      shortenHTML: true,
      imageResizeOnBlock: true,
      simpleEditingBreakpoint: '970px',
      // iframe only

      resizeHeight: false,
      snippetsSidebarDisplay: 'auto',
      // snippetDisplay: 'auto', // values: auto, visible (a new alternative). If used, will set the snippetsSidebarDisplay

      // onImageSelectClick: function () { }, 
      // onFileSelectClick: function () { },
      // onVideoSelectClick: function () { },
      // onAudioSelectClick: function () { },
      // onMediaSelectClick: function () { }, // NEW: for image & video
      // onPluginsLoaded: function () { },
      // onImageBrowseClick: function () { },
      // onImageSettingClick: function () { },

      /* 
      // onImageEditClick: function () { },  // used in elementimage.js
      // Example:
      onImageEditClick: (activeImage)=>{
                   activeImage.setAttribute('crossorigin', 'anonymous');
           const cropperConfig = {
              checkCrossOrigin:false,
              checkOrientation:false,
              crossOrigin:'anonymous',
              zoomable: false,
              viewMode: 1
          };
          builder.setCropperConfig = cropperConfig;
                   return true;
      },
      */
      // setCropperConfig: {}, // used in elementimage.js

      imageEmbed: true,
      imageselect: '',
      fileselect: '',
      videoselect: '',
      imageSelect: '',
      fileSelect: '',
      videoSelect: '',
      audioSelect: '',
      mediaSelect: '',
      // NEW: for image & video

      // selectIcon: '<svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg>',
      selectIcon: '<svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#icon-folder"></use></svg>',
      // NEW: for any other file select. Will be visible on hyperlink dialog, image dialog (image link), and Column Settings dialog (on Click tab)
      otherSelect: '',
      otherSelectCaption: 'Select Document',
      // otherSelectIcon: '<svg class="is-icon-flex"><use xlink:href="#ion-ios-folder-outline"></use></svg>',
      otherSelectIcon: '<svg class="is-icon-flex" style="width:16px;height:16px;"><use xlink:href="#icon-list-search"></use></svg>',
      imageSelectWidth: '88vw',
      imageSelectHeight: '88vh',
      fileSelectWidth: '88vw',
      fileSelectHeight: '88vh',
      videoSelectWidth: '88vw',
      videoSelectHeight: '88vh',
      audioSelectWidth: '88vw',
      audioSelectHeight: '88vh',
      mediaSelectWidth: '88vw',
      mediaSelectHeight: '88vh',
      otherSelectWidth: '88vw',
      otherSelectHeight: '88vh',
      imageSelectMaxWidth: '1600px',
      fileSelectMaxWidth: '1600px',
      videoSelectMaxWidth: '1600px',
      audioSelectMaxWidth: '1600px',
      mediaSelectMaxWidth: '1600px',
      otherSelectMaxWidth: '1600px',
      assetPanelFullScreen: false,
      codeEditorWidth: '80vw',
      codeEditorHeight: '80vh',
      codeEditorMaxWidth: '1600px',
      blockCodeEditorWidth: '80vw',
      blockCodeEditorHeight: '45vh',
      blockCodeEditorMaxWidth: '960px',
      assetRefresh: false,
      // asset manager specified in imageSelect, fileSelect & videoSelect will always refreshed on click/open
      customTags: [],
      buttons: ['bold', 'italic', 'underline', 'formatting', 'color', 'align', 'textsettings', 'createLink', 'tags', '|', 'undo', 'redo', 'zoom', 'livepreview', 'aiassistant', 'snippets', 'more'],
      buttonsMore: ['icon', 'svg', 'image', '|', 'list', 'font', 'formatPara', '|', 'html', 'preferences'],
      elementButtons: ['left', 'center', 'right', 'full', 'undo', 'redo', 'zoom', 'livepreview', 'aiassistant', 'snippets', 'more'],
      elementButtonsMore: ['|', 'html', 'preferences'],
      iconButtons: ['icon', 'color', 'textsettings', 'createLink', '|', 'undo', 'redo', 'zoom', 'livepreview', 'aiassistant', 'snippets', 'more'],
      iconButtonsMore: ['html', 'preferences'],
      lang: [],
      checkLang: false,
      clearPreferences: false,
      toolbarAddSnippetButton: false,
      animateModal: true,
      defaultFontSizes: [16, 17, 18, 19, 21, 24, 32, 35, 42, 48, 54, 64 /*, 76, 96, 120, 200, 300*/],
      fontSizeClassValues: [12, 14, 15, 16, 17, 18, 19, 21, 24, 28, 32, 35, 38, 42, 46, 48, 50, 54, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 304, 308, 312, 316, 320, 324, 328, 332, 336, 340, 344, 348, 352, 356, 360, 364, 368, 372, 376, 380, 384, 388, 392, 396, 400],
      /* If not empty, applying font size will apply class: size-12, size-14, and so on. All responsive, defined in content.css */
      gradientcolors: [['linear-gradient(0deg, rgb(255, 57, 25), rgb(249, 168, 37))'], ['linear-gradient(0deg, rgb(255, 57, 25), rgb(255, 104, 15))'], ['linear-gradient(0deg, #FF5722, #FF9800)'], ['linear-gradient(0deg, #613ca2, rgb(110, 123, 217))'], ['linear-gradient(0deg, rgb(65, 70, 206), rgb(236, 78, 130))'], ['linear-gradient(0deg, rgb(0, 150, 102), rgb(90, 103, 197))'], ['linear-gradient(30deg, rgb(249, 119, 148), rgb(98, 58, 162))'], ['linear-gradient(0deg, rgb(223, 70, 137), rgb(90, 103, 197))'], ['linear-gradient(0deg, rgb(40, 53, 147), rgb(90, 103, 197))'], ['linear-gradient(0deg, rgb(21, 101, 192), rgb(52, 169, 239))'], ['linear-gradient(0deg, rgb(32, 149, 219), rgb(139, 109, 230))'], ['linear-gradient(0deg, rgb(90, 103, 197), rgb(0, 184, 201))'], ['linear-gradient(0deg, rgb(0, 184, 201), rgb(253, 187, 45))'], ['linear-gradient(0deg, rgb(255, 208, 100), rgb(239, 98, 159))'], ['linear-gradient(0deg, rgb(0, 214, 223), rgb(130, 162, 253))'], ['linear-gradient(0deg, rgb(50, 234, 251), rgb(248, 247, 126))'], ['linear-gradient(0deg, rgb(141, 221, 255), rgb(255, 227, 255))'], ['linear-gradient(0deg, rgb(255, 170, 170), rgb(255, 255, 200))'], ['linear-gradient(0deg, rgb(239, 239, 239), rgb(252, 252, 252))']],
      elementEditor: true,
      customval: '',
      moduleConfig: [],
      elementAnimate: false,
      cleanAOS: false,
      framework: '',
      cellFormat: '',
      rowFormat: '',
      // Email mode is an alternatif. 
      // ContentBuilder is focusing more on web building.
      emailMode: false,
      absolutePath: false,
      emailSnippetCategories: [[1, 'Logo'], [14, 'Call to Action'], [2, 'Title'], [3, 'Title, Subtitle'], [4, 'Info, Title'], [7, 'Paragraph'], [6, 'Heading'], [8, 'Buttons'], [9, 'Callouts'], [10, 'Images + Caption'], [12, 'Images'], [13, 'List'], [15, 'Pricing'], [16, 'Quotes'], [17, 'Profile'], [18, 'Contact Info'], [19, 'Footer'], [20, 'Separator']],
      defaultEmailSnippetCategory: 14,
      undoRedoStyles: false,
      // specialElementClasses: ['sl-wrapper', 'sl-overlay'] // specify elements that when clicked will not affect the builder interface (active selection). Usefull for external code, ex lightbox, etc. 

      // freeform
      onUndo: function () {},
      onRedo: function () {},
      onBlockCanvasAdd: function () {},
      // docContainer: '.is-page',
      blockContainer: '.is-box',
      pageSize: '100%,100vh,web',
      //'800px,1000px,web'
      pageSizes: [{
        title: 'Web',
        pagesize: '100%,100vh,web',
        style: 'width:180px;height:112.5px'
      }, {
        title: 'Web (container)',
        pagesize: '1000px,1000px,web',
        style: 'width:180px;height:112.5px'
      }, {
        title: '8.27x5.52',
        pagesize: '8.27in,5.52in',
        style: 'width:124.05px;height:82.8px'
      }, {
        title: '8.3x5.8',
        pagesize: '8.3in,5.8in',
        style: 'width:124.5px;height:87px'
      }, {
        title: '9x7',
        pagesize: '9in,7in',
        style: 'wwidth:135px;height:105px'
      }, {
        title: 'A4',
        pagesize: '11.7in,8.3in',
        style: 'width:175.5px;height:124.5px'
      }, {
        title: 'Letter',
        pagesize: '11in,8.5in',
        style: 'width:165px;height:127.5px'
      }, {
        title: '12.5x10',
        pagesize: '12.5in,10in',
        style: 'width:187.5px;height:150px'
      }, {
        title: '14x11',
        pagesize: '14in,11in',
        style: 'width:210px;height:165px'
      }, {
        title: '8.5x8.5',
        pagesize: '8.5in,8.5in',
        style: 'width:127.5px;height:127.5px'
      }, {
        title: '10x10',
        pagesize: '10in,10in',
        style: 'width:150px;height:150px'
      }, {
        title: '12x12',
        pagesize: '12in,12in',
        style: 'width:180px;height:180px'
      }, {
        title: '5.27x8.27',
        pagesize: '5.27in,8.27in',
        style: 'width:79.05px;height:124.05px'
      }, {
        title: 'A5',
        pagesize: '5.8in,8.3in',
        style: 'width:87px;height:124.5px'
      }, {
        title: '6x9',
        pagesize: '6in,9in',
        style: 'width:90px;height:135px'
      }, {
        title: '6.6x10.25',
        pagesize: '6.6in,10.25in',
        style: 'width:99px;height:153.75px'
      }, {
        title: 'Letter',
        pagesize: '8.5in,11in',
        style: 'width:127.5px;height:165px'
      }, {
        title: 'A4',
        pagesize: '8.3in,11.7in',
        style: 'width:124.5px;height:175.5px'
      }],
      /*
      Deprecated:
      snippetSampleImage: '',
      classReplace: [],
      iconselect: 'assets/ionicons/icons.html',
      rowMoveButtons: true,
      addButtonPlacement: '',
      sourceEditor: true,
      snippetPageSliding
      animatedSorting
      dragWithoutHandle
      */

      maxEmbedImageWidth: 1600,
      //set -1 for no max (use original image width)
      zoom: 1,
      useLightbox: false,
      lightboxArrow: true,
      imageRenameOnEdit: true,
      disableAutoEmbedVideo: false,
      deleteConfirm: false,
      disableBootstrapIcons: false,
      sectionTemplate: `
            <div class="is-section is-box is-section-100 type-system-ui">
                <div class="is-overlay"></div>
                <div class="is-boxes">
                    <div class="is-box-centered">
                        <div class="is-container is-content-1100 v2 size-17 leading-13">
                            [%CONTENT%]
                        </div>
                    </div>
                </div>
            </div>
            `,
      /*
      onZoomStart: () => {
           },
      onZoom: () => {
          console.log(scale);
      },
      onZoomEnd: (scale) => {
          console.log('end: ' + scale);
      }
       themes: [
          ['#ffffff','',''],
          ['#282828','dark','contentbuilder/themes/dark.css'],
          ['#0093dc','colored','contentbuilder/themes/colored-blue.css'],
          ['#006add','colored','contentbuilder/themes/colored-blue6.css'],
          ['#0a4d92','colored','contentbuilder/themes/colored-darkblue.css'],
          ['#96af16','colored','contentbuilder/themes/colored-green.css'],
          ['#e65800','colored','contentbuilder/themes/colored-orange.css'],
           ['#cc016f','colored','contentbuilder/themes/colored-magenta.css'],
          ['#782ec5','colored','contentbuilder/themes/colored-purple.css'],
          ['#de4ea4','colored','contentbuilder/themes/colored-pink.css'],
          ['#dd3905','colored','contentbuilder/themes/colored-red.css'],
          ['#e8ae00','colored','contentbuilder/themes/colored-yellow.css'],
          ['#13b34b','colored','contentbuilder/themes/colored-green4.css'],
          ['#333333','colored-dark','contentbuilder/themes/colored-dark.css'], 
          
          ['#dbe5f5','light','contentbuilder/themes/light-blue.css'],
          ['#fbe6f2','light','contentbuilder/themes/light-pink.css'],
          ['#dcdaf3','light','contentbuilder/themes/light-purple.css'],
          ['#ffe9e0','light','contentbuilder/themes/light-red.css'],
          ['#fffae5','light','contentbuilder/themes/light-yellow.css'],
          ['#ddf3dc','light','contentbuilder/themes/light-green.css'],
          ['#d7f7f1','light','contentbuilder/themes/light-cyan.css'],
           ['#c7ebfd','light','contentbuilder/themes/light-blue2.css'],
          ['#ffd5f2','light','contentbuilder/themes/light-pink2.css'],
          ['#eadafb','light','contentbuilder/themes/light-purple2.css'],
          ['#c5d4ff','light','contentbuilder/themes/light-blue3.css'],
          ['#ffefb1','light','contentbuilder/themes/light-yellow2.css'],
          ['#e5e5e5','light','contentbuilder/themes/light-gray2.css'],
          ['#dadada','light','contentbuilder/themes/light-gray.css'],
           ['#3f4ec9','colored','contentbuilder/themes/colored-blue2.css'],
          ['#6779d9','colored','contentbuilder/themes/colored-blue4.css'],
          ['#10b9d7','colored','contentbuilder/themes/colored-blue3.css'], 
          ['#006add','colored','contentbuilder/themes/colored-blue5.css'],
          ['#e92f94','colored','contentbuilder/themes/colored-pink3.css'],
          ['#a761d9','colored','contentbuilder/themes/colored-purple2.css'],
          ['#ff9d1e','colored','contentbuilder/themes/colored-yellow2.css'],
           ['#f3522b','colored','contentbuilder/themes/colored-red3.css'],
          ['#36b741','colored','contentbuilder/themes/colored-green2.css'],
          ['#00c17c','colored','contentbuilder/themes/colored-green3.css'],
          ['#fb3279','colored','contentbuilder/themes/colored-pink2.css'],
          ['#ff6d13','colored','contentbuilder/themes/colored-orange2.css'], 
          ['#f13535','colored','contentbuilder/themes/colored-red2.css'],
          ['#646464','colored','contentbuilder/themes/colored-gray.css'],
           ['#3f4ec9','dark','contentbuilder/themes/dark-blue.css'],
          ['#0b4d92','dark','contentbuilder/themes/dark-blue2.css'],
          ['#5f3ebf','dark','contentbuilder/themes/dark-purple.css'],
          ['#e92f69','dark','contentbuilder/themes/dark-pink.css'],
          ['#006add','dark','contentbuilder/themes/dark-blue3.css'],
          ['#4c4c4c','dark','contentbuilder/themes/dark-gray.css'],
          ['#ed2828','dark','contentbuilder/themes/dark-red.css'],
      ],
      */

      colHeight: [300, 350, 400, 450, 500, 550, 600, 650, 700],
      maxColumns: 6,
      // leadingPreset: [0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 2],
      // leadingPreset: [1, 1.1, 1.2, 1.3, 1.4, 1.6, 2],
      leadingPreset: [1, 1.1, 1.2, 1.3, 1.4, 1.6, 1.8],
      cssClasses: {
        fontWeight: {
          thin: 'font-thin',
          extralight: 'font-extralight',
          light: 'font-light',
          normal: 'font-normal',
          medium: 'font-medium',
          semibold: 'font-semibold',
          bold: 'font-bold',
          extrabold: 'font-extrabold',
          black: 'font-black',
          defaultBold: 'font-semibold',
          defaultNormal: 'font-light'
        },
        fontStyle: {
          italic: 'italic',
          normal: 'not-italic'
        },
        textDecoration: {
          underline: 'underline',
          linethrough: 'line-through',
          normal: 'no-underline'
        },
        textTransform: {
          uppercase: 'uppercase',
          lowercase: 'lowercase',
          capitalize: 'capitalize',
          normal: 'normal-case'
        },
        tracking: {
          tracking__100: 'tracking--100',
          tracking__075: 'tracking--75',
          tracking__050: 'tracking-tighter',
          tracking__025: 'tracking-tight',
          tracking_000: 'tracking-normal',
          tracking_025: 'tracking-wide',
          tracking_050: 'tracking-wider',
          tracking_075: 'tracking-75',
          tracking_100: 'tracking-widest',
          tracking_125: 'tracking-125',
          tracking_150: 'tracking-150',
          tracking_175: 'tracking-175',
          tracking_200: 'tracking-200',
          tracking_225: 'tracking-225',
          tracking_250: 'tracking-250',
          tracking_275: 'tracking-275',
          tracking_300: 'tracking-300',
          tracking_325: 'tracking-325',
          tracking_350: 'tracking-350',
          tracking_375: 'tracking-375',
          tracking_400: 'tracking-400',
          tracking_425: 'tracking-425',
          tracking_450: 'tracking-450',
          tracking_475: 'tracking-475',
          tracking_500: 'tracking-500'
        },
        leading: {
          leading_5: 'leading-05',
          leading_6: 'leading-06',
          leading_7: 'leading-07',
          leading_8: 'leading-08',
          leading_9: 'leading-09',
          leading_10: 'leading-none',
          leading_11: 'leading-11',
          leading_12: 'leading-12',
          leading_125: 'leading-tight',
          leading_13: 'leading-13',
          leading_1375: 'leading-snug',
          leading_14: 'leading-14',
          leading_15: 'leading-normal',
          leading_16: 'leading-16',
          leading_1625: 'leading-relaxed',
          leading_17: 'leading-17',
          leading_18: 'leading-18',
          leading_19: 'leading-19',
          leading_20: 'leading-loose',
          leading_21: 'leading-21',
          leading_22: 'leading-22',
          leading_23: 'leading-23',
          leading_24: 'leading-24',
          leading_25: 'leading-25',
          leading_26: 'leading-26',
          leading_27: 'leading-27',
          leading_28: 'leading-28',
          leading_29: 'leading-29',
          leading_30: 'leading-30'
        },
        opacity: {
          opacity_0: 'opacity-0',
          opacity_2: 'opacity-2',
          opacity_4: 'opacity-4',
          opacity_5: 'opacity-5',
          opacity_6: 'opacity-6',
          opacity_8: 'opacity-8',
          opacity_10: 'opacity-10',
          opacity_12: 'opacity-12',
          opacity_15: 'opacity-15',
          opacity_20: 'opacity-20',
          opacity_25: 'opacity-25',
          opacity_30: 'opacity-30',
          opacity_35: 'opacity-35',
          opacity_40: 'opacity-40',
          opacity_45: 'opacity-45',
          opacity_50: 'opacity-50',
          opacity_55: 'opacity-55',
          opacity_60: 'opacity-60',
          opacity_65: 'opacity-65',
          opacity_70: 'opacity-70',
          opacity_75: 'opacity-75',
          opacity_80: 'opacity-80',
          opacity_85: 'opacity-85',
          opacity_90: 'opacity-90',
          opacity_95: 'opacity-95',
          opacity_100: 'opacity-100'
        },
        padding: {
          all: {
            p_0: 'p-0',
            p_1: 'p-1',
            p_2: 'p-2',
            p_3: 'p-3',
            p_4: 'p-4',
            p_5: 'p-5',
            p_6: 'p-6',
            p_7: 'p-7',
            p_8: 'p-8',
            p_9: 'p-9',
            p_10: 'p-10',
            p_11: 'p-11',
            p_12: 'p-12',
            p_14: 'p-14',
            p_16: 'p-16',
            p_20: 'p-20'
          },
          x: {
            px_0: 'px-0',
            px_1: 'px-1',
            px_2: 'px-2',
            px_3: 'px-3',
            px_4: 'px-4',
            px_5: 'px-5',
            px_6: 'px-6',
            px_7: 'px-7',
            px_8: 'px-8',
            px_9: 'px-9',
            px_10: 'px-10',
            px_11: 'px-11',
            px_12: 'px-12',
            px_14: 'px-14',
            px_16: 'px-16',
            px_20: 'px-20'
          },
          y: {
            py_0: 'py-0',
            py_1: 'py-1',
            py_2: 'py-2',
            py_3: 'py-3',
            py_4: 'py-4',
            py_5: 'py-5',
            py_6: 'py-6',
            py_7: 'py-7',
            py_8: 'py-8',
            py_9: 'py-9',
            py_10: 'py-10',
            py_11: 'py-11',
            py_12: 'py-12',
            py_14: 'py-14',
            py_16: 'py-16',
            py_20: 'py-20'
          },
          top: {
            pt_0: 'pt-0',
            pt_1: 'pt-1',
            pt_2: 'pt-2',
            pt_3: 'pt-3',
            pt_4: 'pt-4',
            pt_5: 'pt-5',
            pt_6: 'pt-6',
            pt_7: 'pt-7',
            pt_8: 'pt-8',
            pt_9: 'pt-9',
            pt_10: 'pt-10',
            pt_11: 'pt-11',
            pt_12: 'pt-12',
            pt_14: 'pt-14',
            pt_16: 'pt-16',
            pt_20: 'pt-20'
          },
          right: {
            pr_0: 'pr-0',
            pr_1: 'pr-1',
            pr_2: 'pr-2',
            pr_3: 'pr-3',
            pr_4: 'pr-4',
            pr_5: 'pr-5',
            pr_6: 'pr-6',
            pr_7: 'pr-7',
            pr_8: 'pr-8',
            pr_9: 'pr-9',
            pr_10: 'pr-10',
            pr_11: 'pr-11',
            pr_12: 'pr-12',
            pr_14: 'pr-14',
            pr_16: 'pr-16',
            pr_20: 'pr-20'
          },
          bottom: {
            pb_0: 'pb-0',
            pb_1: 'pb-1',
            pb_2: 'pb-2',
            pb_3: 'pb-3',
            pb_4: 'pb-4',
            pb_5: 'pb-5',
            pb_6: 'pb-6',
            pb_7: 'pb-7',
            pb_8: 'pb-8',
            pb_9: 'pb-9',
            pb_10: 'pb-10',
            pb_11: 'pb-11',
            pb_12: 'pb-12',
            pb_14: 'pb-14',
            pb_16: 'pb-16',
            pb_20: 'pb-20'
          },
          left: {
            pl_0: 'pl-0',
            pl_1: 'pl-1',
            pl_2: 'pl-2',
            pl_3: 'pl-3',
            pl_4: 'pl-4',
            pl_5: 'pl-5',
            pl_6: 'pl-6',
            pl_7: 'pl-7',
            pl_8: 'pl-8',
            pl_9: 'pl-9',
            pl_10: 'pl-10',
            pl_11: 'pl-11',
            pl_12: 'pl-12',
            pl_14: 'pl-14',
            pl_16: 'pl-16',
            pl_20: 'pl-20'
          }
        },
        extend: {
          superscript: 'sup',
          subscript: 'sub'
        },
        textAlign: {
          left: 'text-left',
          center: 'text-center',
          right: 'text-right',
          justify: 'text-justify'
        },
        display: {
          flex: 'flex',
          block: 'block',
          inline: 'inline',
          inline_block: 'inline-block'
        },
        flexDirection: {
          row: 'flex-row',
          column: 'flex-col',
          row_reverse: 'flex-row-reverse',
          column_reverse: 'flex-col-reverse'
        },
        flexWrap: {
          wrap: 'flex-wrap',
          nowrap: 'flex-nowrap',
          wrap_reverse: 'flex-wrap-reverse'
        },
        justifyContent: {
          start: 'justify-start',
          end: 'justify-end',
          center: 'justify-center',
          between: 'justify-between',
          around: 'justify-around',
          evenly: 'justify-evenly'
        },
        alignItems: {
          start: 'items-start',
          end: 'items-end',
          center: 'items-center',
          baseline: 'items-baseline',
          stretch: 'items-stretch'
        }
      },
      useCssClasses: true,
      useButtonPlugin: false,
      enableDragResize: true,
      simpleTextSettings: false,
      enableColumnsPerLine: true,
      /* Prompt/Command Stuff for AI Assistant */
      startAIAssistant: false,
      isContentBox: false,
      sendCommandUrl: '',
      // http://localhost:8081/answer
      // speechTranscribeUrl: 'http://192.168.1.7:8081',
      onlineDemo: false,
      autoSendDelay: 4000,
      autoEditBlock: false,
      disclaimerAI: `The feature you're about to use utilizes AI in some of its processes. 
            It's important to understand that AI systems have limitations.
            There may be instances where the results are not 100% accurate or may provide unexpected responses or information.
            As a user, it's your responsibility to independently verify any information or results obtained through this AI-powered feature. 
            Our team is dedicated to continuously improving its performance and accuracy to enhance your experience.`,
      showDisclaimer: true,
      AIModalStyle: '',
      enableShortCommands: true,
      speechRecognitionLang: 'en-US',
      assistantMode: 'general',
      triggerWords: {
        send: ['send', 'okay', 'ok', 'execute', 'run'],
        abort: ['abort', 'cancel'],
        clear: ['clear', 'erase']
      },
      temperature: 0.6,
      //0.4,
      topP: 0.9,
      //0.6,
      useMediaRecorder: true,
      // do not change
      encoderPath: '',
      imageAutoUpscale: true,
      headlineList: ['We create simple and effective designs.', 'Ultimate Experiences With Story, Emotion, And Purpose.', 'Build Anything Beautifully', 'With Less Stuff and More Compassion', 'We\'re [CompanyName]. Full stack development with a spark of creativity.', 'Transforming your digital experience with [CompanyName]. Achieve your online goals with our customized solutions.', 'Revolutionizing web development with [CompanyName]. Unleash your digital potential with our high-performance solutions.', 'Creative and Inspiring'],
      mediaPath: 'assets/gallery/',
      media: {
        slider: ['slide-01.jpg', 'slide-02.jpg'],
        blank_video: 'blank.mp4',
        videos: ['beach1.mp4', 'beach2.mp4'],
        youtube_videos: ['https://www.youtube-nocookie.com/embed/P5yHEKqx86U?rel=0&autoplay=1&color=white'],
        maps: ['https://www.youtube-nocookie.com/embed/P5yHEKqx86U?rel=0&autoplay=1&color=white'],
        audios: ['example.mp3'],
        images: {
          square: ['desk.jpg', 'chair.jpg', 'coffee.jpg', 'product.jpg', 'table.jpg', 'person-01.jpg', 'person-02.jpg', 'person-03.jpg', 'person-04.jpg', 'person-05.jpg', 'person-06.jpg', 'person-08.jpg']
        },
        bg_images: {
          box: ['person-01.jpg', 'person-02.jpg', 'person-03.jpg', 'person-04.jpg', 'person-05.jpg', 'person-06.jpg', 'person-07.jpg', 'person-08.jpg', 'person-09.jpg', 'person-10.jpg', 'building.jpg', 'desk.jpg', 'chair.jpg', 'coffee.jpg', 'product.jpg', 'table.jpg'],
          small_box: ['person-01.jpg', 'person-03.jpg', 'person-04.jpg', 'person-05.jpg', 'person-10.jpg', 'chair.jpg', 'coffee.jpg', 'product.jpg', 'table.jpg'],
          // section: [
          //     'header-01.jpg',
          //     'header-02.jpg',
          //     'header-03.jpg',
          //     'header-04.jpg',
          //     'header-05.jpg',
          //     'header-06.jpg',
          //     'header-07.jpg',
          //     'header-08.jpg',
          //     'header-09.jpg',
          //     'header-10.jpg',
          //     'header-11.jpg',
          //     'header-12.jpg',
          //     'header-13.jpg',
          //     'header-14.jpg',
          //     'header-15.jpg',
          // ],
          section_text_left: ['header-01.jpg', 'header-02.jpg', 'header-03.jpg', 'header-05.jpg', 'header-08.jpg', 'header-10b.jpg',
          // 'header-13.jpg',
          'header-14.jpg'
          // 'header-15b.jpg',
          ],

          section_text_center: ['header-07.jpg', 'header-11.jpg', 'header-12.jpg', 'header-13.jpg'],
          section_text_right: ['header-04.jpg', 'header-05b.jpg', 'header-06.jpg', 'header-08b.jpg', 'header-09.jpg', 'header-10.jpg', 'header-14b.jpg', 'header-15.jpg']
        }
      },
      shortCommandList: {
        undo: ['undo'],
        redo: ['undo'],
        increase: ['increase', 'bigger', 'larger', 'enlarge'],
        decrease: ['decrease', 'smaller'],
        bold: ['bold'],
        italic: ['italic'],
        underline: ['underline'],
        strikethrough: ['strikethrough'],
        superscript: ['superscript'],
        subscript: ['subscript'],
        uppercase: ['uppercase'],
        lowercase: ['lowercase'],
        capitalize: ['capitalize'],
        clean: ['clean']
      },
      similarityThreshold: 0.65,
      commandList: {
        select: ['select', 'select first', 'select first block'],
        select_next: ['select next', 'select after', 'select next block', 'select next row'],
        select_previous: ['select previous', 'select before', 'select previous block', 'select previous row'],
        select_last: ['select last', 'select last block'],
        select_block: ['select block'],
        unselect_block: ['unselect', 'unselect block'],
        select_headline: ['select headline'],
        select_paragraph: ['select paragraph'],
        select_button: ['select button'],
        select_space: ['select space'],
        select_image: ['select image'],
        change_font: ['change font', 'change typography', 'change style'],
        suggest_headline: ['suggest headline', 'suggest header', 'suggest title', 'write headline', 'write header', 'write title'],
        suggest_text: ['suggest text', 'write text'],
        add_headline: ['add headline', 'add header', 'add title'],
        add_paragraph: ['add paragraph'],
        add_image: ['add image'],
        add_youtube: ['add youtube'],
        add_video: ['add video'],
        remove_video: ['remove video', 'clear video'],
        add_bg_video: ['add background video'],
        remove_bg_video: ['remove background video', 'clear background video'],
        add_slider: ['add slider'],
        remove_slider: ['remove slider', 'clear slider'],
        add_audio: ['add audio', 'add music', 'add mp3'],
        add_map: ['add map', 'add google map'],
        add_table: ['add table'],
        add_social: ['add social'],
        add_icon: ['add icon'],
        add_button: ['add button'],
        add_2buttons: ['add 2 button', 'add 2 buttons'],
        add_space: ['add space'],
        position_before: ['above', 'before'],
        increase_line_height: ['increase line height', 'increase line spacing', 'increase text spacing', 'enlarge line height', 'enlarge line spacing', 'enlarge text spacing', 'bigger line height', 'bigger line spacing', 'bigger text spacing', 'make line height bigger', 'make line spacing bigger', 'make text spacing bigger'],
        decrease_line_height: ['decrease line height', 'decrease line spacing', 'decrease text spacing', 'reduce line height', 'reduce line spacing', 'reduce text spacing', 'smaller line height', 'smaller line spacing', 'smaller text spacing', 'make line height smaller', 'make line spacing smaller', 'make text spacing smaller'],
        increase_font_size: ['increase font', 'increase size', 'increase font size', 'increase text', 'increase size', 'increase text size', 'enlarge font', 'enlarge size', 'enlarge font size', 'enlarge text', 'enlarge size', 'enlarge text size', 'text bigger', 'font bigger', 'size bigger'],
        decrease_font_size: ['decrease font', 'decrease size', 'decrease font size', 'decrease text', 'decrease size', 'decrease text size', 'reduce font', 'reduce size', 'reduce font size', 'reduce text', 'reduce size', 'reduce text size', 'text smaller', 'font smaller', 'size smaller'],
        clear_font_size: ['clear font size', 'remove font size', 'clear text size', 'remove text size', 'use default font size'],
        align_left: ['align left', 'align text left', 'left aligned'],
        align_center: ['align center', 'align text center', 'center aligned'],
        align_right: ['align right', 'align text right', 'right aligned'],
        align_full: ['align full', 'align justify', 'justify', 'justify text', 'justify full'],
        clear_alignment: ['clear alignment', 'remove alignment', 'clear text alignment', 'remove text alignment'],
        increase_space: ['more space', 'increase space', 'enlarge space'],
        decrease_space: ['less space', 'decrease space', 'reduce space'],
        move_up: ['move up'],
        move_down: ['move down'],
        move_row_up: ['move row up'],
        move_row_down: ['move row down'],
        duplicate_row: ['duplicate row', 'copy row'],
        remove_row: ['remove row', 'delete row'],
        move_col_left: ['move left', 'move column left'],
        move_col_right: ['move right', 'move column right'],
        duplicate_col: ['duplicate column', 'copy column'],
        remove_col: ['remove column', 'delete column'],
        move_column_up: ['move column up'],
        move_column_down: ['move column down']
      },
      commandInfo: {
        general: {
          title: 'General',
          description: 'Commands for designing or editing.',
          list: [
          // 'Create a section containing a short article with ideas for outdoor activities. Divide into subtopics.',
          'Add a content that highlights our AI-powered web solutions. Include a compelling headline, a paragraph, and two buttons named \'Our Works\' and \'Get in Touch\'. ', 'Create an article on ideas for outdoor activities. Include a minimum of 300 words.', 'Can you suggest a captivating headline for us and replace the current one?', 'Add a content showcasing our AI-powered innovations. Craft an attention-grabbing headline, provide explanations, incorporate an image, and add an enticing call-to-action.',
          // 'Add a new header content for our development studio, which uniquely integrates AI into its solutions. Include a compelling headline, a paragraph, and two buttons named \'Our Works\' and \'Get Started\'. Also, add a background image.',
          // `Add a new header content for our web studio. Include a compelling headline, a paragraph, and two buttons named 'Our Works' and 'Get in Touch'.<br> 
          // Also, add a background image.`,
          `Create a feature list of our wood cabin for rent:<br>
- Scenic forest view<br>
- Modern comforts<br>
- Outdoor escape<br>
Add an icon for each list item.`,
          // `Add a content highlighting the features of our creative arts courses:<br>
          // - Hands-on projects and assignments<br>
          // - Feedback and guidance from experts<br>
          // Include an image for each feature.
          // Provide an engaging headline.`,
          // 'Create a new content showcasing a photo gallery of our latest photography workshop. Includes up to 3 photo placeholders. Additionally, please add a title.',
          `Add a content highlighting the features of our creative arts courses:<br>
- Hands-on projects<br>
- Guidance from experts<br>
Add an image for each feature.`, 'Revise the headline, paragraph, and all the text using alternative ideas.',
          // 'Let\'s redesign the layout. Surprise me with a new idea!',

          'Create a new content showcasing a photo gallery of our latest photography workshop. Includes up to 3 photo placeholders.',
          // Create a new content that highlights our web studio. It should include an attention-grabbing headline, an engaging paragraph, an image, and a compelling call-to-action button.
          // Add a new content consisting of two boxes. The first box should feature a captivating headline about our Arts courses, an informative paragraph, and a button labeled 'Browse Courses'. The second box should remain empty but have a background image.
          'Create a content highlighting what sets our web development studio apart. Include a maximum of 3 list items, each with an item title and a short paragraph with less than 20 words. Also, add a numbering.',
          // Rewrite all the text to improve the overall copywriting quality.
          // Can you come up with another rendition of the content or offer an alternative wording?
          'My name is Emilie, and I\'m a product designer with 5 years of experience. Please create a new \'About Me\' content with a headline, description, and two buttons named \'My Works\' and \'Get in Touch\'. Additionally, please include an image.',
          // Change the button text with an alternative wording'
          // Can you suggest a captivating headline for us?'
          'Do you see the button with a gray background? Please change the background color to light green.',
          // 'Underline the phrase \'every monday\' and change the color to dark blue.',

          'Summarize this content in 100 words.'
          // 'Undo',
          // 'Redo'
          ]
          // width: '400px'
        },

        others: {
          title: 'Ask Questions or Request Information',
          description: 'Commands that are <u>not related to designing and editing of the current content</u>.',
          list: ['Provide well-researched information about bookstores in the Melbourne city area that offer collections of classic titles. Include specific details such as locations, website links, the range of classic titles they offer, and any unique features they have.', 'Explain our galaxy in a beginner-friendly and interesting way.', 'Can you explain the process of baking a classic chocolate cake from scratch?',
          // 'Give me a list of effective home workouts for beginners without any equipment.',
          // 'Give me ideas for designing a cozy and functional home office space.',
          'Provide me with a 10-hour plan for learning practical data science.'
          // 'Can you explain how to set up a new React project?'
          ]
        },

        block: {
          title: 'Edit Selected Text',
          description: 'Specifically target the selected block for editing, providing more precise results.',
          list: ['Enhance the content by including introductory paragraphs after the title.', 'Add a space between the title and the button.', 'Increase the space between the title and the paragraph.', 'Apply a gradient text color from red to orange horizontally to the title.',
          // 'Paraphrase the title.',
          'Rewrite the headline with alternative ideas', 'Reduce the title font size.',
          // 'Align the text to the center.',
          'Add a link on the text \'Download\' that directs to: https://example.com/download', 'Add a new block containing a Google map showing local cafes in the Perth city area.']
        },
        image: {
          title: 'Image',
          description: 'Generate image for the selected image or background',
          list: ['A small office building in a distant view, surrounded by a warm blend of brown and orange hues against a serene blue sky. Embrace a muted color palette with pastel tones, emphasizing natural and clean aesthetics. Craft a simple yet impactful composition with generous negative space, channeling a minimalist look that exudes brightness and sophistication. Infuse the scene with a style reminiscent of architecture magazines, ensuring a full focus background that complements the building\'s design. Utilize high-quality equipment such as an 8K UHD camera and DSLR for impeccable detail, and employ soft lighting to enhance the overall visual appeal.', 'A minimalist wood cabin is captured from a distance, surrounded by a sea of grass, bathed in the soft, breathtaking sunlight of 17:00, under an expansive blue sky. The image is crafted in a true minimalist photographic style, emphasizing the bright open sky and featuring lots of white space.', 'A simple wooden table adorned with a petite vase and a vibrant yellow flower. Opt for a clean background with ample white space, prioritizing minimalism. Cultivate a muted color palette and pastel tones to create a serene atmosphere. Employ soft lighting to enhance the gentle ambiance. Aim for a style reminiscent of interior magazines, capturing the essence of sophistication and simplicity in every detail.']
        }
        /*
        selection: {
            title: 'Selection & Layout',
            list: [
                'Select the headline',
                // 'Select the paragraph',
                // 'Select the button',
                // 'Select the space',
                // 'Select the image',
                'Select the next block',
                // 'Select the previous block',
                // 'Select the first block',
                // 'Select the last block',
                'Move up',
                'Move down',
                'Duplicate row',
                'Remove row',
                'Move column left',
                'Move column right',
                'Duplicate column',
                'Remove column',
                // 'Move column up',
                // 'Move column down',
                'Move section up',
                'Move section down',
                // 'Move section top',
                // 'Move section bottom',
                // 'Duplicate section',
                // 'Remove section',
            ]
        },
        element: {
            title: 'Element',
            list: [
                'Add a headline',
                'Add a paragraph',
                'Add an image',
                'Add a Youtube video',
                // 'Add a table',
                // 'Add audio',
                // 'Add map',
                // 'Add an icon',
                // 'Add social links',
                'Add a button',
                'Add two buttons',
                'Add a space',
                'Increase the space',
                // 'Reduce the space',
            ]
        },
        text: {
            title: 'Text Formatting',
            list: [
                // 'Increase', 'Bigger','Larger','Enlarge', 
                // 'Decrease', 'Smaller',
                'Increase font size',
                // 'Decrease font size',
                'Clear font size',
                // 'Align left',
                'Align center',
                'Align right',
                'Align justify',
                'Clear alignment',
                     'Bold',
                'Italic',
                'Underline',
                'Strikethrough',
                // 'Superscript',
                // 'Subscript',
                'Uppercase',
                // 'Lowercase',
                // 'Capitalize',
                'Clean',
            ]
        },
        */
      },

      commandInfoCanvasMode: {
        general: {
          title: 'General',
          description: 'Commands for designing or editing.',
          list: [
          // 'Create a section containing a short article with ideas for outdoor activities. Divide into subtopics.',
          'Add a content that highlights our AI-powered web solutions. Include a compelling headline, a paragraph, and two buttons named \'Our Works\' and \'Get in Touch\'. ', 'Create an article on ideas for outdoor activities. Include a minimum of 300 words.', 'Add a content showcasing our AI-powered innovations. Craft an attention-grabbing headline, provide explanations, incorporate an image, and add an enticing call-to-action.',
          // 'Add a new header content for our development studio, which uniquely integrates AI into its solutions. Include a compelling headline, a paragraph, and two buttons named \'Our Works\' and \'Get Started\'. Also, add a background image.',
          // `Add a new header content for our web studio. Include a compelling headline, a paragraph, and two buttons named 'Our Works' and 'Get in Touch'.<br> 
          // Also, add a background image.`,
          `Create a feature list of our wood cabin for rent:<br>
- Scenic forest view<br>
- Modern comforts<br>
- Outdoor escape<br>
Add an icon for each list item.`,
          // `Add a content highlighting the features of our creative arts courses:<br>
          // - Hands-on projects and assignments<br>
          // - Feedback and guidance from experts<br>
          // Include an image for each feature.
          // Provide an engaging headline.`,
          // 'Create a new content showcasing a photo gallery of our latest photography workshop. Includes up to 3 photo placeholders. Additionally, please add a title.',
          `Add a content highlighting the features of our creative arts courses:<br>
- Hands-on projects<br>
- Guidance from experts<br>
Add an image for each feature.`, 'Create a new content showcasing a photo gallery of our latest photography workshop. Includes up to 3 photo placeholders.',
          // Create a new content that highlights our web studio. It should include an attention-grabbing headline, an engaging paragraph, an image, and a compelling call-to-action button.
          // Add a new content consisting of two boxes. The first box should feature a captivating headline about our Arts courses, an informative paragraph, and a button labeled 'Browse Courses'. The second box should remain empty but have a background image.
          'Create a content highlighting what sets our web development studio apart. Include a maximum of 3 list items, each with an item title and a short paragraph with less than 20 words. Also, add a numbering.',
          // Rewrite all the text to improve the overall copywriting quality.
          // Can you come up with another rendition of the content or offer an alternative wording?
          'My name is Emilie, and I\'m a product designer with 5 years of experience. Please create a new \'About Me\' content with a headline, description, and two buttons named \'My Works\' and \'Get in Touch\'. Additionally, please include an image.'

          // 'Undo',
          // 'Redo'
          ]
          // width: '400px'
        },

        general2: {
          title: 'General (with block selection)',
          description: 'Commands for designing or editing.',
          list: ['Rewrite the headline to captivate readers and maximize impact',
          // Rewrite all the text to improve the overall copywriting quality.
          // Can you come up with another rendition of the content or offer an alternative wording?
          'Change the button text with an alternative wording', 'Do you see the button with a gray background? Please change the background color to light green.', 'Summarize this content in 100 words.']
          // width: '400px'
        },

        others: {
          title: 'Ask Questions or Request Information',
          description: 'Commands that are <u>not related to designing and editing of the current content</u>.',
          list: ['Provide well-researched information about bookstores in the Melbourne city area that offer collections of classic titles. Include specific details such as locations, website links, the range of classic titles they offer, and any unique features they have.', 'Explain our galaxy in a beginner-friendly and interesting way.', 'Can you explain the process of baking a classic chocolate cake from scratch?',
          // 'Give me a list of effective home workouts for beginners without any equipment.',
          // 'Give me ideas for designing a cozy and functional home office space.',
          'Provide me with a 10-hour plan for learning practical data science.'
          // 'Can you explain how to set up a new React project?'
          ]
        },

        block: {
          title: 'Edit Selected Text',
          description: 'Specifically target the selected block for editing, providing more precise results.',
          list: ['Enhance the content by including introductory paragraphs after the title.', 'Add a space between the title and the button.', 'Increase the space between the title and the paragraph.', 'Apply a gradient text color from red to orange horizontally to the title.',
          // 'Paraphrase the title.',
          'Rewrite the headline with alternative ideas', 'Reduce the title font size.',
          // 'Align the text to the center.',
          'Add a link on the text \'Download\' that directs to: https://example.com/download', 'Add a new block containing a Google map showing local cafes in the Perth city area.']
        },
        image: {
          title: 'Image',
          description: 'Generate image for the selected image or background',
          list: ['A small office building in a distant view, surrounded by a warm blend of brown and orange hues against a serene blue sky. Embrace a muted color palette with pastel tones, emphasizing natural and clean aesthetics. Craft a simple yet impactful composition with generous negative space, channeling a minimalist look that exudes brightness and sophistication. Infuse the scene with a style reminiscent of architecture magazines, ensuring a full focus background that complements the building\'s design. Utilize high-quality equipment such as an 8K UHD camera and DSLR for impeccable detail, and employ soft lighting to enhance the overall visual appeal.', 'A minimalist wood cabin is captured from a distance, surrounded by a sea of grass, bathed in the soft, breathtaking sunlight of 17:00, under an expansive blue sky. The image is crafted in a true minimalist photographic style, emphasizing the bright open sky and featuring lots of white space.', 'A simple wooden table adorned with a petite vase and a vibrant yellow flower. Opt for a clean background with ample white space, prioritizing minimalism. Cultivate a muted color palette and pastel tones to create a serene atmosphere. Employ soft lighting to enhance the gentle ambiance. Aim for a style reminiscent of interior magazines, capturing the essence of sophistication and simplicity in every detail.']
        }
      }
    };

    // obj.preserveSelection = true; (can be set programmatically) to prevent click that clears selection on external custom modal.

    this.opts = Object.assign(this, defaults, opts);
    if (window.data_basic) {
      // if snippet file included
      this.opts.snippetJSON = window.data_basic;
      if (!this.canvas) for (let i = this.opts.snippetJSON.snippets.length - 1; i >= 0; i--) {
        if (this.opts.snippetJSON.snippets[i].mode === 'canvas') {
          this.opts.snippetJSON.snippets.splice(i, 1);
        }
      }

      // if snippetPath is specified (not empty), then use the specified. Otherwise, use the one generated from snippet file (_snippets_path)
      if (this.opts.snippetPath === '') {
        this.opts.snippetPath = window._snippets_path;
      }
    }
    if (this.opts.snippetDisplay) {
      if (this.opts.snippetDisplay === 'auto') {
        this.opts.snippetsSidebarDisplay = 'auto';
      } else {
        // can be any: 'stay', 'visible'
        this.opts.snippetsSidebarDisplay = 'always';
      }
    }

    // if scriptPath is specified (not empty), then use the specified. Otherwise, use generated.
    if (this.opts.scriptPath === '') {
      this.opts.scriptPath = this.currentScriptPath();
    }
    if (window._txt) {
      // if language file is included
      this.opts.lang = window._txt;
    }
    this.settings = this.opts; // Backward compatible

    // freeform
    if (this.canvas && !this.isContentBox) {
      /*
      blockContainer: '.is-box',
      imageResizeOnBlock: false,
      toolbarDisplay: 'always',
      buttons: ['bold', 'italic', 'underline', 'formatting', 'color', 'align', 'textsettings', 'createLink', 'tags', '|', 'undo', 'redo', 'aiassistant', 'snippets', 'zoom', 'pageoptions', 'print', 'html', 'more'],  
      buttonsMore: ['icon', 'image', '|', 'list', 'font', 'formatPara'], 
      elementButtons: ['front', 'backward', 'moveup', 'movedown',  'group', 'ungroup', 'duplicate', 'delete','left', 'center', 'right', 'full' , 'undo', 'redo', 'aiassistant', 'snippets', 'blocksettings', 'zoom', 'pageoptions', 'print', 'html'],  
      elementButtonsMore: [], 
      iconButtons: ['icon', 'color','textsettings', 'createLink','|', 'undo', 'redo', 'aiassistant', 'snippets', 'zoom', 'pageoptions', 'print', 'html'],  
      iconButtonsMore: [], 
      */
      this.blockContainer = '.is-box';
      this.imageResizeOnBlock = false;
      this.toolbarDisplay = 'always';
      // this.buttons = ['bold', 'italic', 'underline', 'formatting', 'color', 'align', 'textsettings', 'createLink', 'tags', '|', 'undo', 'redo', 'aiassistant', 'snippets','pageoptions', 'print', 'html',  'zoom', 'more'];  
      // this.buttonsMore = ['icon', 'image', '|', 'list', 'font', 'formatPara'];
      // this.elementButtons = ['front', 'backward', 'moveup', 'movedown',  'group', 'ungroup', 'duplicate', 'delete','left', 'center', 'right', 'full' , 'undo', 'redo', 'aiassistant', 'snippets', 'blocksettings', 'pageoptions', 'print', 'zoom', 'html'];
      // this.elementButtonsMore = [];
      // this.iconButtons = ['icon', 'color','textsettings', 'createLink','|', 'undo', 'redo', 'aiassistant', 'snippets', 'pageoptions', 'print', 'zoom', 'html'];
      // this.iconButtonsMore = [];

      this.buttons = ['bold', 'italic', 'underline', 'formatting', 'color', 'align', 'textsettings', 'createLink', 'tags', '|', 'undo', 'redo', 'zoom', 'pageoptions', 'print', 'html', 'more'];
      this.buttonsMore = ['icon', 'image', '|', 'list', 'font', 'formatPara', '|', 'aiassistant', 'snippets', 'preferences'];
      this.elementButtons = ['front', 'backward', 'moveup', 'movedown', 'group', 'ungroup', 'duplicate', 'delete', 'left', 'center', 'right', 'full', 'undo', 'redo', 'blocksettings', 'zoom', 'pageoptions', 'print', 'html', 'more'];
      this.elementButtonsMore = ['aiassistant', 'snippets', 'preferences'];
      this.iconButtons = ['icon', 'color', 'textsettings', 'createLink', '|', 'undo', 'redo', 'zoom', 'pageoptions', 'print', 'html', 'more'];
      this.iconButtonsMore = ['aiassistant', 'snippets', 'preferences'];
      if (!this.docContainer && this.container !== '.is-container') {
        this.docContainer = this.container;
        this.container = '.is-container';
        this.opts.container = '.is-container';
      }
    }
    if (this.opts.imageSelect !== '') {
      this.opts.imageselect = this.opts.imageSelect;
    } else if (this.opts.imageselect !== '') {
      this.opts.imageSelect = this.opts.imageselect;
    }
    if (this.opts.fileSelect !== '') {
      this.opts.fileselect = this.opts.fileSelect;
    } else if (this.opts.fileselect !== '') {
      this.opts.fileSelect = this.opts.fileselect;
    }
    if (this.opts.videoSelect !== '') {
      this.opts.videoselect = this.opts.videoSelect;
    } else if (this.opts.videoselect !== '') {
      this.opts.videoSelect = this.opts.videoselect;
    }
    if (this.assetPanelFullScreen) {
      this.imageSelectWidth = '100vw';
      this.imageSelectHeight = '100vh';
      this.fileSelectWidth = '100vw';
      this.fileSelectHeight = '100vh';
      this.videoSelectWidth = '100vw';
      this.videoSelectHeight = '100vh';
      this.audioSelectWidth = '100vw';
      this.audioSelectHeight = '100vh';
      this.mediaSelectWidth = '100vw';
      this.mediaSelectHeight = '100vh';
      this.otherSelectWidth = '100vw';
      this.otherSelectHeight = '100vh';
      this.imageSelectMaxWidth = '100vw';
      this.fileSelectMaxWidth = '100vw';
      this.videoSelectMaxWidth = '100vw';
      this.audioSelectMaxWidth = '100vw';
      this.mediaSelectMaxWidth = '100vw';
      this.otherSelectMaxWidth = '100vw';
    }

    // if(this.opts.largerImageHandler!=='') {
    //     this.opts.mediaHandler = this.opts.largerImageHandler;
    // } else if(this.opts.mediaHandler!=='') {
    //     this.opts.largerImageHandler = this.opts.mediaHandler;
    // }
    // if(this.opts.onLargerImageUpload) {
    //     this.opts.onMediaUpload = this.opts.onLargerImageUpload;
    // } else if(this.opts.onMediaUpload) {
    //     this.opts.onLargerImageUpload = this.opts.onMediaUpload;
    // }

    // Just in case
    if (!this.opts.onImageUpload && !this.opts.onLargerImageUpload) {
      this.opts.onImageUpload = this.opts.onMediaUpload;
    }
    if (!this.opts.imageHandler && !this.opts.largerImageHandler) {
      this.opts.imageHandler = this.opts.mediaHandler;
    }

    // Currently used: largerImageHandler & onLargerImageUpload (as in elementimage.js)
    if (this.opts.imageHandler !== '') {
      this.opts.largerImageHandler = this.opts.imageHandler;
    }
    if (this.opts.onImageUpload) {
      this.opts.onLargerImageUpload = this.opts.onImageUpload;
    }

    // useButtonPlugin
    if (this.opts.emailMode) {
      this.useButtonPlugin = true;
    }
    if (!this.useButtonPlugin) {
      let _arr = this.plugins.filter(item => {
        return item.name !== 'buttoneditor';
      });
      this.plugins = [..._arr];
    }

    // Alternative settions to define css grid frameworks
    if (this.opts.framework === 'bootstrap') {
      this.opts.row = 'row';
      this.opts.cols = ['col-md-1', 'col-md-2', 'col-md-3', 'col-md-4', 'col-md-5', 'col-md-6', 'col-md-7', 'col-md-8', 'col-md-9', 'col-md-10', 'col-md-11', 'col-md-12'];
      this.opts.colequal = [];
      this.opts.colsizes = [];
    } else if (this.opts.framework === 'tailwind') {
      this.opts.row = 'flex flex-col md:flex-row';
      this.opts.cols = ['w-full md:w-1/12 px-4', 'w-full md:w-2/12 px-4', 'w-full md:w-3/12 px-4', 'w-full md:w-4/12 px-4', 'w-full md:w-5/12 px-4', 'w-full md:w-6/12 px-4', 'w-full md:w-7/12 px-4', 'w-full md:w-8/12 px-4', 'w-full md:w-9/12 px-4', 'w-full md:w-10/12 px-4', 'w-full md:w-11/12 px-4', 'w-full px-4'];
      this.opts.colequal = [];
      this.opts.colsizes = [];
    } else if (this.opts.framework === 'foundation') {
      this.opts.row = 'row';
      this.opts.cols = ['large-1 columns', 'large-2 columns', 'large-3 columns', 'large-4 columns', 'large-5 columns', 'large-6 columns', 'large-7 columns', 'large-8 columns', 'large-9 columns', 'large-10 columns', 'large-11 columns', 'large-12 columns'];
      this.opts.colequal = [];
      this.opts.colsizes = [];
    } else if (this.opts.framework === 'material') {
      this.opts.row = 'mdl-grid';
      this.opts.cols = ['mdl-cell mdl-cell--1-col', 'mdl-cell mdl-cell--2-col', 'mdl-cell mdl-cell--3-col', 'mdl-cell mdl-cell--4-col', 'mdl-cell mdl-cell--5-col', 'mdl-cell mdl-cell--6-col', 'mdl-cell mdl-cell--7-col', 'mdl-cell mdl-cell--8-col', 'mdl-cell mdl-cell--9-col', 'mdl-cell mdl-cell--10-col', 'mdl-cell mdl-cell--11-col', 'mdl-cell mdl-cell--12-col'];
      this.opts.colequal = [];
      this.opts.colsizes = [];
    } else if (this.opts.framework === 'uikit') {
      this.opts.row = '';
      this.opts.cols = [];
      this.opts.colequal = [];
      this.opts.colsizes = [];
      this.opts.cellFormat = '<div class="uk-width-1-1"></div>';
      this.opts.rowFormat = '<div class="uk-grid"></div>';
    } else {
      // If framework param is not used
      if (this.opts.row !== '' && this.opts.cols.length > 0) ; else {
        if (this.opts.cellFormat === '' && this.opts.rowFormat === '') {
          this.useDefaultGrid = true; // used in columntool.js, grid.js & util.js

          // DEFAULT: Built-in simple css grid
          this.opts.row = 'row'; //row clrfx
          this.opts.cols = ['column twelfth', 'column eleventh', 'column tenth', 'column ninth', 'column eighth', 'column seventh', 'column sixth', 'column fifth', 'column fourth', 'column third', 'column half', 'column two-third', 'column two-fourth', 'column two-fifth', 'column two-sixth', 'column'];
          this.opts.colequal = [['column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth', 'column twelfth'], ['column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh', 'column eleventh'], ['column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth', 'column tenth'], ['column ninth', 'column ninth', 'column ninth', 'column ninth', 'column ninth', 'column ninth', 'column ninth', 'column ninth', 'column ninth'], ['column eighth', 'column eighth', 'column eighth', 'column eighth', 'column eighth', 'column eighth', 'column eighth', 'column eighth'], ['column seventh', 'column seventh', 'column seventh', 'column seventh', 'column seventh', 'column seventh', 'column seventh'], ['column sixth', 'column sixth', 'column sixth', 'column sixth', 'column sixth', 'column sixth'], ['column fifth', 'column fifth', 'column fifth', 'column fifth', 'column fifth'], ['column fourth', 'column fourth', 'column fourth', 'column fourth'], ['column third', 'column third', 'column third'], ['column half', 'column half']];
          this.opts.colsizes = [
          //needed for columns in which the size increment is not constant.
          [
          //increment for 3 columns
          ['column third', 'column third', 'column third'], ['column half', 'column fourth', 'column fourth']], [
          //increment for 2 columns
          ['column sixth', 'column two-sixth'], ['column fifth', 'column two-fifth'], ['column fourth', 'column two-fourth'], ['column third', 'column two-third'], ['column half', 'column half'], ['column two-third', 'column third'], ['column two-fourth', 'column fourth'], ['column two-fifth', 'column fifth'], ['column two-sixth', 'column sixth']]];
        }
      }
    }
    this.sortableObjects = [];

    // Experimental for iframe
    let win, doc;
    if (this.iframe) {
      win = this.iframe.contentWindow;
      let iframeDocument = this.iframe.contentDocument || this.iframe.contentWindow.document;
      doc = iframeDocument;
      this.iframeDocument = iframeDocument;
    } else {
      win = window;
      doc = document;
    }
    this.win = win;
    this.doc = doc;
    this.doc.body.classList.add('data-editor');
    if (this.canvas && !this.isContentBox && this.docContainer && !this.iframe) {
      const docContainer = document.querySelector(this.docContainer);
      docContainer.classList.add('is-page');
    }

    // Disable on mobile
    const viewportWidth = this.doc.body.clientWidth;
    if (viewportWidth <= 768) {
      this.hideImageResizer = true;
    }
    const dom = new Dom(this);
    this.dom = dom;
    const util = new Util(this); // General utilities
    this.util = util;
    if (!this.pageTemplate) {
      this.pageTemplate = util.getPageTemplate(this.framework);
    }
    const responsive = new Responsive(this); // General utilities
    this.responsive = responsive;

    // Content stuff
    if (this.iframe) {
      let contentStuff = doc.querySelector('.content-stuff');
      if (!contentStuff) {
        contentStuff = document.createElement('div');
        contentStuff.className = 'content-stuff is-ui';
        contentStuff.id = '_cbhtml';
        doc.body.appendChild(contentStuff);
      }
      this.contentStuff = contentStuff;
      this.stuff = new ContentStuff(this);
    }
    this.isTouchSupport = util.isTouchSupport();
    this.isIE = util.detectIE();
    if (this.opts.clearPreferences) {
      util.clearPreferences();
    }
    this.uoTm = null;
    this.uo = new UndoRedo(this);
    this.cbDom = dom;
    this.autoclean = false;
    this.filesAdded = '';
    if (this.opts.emailMode) {
      this.applyStyle('emailmode', '.is-builder > div {display: block}');
    }
    let builderStuff = document.querySelector('#_cbhtml'); // All editing controls will be placed within <div id="_cbhtml">...</div>
    if (!builderStuff) {
      builderStuff = this.dom.createElement('div');
      builderStuff.id = '_cbhtml';
      builderStuff.className = 'is-ui';
      this.dom.appendChild(document.body, builderStuff);
    }
    this.builderStuff = builderStuff;
    this.htmlutil = new HtmlUtil(this);
    this.initStyle();
    prepareSvgIcons(this); // Prepare icons (embed svg definitions for icons) 

    if (!this.controlPanel) this.preferences = new Preferences(this); // this will also call setUIColor() and getUIStyles() for theme
    else {
      if (localStorage.getItem('_theme') != null) {
        const n = localStorage.getItem('_theme');
        this.themeIndex = n;
        if (this.themes) {
          if (this.themes.length > 0) {
            const item = this.themes[n];
            if (item) {
              this.setUIColor(item[1], item[2]);
              this.renderIframeLater = true;
            }
          }
        }
      } else {
        this.setUIColor('', '');
        this.renderIframeLater = true;
      }
      if (!this.renderIframeLater) {
        // means setUIColor() not called, so we need to call getUIStyles() manually
        util.getUIStyles();
      }
    }
    renderGridEditor(this); // Render Grid Editor

    // Get all builder areas
    this.preview = false;
    const builders = this.doc.querySelectorAll(this.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      builder.classList.add('is-container');

      // Check if preview
      if (this.dom.hasClass(builder, 'preview')) this.preview = true;
    });
    if (!this.preview) {
      if (this.opts.snippetJSON) if (this.opts.snippetJSON.snippets.length > 0) {
        renderSnippetPanel(this); // Render Snippet Panel
      }
    }

    this.colTool = new ColumnTool(this); // Render Column Tool

    this._rowTool = new RowTool(this);
    this.livePreview = new LivePreview(this);
    this.mediaPicker = new MediaPicker(this);

    // Extend the onChange function
    var oldget = this.opts.onChange;
    this.opts.onChange = () => {
      var ret = oldget.apply(this, arguments);
      if (this.activeCol) {
        // Quick reposition column tool
        this.util.repositionColumnTool();
      }
      this.elmTool.repositionElementTool(true);

      // if(this.element.image.imageTool) this.element.image.imageTool.style.display='';
      // if(this.element.module.moduleTool) this.element.module.moduleTool.style.display='';
      // if(this.element.hyperlink.linkTool) this.element.hyperlink.linkTool.style.display='';
      // this.colTool.lockIndicator.style.display='';

      // this.hideTools();
      setTimeout(() => {
        this.hideTools();
      }, 40); // give delay, in case of programmatically click after col move

      return ret;
    };

    // freeform
    let oldOnBlockCanvasAdd = this.opts.onBlockCanvasAdd;
    this.opts.onBlockCanvasAdd = () => {
      let ret = oldOnBlockCanvasAdd.apply(this, arguments);
      if (this.eb) this.eb.refresh();
      return ret;
    };
    let oldOnUndo = this.opts.onUndo;
    this.opts.onUndo = () => {
      let ret = oldOnUndo.apply(this, arguments);
      if (this.eb) {
        this.eb.refresh();
        this.rte.hideBlockButtons();
        this.rte.positionToolbar();
      }
      return ret;
    };
    let oldOnRedo = this.opts.onRedo;
    this.opts.onRedo = () => {
      let ret = oldOnRedo.apply(this, arguments);
      if (this.eb) {
        this.eb.refresh();
        this.rte.hideBlockButtons();
        this.rte.positionToolbar();
      }
      return ret;
    };
    let htmlCommons = `
            <div class="is-modal fileselect" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="width:${this.fileSelectWidth};max-width:${this.fileSelectMaxWidth};height:${this.fileSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal otherselect" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="width:${this.otherSelectWidth};max-width:${this.otherSelectMaxWidth};height:${this.otherSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal videoselect" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="width:${this.videoSelectWidth};max-width:${this.videoSelectMaxWidth};height:${this.videoSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal imageselect" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="width:${this.imageSelectWidth};max-width:${this.imageSelectMaxWidth};height:${this.imageSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal mediaselect" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="width:${this.mediaSelectWidth};max-width:${this.mediaSelectMaxWidth};height:${this.mediaSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal audioselect" style="z-index:10005" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div style="width:${this.audioSelectWidth};max-width:${this.audioSelectMaxWidth};height:${this.audioSelectHeight};padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
            <div class="is-modal snippets" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
                <div class="is-modal-content" style="max-width:1500px;width:80vw;height:80vh;padding:0;">
                    <iframe tabindex="0" style="width:100%;height:100%;border: none;display: block;" src="about:blank"></iframe>
                </div>
            </div>
        `;
    dom.appendHtml(builderStuff, htmlCommons);
    this.elmTool = new ElementTool(this); // Render Element Tool

    // Render controls or behavior for handling element editing
    this.element = new Element$1(this);
    this.rte = new Rte(this);
    this.tooltip = new Tooltip(this);
    this.lightbox = new Lightbox(this);
    if (!this.preview) this.applyBehavior(); // Apply editing behavior on content (builder areas)

    // Load plugins
    if (!this.preview) {
      if (this.opts.plugins.length > 0) {
        // Option to load plugins without config.js => just use plugins param (and specify the pluginPath).

        this.loadPlugins();
      } else {
        if (typeof this.opts.scriptPath === 'undefined' && this.opts.pluginPath === '') ; else {
          // Backward compatibility

          if (!this.opts.disableConfig) {
            let scriptUrl = this.opts.scriptPath + 'config.js';
            if (this.opts.pluginPath !== '') scriptUrl = this.opts.pluginPath + 'config.js'; // overide plugin location if pluginPath is specified
            this.loadScript(scriptUrl).then(() => {
              if (this.opts.plugins.length > 0) {
                this.loadPlugins();
              }
            }, () => {
              console.log('Fail to load config');
            });
          }
        }
      }
    }

    // Tooltip (move to after plugins loaded)
    // new Tooltip();

    // Run Tabs
    this.tabs = new Tabs();

    // Color Picker
    this.colorPicker = new ColorPicker({
      lang: this.opts.lang,
      colors: this.opts.colors
    });

    // Shortcut Info
    this.ShortcutInfo = new ShortcutInfo(this);

    // Prompt Stuff
    if (!this.opts.isContentBox) {
      if (localStorage.getItem('_dictation') !== null) {
        localStorage.removeItem('_dictation');
      }
    }
    this.dictation = new Dictation({}, this); // Dictation Panel 
    this.lib = new Lib(this); // Libraries of common editing functions
    this.similarity = new Similarity(this);
    if (!this.opts.isContentBox) {
      this.command = new Command(this);
      if (this.startAIAssistant) {
        this.openAIAssistant();
      }
    }

    // freeform
    if (this.canvas && !this.isContentBox) this.blockmodal = new BlockModal(this);
    if (this.canvas) this.pageoption = new PageSize(this);

    // freeform
    if (this.canvas) this.eb = new EditableBlocks({
      doc: this.doc,
      win: this.win,
      selector: '.is-block',
      controlSelector: '.is-tool,.is-pop,.is-modal,#divImageResizer,.is-rte-tool,.is-elementrte-tool,.is-rte-pop,.is-side,.keep-selection',
      parentSelector: '.box-canvas',
      rotate: true,
      // disableOnMobile: 760,
      zoom: this.opts.zoom,
      onBeforeChange: () => {
        this.uo.saveForUndo();
      },
      onChange: () => {
        this.opts.onChange();
      },
      onEditStart: (event, block) => {
        let activeBlock = this.doc.querySelector('.is-block.cloned');
        if (!activeBlock) activeBlock = this.doc.querySelector('.is-block.active');
        if (!activeBlock) return;
        const container = activeBlock.querySelector('.is-container');
        if (!container) return;
        block.classList.add('editable');

        // get element to activate
        let x = event.clientX;
        let y = event.clientY;
        const cols = this.getAllColumns(container);
        let clickedElm;
        let clickedCol;
        cols.forEach(col => {
          let elms = col.children;
          for (let i = 0; i < elms.length; i++) {
            let rect = elms[i].getBoundingClientRect();
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
              clickedElm = elms[i];
            }
          }
          let rect = col.getBoundingClientRect();
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
            clickedCol = col;
          }
        });
        if (clickedElm) {
          const tagName = clickedElm.tagName.toLowerCase();
          if (tagName !== 'img') this.eb.placeCursorAtEnd(clickedElm);
          setTimeout(() => {
            clickedElm.click();
          }, 1); // give time for the placeCursorAtEnd
        } else if (clickedCol) {
          clickedCol.click();
        }
      },
      onEditEnd: block => {
        block.classList.remove('editable');
        this.util.clearActiveCell();
        this.util.clearPops();
        this.hideElementTools();
      },
      onDuplicate: block => {
        const builder = block.querySelector(this.container);
        let html = '';
        if (builder) {
          html = this.readHtml(builder);
        }
        let clonedDiv = block.cloneNode(true);
        clonedDiv.style.top = '20%';
        clonedDiv.style.left = '20%';
        if (builder) {
          const cloneBuilder = clonedDiv.querySelector(this.container);
          cloneBuilder.innerHTML = '';
          block.parentNode.appendChild(clonedDiv);
          const range = document.createRange();
          cloneBuilder.appendChild(range.createContextualFragment(html));
          this.applyBehaviorOn(cloneBuilder);
          cloneBuilder.click();
        } else {
          block.parentNode.appendChild(clonedDiv);
        }
        block.classList.remove('active');
        this.doc.querySelectorAll('.clone').forEach(elm => elm.parentNode.removeChild(elm));
        this.doc.querySelectorAll('.cloned').forEach(elm => elm.classList.remove('cloned'));
      },
      onAddBlock: block => {
        const builder = block.querySelector(this.container);
        if (builder) this.applyBehaviorOn(builder);
      },
      onMultipleSelect: () => {
        if (this.onMultipleSelect) this.onMultipleSelect();
        if (!this.controlPanel) {
          setTimeout(() => {
            this.rte.rteTool.style.display = 'none';
            this.rte.elementRteTool.style.display = 'flex';
            this.rte.hideAlignButtons();
            this.rte.hideBlockButtons();

            // group/ungroup
            let elms = this.rte.elementRteTool.querySelectorAll('.rte-group');
            Array.prototype.forEach.call(elms, elm => {
              elm.style.display = '';
            });
            elms = this.rte.elementRteTool.querySelectorAll('.rte-delete');
            Array.prototype.forEach.call(elms, elm => {
              elm.style.display = '';
            });
            this.rte.positionToolbar();
          }, 10);
        }
      },
      onDelete: () => {
        if (this.onDelete) this.onDelete();
        if (!this.controlPanel) {
          this.rte.hideBlockButtons();
          this.rte.positionToolbar();
        }
        if (this.blockmodal) {
          setTimeout(() => {
            this.blockmodal.showHideControls();
          }, 30);
        }
      },
      onSelectBlock: block => {
        if (this.onSelectBlock) this.onSelectBlock(block);
        if (block.classList.contains('editable')) return;
        if (this.controlPanel) return;
        this.rte.rteTool.style.display = 'none';
        this.rte.elementRteTool.style.display = 'flex';
        this.rte.hideAlignButtons();
        let elms = this.rte.elementRteTool.querySelectorAll('.rte-duplicate');
        Array.prototype.forEach.call(elms, elm => {
          elm.style.display = '';
        });
        elms = this.rte.elementRteTool.querySelectorAll('.rte-moveup');
        Array.prototype.forEach.call(elms, elm => {
          elm.style.display = '';
        });
        elms = this.rte.elementRteTool.querySelectorAll('.rte-movedown');
        Array.prototype.forEach.call(elms, elm => {
          elm.style.display = '';
        });
        elms = this.rte.elementRteTool.querySelectorAll('.rte-delete');
        Array.prototype.forEach.call(elms, elm => {
          elm.style.display = '';
        });
        // elms = this.rte.elementRteTool.querySelectorAll('.rte-blocksettings'); 
        // Array.prototype.forEach.call(elms, (elm) => {
        //     elm.style.display = '';
        // });

        const viewportWidth = this.doc.body.clientWidth;
        if (viewportWidth <= 768) {
          elms = this.rte.elementRteTool.querySelectorAll('.rte-moveup');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = '';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-movedown');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = '';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-front');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = 'none';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-backward');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = 'none';
          });
        } else {
          elms = this.rte.elementRteTool.querySelectorAll('.rte-moveup');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = 'none';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-movedown');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = 'none';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-front');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = '';
          });
          elms = this.rte.elementRteTool.querySelectorAll('.rte-backward');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = '';
          });
        }

        // group/ungroup
        elms = this.rte.elementRteTool.querySelectorAll('.rte-group');
        Array.prototype.forEach.call(elms, elm => {
          elm.style.display = 'none';
        });
        if (block.classList.contains('is-group')) {
          elms = this.rte.elementRteTool.querySelectorAll('.rte-ungroup');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = '';
          });
        } else {
          elms = this.rte.elementRteTool.querySelectorAll('.rte-ungroup');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.display = 'none';
          });
        }
        this.rte.positionToolbar();
      },
      onUnselectBlock: () => {
        if (this.onUnselectBlock) this.onUnselectBlock();
      }
    });

    // Canvas Mode
    const copyBlock = e => {
      const docContainer = this.doc.querySelector(this.docContainer);
      if ((e.ctrlKey || e.metaKey) && e.which === 67) {
        //CTRL-C
        const activeBlock = docContainer.querySelector('.is-block.active'); // always get .cloned
        if (activeBlock) {
          const focusedElement = e.target;
          const isEditable = focusedElement.tagName === 'INPUT' || focusedElement.tagName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable');
          if (isEditable) return;
          this.copyBlock = activeBlock;
        }
      }
    };
    const pasteBlock = e => {
      const docContainer = this.doc.querySelector(this.docContainer);
      if ((e.ctrlKey || e.metaKey) && e.which === 86) {
        //CTRL-V

        const box = docContainer.querySelector('.is-box.box-select'); // always get .cloned
        let block = this.copyBlock;
        if (box && block) {
          if (document.querySelector('.is-modal.active:not(.is-modal-content)')) return;
          const focusedElement = e.target;
          const isEditable = focusedElement.tagName === 'INPUT' || focusedElement.tagName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable');
          if (isEditable) return;
          this.uo.saveForUndo();
          let block = this.copyBlock;
          const builder = block.querySelector(this.container);
          let html = '';
          if (builder) {
            html = this.readHtml(builder);
          }
          let clonedDiv = block.cloneNode(true);
          clonedDiv.style.top = '20%';
          clonedDiv.style.left = '20%';
          clonedDiv.style.transform = ''; // clear anim
          clonedDiv.style.transition = '';
          clonedDiv.style.opacity = '';
          if (builder) {
            const cloneBuilder = clonedDiv.querySelector(this.container);
            cloneBuilder.innerHTML = '';
            box.appendChild(clonedDiv);
            const range = document.createRange();
            cloneBuilder.appendChild(range.createContextualFragment(html));
            this.applyBehaviorOn(cloneBuilder);
            cloneBuilder.click();
          } else {
            box.appendChild(clonedDiv);
          }
          block.classList.remove('active');
          this.doc.querySelectorAll('.clone').forEach(elm => elm.parentNode.removeChild(elm));
          this.doc.querySelectorAll('.cloned').forEach(elm => elm.classList.remove('cloned'));
          this.eb.refresh();
          this.opts.onChange();
        }
      }
    };

    // SHIFT + Right Clidk to Zoom In
    if (this.canvas && !this.isContentBox && this.docContainer && !this.iframe) {
      //--- see loadHtml ---
      const docContainer = document.querySelector(this.docContainer);

      // set page size 
      let s;
      const elm = docContainer.querySelector('[data-pagesize]');
      if (elm) {
        s = elm.getAttribute('data-pagesize');
      } else {
        if (localStorage.getItem('_pagesize') === '' || localStorage.getItem('_pagesize')) {
          s = localStorage.getItem('_pagesize');
        } else {
          s = this.pageSize || '';
        }
      }
      this.setPageSize(s);
      this.applyBehaviorCanvas();
      const builders = docContainer.querySelectorAll(this.container);
      builders.forEach(builder => {
        this.applyBehaviorOn(builder);
      });
      this.refresh();
      if (this.win.Block) {
        this.win.Block.render();
      }
      docContainer.style.opacity = '';
      //--- /see loadHtml ---

      // docContainer.style.transform = '';
      // this.opts.zoom = 1;
      // this.eb.setZoom(1);

      document.addEventListener('contextmenu', this.toggleEnlargePage = e => {
        if (e.shiftKey && e.button === 2) {
          e.preventDefault();
          if (docContainer.style.transform.includes('scale(1)')) {
            docContainer.style.transform = '';
          }
          if (docContainer.classList.contains('expand')) {
            // back (zoom-out)
            docContainer.classList.remove('expand');
            docContainer.style.transform = '';
            this.opts.zoom = 1;
            localStorage.setItem('_zoom', 1);
            this.eb.setZoom(1);
            this.setZoomOnControl(docContainer);
          } else {
            // expand (zoom-in)
            docContainer.classList.add('expand');
            const viewportWidth = document.body.clientWidth;
            const targetWidth = viewportWidth * 0.8;
            const box = docContainer.querySelector(this.blockContainer);
            if (box) {
              let scale = targetWidth / box.offsetWidth;
              if (scale > 1.4) scale = 1.4;
              docContainer.style.transform = `scale(${scale})`;
              this.opts.zoom = scale;
              localStorage.setItem('_zoom', scale);
              this.eb.setZoom(scale);
              this.setZoomOnControl(docContainer);
            }
          }
        }
      });

      // Copy & Paste Block
      document.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.which === 67) {
          //CTRL-C
          copyBlock(e);
        }
      });
      document.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.which === 86) {
          //CTRL-V
          pasteBlock(e);
        }
      });
    }
    if (this.canvas && this.isContentBox) {
      // Copy & Paste Block
      document.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.which === 67) {
          copyBlock(e);
        }
      });
      document.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.which === 86) {
          pasteBlock(e);
        }
      });
      if (this.iframe) {
        this.doc.addEventListener('keydown', e => {
          if ((e.ctrlKey || e.metaKey) && e.which === 67) {
            copyBlock(e);
          }
        });
        this.doc.addEventListener('keydown', e => {
          if ((e.ctrlKey || e.metaKey) && e.which === 86) {
            pasteBlock(e);
          }
        });
      }
    }
    let previousWidth = this.win.innerWidth;
    let timer;
    const debounce = (func, delay) => {
      return () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          func.apply(this, arguments);
        }, delay);
      };
    };
    if (this.iframe) {
      // this.win.addEventListener('scroll', this.doWindowScroll = ()=>{
      //     this.util.hidePops();
      // });

      let previousScroll = this.win.pageYOffset;
      this.win.addEventListener('scroll', this.doWindowScroll = () => {
        // this.util.hidePops();
        const threshold = 5; // Hide pops if page is scrolled more than 5px
        const debouncedResizeHandler = debounce(() => {
          if (Math.abs(previousScroll - this.win.pageYOffset) > threshold) {
            this.util.hidePops();
            // let clearPops = true;
            // let screenMode = this.screenMode;
            // if(screenMode==='fullview') {
            //     if(window.innerWidth<1366) {
            //         clearPops=false;
            //     }
            // }
            // if(clearPops) {
            //     this.util.hidePops();
            // }
          }

          previousScroll = this.win.pageYOffset;
        }, 10);
        debouncedResizeHandler();
      });
      this.win.addEventListener('resize', this.doWindowResize = () => {
        const threshold = 100;
        const debouncedResizeHandler = debounce(() => {
          if (Math.abs(previousWidth - this.win.innerWidth) > threshold) {
            // console.log('clear');
            this.util.clearPops();
            // let clearPops = true;
            // let screenMode = this.screenMode;
            // if(screenMode==='fullview') {
            //     if(window.innerWidth<1366) {
            //         clearPops=false;
            //     }
            // }
            // if(clearPops) {
            //     this.util.clearPops();
            // }
          }

          previousWidth = this.win.innerWidth;

          // Disable on mobile
          const viewportWidth = this.doc.body.clientWidth;
          if (viewportWidth <= 768) {
            this.hideImageResizer = true;
          }

          // console.log('resize');
          setTimeout(() => {
            // if(this.blockmodal) this.blockmodal.realtime(); // freeform
            if (this.onPageResizeDebounce) this.onPageResizeDebounce();
          }, 300); // give time for block transition
        }, 200);
        debouncedResizeHandler();
        if (this.canvas) {
          this.eb.addBreakpoint(); // freeform
          if (this.onPageResize) this.onPageResize();
        }
      });
    } else {
      if (this.canvas) this.win.addEventListener('resize', this.doWindowResize = () => {
        // freeform

        const debouncedResizeHandler = debounce(() => {
          // console.log('resize');
          setTimeout(() => {
            // if(this.blockmodal) this.blockmodal.realtime();
            if (this.onPageResizeDebounce) this.onPageResizeDebounce();
          }, 300); // give time for block transition
        }, 200);
        debouncedResizeHandler();
        this.eb.addBreakpoint();
        if (this.onPageResize) this.onPageResize();
      });
    }
    if (this.canvas) this.eb.addBreakpoint(); // freeform

    const rteClick = e => {
      let target = e.target;
      if (!target) return;
      let inputFocused = document.activeElement.tagName.toLowerCase() === 'input';
      if (!inputFocused && (this.rte.rteMoreOptions.style.display === 'flex' || this.rte.elementRteMoreOptions.style.display === 'flex')) {
        if (this.rte.rteMoreOptions.style.display === 'flex') {
          let rte = target.closest('.rte-more, .rte-more-options, .is-rte-pop, .is-modal');
          if (!rte) {
            this.rte.rteMoreOptions.style.display = '';
            dom.removeClass(this.rte.rteMoreOptions, 'active');
            dom.addClass(this.rte.rteMoreOptions, 'deactive');
          }
        }
        if (this.rte.elementRteMoreOptions.style.display === 'flex') {
          let rte = target.closest('.rte-more, .elementrte-more-options, .is-rte-pop, .is-modal');
          if (!rte) {
            this.rte.elementRteMoreOptions.style.display = '';
            dom.removeClass(this.rte.elementRteMoreOptions, 'active');
            dom.addClass(this.rte.elementRteMoreOptions, 'deactive');
          }
        }
      }
    };

    // Add document Click event
    document.addEventListener('click', this.doDocumentClick = e => {
      let target = e.target;
      if (!target) return;
      rteClick(e);
      let rowClicked;
      if (target.parentNode && target.parentNode.classList) rowClicked = target.parentNode.classList.contains('is-builder');
      let containerClicked = target.classList.contains('is-builder');
      let a = target.closest('.is-builder') || target.closest('.is-block'); // freeform
      let p = target.closest('.is-subblock');
      let b = target.closest('.is-modal') || target.closest('.keep-selection');
      let c = target.closest('.is-side') || target.closest('.is-sidebar');
      let d = target.closest('.is-pop');
      let f = target.closest('.is-tool');
      let g = target.closest('.is-rte-tool') || target.closest('.is-elementrte-tool');
      let h = target.closest('.is-rte-pop');
      let i = target.closest('.row-add-initial');
      let j = target.closest('.sl-wrapper') || target.closest('.sl-overlay') || target.closest('.sl-close');
      let k = target.closest('.is-selectbox') || target.closest('.is-selectbox-options');
      let isSpecialElement = false;
      if (this.opts.specialElementClasses) {
        for (let i = 0; i < this.opts.specialElementClasses.length; i++) {
          isSpecialElement = target.closest('.' + this.opts.specialElementClasses[i]);
        }
      }
      let o;
      if (this.preserveSelection) o = true;

      // dropdown
      if (!k) {
        let dropdowns = document.querySelectorAll('.is-selectbox-options');
        Array.prototype.forEach.call(dropdowns, dropdown => {
          dropdown.style.display = 'none';
        });
      }
      const clrPicker = document.querySelector('.clr-picker.clr-open');
      // if(clrPicker) return;

      // Image Resizer
      let n = target.closest('#divImageResizer');
      if (n) return;

      /*
      let m = target.closest('#divImageTool');
      
      let resizeProcess = false;
      let imageResizer = document.querySelector('#divImageResizer');
      if(imageResizer) if(imageResizer.getAttribute('data-resized')==='1') resizeProcess = true;
      if(resizeProcess) return; // to prevent unwanted click/clearActiveCell during image resize end.
       if(!(b||j||m||n||target.tagName.toLowerCase() === 'img')) {
                  let imageTool = document.querySelector('#divImageTool');
          if(imageTool) imageTool.style.display = '';
          // this.activeImage =  null; // Commented => Additional (to prevent lost focus)
               let imageResizer = document.querySelector('#divImageResizer');
          imageResizer.style.display = 'none';
          
          // moveable
          imageResizer.style.top = '-10px';
          imageResizer.style.left = '-10px';
          imageResizer.style.width = '1px';
          imageResizer.style.height = '1px';
          if(this.moveable) {
              this.moveable.updateRect();
              document.querySelector('.moveable-control-box').style.display = 'none'; 
          }
      }
      */

      if (!(a || p || b || c || d || f || g || h || i || j || o || isSpecialElement || clrPicker) || rowClicked && !i || containerClicked) {
        // Click anywhere but is not inside builder area, modal, popup, tool or rte, then clear row/column (cell) selection

        if (!this.dom.getSelected()) {
          let inputFocused = document.activeElement.tagName.toLowerCase() === 'input';

          // if(!document.querySelector('.is-modal.active')) { // Additional (to prevent lost focus)
          let openedModal = document.querySelector('.is-modal.active:not(.is-modal-content)');
          if (!openedModal && !inputFocused) {
            // Additional (to prevent lost focus)

            util.clearActiveCell();
            util.clearControls();
            if (!target.closest('.is-block')) this.rte.hideBlockButtons(); // freeform

            if (!this.controlPanel) if (this.toolbarDisplay !== 'auto') {
              this.rte.showDefaultToolbar();
            }
            if (this.settings.onSelectionChange) this.settings.onSelectionChange(e);
            this.activeIcon = null;
            this.activeSvg = null;
            this.inspectedElement = null;
            this.activeElement = null;
            this.activeImage = null;
            this.activeAudio = null;
            this.activeButton = null;
            this.activeLink = null;
            this.activeCodeBlock = null;
            this.activeIframe = null;
            this.activeModule = null;
            this.activeSpacer = null;
            this.activeTable = null;
            this.activeTd = null;
            this.activeVideo = null;

            // if(this.settings.onPageContentClick) this.settings.onPageContentClick(e);
          }
        }

        /*
        this.element.hyperlink.buttonEditor.hide();
        */
      }

      /*
      // Button Modal
      if(!this.activeLinkButton && !this.activeButton && 
          !target.closest('.buttoneditor') && !target.closest('.link-button-edit') && 
          !target.closest('.is-modal')) {
           this.element.hyperlink.buttonEditor.hide();
      }
      */

      /*
      // Backward compatibility (for examples)
      if(!d && !this.dom.parentsHasId(target, '_cbhtml')) {
          const pops = document.querySelectorAll('.is-pop');
          Array.prototype.forEach.call(pops, (pop) => {
              if(!this.dom.parentsHasId(pop, '_cbhtml')) pop.style.display = '';
          });
      }
      */
    });

    if (this.iframe) {
      this.doc.addEventListener('click', this.doDocumentClick);
    }

    // Drag row will hide content tools
    this.doc.addEventListener('mousedown', this.doDocumentMousedown = e => {
      e = e || window.event;
      var target = e.target || e.srcElement;
      let a = this.dom.parentsHasClass(target, 'row-handle');
      if (a) {
        util.clearControls();
      }
    });

    // Undo Redo
    document.addEventListener('keydown', this.doDocumentKeydown = e => {
      if (e.which === 90 && (e.ctrlKey || e.metaKey)) {
        //CTRL-Z
        if (e.shiftKey) this.uo.doRedo();else {
          if (!e.altKey) {
            //if(!document.queryCommandEnabled('undo')){
            this.uo.doUndo();
            //}
          }
        }
      }

      if (e.which === 89 && e.ctrlKey) {
        //CTRL-Y
        if (!e.altKey) this.uo.doRedo();
      }
      const isCmd = e.ctrlKey || e.metaKey;
      if (isCmd && e.which === 191) {
        // CMD+/
        this.ShortcutInfo.open();
      }
      const isAPressed = e.key === 'a' || e.key === 'A';
      if (isCmd && isAPressed) {
        // CMD-A or CTRL-A
        if (this.canvas && this.docContainer) {
          if (document.activeElement.tagName.toLowerCase() === 'body' || this.doc.activeElement.tagName.toLowerCase() === 'body' || document.activeElement.classList.contains('is-design-list')) {
            const focusedElement = e.target;
            const isEditable = focusedElement.tagName === 'INPUT' || focusedElement.tagName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable');
            if (isEditable) return;
            const blocks = this.doc.querySelectorAll('.is-block');
            blocks.forEach(block => {
              block.classList.add('active');
              if (blocks.length > 1) {
                block.classList.add('multi');
              }
            });
            e.preventDefault();
            if (blocks.length > 0 && this.eb.onMultipleSelect) this.eb.onMultipleSelect();
          }
        }
      }
    });

    // this.uo.saveForUndo(); //First time

    if (this.iframe) {
      this.doc.addEventListener('keydown', this.doDocumentKeydown);
    }

    // https://stackoverflow.com/questions/4860936/how-to-remove-the-resizig-handlers-around-an-image-in-ie-with-javascript
    document.body.addEventListener('mscontrolselect', function (e) {
      e.preventDefault();
    });

    // Convenience variable for outside access, for example, from snippet dialog (assets/minimalist-blocks/snippets.html))
    window._cb = this;
    window.applyLargerImage = this.applyLargerImage.bind(this);
    window.returnUrl = this.returnUrl.bind(this); // same as applyLargerImage (NEW)
    window.selectFile = this.selectFile.bind(this);
    window.selectImage = this.selectImage.bind(this);
    window.selectVideo = this.selectVideo.bind(this);
    window.selectAsset = this.selectAsset.bind(this);
    window.assetType = this.assetType.bind(this);
    window.hideModal = this.hideModal.bind(this);
    window.generateImage = this.generateImage.bind(this);
    setTimeout(() => {
      // Remember UI
      if (localStorage.getItem('_livepreview') != null) {
        this.openPreview();
      } else {
        if (this.opts.livePreviewOpen) {
          this.openPreview();
        }
      }
    }, 300);

    // info
    let largeScreenBreakpoint = 1280; //1920
    largeScreenBreakpoint = window.innerWidth - 360; //351
    if (largeScreenBreakpoint < 1280) largeScreenBreakpoint = 1280;
    if (this.consoleLog) {
      console.log('vw: ' + window.innerWidth);
      console.log('lg: ' + largeScreenBreakpoint);
    }
  } // constructor

  // Convenience constructor, so that the plugin can be called directly using: ContentBuilder.run({ ... });
  static run(opts = {}) {
    return new ContentBuilder(opts);
  }
  initStyle() {
    // Add special css (remove on destroy)
    // This is also for backward compatible if using npm but still using old local assets/css
    this.dom.appendHtml(this.doc.head, `<style id="_contentbuilder_css">

        /* box-canvas */
        :root {
            --is-outline: 1px solid rgb(96 108 255 / 65%);
            --is-handle: 1px solid  rgb(121 131 255);
        
            --is-outline2: 1px solid  rgba(255, 1, 107, 0.65);
            --is-handle2: 1px solid rgb(253 83 154); 
        }
        
        .editableblocks .is-block {
            cursor: pointer;
            user-select: none;
            touch-action: none;
            outline: none;
        }
        .editableblocks .is-block:not(.is-group):not(.editable):after {
            position: absolute;
            content: "";
            display: block;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            z-index: 1;
        }
        .is-block.active {
            outline: var(--is-outline);
        }
        .is-block.active.editable {
            outline: none;
            cursor: auto;
            z-index: 10;
        }
        .is-block.active.multi {
            outline: var(--is-outline);
        }
        .is-block.is-shape.active.multi {
            outline: var(--is-outline2);
        }
        .is-block.is-shape.active:not(.multi) {
            outline: none;
        }
        .is-block.is-shape {
            transform-origin: 0 0 !important;
            -webkit-transform-origin: 0 0;
            -moz-transform-origin: 0 0;
            -o-transform-origin: 0 0;
        }
        .block-active {
            background-color: #f5f6f7c7;
        }
        
        /* Ruler */
        .ruler {
            position: absolute;
            background-color:  rgba(157, 155, 255, 0.4);
            z-index: 1;
        }
        .horizontal-ruler {
            width: 100%;
            height: 2px;
            top: -1000px;
            left: 0;
        }
        .vertical-ruler {
            width: 2px;
            height: 100%;
            top: 0;
            left: -1000px;
        }
        .h-ruler {
            top:0;
            left:-100vw;
            width: 300vw;
            height:2px;
            display:none;
        }
        .h-ruler.active { display: block }
        .v-ruler {
            top:0;
            left:0;
            width:2px;
            height: 100%;
            display:none;
        }
        .v-ruler.active { display: block }
        
        /* Resize Handles */
        .handle {
            width: 8px;
            height: 8px;
            position: absolute;
            cursor: pointer;
            display: none;
        
            background-color: #fff;
            outline: var(--is-handle);
        }
        .is-block.active > .handle {
            display: block;
            z-index: 2;
        }
        .is-block.active.editable > .handle {
            display: none;
        }
        .is-block.active.multi .handle {
            display: none;
        }
        .top-left,
        .top-right,
        .bottom-left,
        .bottom-right,
        .top, .bottom, .left, .right {
            z-index: 1;
        }
        .top-left {
            top: -4px;
            left: -4px;
            cursor: nwse-resize;
        }
        .top-right {
            top: -4px;
            right: -4px;
            cursor: nesw-resize;
        }
        .bottom-left {
            bottom: -4px;
            left: -4px;
            cursor: nesw-resize;
        }
        .bottom-right {
            bottom: -4px;
            right: -4px;
            cursor: nwse-resize;
        }
        .top {
            top: -4px;
            left: calc(50% - 4px);
            cursor: ns-resize;
        }
        .bottom {
            bottom: -4px;
            left: calc(50% - 4px);
            cursor: ns-resize;
        }
        .left {
            top: calc(50% - 4px);
            left: -4px;
            cursor: ew-resize;
        }
        .right {
            top: calc(50% - 4px);
            right: -4px;
            cursor: ew-resize;
        }
        
        /* Rotate handle */
        .rotate-handle {
            width: 8px;
            height: 8px;
            position: absolute;
            top: calc(50% - 4px);
            right: -33px;
            cursor: ew-resize;
            display: none;
            cursor: grab;
            z-index: 2;
        
            background-color: #fff;
            outline: var(--is-handle);
        }
        .rotate-handle div {
            width: 25px;
            height: 1px;
            border-top: var(--is-outline);
            right: 8px;
            top: calc(50% - 0px);
            position: absolute;
            pointer-events: none;
        }
        .is-block.active > .rotate-handle {
            display: block;
        }
        .is-block.active.editable .rotate-handle  {
            display: none;
        }
        .is-block.is-group.active > .rotate-handle {
            display: none;
        }
        .is-block.active.multi .rotate-handle {
            display: none;
        }
        
        /* Shape handles */
        .shape-handle {
            width: 8px;
            height: 8px;
            position: absolute;
            display: none;
            transform: none;
            z-index: 1;
            /*backface-visibility: hidden;  Improve rendering during transformation */
        
            background-color: #fff;
            outline: var(--is-handle2);
        }
        .shape-handle.top-left {
            transform: translate(-4px, -4px);
        }
        .shape-handle.top-right {
            transform: translate(-4px, -4px);
        }
        .shape-handle.bottom-left {
            transform: translate(-4px, -4px);
        }
        .shape-handle.bottom-right {
            transform: translate(-4px, -4px);
        }
        .shape-handle.rotate {
            transform: translate(-4px, -4px);
            cursor: grab;
        }
        .shape-line {
            width: 0px;
            height: 1px;
            position: absolute;
            transform-origin: 0 0;
            border-top: var(--is-outline2);
            display: none;
            z-index: 1;
            pointer-events: none;
            backface-visibility: hidden; /* Improve rendering during transformation */
        }
        
        .is-shape > .rotate-handle,
        .is-shape > .handle,
        .is-shape > .handle.left, .is-shape  >.handle.top, .is-shape > .handle.right, .is-shape > .handle.bottom {
            display: none !important;
        }
        
        .is-block.clone {
            z-index:1000;
            background-color: transparent !important;
            background: none !important;
        }
        .is-block.clone .is-container,
        .is-block.clone .is-block-overlay {
            opacity:0;
        }
        .is-block.cloned {
            outline:none;
        }
        .is-block.cloned .handle, 
        .is-block.cloned .rotate-handle {
            display:none;
        }
        
        @media (max-width: 760px) {
            .is-box.autolayout .is-block > .rotate-handle,
            .is-box.autolayout .is-block > .handle {
                display: none;
            }
        
            /* NEW */
            .is-box.autolayout .is-block.clone {
                display:none;
            }
            .is-box.autolayout .is-block.cloned {
                outline: var(--is-outline);
            }
            .is-box.box-select {
                outline: none !important;
            }
        }
        
        .is-block.locked .handle,
        .is-block.locked .rotate-handle {
            display: none !important;
        }
          
          
        
        /* Canvas Mode */
        .box-canvas > .sortable-ghost {
            background: transparent;
            outline: rgba(140, 140, 140, 0.5) 4px dashed !important;
            outline-offset: -15px;
            height:100% !important;
            transition: none !important;
            z-index:100;
            position:absolute;
        }
        </div>
        `);
  }
  getAllColumns(container) {
    let arrCells = [];
    let rows = container.children;
    for (let i = 0; i < rows.length; i++) {
      let cols = rows[i].children;
      for (let j = 0; j < cols.length; j++) {
        let col = cols[j];
        if (col.classList.contains('is-row-tool') || col.classList.contains('is-col-tool') || col.classList.contains('is-rowadd-tool') || col.classList.contains('is-row-overlay')) ; else {
          arrCells.push(col);
        }
      }
    }
    return arrCells;
  }
  setZoom() {
    // Complete (On Area + On Control)

    if (this.opts.page !== '') {
      const wrapper = this.doc.querySelector(this.opts.page);
      wrapper.style.transform = `scale(${this.opts.zoom})`;
      this.setZoomOnControl(wrapper);
    } else {
      const builders = this.doc.querySelectorAll(this.opts.container);
      builders.forEach(builder => {
        let fade = false; // to prevent initial load animation
        if (!builder.style.transform) fade = true;
        if (fade) {
          builder.style.transition = 'none';
        }
        builder.style.transform = `scale(${this.opts.zoom})`;
        if (fade) {
          setTimeout(() => {
            builder.style.transition = '';
          }, 300);
        }
        this.setZoomOnControl(builder);
      });
    }

    /*
    if(this.opts.zoom<1) {
        let ss = document.styleSheets;
        for (let i=0; i<ss.length; i++) {
            let ss = document.styleSheets;
            let rules = ss[i].cssRules || ss[i].rules;
            for (let j=0; j<rules.length; j++) {
                if (rules[j].selectorText === '.sortable-drag') {
                    rules[j].style.background = `transparent`;
                }
            }
        }
    }
    */
  }

  /*
  If latest npm is used, while local contentbuilder.css is still using the old version,
  then add the newest css here, so the newest script from npm will  work fine.
  backwardCompatible() is called by rowtool.js
  */
  backwardCompatible() {
    let css = `
        .row-active .is-col-tool {
            display: flex;
        }
        .is-builder[rowoutline] .row-active .is-col-tool {
            display: none;
        }
        .is-builder[hidecolumntool] .row-active .is-col-tool {
            display: none;
        }

        .is-tool.is-col-tool {
            flex-direction: row;
            margin-top: 0px;
            margin-left: -1px;
        }
        .is-tool.is-col-tool button {
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .is-tool.is-col-tool .cell-add {
            background: #0fcc52;
        }
        .is-tool.is-col-tool .cell-more {
            background: rgba(216, 200, 6, 0.9);
        }
        .is-tool.is-col-tool .cell-remove {
            background: rgba(255, 85, 4, 0.9);
        }
        .is-tool.is-col-tool svg {
            width: 23px;
            height: 23px;
            fill: #fff  !important;
        }
        .is-tool.is-col-tool .cell-more svg {
            width: 14px;
            height: 14px;
        }


        .is-builder[gray] .is-tool.is-col-tool {
            background: rgba(243, 243, 243, 0.9);
            flex-direction: row;
            top:-3px;
            margin-top: 0px;
            margin-left: -1px;
        }
        .is-builder[gray] .is-tool.is-col-tool button {
            width: 27px;
            height: 27px;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-add {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-more {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-remove {
            background: transparent;
        }
        .is-builder[gray] .is-tool.is-col-tool svg {
            width: 18px;
            height: 18px;
            fill: #000 !important;
        }
        .is-builder[gray] .is-tool.is-col-tool .cell-more svg {
            width: 12px;
            height: 12px;
        }


        .is-col-tool svg {
            display: initial !important;
        }
        
        `;
    if (!this.builderStuff.querySelector('style[data-rel="css-new"]')) {
      this.builderStuff.insertAdjacentHTML('afterbegin', `
            <style data-rel="css-new">
                ${css}
            </style>
            `);
    }
  }
  setZoomOnControl(area) {
    const rowtools = area.querySelectorAll('.is-row-tool');
    rowtools.forEach(rowtool => {
      rowtool.style.transform = `scale(${1 / this.opts.zoom})`;
      rowtool.style.transformOrigin = 'top';
    });
    const coltools = area.querySelectorAll('.is-col-tool');
    coltools.forEach(coltool => {
      coltool.style.transform = `scale(${1 / this.opts.zoom})`;
      coltool.style.transformOrigin = 'top left';
      coltool.style.marginTop = `${-(27 / this.opts.zoom)}px`;
    });
    const rowaddtools = area.querySelectorAll('.is-rowadd-tool button');
    rowaddtools.forEach(rowaddtool => {
      rowaddtool.style.transform = `scale(${1 / this.opts.zoom})`;
      // rowtool.style.transformOrigin = 'top';
    });

    // freeform
    let tools = area.querySelectorAll('.is-canvas-tool');
    tools.forEach(tool => {
      tool.style.transform = `scale(${1 / this.opts.zoom})`;
      tool.style.transformOrigin = 'top';
    });
    tools = area.querySelectorAll('.is-canvasadd-tool');
    tools.forEach(tool => {
      tool.style.transform = `scale(${1 / this.opts.zoom})`;
      tool.style.transformOrigin = 'top';
    });
  }
  setZoomOnArea() {
    if (this.canvas && !this.isContentBox && this.docContainer) {
      // freeform
      const docContainer = this.doc.querySelector(this.docContainer);
      docContainer.style.transform = `scale(${this.opts.zoom})`;
      if (this.eb) this.eb.setZoom(this.opts.zoom);
      return;
    }
    if (this.opts.page !== '') {
      const wrapper = this.doc.querySelector(this.opts.page);
      wrapper.style.transform = `scale(${this.opts.zoom})`;
    } else {
      const builders = this.doc.querySelectorAll(this.opts.container);
      builders.forEach(builder => {
        let fade = false; // to prevent initial load animation
        if (!builder.style.transform) fade = true;
        if (fade) {
          builder.style.transition = 'none';
        }
        builder.style.transform = `scale(${this.opts.zoom})`;
        if (fade) {
          setTimeout(() => {
            builder.style.transition = '';
          }, 300);
        }
      });
    }
  }
  applyBehavior() {
    // Zoom (required by the next process, eg. setZoomOnControl)
    if (localStorage.getItem('_zoom') !== null) {
      this.opts.zoom = localStorage.getItem('_zoom'); // Get from saved localStorage
    }

    this.rte.rteZoomSlider.value = this.opts.zoom * 100; // Set slider value

    // Get all builder areas
    const builders = this.doc.querySelectorAll(this.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      this.applyBehaviorOn(builder); // includes setZoomOnControl

      this.contentReformatOn(builder);
    });

    // Call onRender to indicate content is ready for editing (applyBehavior has been applied)
    this.opts.onRender();
    this.setZoomOnArea(); // Set zoom
  } // applyBehavior

  contentReformatOn(builder) {
    if (this.opts.useCssClasses) this.dom.contentReformat(builder, this.opts.cssClasses);
  }
  applyBehaviorOn(builder) {
    const util = this.util;

    //Make absolute
    if (this.opts.absolutePath) {
      let links = builder.querySelectorAll('a');
      Array.prototype.forEach.call(links, link => {
        let href = link.href;
        link.setAttribute('href', href);
      });
      let imgs = builder.querySelectorAll('img');
      Array.prototype.forEach.call(imgs, img => {
        let src = img.src;
        img.setAttribute('src', src);
      });
    }

    // Add .is-builder class on each builder area (container)
    this.dom.addClass(builder, 'is-builder');

    // Additional setting needed for dynamically added .is-builder. Without this, current toolStyle won't be applied to newly created section (eg. in ContentBox))
    // if (localStorage.getItem('_toolstyle') !== null) {
    //     let toolStyle = localStorage.getItem('_toolstyle');
    //     this.preferences.setToolStyle(toolStyle);
    // } 
    // if (localStorage.getItem('_outlinestyle') !== null) {
    //     let outlineStyle = localStorage.getItem('_outlinestyle');
    //     this.preferences.setOutlineStyle(outlineStyle);
    // } 
    if (this.preferences) this.preferences.initBuilder(builder);

    // Apply behavior on each row
    const rows = this.dom.elementChildren(builder);
    rows.forEach(row => {
      // The saveForUndo also saves sortable class when start dragging. If Undo is performed, the classes are returned. Cleanup the classes here.
      row.classList.remove('sortable-ghost');
      row.classList.remove('sortable-chosen');
      if (this.dom.hasClass(row, 'row-add-initial')) return;

      // Hack. If a row has margin left/right specified, don't need to set hidden border (that is used to make smooth sortable)
      if (row.style.marginLeft || row.style.marginRight) {
        row.style.border = 'none';
      }

      // On each row, add 2 tools: Row tool (div.is-row-tool) & Row Add tool (div.is-rowadd-tool)

      // Render Row tool
      this._rowTool.render(row);

      // Render Row Add tool
      const rowaddtool = new RowAddTool(this);
      rowaddtool.render(row);

      // Apply behavior on each column
      const cols = this.dom.elementChildren(row);
      cols.forEach(col => {
        if (this.dom.hasClass(col, 'is-row-tool') || this.dom.hasClass(col, 'is-col-tool') || this.dom.hasClass(col, 'is-rowadd-tool')) return; // Return if not a column

        // For backward compatibility, replace:
        // - data-mode="readonly" with data-noedit
        // - data-mode="readonly-protected" with data-protected
        if (col.getAttribute('data-mode') === 'readonly') {
          col.setAttribute('data-noedit', '');
          col.removeAttribute('data-mode');
        }
        if (col.getAttribute('data-mode') === 'readonly-protected') {
          col.setAttribute('data-protected', '');
          col.removeAttribute('data-mode');
        }

        // Set ContentEditable

        let noedit = false;
        if (col.hasAttribute('data-noedit')) {
          // Column is not (text) editable.
          noedit = true;
        }
        let _protected = false;
        if (col.hasAttribute('data-protected')) {
          // Column is not (text) editable and also: cannot be deleted, moved or duplicated.
          _protected = true;
        }
        let customcode = false;
        if (col.hasAttribute('data-html')) {
          // Column contains custom code.
          customcode = true;
        }

        // let custommodule = false;
        // if (col.hasAttribute('data-module')) { // Column contains custom module.
        //     custommodule = true;
        // }

        if (!customcode && !noedit && !_protected) {
          // Check if column contains editable text
          const _text = col.innerText.trim();
          let elms = col.querySelectorAll('p,h1,h2,h3,h4,h5,h6,table,ul,ol,pre,blockquote,code,figcaption,label,legend,button,a,span');
          if (elms.length > 0 || _text !== '') {
            col.contentEditable = true; // Column is (text) editable
          }
        }

        // Apply behavior on several elements for editing purpose
        this.element.applyBehavior(col);

        // Add events on column
        if (!col.getAttribute('data-click')) {
          // ON CLICK
          // Use bind() => https://www.w3schools.com/react/react_events.asp
          col.addEventListener('click', this.handleCellClick.bind(this, col));

          // ON KEYPRESS
          col.addEventListener('keydown', this.handleCellKeypress.bind(this));

          // ON KEYDOWN
          col.addEventListener('keydown', this.handleCellKeydown.bind(this, col));

          // ON KEYUP
          col.addEventListener('keyup', this.handleCellKeyup.bind(this, col));

          // ON DOUBLE CLICK TO SELECT
          let isDoubleClick = false; // Double click flag

          col.addEventListener('dblclick', () => {
            isDoubleClick = true;
          });
          col.addEventListener('mouseup', () => {
            if (isDoubleClick) {
              let selection = this.win.getSelection();
              let selectedText = selection.toString().trim();
              if (selectedText.length > 0) {
                let elm = this.dom.getElm();
                if (this.dom.getStyle(elm, 'display') === 'inline') {
                  elm = elm.closest('li,p,h1,h2,h3,h4,h5,h6,div,pre,td,th,li');
                  if (elm) {
                    if (!this.dom.hasClass(elm.parentNode.parentNode, 'is-builder')) {
                      this.dom.selectElementContents(elm);
                    }
                  }
                } else {
                  // block
                  this.dom.selectElementContents(elm);
                }
              }
              // Reset the flag after handling the double-click
              isDoubleClick = false;
            }
          });

          // ON FOCUS
          // col.addEventListener('focus', this.handleCellFocus.bind(this, col));

          // ON PASTE
          // col.addEventListener('paste', this.handleCellPaste.bind(this));
          col.addEventListener('paste', e => {
            e.preventDefault();
            let clipboardDataText = (e.clipboardData || window.clipboardData).getData('text');
            let clipboardDataHtml = (e.clipboardData || window.clipboardData).getData('text/html');
            if (clipboardDataHtml.trim() === '') clipboardDataHtml = clipboardDataText;
            this.handleCellPaste(clipboardDataText, clipboardDataHtml);
          });
          col.setAttribute('data-click', true);
        }
      });
    });

    // Sortable on each builder (container)
    if (!builder.getAttribute('data-sort') && !builder.hasAttribute('nogrid')) {
      // Check first if sortable has been added.

      /*
      let userAgentString = navigator.userAgent; 
      let safariAgent = userAgentString.indexOf('Safari') > -1; 
      let chromeAgent = userAgentString.indexOf('Chrome') > -1; 
      if ((chromeAgent) && (safariAgent)) safariAgent = false;
      */
      // let safariAgent = false;

      let sortableObject = new Sortable(builder, {
        // forceFallback: safariAgent,
        // forceFallback: true,
        scroll: true,
        // invertSwap: true, /* https://github.com/SortableJS/Sortable/wiki/Swap-Thresholds-and-Direction#swap-threshold */
        group: 'shared',
        // direction: 'dummy', // works well with border-right hack & empty-info
        animation: 300,
        handle: '.row-handle',
        // swapThreshold: 0.1, // this cause drag drop snippet sometimes difficult
        // invertedSwapThreshold: 0.1,
        sort: true,
        //new
        // swapThreshold: 0.5,

        onChoose: () => {
          // Get zoom (scale) value
          let scale;
          if (this.opts.page !== '') {
            const wrapper = this.doc.querySelector(this.opts.page);
            scale = this.dom.getScale(wrapper);
          } else {
            const area = this.doc.querySelector('.is-builder'); // get one of the builder area
            scale = this.dom.getScale(area);
            if (!scale) scale = 1;
          }

          // Make moving draggable item scaled & positioned correctly (due to zoom value)
          const newCss = `
                    <style id="css-scale">
                        .sortable-drag::before {
                            transform: scale(${scale});
                        }
                    </style>
                    `;
          if (this.iframe) {
            const oldCss = this.contentStuff.querySelector('#css-scale');
            if (oldCss) oldCss.parentNode.removeChild(oldCss);
            this.contentStuff.insertAdjacentHTML('afterbegin', newCss);
          } else {
            const oldCss = this.builderStuff.querySelector('#css-scale');
            if (oldCss) oldCss.parentNode.removeChild(oldCss);
            this.builderStuff.insertAdjacentHTML('afterbegin', newCss);
          }

          // this.sectionDropSetup(); // enable drop as section (ContentBox)
        },

        onStart: () => {
          this.uo.saveForUndo(); // Even if cancelled, saveForUndo will make sure not to save if there is no change 

          this.elmTool.hide();
        },
        onEnd: () => {
          this.util.checkEmpty(); // for multiple instances check

          // if(this.sortableOnPage) this.sortableOnPage.destroy(); // enable drop as section (ContentBox)

          if (this.controlPanel) {
            // && document.body.classList.contains('controlpanel') (already opens)
            this.controlpanel.getActive();
            this.controlpanel.select('column');
            setTimeout(() => {
              // Hide element tool
              this.elmTool.hide();
            }, 600);
          }

          //Trigger Change event
          this.opts.onChange();

          //Trigger Render event
          this.opts.onRender();
        },
        onAdd: evt => {
          var itemEl = evt.item;
          if (itemEl.getAttribute('data-id')) {
            // If has data-id attribute, the dropped item is from snippet panel (snippetpanel.js)

            let snippetid = itemEl.getAttribute('data-id');

            // snippetJSON is snippet's JSON (from assets/minimalist-blocks/content.js) that store all snippets' html
            const result = this.opts.snippetJSON.snippets.filter(item => {
              if (item.id + '' === snippetid) return item;else return false;
            });
            var html = result[0].html;
            var noedit = result[0].noedit;
            if (result[0].mode === 'canvas') {
              html = result[0].html2;
              if (!html) {
                html = `
                                <div class="row">
                                    <div class="column pt-0 pb-0 pl-0 pr-0 flex flex-col justify-center">
                                    <img src="${this.opts.snippetPath}images/img-2400x1350.png" alt="">
                                    </div>
                                </div>
                            `;
              }
            }
            var bSnippet;
            if (html.indexOf('"row') === -1) {
              bSnippet = true; // Just snippet (without row/column grid)
            } else {
              bSnippet = false; // Snippet is wrapped in row/colum
            }

            if (this.opts.emailMode) bSnippet = false;

            // Convert snippet into your defined 12 columns grid   
            var rowClass = this.opts.row; //row
            var colClass = this.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
            if (rowClass !== '' && colClass.length === 12) {
              // html = html.replace(new RegExp('row clearfix', 'g'), rowClass);
              html = html.replace(new RegExp('row clearfix', 'g'), 'row'); // backward
              html = html.replace(new RegExp('"row', 'g'), '"' + rowClass);
              html = html.replace(new RegExp('column full', 'g'), colClass[11]);
              html = html.replace(new RegExp('column half', 'g'), colClass[5]);
              html = html.replace(new RegExp('column third', 'g'), colClass[3]);
              html = html.replace(new RegExp('column fourth', 'g'), colClass[2]);
              html = html.replace(new RegExp('column fifth', 'g'), colClass[1]);
              html = html.replace(new RegExp('column sixth', 'g'), colClass[1]);
              html = html.replace(new RegExp('column two-third', 'g'), colClass[7]);
              html = html.replace(new RegExp('column two-fourth', 'g'), colClass[8]);
              html = html.replace(new RegExp('column two-fifth', 'g'), colClass[9]);
              html = html.replace(new RegExp('column two-sixth', 'g'), colClass[9]);
            }
            html = html.replace(/{id}/g, util.makeId());
            if (this.opts.onAdd) {
              html = this.opts.onAdd(html);
            }
            if (this.opts.snippetPathReplace.length > 0) {
              // try {
              if (this.opts.snippetPathReplace[0] !== '') {
                var regex = new RegExp(this.opts.snippetPathReplace[0], 'g');
                html = html.replace(regex, this.opts.snippetPathReplace[1]);
                var string1 = this.opts.snippetPathReplace[0].replace(/\//g, '%2F');
                var string2 = this.opts.snippetPathReplace[1].replace(/\//g, '%2F');
                var regex2 = new RegExp(string1, 'g');
                html = html.replace(regex2, string2);
              }
              // } catch (e) { 1; }
            }

            if (bSnippet) {
              // Just snippet (without row/column grid), ex. buttons, line, social, video, map.
              // Can be inserted after current row, column (cell), element, or last row.

              html = `<div class="${this.opts.row}"><div class="${this.opts.cols[this.opts.cols.length - 1]}"${noedit ? ' data-noedit' : ''}>${html}</div></div>`;

              // Clean snippet from sortable related code
              itemEl.removeAttribute('draggable');
              this.dom.removeClass(itemEl, 'snippet-item');
              itemEl.outerHTML = html;
            } else {
              // Snippet is wrapped in row/colum (may contain custom code or has [data-html] attribute)
              // Can only be inserted after current row or last row (not on column or element).

              let snippet = this.dom.createElement('div');
              snippet.innerHTML = html;
              let blocks = snippet.querySelectorAll('[data-html]');
              Array.prototype.forEach.call(blocks, block => {
                // Render custom code block
                html = decodeURIComponent(block.getAttribute('data-html'));
                html = html.replace(/{id}/g, util.makeId());
                html = html.replace(/<script>/g, `${this.nonce ? `<script nonce="${this.nonce}">` : '<script>'}`);
                for (var i = 1; i <= 20; i++) {
                  html = html.replace('[%HTML' + i + '%]', block.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-' + i))); //render editable area
                }

                block.innerHTML = html;
              });
              html = snippet.innerHTML;

              // Clean snippet from sortable related code
              itemEl.removeAttribute('draggable');
              this.dom.removeClass(itemEl, 'snippet-item');
              itemEl.innerHTML = '';

              // Use createContextualFragment() to make embedded script executable
              // https://ghinda.net/article/script-tags/
              var range = document.createRange();
              range.setStart(itemEl, 0);
              itemEl.appendChild(range.createContextualFragment(html));
              itemEl.outerHTML = itemEl.innerHTML;
            }

            // After snippet has been added, re-apply behavior on builder areas
            this.applyBehaviorOn(builder);

            //Trigger Change event
            this.opts.onChange();

            //Trigger Render event
            this.opts.onRender();

            // Hide element tool
            this.elmTool.hide();

            // destroy (extra)
            if (this.sortableOnCanvas) {
              this.sortableOnCanvas.forEach(obj => {
                if (obj) {
                  obj.destroy();
                }
              });
              let dummies = this.doc.querySelectorAll('.block-dummy');
              dummies.forEach(elm => elm.parentNode.removeChild(elm));
              this.sortableOnCanvas = [];
            }
            if (this.sortableOnPage) {
              this.sortableOnPage.destroy();
              this.sortableOnPage = null;
            }
          }
        }
      });
      this.sortableObjects.push(sortableObject);
      builder.setAttribute('data-sort', true);
    }
    // /Sortable

    // Fix buttons not wrapped in  <div style="white-space: nowrap;">
    const linkButtons = builder.querySelectorAll('a[role="button"]');
    Array.prototype.forEach.call(linkButtons, btn => {
      if (btn.parentNode) {
        if (btn.parentNode.parentNode) {
          if (btn.parentNode.parentNode.parentNode === builder) {
            btn.outerHTML = `
                        <div style="white-space: nowrap;">
                            ${btn.outerHTML}
                        </div>
                        `;
          }
        }
      }
    });

    // Additional contentEditable for subblock
    const subblocks = builder.querySelectorAll('.is-subblock');
    Array.prototype.forEach.call(subblocks, subblock => {
      subblock.contentEditable = true;
    });

    // Check if there is empty builder area (still has no content)
    this.util.checkEmptyOn(builder);

    // Zoom
    this.setZoomOnControl(builder);
  }
  html(area) {
    if (this.docContainer && !area) {
      // freeform

      const docContainer = this.doc.querySelector(this.docContainer);
      const html = this.readHtml(docContainer, false, true);
      return html;
    }
    const util = this.util;
    if (area) ; else {
      const builders = this.doc.querySelectorAll(this.opts.container);
      if (builders.length > 1) {
        const cell = util.cellSelected();
        if (!cell) {
          // Return first instance
          area = builders[0];
        } else {
          // Return active instance
          area = cell.parentNode.parentNode;
        }
      } else {
        // Single instance
        area = builders[0];
      }
      if (this.opts.page !== '') {
        const wrapper = this.doc.querySelector(this.opts.page);
        if (wrapper) {
          //return wrapper
          area = wrapper;
        }
      }
    }
    this.cleanHtmlFormatting = true;
    let outputHtml = this.htmlutil.readHtml(area); //for view=false
    this.cleanHtmlFormatting = false;
    return outputHtml;
  }

  // ContentBox
  viewHtmlNormal() {
    this.htmlutil.viewHtmlExternal();
  }
  readHtml(content, view, multiple, excludeCustomBlock) {
    return this.htmlutil.readHtml(content, view, multiple, excludeCustomBlock);
  }
  fromViewToActual(html) {
    return this.htmlutil.fromViewToActual(html);
  }
  colorpicker(onPick, defaultcolor) {
    return new ColorPicker({
      onPick: onPick,
      color: defaultcolor,
      colors: this.opts.colors,
      animateModal: this.opts.animateModal,
      elementToAnimate: this.opts.container,
      lang: this.opts.lang
    });
  }
  gradientpicker() {
    return new GradientPicker({
      gradientcolors: this.opts.gradientcolors,
      colors: this.opts.colors,
      animateModal: this.opts.animateModal,
      elementToAnimate: this.opts.container,
      lang: this.opts.lang
    });
  }

  // simpleColorPicker(onPick,mode) {
  //     return this.colorClassPicker.open(onPick,mode);
  // }

  openAIAssistant() {
    this.dictation.openDictation();
  }
  closeAIAssistant() {
    let modal = document.querySelector('.is-modal.page-command');
    modal.classList.remove('active');
    this.dictation.stopDictation();
    localStorage.setItem('_dictation', '0');
  }
  toggleAIAssistant() {
    let modal = document.querySelector('.is-modal.page-command');
    if (modal.classList.contains('active')) {
      this.closeAIAssistant();
    } else {
      this.openAIAssistant();
    }
  }

  // freeform
  toggleSnippetModal() {
    const snippetModal = this.builderStuff.querySelector('.is-modal.snippetwindow');
    if (snippetModal.classList.contains('active')) {
      snippetModal.classList.remove('active');
    } else {
      snippetModal.classList.add('active');
    }
  }
  openSnippetModal() {
    const snippetModal = this.builderStuff.querySelector('.is-modal.snippetwindow');
    snippetModal.classList.add('active');
  }
  closeSnippetModal() {
    const snippetModal = this.builderStuff.querySelector('.is-modal.snippetwindow');
    snippetModal.classList.remove('active');
  }
  refresh() {
    if (this.eb) this.eb.refresh();

    /*
    // Add block tool
    let html = `
    <div class="is-tool is-block-tool">
        <button type="button" tabindex="-1" title="${this.util.out('Settings')}" class="block-settings"><svg class="is-icon-flex"><use xlink:href="#icon-settings"></use></svg></button>
    </div>
    `;
    let blocks = this.doc.querySelectorAll('.is-block');
    blocks.forEach(block => {
        let tool = block.querySelector('.is-block-tool');
        if(tool) tool.remove();
        block.insertAdjacentHTML('beforeend', html);
        tool = block.querySelector('.is-block-tool');
        tool.addEventListener('click',(e)=>{
            if(document.querySelector('.is-modal.editblock.active')) {
                this.blockmodal.hide();
            } else {
                this.blockmodal.show();
            }
            e.preventDefault();
            e.stopImmediatePropagation();
        });
    });
    */
  }

  group() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    const group = this.eb.group();
    this.opts.onChange();
    return group;
  }
  unGroup() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.unGroup();
    this.opts.onChange();
  }
  delete() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.delete();
    this.opts.onChange();
  }
  forward(target) {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.forward(target);
    this.opts.onChange();
  }
  backward(target) {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.backward(target);
    this.opts.onChange();
  }
  moveUp(target) {
    let arrBlocks = [];
    const container = target.parentNode;
    let elms = container.querySelectorAll('.is-block');
    elms.forEach(elm => {
      arrBlocks.push(elm);
    });
    let previousBlock; //, nextBlock;
    for (let i = 0; i < arrBlocks.length; i++) {
      if (arrBlocks[i] === target) {
        if (i - 1 >= 0) previousBlock = arrBlocks[i - 1];
        // if(i+1<arrBlocks.length) nextBlock = arrBlocks[i+1];
      }
    }

    if (previousBlock) {
      this.uo.saveForUndo();
      container.insertBefore(target, previousBlock);
      this.opts.onChange();
    }
  }
  moveDown(target) {
    let arrBlocks = [];
    const container = target.parentNode;
    let elms = container.querySelectorAll('.is-block');
    elms.forEach(elm => {
      arrBlocks.push(elm);
    });
    let nextBlock; //, previousBlock;
    for (let i = 0; i < arrBlocks.length; i++) {
      if (arrBlocks[i] === target) {
        // if(i-1>=0) previousBlock = arrBlocks[i-1];
        if (i + 1 < arrBlocks.length) nextBlock = arrBlocks[i + 1];
      }
    }
    if (nextBlock) {
      this.uo.saveForUndo();
      container.insertBefore(nextBlock, target);
      this.opts.onChange();
    }
  }
  enableShape() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.enableShape();
    this.opts.onChange();
  }
  removeShape() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.removeShape();
    this.opts.onChange();
  }
  addBlock(html, blockContainer) {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.addBlock(html, blockContainer);
    this.opts.onChange();
    this.opts.onRender();
  }
  duplicate() {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.duplicate();
    this.opts.onChange();
    this.opts.onRender();
  }
  addBreakpoint() {
    if (!this.eb) return;
    this.eb.addBreakpoint();
  }
  getBreakpoints(target) {
    if (!this.eb) return;
    return this.eb.getBreakpoints(target);
  }
  clearBreakpoint(target) {
    if (!this.eb) return;
    this.uo.saveForUndo();
    this.eb.clearBreakpoint(target);
    this.opts.onChange();
  }
  quitEditable(target) {
    if (!this.eb) return;
    this.eb.quitEditable(target);
  }
  addPage(box) {
    this.uo.saveForUndo();
    let s;
    if (localStorage.getItem('_pagesize') === '' || localStorage.getItem('_pagesize')) {
      s = localStorage.getItem('_pagesize');
    } else {
      s = this.pageSize || '';
    }
    const html = `
        <div class="is-box box-canvas autolayout new-canvas" data-pagesize="${s}">
        `;
    const docContainer = this.doc.querySelector(this.docContainer);
    if (box) {
      box.insertAdjacentHTML('afterend', html);
    } else {
      docContainer.insertAdjacentHTML('beforeend', html);
    }
    const newBox = docContainer.querySelector('.new-canvas');
    newBox.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
    newBox.classList.remove('new-canvas');
    this.applyBehaviorCanvas();
    this.opts.onChange();
  }
  setPageSize(s) {
    this.pageoption.setPageSize(s);
  }
  applyBehaviorCanvas() {
    if (this.canvas && !this.isContentBox && this.docContainer && !this.iframe) {
      let htmlTool = `
            <div class="is-tool is-canvas-tool" style="transform: scale(1); transform-origin: center top;">
                <button type="button" tabindex="-1" class="box-up" title="${this.util.out('Move Up')}"><svg class="is-icon-flex"><use xlink:href="#icon-arrow-up"></use></svg></button>
                <button type="button" tabindex="-1" class="box-down" title="${this.util.out('Move Down')}"><svg class="is-icon-flex"><use xlink:href="#icon-arrow-down"></use></svg></button>
                <!--
                <button type="button" tabindex="-1" class="box-settings" title="${this.util.out('Settings')}"><svg class="is-icon-flex"><use xlink:href="#ion-more"></use></svg></button>
                -->
                <button type="button" tabindex="-1" class="box-duplicate" title="${this.util.out('Duplicate')}"><svg class="is-icon-flex" style="width:14px;height:14px"><use xlink:href="#icon-duplicate"></use></svg></button>
                <button type="button" tabindex="-1" class="box-remove" title="${this.util.out('Remove')}"><svg class="is-icon-flex"><use xlink:href="#icon-trash"></use></svg></button>
            </div>
            <div class="is-tool is-canvasadd-tool" style="transform: scale(1); transform-origin: center top;">
                <button type="button" tabindex="-1" class="box-add" title="${this.util.out('Add')}"><svg class="is-icon-flex"><use xlink:href="#icon-plus2"></use></svg></button>
            </div>
            `;
      const docContainer = this.doc.querySelector(this.docContainer);
      const boxes = this.dom.elementChildren(docContainer);
      boxes.forEach(box => {
        let tool1 = box.querySelector('.is-canvas-tool');
        let tool2 = box.querySelector('.is-canvasadd-tool');
        if (tool1) tool1.remove();
        if (tool2) tool2.remove();
        if (!box.querySelector('.is-canvas-tool')) {
          box.addEventListener('click', () => {
            boxes.forEach(elm => elm.classList.remove('box-select'));
            box.classList.add('box-select');

            // onSelectPage (see onSelectBlock)

            let elms = this.rte.elementRteTool.querySelectorAll('.rte-blocksettings');
            Array.prototype.forEach.call(elms, elm => {
              elm.style.display = '';
            });
          });
          box.insertAdjacentHTML('afterbegin', htmlTool);
          const btnUp = box.querySelector('.is-canvas-tool .box-up');
          btnUp.addEventListener('click', e => {
            const box = e.target.closest('.is-box');
            this.uo.saveForUndo();
            let boxPrev = box.previousElementSibling;
            if (boxPrev) box.parentNode.insertBefore(box, boxPrev);
            box.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });
            this.opts.onChange();
          });
          const btnDown = box.querySelector('.is-canvas-tool .box-down');
          btnDown.addEventListener('click', e => {
            const box = e.target.closest('.is-box');
            this.uo.saveForUndo();
            let boxNext = box.nextElementSibling;
            if (boxNext) box.parentNode.insertBefore(boxNext, box);
            box.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });
            this.opts.onChange();
          });
          const btnDuplicate = box.querySelector('.is-canvas-tool .box-duplicate');
          btnDuplicate.addEventListener('click', e => {
            this.eb.selectClear(); // clear clone

            // clear active
            const box = e.target.closest('.is-box');
            const block = box.querySelector('.is-block.active');
            if (block) block.classList.remove('active');
            this.uo.saveForUndo();
            let copiedBox = box.cloneNode(true);
            copiedBox.setAttribute('data-box-copied', '1');
            let parent = box.parentNode;
            parent.insertBefore(copiedBox, box.nextElementSibling);
            let newBox = docContainer.querySelector('[data-box-copied]');
            newBox.removeAttribute('data-box-copied');

            // Code Blocks Handling
            let codeBlocks = newBox.querySelectorAll('[data-module]');
            codeBlocks.forEach(element => {
              let html = decodeURIComponent(element.getAttribute('data-html')); // Original code is stored in data-html attribute
              html = html.replace(/{id}/g, this.util.makeId());
              //Fill the block with original code
              this.html(element, html);
            });
            newBox.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });
            this.applyBehaviorCanvas();

            // ContentBuilder Handling
            let containers = newBox.querySelectorAll('.is-builder');
            containers.forEach(container => {
              let containerHtml = this.html(container);
              let range = document.createRange();
              container.innerHTML = '';
              container.appendChild(range.createContextualFragment(containerHtml));
              container.removeAttribute('data-sort'); //important (ContentBuilder cleanup for the container)
              this.applyBehaviorOn(container);
            });
            this.eb.refresh();
            this.opts.onChange();

            // Change selection
            setTimeout(() => {
              box.classList.remove('box-select');
              const prevBox = docContainer.querySelector('.box-select');
              if (prevBox) prevBox.classList.remove('box-select');
              newBox.classList.add('box-select');
            }, 30);
          });
          const btnRemove = box.querySelector('.is-canvas-tool .box-remove');
          btnRemove.addEventListener('click', e => {
            const box = e.target.closest('.is-box');
            this.uo.saveForUndo();
            box.remove();
            this.blockmodal.showHideControls();
            if (!docContainer.querySelector('.is-box')) this.addPage();
            this.opts.onChange();
          });
          const btnAdd = box.querySelector('.is-canvasadd-tool .box-add');
          btnAdd.addEventListener('click', e => {
            const box = e.target.closest('.is-box');
            this.addPage(box);
          });
        }
      });
      if (localStorage.getItem('_zoom') !== null) {
        this.opts.zoom = localStorage.getItem('_zoom'); // Get from saved localStorage
      }

      this.eb.setZoom(this.opts.zoom);
      this.setZoomOnControl(docContainer);
    }
  }
  openPageOptions() {
    this.pageoption.open();
  }
  print() {
    this.pageoption.print();
  }
  destroy() {
    if (this.eb) this.eb.destroy();
    this.doc.body.classList.remove('data-editor');
    document.removeEventListener('click', this.doDocumentClick, false);
    document.removeEventListener('keydown', this.doDocumentKeydown, false);
    document.removeEventListener('mousedown', this.doDocumentMousedown, false);
    document.removeEventListener('click', this.doRteClick, false);
    this.doc.removeEventListener('click', this.doHideSnippetHandler, false);
    if (this.iframe) {
      this.doc.removeEventListener('click', this.doDocumentClick, false);
      this.doc.removeEventListener('keydown', this.doDocumentKeydown, false);
      this.doc.removeEventListener('mousedown', this.doDocumentMousedown, false);
      this.doc.removeEventListener('click', this.doRteClick, false);
      this.win.removeEventListener('scroll', this.doWindowScroll, false);
      this.win.removeEventListener('resize', this.doWindowResize, false);
    }
    this.util.clearControls();
    let builderStuff = this.util.builderStuff();
    if (!builderStuff) return; // in case the builder is destroyed

    // Reset Zoom
    if (this.opts.page !== '') {
      const wrapper = this.doc.querySelector(this.opts.page);
      if (wrapper) wrapper.style.transform = '';
    } else {
      const builders = this.doc.querySelectorAll(this.opts.container);
      builders.forEach(builder => {
        builder.style.transform = '';
      });
    }
    const builders = this.doc.querySelectorAll(this.opts.container);
    Array.prototype.forEach.call(builders, builder => {
      // builder.innerHTML = htmlutil.readHtml(builder, true);

      let html = this.htmlutil.readHtml(builder, false);
      let range = this.doc.createRange();
      builder.innerHTML = '';
      builder.appendChild(range.createContextualFragment(html)); // Use createContextualFragment so that embedded javascript code (code block) will be executed
    });

    if (this.canvas && !this.isContentBox) {
      let html = this.html();
      let range = this.doc.createRange();
      const docContainer = this.doc.querySelector(this.docContainer);
      docContainer.innerHTML = '';
      docContainer.appendChild(range.createContextualFragment(html));
    }
    Array.prototype.forEach.call(builders, builder => {
      builder.removeAttribute('data-sort');
      this.dom.removeClass(builder, 'is-builder');
    });
    Array.prototype.forEach.call(this.sortableObjects, sortableObject => {
      try {
        sortableObject.destroy();
      } catch (e) {
        // Do Nothing
      }
    });
    if (this.moveable) this.moveable.destroy();

    // Remove special css
    const cbContentStyle = this.doc.querySelector('#_contentbuilder_css');
    if (cbContentStyle) cbContentStyle.parentNode.removeChild(cbContentStyle);
    this.builderStuff.parentNode.removeChild(this.builderStuff);
    this.builderStuff = null;
    if (this.iframe) {
      this.contentStuff.parentNode.removeChild(this.contentStuff);
      this.contentStuff = null;
    }
  }
  saveImages(handler, onComplete, onBase64Upload) {
    let si = new SaveImages({
      page: this.opts.page,
      container: this.opts.container,
      customval: this.opts.customval,
      handler: handler,
      onComplete: onComplete,
      onBase64Upload: onBase64Upload ? onBase64Upload : null
    }, this);
    si.save();
  }
  // /ContentBox

  // External (eg. from IFRAME)
  clearFont() {
    this.rte.clearFont();
  }
  applyFont(fontfamily, fontstyle, provider) {
    // called from iframe: parent._cb.applyFont
    this.rte.applyFont(fontfamily, fontstyle, provider);
  }
  setFont(fontfamily, fontstyle, fontdisplay, provider) {
    // called from iframe: parent._cb.applyFont
    this.rte.setFont(fontfamily, fontstyle, fontdisplay, provider);
  }
  addIcon(classname) {
    this.rte.addIcon(classname);
  }
  applyLargerImage(s) {
    // called from iframe: parent.applyLargerImage() see line 345

    let forms = document.querySelectorAll('.form-upload-larger'); // elementimage.js
    Array.prototype.forEach.call(forms, formUpload => {
      if (this.dom.hasClass(formUpload, 'please-wait')) {
        this.dom.removeClass(formUpload, 'please-wait');
        formUpload.parentNode.parentNode.querySelector('input[type="text"]').value = s;
        formUpload.parentNode.parentNode.querySelector('input[type="file"]').value = '';
      }
    });
  }
  returnUrl(s) {
    // Same as applyLargerImage (NEW)

    let forms = document.querySelectorAll('.form-upload-larger'); // elementimage.js
    Array.prototype.forEach.call(forms, formUpload => {
      if (this.dom.hasClass(formUpload, 'please-wait')) {
        this.dom.removeClass(formUpload, 'please-wait');
        if (s) formUpload.parentNode.parentNode.querySelector('input[type="text"]').value = s;
        formUpload.parentNode.parentNode.querySelector('input[type="file"]').value = '';
      }
    });
    this.opts.assetRefresh = true; // After file upload, make open asset refreshed

    if (this.onAssetUpload) {
      this.onAssetUpload(s);
      this.onAssetUpload = null; // clear
    }
  }

  openMediaPicker(currentUrl, assetType = 'media', callback, btn) {
    this.mediaPicker.openMediaPicker(currentUrl, assetType, callback, btn);
  }
  openImagePicker(currentUrl, callback, btn) {
    this.colTool.openImagePicker(currentUrl, callback, btn);
  }
  openImageAdjust(elm, btn, useTarget) {
    if (this.opts.imageAdjust === 2) {
      this.colTool.openImageAdjust2(elm, btn);
    } else {
      this.colTool.openImageAdjust(elm, btn, useTarget);
    }
  }
  selectFile(s) {
    // Backward compatible

    this.selectAsset(s);
  }
  selectImage(s) {
    // Backward compatible

    this.selectAsset(s);
  }
  selectVideo(s) {
    // Backward compatible

    this.selectAsset(s);
  }
  selectAsset(s, f) {
    let extension = s.split('.').pop().split('?')[0].split('#')[0]; //
    extension = extension.toLowerCase();
    let ok = false;
    if (this.targetAssetType === 'all') {
      ok = true;
    } else if (this.targetAssetType === 'media') {
      if (s.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp' || extension === 'mp4') {
        ok = true;
      } else {
        alert(this.util.out('Please select an image or video file.'));
      }
    } else if (this.targetAssetType === 'image') {
      if (s.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
        ok = true;
      } else {
        alert(this.util.out('Please select an image file.'));
      }
    } else if (this.targetAssetType === 'video') {
      if (extension === 'mp4') {
        ok = true;
      } else {
        alert(this.util.out('Please select an mp4 file.'));
      }
    } else if (this.targetAssetType === 'audio') {
      if (extension === 'mp3') {
        ok = true;
      } else {
        alert(this.util.out('Please select an mp3 file.'));
      }
    }
    if (ok) {
      if (f) this.targetInput.setAttribute('data-filename', f);else this.targetInput.removeAttribute('data-filename');
      this.targetInput.value = s;

      // if(this.targetCallback) this.targetCallback();
      if (this.targetInput.id === 'inpCellLinkSource') {
        // Special case (need to run a process on asset select). See columntool.js on targetCallback.
        this.targetCallback();
      }
      let modal = document.querySelector('.is-modal.videoselect.active');
      if (modal) this.hideModal(modal);
      modal = document.querySelector('.is-modal.imageselect.active');
      if (modal) this.hideModal(modal);
      modal = document.querySelector('.is-modal.fileselect.active');
      if (modal) this.hideModal(modal);
      modal = document.querySelector('.is-modal.audioselect.active');
      if (modal) this.hideModal(modal);
      modal = document.querySelector('.is-modal.mediaselect.active');
      if (modal) this.hideModal(modal);
      modal = document.querySelector('.is-modal.otherselect.active');
      if (modal) this.hideModal(modal);
    }
  }
  assetType() {
    // not used yet
    return this.targetAssetType; // not used yet
  }

  openImageSelect(callback, defaultValue) {
    const inpUrl = document.createElement('input');

    // dummy button (for the openAsset() method, for the old Asset Manager. Not needed for the new.)
    const btn = document.createElement('button');
    this.openAsset(inpUrl, 'image', btn, defaultValue);
    let out = s => this.util.out(s);
    const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
    Object.defineProperty(inpUrl, 'value', {
      get: desc.get,
      set: function (s) {
        // Additional protection if normal selectAsset() is not used in asset dialog.
        // This is used if onImageSelectClick or onFileSelectClick are used.
        const filename = s.substring(s.lastIndexOf('/') + 1);
        let extension = filename.split('.').pop();
        extension = extension.toLowerCase();
        let ok = false;
        if (s.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
          ok = true;
        } else {
          alert(out('Please select an image file.'));
        }
        if (ok) {
          // if(callback) callback(s);
          if (callback) {
            // if s is base64 and there is data-filename attribute set
            let f;
            if (inpUrl.hasAttribute('data-filename')) f = inpUrl.getAttribute('data-filename');
            callback(s, f);
          }
        }
        desc.set.call(this, s);
      }
    });
  }
  openAssetSelect(targetAssetType, callback, defaultValue) {
    const inpUrl = document.createElement('input');

    // dummy button (for the openAsset() method, for the old Asset Manager. Not needed for the new.)
    const btn = document.createElement('button');
    this.openAsset(inpUrl, targetAssetType, btn, defaultValue);
    let out = s => this.util.out(s);
    const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
    Object.defineProperty(inpUrl, 'value', {
      get: desc.get,
      set: function (s) {
        // Additional protection if normal selectAsset() is not used in asset dialog.
        // This is used if onImageSelectClick or onFileSelectClick are used.
        const filename = s.substring(s.lastIndexOf('/') + 1);
        let ext = filename.split('.').pop();
        ext = ext.toLowerCase();
        let ok = false;
        if (targetAssetType === 'image' && (s.includes('base64') || ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'gif' || ext === 'webm' || ext === 'webp')) {
          ok = true;
        } else if (targetAssetType === 'video' && ext === 'mp4') {
          ok = true;
        } else if (targetAssetType === 'audio' && ext === 'mp3') {
          ok = true;
        } else if (targetAssetType === 'media' && (s.includes('base64') || ext === 'mp4' || ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'gif' || ext === 'webm' || ext === 'webp')) {
          ok = true;
        } else if (targetAssetType === 'all') {
          ok = true;
        } else {
          if (targetAssetType === 'image') alert(out('Please select an image file.'));
          if (targetAssetType === 'video') alert(out('Please select an mp4 file.'));
          if (targetAssetType === 'audio') alert(out('Please select an mp3 file.'));
          if (targetAssetType === 'media') alert(out('Please select an image or video file.'));
        }
        if (ok) {
          // if(callback) callback(s);
          if (callback) {
            // if s is base64 and there is data-filename attribute set
            let f;
            if (inpUrl.hasAttribute('data-filename')) f = inpUrl.getAttribute('data-filename');
            callback(s, f);
          }
        }
        desc.set.call(this, s);
      }
    });
  }
  renderSelectAsset(btn, targetAssetType, callback) {
    const _id = 'inp_' + this.util.makeId();
    btn.insertAdjacentHTML('afterend', `<input type="hidden" id="${_id}">`);
    const inpUrl = btn.parentNode.querySelector(`#${_id}`);
    btn.addEventListener('click', () => {
      this.openAsset(inpUrl, targetAssetType, btn);
    });
    let out = s => this.util.out(s);
    const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
    Object.defineProperty(inpUrl, 'value', {
      get: desc.get,
      set: function (s) {
        // Additional protection if normal selectAsset() is not used in asset dialog.
        // This is used if onImageSelectClick or onFileSelectClick are used.
        const filename = s.substring(s.lastIndexOf('/') + 1);
        let extension = filename.split('.').pop();
        extension = extension.toLowerCase();
        let ok = false;
        if (targetAssetType === 'all') {
          ok = true;
        } else if (targetAssetType === 'media') {
          if (s.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp' || extension === 'mp4') {
            ok = true;
          } else {
            alert(out('Please select an image or video file.'));
          }
        } else if (targetAssetType === 'video') {
          if (extension === 'mp4') {
            ok = true;
          } else {
            alert(out('Please select an mp4 file.'));
          }
        } else if (targetAssetType === 'image') {
          if (s.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
            ok = true;
          } else {
            alert(out('Please select an image file.'));
          }
        } else if (targetAssetType === 'audio') {
          if (extension === 'mp3') {
            ok = true;
          } else {
            alert(out('Please select an mp3 file.'));
          }
        }
        if (ok) {
          // if(callback) callback(s);
          if (callback) {
            // if s is base64 and there is data-filename attribute set
            let f;
            if (inpUrl.hasAttribute('data-filename')) f = inpUrl.getAttribute('data-filename');
            callback(s, f);
          }
        }
        desc.set.call(this, s);
      }
    });
  }
  openOther(targetInput, targetAssetType, theTrigger) {
    if (this.opts.onOtherSelectClick) {
      this.opts.onOtherSelectClick({
        targetInput: targetInput,
        theTrigger: theTrigger
      });
    } else {
      let iframe;
      let modal = this.builderStuff.querySelector('.is-modal.otherselect');
      iframe = modal.querySelector('iframe');
      if (iframe.src === 'about:blank') iframe.src = this.opts.otherSelect;
      this.util.showModal(modal, false, () => {
        theTrigger.removeAttribute('data-focus');
        theTrigger.focus();
      }, false, this.assetPanelFullScreen);
      this.targetInput = targetInput; // used by selectAsset() (see contentbuilder.js)
      this.targetCallback = null;
      this.targetAssetType = targetAssetType;
    }
  }
  openAsset(targetInput, targetAssetType, theTrigger, defaultValue) {
    let iframe;
    let modal;
    if (targetAssetType === 'media' && (this.opts.onMediaSelectClick || this.opts.onImageSelectClick)) {
      if (this.opts.onMediaSelectClick) {
        this.opts.onMediaSelectClick({
          targetInput: targetInput,
          theTrigger: theTrigger
        });
      } else {
        this.opts.onImageSelectClick({
          targetInput: targetInput,
          theTrigger: theTrigger
        });
      }
    } else if (targetAssetType === 'video' && this.opts.onVideoSelectClick) {
      this.opts.onVideoSelectClick({
        targetInput: targetInput,
        theTrigger: theTrigger
      });
    } else if (targetAssetType === 'image' && this.opts.onImageSelectClick) {
      this.opts.onImageSelectClick({
        targetInput: targetInput,
        theTrigger: theTrigger
      });
    } else if (targetAssetType === 'audio' && this.opts.onAudioSelectClick) {
      this.opts.onAudioSelectClick({
        targetInput: targetInput,
        theTrigger: theTrigger
      });
    } else if (targetAssetType === 'all' && this.opts.onFileSelectClick) {
      this.opts.onFileSelectClick({
        targetInput: targetInput,
        theTrigger: theTrigger
      });
    } else {
      if (targetAssetType === 'media') {
        modal = this.builderStuff.querySelector('.is-modal.mediaselect');
        iframe = modal.querySelector('iframe');
        if (iframe.src === 'about:blank') {
          if (this.opts.mediaSelect) iframe.src = this.opts.mediaSelect;else if (this.opts.imageSelect) iframe.src = this.opts.imageSelect;
        }
      } else if (targetAssetType === 'video') {
        modal = this.builderStuff.querySelector('.is-modal.videoselect');
        iframe = modal.querySelector('iframe');
        if (iframe.src === 'about:blank') iframe.src = this.opts.videoSelect;
      } else if (targetAssetType === 'image') {
        modal = this.builderStuff.querySelector('.is-modal.imageselect');
        iframe = modal.querySelector('iframe');
        if (iframe.src === 'about:blank') iframe.src = this.opts.imageSelect;
      } else if (targetAssetType === 'audio') {
        modal = this.builderStuff.querySelector('.is-modal.audioselect');
        iframe = modal.querySelector('iframe');
        if (iframe.src === 'about:blank') iframe.src = this.opts.audioSelect;
      } else if (targetAssetType === 'all') {
        modal = this.builderStuff.querySelector('.is-modal.fileselect');
        iframe = modal.querySelector('iframe');
        if (iframe.src === 'about:blank') iframe.src = this.opts.fileSelect;
      }
      this.util.showModal(modal, false, () => {
        theTrigger.removeAttribute('data-focus');
        theTrigger.focus();
      }, false, this.assetPanelFullScreen);
      this.targetInput = targetInput; // used by selectAsset() (see contentbuilder.js)
      this.targetCallback = null;
      this.targetAssetType = targetAssetType;
    }
    if (!defaultValue) defaultValue = '';
    if (targetInput && targetInput.value) {
      defaultValue = targetInput.value;
    }
    if (this.onAssetOpen) {
      if (iframe) {
        if (iframe.contentWindow.document.body.innerHTML !== '') {
          this.onAssetOpen(defaultValue, iframe.contentWindow);
        } else {
          iframe.addEventListener('load', () => {
            this.onAssetOpen(defaultValue, iframe.contentWindow);
          });
        }
      } else {
        this.onAssetOpen(defaultValue, iframe);
      }
    }
  }

  // Grid
  moveRowUp() {
    this._rowTool.moveRowUp();
  }
  moveRowDown() {
    this._rowTool.moveRowDown();
  }
  duplicateRow() {
    this._rowTool.duplicateRow();
  }
  removeRow() {
    this._rowTool.removeRow();
  }
  moveColumnLeft() {
    this.colTool.moveColumnLeft();
  }
  moveColumnRight() {
    this.colTool.moveColumnRight();
  }
  duplicateColumn() {
    this.colTool.duplicateColumn();
  }
  removeColumn() {
    this.colTool.removeColumn();
  }
  moveColumnUp() {
    this.colTool.moveColumnUp();
  }
  moveColumnDown() {
    this.colTool.moveColumnDown();
  }

  // Text
  formatText(command) {
    this.rte.formatText(command);
  }
  formatTextNonToggle(command) {
    this.rte.formatTextNonToggle(command);
  }
  LightenDarkenColor(col, amt) {
    // Backward compatibility (used by: Button Editor plugin)
    return this.util.LightenDarkenColor(col, amt);
  }
  pickColor(onPick, defaultcolor) {
    // Backward compatibility (used by: Button Editor plugin)
    let colorPicker = new ColorPicker({
      colors: this.opts.colors,
      animateModal: false,
      lang: this.opts.lang
    });
    colorPicker.open(onPick, defaultcolor);
  }
  addSnippet(html, bSnippet, noedit) {
    //called by snippetlist.html
    this.util.addSnippet(html, bSnippet, noedit);
  }
  viewSnippets() {
    this.rte.viewSnippets();
  }
  saveForUndo(checkLater) {
    this.uo.saveForUndo(checkLater);
  }
  download(options = {}) {
    this.export(options, true);
  }
  export(options = {}, shortenOutput = false) {
    let pageTemplate = this.pageTemplate;
    let output = '';

    // [%CONTENT%]
    this.makeAbsolute = true; //To make absolute (for Export/Download)
    this.shortenOutput = shortenOutput;
    let html = this.html();
    this.makeAbsolute = false;
    this.shortenOutput = false;
    output = pageTemplate.replace('[%CONTENT%]', html);

    // Custom
    if (options.replace) {
      options.replace.forEach(rule => {
        output = output.replaceAll(`${rule[0]}`, rule[1]);
      });
    }

    // [%PATH%]
    if (options.path) {
      output = output.replaceAll('[%PATH%]', options.path);
    } else {
      let urlBase;
      urlBase = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
      output = output.replaceAll('[%PATH%]', urlBase);
    }

    // Beautify
    output = this.beautify(output);
    const a = document.createElement('a');
    a.href = window.URL.createObjectURL(new Blob([output], {
      type: 'text/plain'
    }));
    a.download = 'page.html';
    a.click();
  }
  beautify(html) {
    return this.htmlutil.beautify(html);
  }
  openPreview() {
    this.livePreview.openPreview();
  }
  closePreview() {
    this.livePreview.closePreview();
  }

  // Module related
  getActiveModule() {
    return this.doc.querySelector('[data-module-active]');
  }
  getModuleSettings() {
    let activeModule = this.doc.querySelector('[data-module-active]'); //get active module 
    return decodeURIComponent(activeModule.getAttribute('data-settings'));
  }
  setModuleHtml(html) {
    document.querySelector('#hidContentModuleCode').value = html; // See elementmodule.js
  }

  setModuleSettings(settings) {
    document.querySelector('#hidContentModuleSettings').value = settings; // See elementmodule.js
  }

  makeId() {
    return this.util.makeId();
  }
  setTooltip(area) {
    this.tooltip.setAll(area);
  }

  // Plugins related

  loadPlugins() {
    if (!this.builderStuff) return; // in case of builder destroyed while plugins still loading

    if (typeof this.opts.scriptPath === 'undefined' && this.opts.pluginPath === '') return;
    this.numOfPlugins = 0;
    if (typeof this.opts.plugins[0] === 'string') {
      // backward compatible
      this.loadPluginsOldWay();
      return;
    }
    const rteTool = this.builderStuff.querySelector('.is-rte-tool');
    const rteMoreOptions = this.builderStuff.querySelector('.rte-more-options');
    const elementRteTool = this.builderStuff.querySelector('.is-elementrte-tool');
    const elementRteMoreOptions = this.builderStuff.querySelector('.elementrte-more-options');
    let i;
    for (i = this.opts.plugins.length - 1; i >= 0; i--) {
      const pluginName = this.opts.plugins[i].name;
      const showInMainToolbar = this.opts.plugins[i].showInMainToolbar;
      const showInElementToolbar = this.opts.plugins[i].showInElementToolbar;

      // -- Check if button exists
      let buttonExistOnMainToolbar = false;
      if (rteTool.querySelector('[data-plugin="' + pluginName + '"]') || rteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
        buttonExistOnMainToolbar = true;
      }
      let buttonExistOnElementToolbar = false;
      if (elementRteTool.querySelector('[data-plugin="' + pluginName + '"]') || elementRteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
        buttonExistOnElementToolbar = true;
      }
      // -- 

      if (showInMainToolbar && !buttonExistOnMainToolbar) {
        let divs = rteMoreOptions.querySelectorAll('div:not(.rte-separator)');
        divs.forEach(div => {
          div.insertAdjacentHTML('afterbegin', '<button style="width:46px;" title="button not found" data-plugin="' + pluginName + '"></button>');
        });
      }
      if (showInElementToolbar && !buttonExistOnElementToolbar) {
        elementRteMoreOptions.querySelector('div').insertAdjacentHTML('afterbegin', '<button style="width:46px;" title="button not found" data-plugin="' + pluginName + '"></button>');
      }
    }
    for (i = 0; i < this.opts.plugins.length; i++) {
      const pluginName = this.opts.plugins[i].name;
      let pluginFile = this.opts.scriptPath + 'plugins/' + pluginName + '/plugin.js';
      if (this.opts.pluginPath !== '') pluginFile = this.opts.pluginPath + 'plugins/' + pluginName + '/plugin.js';
      this.loadScript(pluginFile).then(() => {
        this.numOfPlugins++;
        if (this.numOfPlugins === this.opts.plugins.length) {
          if (this.opts.onPluginsLoaded) {
            this.opts.onPluginsLoaded();
          }
          this.tooltip.setAll();
          new Draggable$2({
            selector: '.is-draggable'
          }); //draggable for plugins

          // setTimeout(()=>{
          //     this.rte.positionRteMore();
          //     this.rte.positionElementRteMore();
          // }, 10);
        }
      });
    }
  }

  loadPluginsOldWay() {
    const rteTool = this.builderStuff.querySelector('.is-rte-tool');
    const rteMoreOptions = this.builderStuff.querySelector('.rte-more-options');
    const elementRteTool = this.builderStuff.querySelector('.is-elementrte-tool');
    const elementRteMoreOptions = this.builderStuff.querySelector('.elementrte-more-options');
    let i;
    for (i = this.opts.plugins.length - 1; i >= 0; i--) {
      const pluginName = this.opts.plugins[i];

      // -- Check if button exists
      let buttonExistOnMainToolbar = false;
      if (rteTool.querySelector('[data-plugin="' + pluginName + '"]') || rteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
        buttonExistOnMainToolbar = true;
      }
      let buttonExistOnElementToolbar = false;
      if (elementRteTool.querySelector('[data-plugin="' + pluginName + '"]') || elementRteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
        buttonExistOnElementToolbar = true;
      }
      // -- 

      if (!buttonExistOnMainToolbar) {
        rteMoreOptions.querySelector('div').insertAdjacentHTML('afterbegin', '<button style="width:46px;" title="button not found" data-plugin="' + this.opts.plugins[i] + '"></button>');
      }
      if (!buttonExistOnElementToolbar) {
        elementRteMoreOptions.querySelector('div').insertAdjacentHTML('afterbegin', '<button style="width:46px;" title="button not found" data-plugin="' + this.opts.plugins[i] + '"></button>');
      }
    }
    for (i = 0; i < this.opts.plugins.length; i++) {
      let pluginFile = this.opts.scriptPath + 'plugins/' + this.opts.plugins[i] + '/plugin.js';
      if (this.opts.pluginPath !== '') pluginFile = this.opts.pluginPath + 'plugins/' + this.opts.plugins[i] + '/plugin.js';
      this.loadScript(pluginFile).then(() => {
        this.numOfPlugins++;
        if (this.numOfPlugins === this.opts.plugins.length) {
          // All plugin scripts loaded
          let pluginbuttons = rteMoreOptions.querySelectorAll('[data-plugin]');
          Array.prototype.forEach.call(pluginbuttons, pluginbutton => {
            pluginbutton.outerHTML = ''; //Remove unused buttons (if loaded plugins don't use button)
          });

          pluginbuttons = elementRteMoreOptions.querySelectorAll('[data-plugin]');
          Array.prototype.forEach.call(pluginbuttons, pluginbutton => {
            pluginbutton.outerHTML = ''; //Remove unused buttons (if loaded plugins don't use button)
          });

          if (this.opts.onPluginsLoaded) {
            this.opts.onPluginsLoaded();
          }
          this.tooltip.setAll();
          new Draggable$2({
            selector: '.is-draggable'
          }); //draggable for plugins

          // setTimeout(()=>{
          //     this.rte.positionRteMore();
          //     this.rte.positionElementRteMore();
          // }, 10);
        }
      });
    }
  }

  addHtml(html) {
    this.dom.appendHtml(this.builderStuff, html);
  }
  addCss(css) {
    this.dom.appendHtml(document.head, css);
  }
  addButton_OLD(pluginName, html, selector, exec) {
    if (!this.builderStuff) return;
    const rteTool = this.builderStuff.querySelector('.is-rte-tool');
    const rteMoreOptions = this.builderStuff.querySelector('.rte-more-options');
    var bUseMore = false;
    if (rteTool.querySelector('[data-plugin="' + pluginName + '"]')) {
      //if plugin button exists on the toolbar
      rteTool.querySelector('[data-plugin="' + pluginName + '"]').outerHTML = html;
    } else if (rteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
      //if plugin button exists on the more popup
      rteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]').outerHTML = html;
      bUseMore = true;
    } /*else {
        rteMoreOptions.querySelector('div').insertAdjacentHTML('afterbegin', html);
        bUseMore = true;
      }*/

    // Add More button if needed
    if (!rteTool.querySelector('.rte-more') && bUseMore) {
      rteTool.insertAdjacentHTML('beforeend', `<button title="${this.util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`);
      let btnRteMore = this.rteTool.querySelector('button.rte-more');
      if (btnRteMore) this.dom.addEventListener(btnRteMore, 'click', () => {
        this.rte.showRteMore();
      });
    }

    // Add event to the button
    let btnPlugin = rteTool.querySelector(selector);
    btnPlugin = btnPlugin ? btnPlugin : rteMoreOptions.querySelector(selector);
    if (btnPlugin) {
      // Prepare for tooltip
      btnPlugin.setAttribute('data-title', btnPlugin.getAttribute('title'));
      this.dom.addEventListener(btnPlugin, 'click', e => {
        exec(e);
      });
    }
  }
  addButton(pluginName, html, selector, exec) {
    if (!this.builderStuff) return;
    if (this.controlPanel && this.controlpanel.controlPanel) {
      const popMore = this.controlpanel.controlPanel.querySelector('.panel-pop.more');
      const pluginArea = popMore.querySelector('div.plugins');
      pluginArea.insertAdjacentHTML('beforeend', html);
      const btn = popMore.querySelector(selector);
      btn.addEventListener('click', e => {
        exec(e);
      });
      const label = popMore.querySelector('.label-plugins');
      label.style.display = ''; //show label
    }

    const rteTool = this.builderStuff.querySelector('.is-rte-tool');
    const rteMoreOptions = this.builderStuff.querySelector('.rte-more-options');
    var bUseMore = false;
    if (rteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
      //if plugin button exists on the more popup
      bUseMore = true;
    }

    // Replace buttons
    const btnPlugins = this.builderStuff.querySelectorAll('[data-plugin="' + pluginName + '"]');
    btnPlugins.forEach(btn => {
      btn.outerHTML = html;
    });

    // Add More button if needed
    if (!rteTool.querySelector('.rte-more') && bUseMore) {
      rteTool.insertAdjacentHTML('beforeend', `<button title="${this.util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`);
      let btnRteMore = this.rteTool.querySelector('button.rte-more');
      if (btnRteMore) this.dom.addEventListener(btnRteMore, 'click', () => {
        this.rte.showRteMore();
      });
    }
    let btnPlugin = rteTool.querySelectorAll(selector);
    btnPlugin.forEach(btn => {
      // Prepare for tooltip
      btn.setAttribute('data-title', btn.getAttribute('title'));
      this.dom.addEventListener(btn, 'click', e => {
        exec(e);
      });
    });
    btnPlugin = rteMoreOptions.querySelectorAll(selector);
    btnPlugin.forEach(btn => {
      // Prepare for tooltip
      btn.setAttribute('data-title', btn.getAttribute('title'));
      this.dom.addEventListener(btn, 'click', e => {
        exec(e);
      });
    });
  }

  // Element Toolbar
  addButton2(pluginName, html, selector, exec) {
    if (!this.builderStuff) return;
    const elementRteTool = this.builderStuff.querySelector('.is-elementrte-tool');
    const elementRteMoreOptions = this.builderStuff.querySelector('.elementrte-more-options');
    var bUseMore = false;
    if (elementRteTool.querySelector('[data-plugin="' + pluginName + '"]')) {
      //if plugin button exists on the toolbar
      elementRteTool.querySelector('[data-plugin="' + pluginName + '"]').outerHTML = html;
    } else if (elementRteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]')) {
      //if plugin button exists on the more popup
      elementRteMoreOptions.querySelector('[data-plugin="' + pluginName + '"]').outerHTML = html;
      bUseMore = true;
    } /*else {
        elementRteMoreOptions.querySelector('div').insertAdjacentHTML('afterbegin', html);
        bUseMore = true;
      }*/

    // Add More button if needed
    if (!elementRteTool.querySelector('.rte-more') && bUseMore) {
      elementRteTool.insertAdjacentHTML('beforeend', `<button title="${this.util.out('More')}" class="rte-more"><svg class="is-icon-flex" style="width:13px;height:13px;"><use xlink:href="#ion-more"></use></svg></button>`);
      let btnRteMore = this.elementRteTool.querySelector('button.rte-more');
      if (btnRteMore) this.dom.addEventListener(btnRteMore, 'click', () => {
        this.rte.showElementRteMore();
      });
    }

    // Add event to the button
    let btnPlugin = elementRteTool.querySelector(selector);
    btnPlugin = btnPlugin ? btnPlugin : elementRteMoreOptions.querySelector(selector);
    if (btnPlugin) {
      // Prepare for tooltip
      btnPlugin.setAttribute('data-title', btnPlugin.getAttribute('title'));
      this.dom.addEventListener(btnPlugin, 'click', e => {
        exec(e);
      });
    }
  }
  showModal(modal, overlayStay, cancelCallback, animated, overflowHidden) {
    this.util.showModal(modal, overlayStay, cancelCallback, animated, overflowHidden);
  }
  hideModal(modal) {
    this.util._hideModal(modal); // this _hideModal will also trigger cancelCallback defined by showModal. This is done by programmatically click the overlay.
  }

  draggable(selector) {
    new Draggable$2({
      selector: selector
    });
  }
  createModal(modal, selector, overlayStay, cancelCallback, animated, overflowHidden) {
    let embeddedModal = this.builderStuff.querySelector(selector);
    if (!embeddedModal) {
      this.builderStuff.appendChild(modal);
      embeddedModal = this.builderStuff.querySelector(selector);
    }
    this.showModal(embeddedModal, overlayStay, cancelCallback, animated, overflowHidden);
    new Draggable$2({
      selector: '.is-draggable'
    });
    return embeddedModal;
  }
  getIcons() {
    return this.rte.getIcons();
  }
  showSidePanel(panel) {
    let panels = this.builderStuff.querySelectorAll('.is-side');
    Array.prototype.forEach.call(panels, panel => {
      this.dom.removeClass(panel, 'active');
    });
    this.dom.addClass(panel, 'active');
  }
  hideSidePanel(panel) {
    this.dom.removeClass(panel, 'active');
  }
  getScriptPath() {
    return this.opts.scriptPath;
  }
  getSnippetPath() {
    // return this.opts.snippetData.substring(0, this.opts.snippetData.lastIndexOf('/') + 1);
    return this.opts.snippetPath;
  }
  out(text) {
    return this.util.out(text);
  }
  undo() {
    this.uo.doUndo();
  }
  redo() {
    this.uo.doRedo();
  }
  getScope() {
    let area;
    const builders = this.doc.querySelectorAll(this.opts.container);
    if (builders.length > 1) {
      const cell = this.util.cellSelected();
      if (!cell) {
        // Return first instance
        area = builders[0];
      } else {
        // Return active instance
        area = cell.parentNode.parentNode;
      }
    } else {
      // Single instance
      area = builders[0];
    }
    if (this.opts.page !== '') {
      const wrapper = this.doc.querySelector(this.opts.page);
      if (wrapper) {
        //return wrapper
        area = wrapper;
      }
    }
    return area;
  }
  saveSelection() {
    this.util.saveSelection();
  }
  restoreSelection() {
    this.util.restoreSelection();
  }
  pasteHtmlAtCaret(html, selectPastedContent) {
    this.util.pasteHtmlAtCaret(html, selectPastedContent);
  }
  getScript(scriptUrl, callback) {
    this.loadScript(scriptUrl).then(() => {
      if (callback) callback();
    }, () => {
      console.log('Fail to load config');
    });
  }
  getScripts(scriptUrls, callback) {
    let count = 0;

    //console.log(count)
    let a = this.loadScript(scriptUrls[count]);
    a.then(() => {
      count = this._helper1(count, scriptUrls, callback);
    });
  }
  _helper1(count, scriptUrls, callback) {
    count++;
    if (count < scriptUrls.length) {
      //console.log(count)
      let a = this.loadScript(scriptUrls[count]);
      a.then(() => {
        count = this._helper1(count, scriptUrls, callback);
      });
      return count;
    } else {
      if (callback) callback();
    }
  }
  includeJs(filename, callback) {
    if (this.filesAdded.indexOf('[' + filename + ']') === -1) {
      this.getScript(filename, callback);
      this.filesAdded += '[' + filename + ']';
    } else {
      //alert('already added');
      if (callback) callback();
    }
  }
  includeCss(filename) {
    if (this.filesAdded.indexOf('[' + filename + ']') === -1) {
      var inc = document.createElement('link');
      inc.setAttribute('rel', 'stylesheet');
      inc.setAttribute('href', filename);
      document.getElementsByTagName('head')[0].appendChild(inc);
      this.filesAdded += '[' + filename + ']';
    }
  }
  applyStyle(id, s) {
    if (this.filesAdded.indexOf('[' + id + ']') === -1) {
      var inc = document.createElement('style');
      inc.innerHTML = s;
      document.getElementsByTagName('head')[0].appendChild(inc);
      this.filesAdded += '[' + id + ']';
    }
  }
  // /Plugins related

  viewHtml(area) {
    if (this.docContainer) {
      // freeform
      area = this.doc.querySelector(this.docContainer);
    }
    this.htmlutil.view('full', area);
  }
  viewPreferences() {
    if (this.preferences) this.preferences.view();
  }
  viewConfig() {
    //backward
    if (this.preferences) this.preferences.view();
  }
  viewZoom() {
    this.rte.viewZoom();
  }
  loadSnippets(snippetFile, snippetOpen) {
    if (this.preview) return;
    if (this.opts.snippetList === '#divSnippetList') {
      let snippetPanel = document.querySelector(this.opts.snippetList);
      if (snippetPanel) {
        if (snippetOpen) openSnippets(this);
        return; // do not render if already rendered (just protection)
      }
    }

    if (this.isScriptAlreadyIncluded(snippetFile)) return;
    const script = document.createElement('script');
    script.src = snippetFile;
    script.async = true;
    script.onload = () => {
      this.opts.snippetJSON = window.data_basic;
      if (!this.canvas) for (let i = this.opts.snippetJSON.snippets.length - 1; i >= 0; i--) {
        if (this.opts.snippetJSON.snippets[i].mode === 'canvas') {
          this.opts.snippetJSON.snippets.splice(i, 1);
        }
      }

      // if snippetPath is specified (not empty), then use the specified. Otherwise, use the one generated from snippet file (_snippets_path)
      if (this.opts.snippetPath === '') {
        this.opts.snippetPath = window._snippets_path;
      }
      if (this.opts.snippetJSON.snippets.length > 0) {
        renderSnippetPanel(this, snippetOpen); // Render Snippet Panel
      }
    };

    document.body.appendChild(script);
  }
  isScriptAlreadyIncluded(src) {
    const scripts = document.getElementsByTagName('script');
    for (let i = 0; i < scripts.length; i++) if (scripts[i].getAttribute('src') === src) return true;
    return false;
  }
  loadHtml(html, area) {
    if (this.canvas && !this.isContentBox && this.docContainer) {
      // freeform
      const docContainer = this.doc.querySelector(this.docContainer);
      let range = this.doc.createRange();
      docContainer.innerHTML = '';
      if (!html.includes('is-box')) {
        html = `
                <div class="is-box box-canvas autolayout">
                    <div class="is-block block-steady height-auto" style="top: calc(50% - 357px); left: calc(50% - 348px); width: 696px;" data--t="calc(50% - 357px)" data--l="calc(50% - 348px)" data--b="" data--r="" data--w="696px" data--h="">
                        <div class="is-container">
                            ${html}
                        </div>
                        <div class="is-block-overlay"></div>
                    </div>
                </div>
                `;
      }
      docContainer.appendChild(range.createContextualFragment(html)); // We use createContextualFragment so that embedded javascript code (code block) will be executed

      // set page size 
      let s;
      const elm = docContainer.querySelector('[data-pagesize]');
      if (elm) {
        s = elm.getAttribute('data-pagesize');
      } else {
        if (localStorage.getItem('_pagesize') === '' || localStorage.getItem('_pagesize')) {
          s = localStorage.getItem('_pagesize');
        } else {
          s = this.pageSize || '';
        }
      }
      this.setPageSize(s);
      this.applyBehaviorCanvas();
      const builders = docContainer.querySelectorAll(this.container);
      builders.forEach(builder => {
        this.applyBehaviorOn(builder);
      });
      this.refresh();
      if (this.win.Block) {
        this.win.Block.render();
      }
      return;
    }
    const util = this.util;
    if (area) ; else {
      const builders = this.doc.querySelectorAll(this.opts.container);
      if (builders.length > 1) {
        const cell = util.cellSelected();
        if (!cell) {
          // Return first instance
          area = builders[0];
        } else {
          // Return active instance
          area = cell.parentNode.parentNode;
        }
      } else {
        // Single instance
        area = builders[0];
      }
      if (this.opts.page !== '') {
        const wrapper = this.doc.querySelector(this.opts.page);
        if (wrapper) {
          //return wrapper
          area = wrapper;
        }
      }
    }

    // area.innerHTML = html;
    let range = this.doc.createRange();
    area.innerHTML = '';
    area.appendChild(range.createContextualFragment(html)); // We use createContextualFragment so that embedded javascript code (code block) will be executed

    this.applyBehavior();

    // this.uo.saveForUndo(); //First time

    //Trigger Change event
    this.opts.onChange();

    //Trigger Render event
    this.opts.onRender();
    if (localStorage.getItem('_livepreview') != null) {
      this.livePreview.openPreview();
    }
  }
  // loadHtml(html) {

  //     let area = this.getScope();
  //     area.innerHTML = html;

  //     this.builder.applyBehavior();

  //     //Trigger Change event
  //     this.builder.opts.onChange();

  //     //Trigger Render event
  //     this.builder.opts.onRender();
  // }
  loadHTML(html) {
    //backward

    this.loadHtml(html);
  }
  async setUIColor(mode, csslink) {
    // Get previous css
    let cssLink = document.querySelector('[data-cb-color]');
    if (cssLink) cssLink.setAttribute('data-cb-del', '');
    // if(cssLink) cssLink.parentNode.removeChild(cssLink);

    // Add new css
    if (csslink) {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = csslink;
      link.setAttribute('data-cb-color', '');
      link.addEventListener('load', () => {
        // Remove previous css
        cssLink = document.querySelector('[data-cb-del]');
        if (cssLink) cssLink.parentNode.removeChild(cssLink);
        if (mode === 'dark') {
          this.dom.removeClass(document.body, 'colored');
          this.dom.removeClass(document.body, 'colored-dark');
          this.dom.removeClass(document.body, 'light');
          this.dom.addClass(document.body, 'dark');
        }
        if (mode === 'colored') {
          this.dom.removeClass(document.body, 'dark');
          this.dom.removeClass(document.body, 'colored-dark');
          this.dom.removeClass(document.body, 'light');
          this.dom.addClass(document.body, 'colored');
        }
        if (mode === 'colored-dark') {
          this.dom.removeClass(document.body, 'dark');
          this.dom.removeClass(document.body, 'colored');
          this.dom.removeClass(document.body, 'light');
          this.dom.addClass(document.body, 'colored-dark');
        }
        if (mode === '') {
          this.dom.removeClass(document.body, 'dark');
          this.dom.removeClass(document.body, 'colored-dark');
          this.dom.removeClass(document.body, 'colored');
          this.dom.removeClass(document.body, 'light');
        }
        if (mode === 'light') {
          this.dom.removeClass(document.body, 'dark');
          this.dom.removeClass(document.body, 'colored-dark');
          this.dom.removeClass(document.body, 'colored');
          this.dom.addClass(document.body, 'light');
        }

        // Css loaded. Now we can get UI styles.
        const util = this.util;

        // util.getUIStyles();

        // this.setUIColorRefresh();

        // if(this.opts.onThemeChange) this.opts.onThemeChange();

        setTimeout(() => {
          util.getUIStyles();
          this.setUIColorRefresh();
          if (this.opts.onThemeChange) this.opts.onThemeChange();
        }, 300);
      });
      document.head.appendChild(link);
    } else {
      // Remove previous css
      cssLink = document.querySelector('[data-cb-del]');
      if (cssLink) cssLink.parentNode.removeChild(cssLink);
      if (mode === '') {
        this.dom.removeClass(document.body, 'dark');
        this.dom.removeClass(document.body, 'colored-dark');
        this.dom.removeClass(document.body, 'colored');
        this.dom.removeClass(document.body, 'light');
      }

      // Css loaded. Now we can get UI styles.
      const util = this.util;

      // util.getUIStyles();

      // this.setUIColorRefresh();

      // if(this.opts.onThemeChange) this.opts.onThemeChange();

      await this.delay(1000);
      // setTimeout(()=>{
      util.getUIStyles();
      this.setUIColorRefresh();
      if (this.opts.onThemeChange) this.opts.onThemeChange();
      // }, 1000);
    }
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  setUIColorRefresh() {
    // All related with iframe style

    if (!this.rte || !this.element) {
      // || this.element
      setTimeout(() => {
        // console.log('Not ready, delay 1!');
        this.setUIColorRefresh();
      }, 600);
      return;
    }

    // Snippets (Modal)
    let modalSnippets = this.builderStuff.querySelector('.snippets');
    modalSnippets.querySelector('iframe').src = 'about:blank';
    let modal1 = document.querySelector('.is-modal.videoselect');
    let modal2 = document.querySelector('.is-modal.imageselect');
    let modal3 = document.querySelector('.is-modal.fileselect');
    let modal4 = document.querySelector('.is-modal.otherselect');
    let modal5 = document.querySelector('.is-modal.audioselect');
    let modal6 = document.querySelector('.is-modal.mediaselect');
    let modalIframe1 = modal1.querySelector('iframe');
    let modalIframe2 = modal2.querySelector('iframe');
    let modalIframe3 = modal3.querySelector('iframe');
    let modalIframe4 = modal4.querySelector('iframe');
    let modalIframe5 = modal5.querySelector('iframe');
    let modalIframe6 = modal6.querySelector('iframe');
    if (modalIframe1.contentWindow.applyParentStyles) modalIframe1.contentWindow.applyParentStyles();
    if (modalIframe2.contentWindow.applyParentStyles) modalIframe2.contentWindow.applyParentStyles();
    if (modalIframe3.contentWindow.applyParentStyles) modalIframe3.contentWindow.applyParentStyles();
    if (modalIframe4.contentWindow.applyParentStyles) modalIframe4.contentWindow.applyParentStyles();
    if (modalIframe5.contentWindow.applyParentStyles) modalIframe5.contentWindow.applyParentStyles();
    if (modalIframe6.contentWindow.applyParentStyles) modalIframe6.contentWindow.applyParentStyles();
  }
  openMedia(elm) {
    let url = '';
    let theme = elm.getAttribute('data-modal-theme');
    if (!theme) theme = 'light';
    const color = elm.getAttribute('data-modal-color');
    if (elm.getAttribute('data-modal-url')) {
      url = elm.getAttribute('data-modal-url');
      let extension = url.split('.').pop().split('?')[0].split('#')[0]; //

      if (url.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
        this.lightbox.openImage(url, theme, color);
      } else if (extension === 'mp4') {
        this.lightbox.openVideo(url, 'dark', color);
      } else if (url.toLowerCase().indexOf('youtube.com') !== -1 || url.toLowerCase().indexOf('youtube-nocookie.com') !== -1 || url.toLowerCase().indexOf('vimeo.com') !== -1) {
        this.lightbox.openExternalVideo(url, 'dark', color);
      } else {
        if (url.indexOf('#') === 0) ; else {
          // Will go to the link
          const answer = window.confirm(this.util.out('Do you really want to leave?'));
          // cancel the navigation and stay on the same page
          if (!answer) {
            return false;
          }
        }
        window.location.href = url;
      }
    } else {
      // Other options
      if (elm.getAttribute('data-modal-image')) {
        url = elm.getAttribute('data-modal-image');
        this.lightbox.openImage(url, theme, color);
      }
      if (elm.getAttribute('data-modal-video')) {
        url = elm.getAttribute('data-modal-video');
        this.lightbox.openVideo(url, 'dark', color);
      }
      if (elm.getAttribute('data-modal-externalvideo')) {
        url = elm.getAttribute('data-modal-externalvideo');
        this.lightbox.openExternalVideo(url, 'dark', color);
      }
    }
  }
  async upscaleImage(src, callback) {
    if (this.viewImageUrl) {
      src = this.viewImageUrl + '?url=' + src;
    }
    if (src.includes('http') && this.viewFileUrl) {
      /*
      Can be from:
      External site, 
      ex:
          http://bucket-name.s3-website-us-east-1.amazonaws.com/readme.txt
      */
      src = this.viewFileUrl + '?url=' + src;
    }
    const width = 512;
    const height = 512;
    const img = new Image();
    img.src = src;
    img.crossOrigin = 'anonymous';
    img.onload = async () => {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);
      const resizedBase64 = canvas.toDataURL('image/jpeg');
      let image = resizedBase64;
      image = image.replace(/^data:image\/(png|jpeg);base64,/, '');
      const messages = {
        image: image,
        folder_path: ''
      };
      const response = await fetch(this.upscaleImageUrl, {
        signal: this.signal,
        // Abort
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(messages)
      });
      const result = await response.json();
      callback(result.url);
    };
  }
  async generateImage(prompt, callback) {
    this.controller = new AbortController(); // Create a new AbortController
    this.signal = this.controller.signal; // Get a new signal object

    let model = this.imageModel || 'realistic-vision-v3';
    let negative_prompt = this.imageNegativePrompt || 'duplicate, (deformed iris, deformed pupils, semi-realistic, cgi, 3d, render, sketch, cartoon, drawing, anime:1.4), text, close up, cropped, out of frame, worst quality, low quality, jpeg artifacts, ugly, duplicate, morbid, mutilated, extra fingers, mutated hands, poorly drawn hands, poorly drawn face, mutation, deformed, blurry, dehydrated, bad anatomy, bad proportions, extra limbs, cloned face, disfigured, gross proportions, malformed limbs, missing arms, missing legs, extra arms, extra legs, fused fingers, too many fingers, long neck, bad_prompt_version2, bad-hands-5, badhandv4, bad anatomy, deformed, mutated, amputated, missing finger, extra finger, fused fingers, missing leg, extra leg, fused legs, missing digit, extra digit, fused digits, missing hand, extra hand, fused hands, missing arm, extra arm, fused arms, missing limb, extra limb, fused limbs, fused bodies, merged bodies, extra bodies, dual bodies, extra navel, elongated body, missing joint, extra joint, fused joints, deformed hip, twisted limbs, twisted legs, twisted arms, missing head, extra head, double head, twins, missing ear, extra ear, deformed ear, black and white, monochrome, multiple views, blurry, text, signature, head out of frame, paintings, sketches, (worst quality:2), (low quality:2), (normal quality:2), lowres, grayscale, glans, bad hands, error, extra digit, fewer digits, cropped, jpeg artifacts, watermark, username, bad feet, poorly drawn hands, poorly drawn face, mutation, too many fingers, long neck, long body, long arms, cross-eyed, mutated hands, polar lowres, bad body, bad proportions, gross proportions, cropped head , bad eyes, extra breast, missing breast, fused breasts, unnatural proportions, necklace';
    let steps = this.imageSteps || 25;
    let guidance = this.imageGuidance || 7.5;
    let scheduler = this.imageScheduler || 'dpmsolver++';
    const messages = {
      model,
      prompt: prompt,
      negative_prompt,
      width: 512,
      height: 512,
      steps,
      guidance,
      scheduler,
      output_format: 'jpeg',
      folder_path: ''
    };
    try {
      let url = this.textToImageUrl;
      const response = await fetch(url, {
        signal: this.signal,
        // Abort
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(messages)
      });
      const result = await response.json();
      if (result.error) {
        console.log('Error:\n' + result.error);
        return;
      }
      const imageUrl = result.url;
      if (this.imageAutoUpscale) {
        this.upscaleImage(imageUrl, callback);
      } else {
        callback(imageUrl);
      }
    } catch (error) {
      if (error.name === 'AbortError') ; else {
        // CORS or code errors goes here
        console.error('Error:', error);
        // console.log('Error:\n'+error);

        this.dictation.finish(); // Must be called after finished
      }
    }
  }

  /* OpenAI
  // Requires:
  // generateImageUrl: '/generateimage',
  // uploadBase64Url:'/uploadbase64',
   async generateImage(prompt, num, callback) {
       if(!(this.generateImageUrl && this.uploadBase64Url)) return;
       this.controller = new AbortController(); // Create a new AbortController
      this.signal = this.controller.signal; // Get a new signal object
       const messages = { prompt, num };
       try {
           const response = await fetch(this.generateImageUrl, {
              signal: this.signal, // Abort
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify(messages),
          });
  
          const result = await response.json();
  
          if(result.error) {
              console.log('Error:\n'+result.error);
              return;
          }
  
          const filename = result.filename;
  
          let images = [];
  
          const numOfImages = result.data.data.length;
  
          const imageList = result.data.data;
          imageList.forEach(item=>{
              const base64 = item.b64_json;
              const src = `data:image/jpeg;base64,${base64}`;
  
              var newWidth = 1024;
              var newHeight = 1024;
              var img = new Image();
              img.src = src;
              img.onload = () => {
  
                  var canvas = document.createElement('canvas');
                  canvas.width = newWidth;
                  canvas.height = newHeight;
  
                  var ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, newWidth, newHeight);
                  var resizedBase64 = canvas.toDataURL('image/jpeg');
  
                  let image = resizedBase64;
                  image = image.replace(/^data:image\/(png|jpeg);base64,/, '');
  
                  const reqBody = { image: image, filename: filename };
                  fetch(this.uploadBase64Url, {
                      method:'POST',
                      body: JSON.stringify(reqBody),
                      headers: {
                          'Content-Type': 'application/json',
                      }
                  })
                      .then(response=>response.json())
                      .then(response=>{
                          if(!response.error) { 
                              const uploadedImageUrl = response.url;
                              images.push(uploadedImageUrl);
                              if(images.length===numOfImages) {
                                  callback(images);
                              }
                          }
                      });
              };
  
          });
       } catch (error) {
          if (error.name === 'AbortError') {
              // Do Nothing
              // console.log('Request aborted by user.');
          } else {
              // CORS or code errors goes here
              console.error('Error:', error);
              // console.log('Error:\n'+error);
               this.dictation.finish(); // Must be called after finished
          }
      }
  }
  */

  lightboxOpen(col) {
    // Open Lightbox
    if (this.useLightbox) {
      if ((col.hasAttribute('data-noedit') || col.hasAttribute('data-protected')) && this.dom.hasClass(col, 'block-click') /*  && this.dom.hasClass(col,'cell-active') */) {
        this.openMedia(col);
      }
    }
  }
  handleCellClick(col, e) {
    if (this.cleanEditing) {
      col.parentNode.querySelector('.is-row-tool').style.display = '';
      col.parentNode.querySelector('.is-col-tool').style.display = '';
    }
    this.lightboxOpen(col);
    const util = this.util;
    util.clearActiveCell();
    this.activeCol = col;
    let elm = e.target;
    col.classList.add('cell-active');
    let row = col.parentNode;
    row.classList.add('row-active');
    const builders = this.doc.querySelectorAll(this.opts.container);
    builders.forEach(builder => {
      builder.classList.remove('builder-active');
    });
    row.parentNode.classList.add('builder-active');
    this.doc.body.classList.add('content-edit');
    if (row.childElementCount - 2 === 1) ; else {
      row.classList.add('row-outline');
    }

    // Call onContentClick to indicate click on editable content (eg. for plugin usage)
    if (this.opts.onContentClick) this.opts.onContentClick(e);
    this.element.click(col, e);
    this.colTool.click(col);
    this.elmTool.click(col, e);
    if (!this.controlPanel) this.rte.click(col, e);else this.util.saveSelection(); // important (eg. for create/edit link)

    /*
    // TODO: move to grideditor.js
    // Grid Editor Status
    // On/off lock button
    const grideditor = document.querySelector('.grideditor.active');
    if(grideditor) {
        const btnCellLocking = grideditor.querySelector('.cell-locking');
        if(col.hasAttribute('data-noedit')) {
            btnCellLocking.classList.add('on');
        } else {
            btnCellLocking.classList.remove('on');
        }
    }
    */

    // If column only has spacer, locked or unlocked, 
    // the text should not be able to edit (cursor should not be able to be placed)
    // So, make the column uneditable (text) if only has a spacer.
    if (col.childElementCount === 1) {
      let elm = col.children[0];
      if (elm) if (this.dom.hasClass(elm, 'spacer')) {
        col.contentEditable = false;
      }
    }

    // Show Lock Indicator
    this.colTool.showHideLockIndicator(col);
    if (this.opts.enableDragResize) {
      if (this.resize) {
        // console.log(this.resize);
        this.resize.destroy(); // destroy previous instance
      }

      // Enable resizable on click
      if (!col.classList.contains('noresize')) {
        // Disable on mobile
        const viewportWidth = this.doc.body.clientWidth;
        if (viewportWidth > 768) {
          this.resize = new Resize(col, this);
          this.resize.enable();
        }
      }
    }
    if (this.settings.onSelectionChange) this.settings.onSelectionChange(e);

    // if(this.settings.onPageContentClick) this.settings.onPageContentClick(e);

    // Lightbox
    let link = elm.closest('a');
    if (link) {
      if (col.hasAttribute('data-noedit') || col.hasAttribute('data-protected')) {
        // Link & Lightbox click allowed only on locked column

        // Disable link open on builder area
        if (col.getAttribute('contenteditable') === 'true') {
          e.preventDefault();
          return false;
        } else {
          if (elm.tagName.toLowerCase() === 'a') link = elm;

          // Open Lightbox
          if (this.useLightbox && this.dom.hasClass(link, 'is-lightbox')) {
            let url = link.getAttribute('href');
            if (!url) {
              e.preventDefault();
              return false;
            }
            let extension = url.split('.').pop().split('?')[0].split('#')[0]; //

            let theme = link.getAttribute('data-modal-theme');
            if (!theme) theme = 'light';
            const color = elm.getAttribute('data-modal-color');
            if (url.includes('base64') || extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'gif' || extension === 'webm' || extension === 'webp') {
              this.lightbox.openImage(url, theme, color);
              e.preventDefault();
              return false;
            } else if (extension === 'mp4') {
              this.lightbox.openVideo(url, 'dark', color);
              e.preventDefault();
              return false;
            } else if (url.toLowerCase().indexOf('youtube.com') !== -1 || url.toLowerCase().indexOf('youtube-nocookie.com') !== -1 || url.toLowerCase().indexOf('vimeo.com') !== -1) {
              this.lightbox.openExternalVideo(url, 'dark', color);
              e.preventDefault();
              return false;
            } else {
              // Will go to the link
              if (url.indexOf('#') === 0) ; else {
                const answer = window.confirm(this.util.out('Do you really want to leave?'));
                // cancel the navigation and stay on the same page
                if (!answer) {
                  e.preventDefault();
                  return false;
                }
              }
            }
          } else {
            let url = link.getAttribute('href');
            if (!url) {
              e.preventDefault();
              return false;
            }
            if (url.indexOf('#') === 0) ; else {
              const answer = window.confirm(this.util.out('Do you really want to leave?'));
              // cancel the navigation and stay on the same page
              if (!answer) {
                e.preventDefault();
                return false;
              }
            }
          }
        }
      }

      // e.preventDefault();
      // return false;
    }

    // Extra: Check if last row, make sure the Row Add Tool visible
    const tool = row.querySelector('.is-rowadd-tool');
    const tollAddButton = tool.querySelector('button');
    tollAddButton.style.marginTop = '';
    const children = Array.from(row.parentNode.children).filter(element => {
      return element.nodeName.toLowerCase() === 'div';
    });
    if (children && children.length > 0) {
      let lastChild = children[children.length - 1];
      if (row === lastChild) {
        const section = row.closest('.is-section');
        if (section) {
          const sectionOffset = this.dom.getElementOffset(section);
          let h1 = sectionOffset.top + sectionOffset.height;
          const rowOffset = this.dom.getElementOffset(row);
          let h2 = rowOffset.top + rowOffset.height;
          if (h1 - h2 < 19) {
            tollAddButton.style.marginTop = '-14px';
          }
        }
      }
    }
  }
  handleCellKeypress(e) {
    if (e.ctrlKey || e.metaKey) {
      //CTRL
      return;
    }
    if (this.uoTm === null) {
      this.uo.saveForUndo();
      this.uoTm = setTimeout(() => {
        this.uoTm = null;
      }, 1000);
    } else {
      clearTimeout(this.uoTm);
      this.uoTm = setTimeout(() => {
        this.uoTm = null;
      }, 1000);
    }
  }
  handleCellKeydown(col, e) {
    if (e.which === 46 || e.which === 8) {
      //delete or backspace
      if (this.activeIcon) {
        // Delete icon
        if (this.activeIcon.parentNode.tagName.toLowerCase() === 'a' && this.activeIcon.parentNode.innerText.trim() === '') {
          let link = this.activeIcon.parentNode;
          let parentElm = link.parentNode;
          link.parentNode.removeChild(link);
          // direct
          const linkTool = this.builderStuff.querySelector('#divLinkTool');
          if (linkTool) linkTool.style.display = '';
          const elmTool = this.builderStuff.querySelector('.is-element-tool');
          elmTool.style.display = '';
          if (parentElm) {
            if (parentElm.innerHTML.trim() === '') parentElm.parentNode.removeChild(parentElm);
          }
        } else {
          this.activeIcon.parentNode.removeChild(this.activeIcon);
        }
        e.preventDefault();
        return;
      }
      if (this.activeImage) {
        this.util.hideControls(); //deleting an image should also clear the visible image tool (and resizer).
      }

      col.querySelectorAll('.is-social').forEach(elm => {
        elm.removeAttribute('contentEditable'); // Return back the div.is-social (See: Prevent div.is-social gets deleted)
      });
    }

    this.oriLen = col.textContent.length; // get character length

    // Cleanup unwanted span
    let spans = col.querySelectorAll('span');
    Array.prototype.forEach.call(spans, span => {
      span.setAttribute('data-keep', '');
    });

    // Cleanup all elements with unwanted style
    let elms = col.querySelectorAll('[style]');
    elms.forEach(elm => {
      let attr = elm.getAttribute('style');
      if (attr.includes('font-size')) {
        elm.setAttribute('data-keep-font-size', '');
      }
      if (attr.includes('background-color')) {
        elm.setAttribute('data-keep-background-color', '');
      }
      if (attr.includes('background')) {
        elm.setAttribute('data-keep-background', '');
      }
      if (attr.includes('line-height')) {
        elm.setAttribute('data-keep-line-height', '');
      }
    });
    this.autoclean = true;
    if ((e.ctrlKey || e.metaKey) && e.which === 86) ;
    if (this.opts.elementSelection && !this.emailMode) {
      if ((e.ctrlKey || e.metaKey) && e.which === 65) {
        //CTRL-A

        let el;
        try {
          if (this.win.getSelection) {
            el = this.win.getSelection().getRangeAt(0).commonAncestorContainer.parentNode;
          } else if (this.doc.selection) {
            el = this.doc.selection.createRange().parentElement();
          }
          if (!this.dom.hasClass(el.parentNode.parentNode, 'is-builder')) {
            this.dom.selectElementContents(el);
          }
          e.preventDefault();
        } catch (e) {
          // Do Nothing
        }
      }
    }
    if (e.keyCode === 46) {
      // console.log("delete");
      let curr;
      try {
        if (window.getSelection) {
          curr = window.getSelection().getRangeAt(0).commonAncestorContainer;
        } else if (document.selection) {
          curr = document.selection.createRange();
        }
        if (curr.innerHTML === '<br>') {
          let next = curr.nextElementSibling;
          if (next) {
            curr.parentNode.removeChild(curr); //without this, empty P, H1, H2 (contains only <br />) cannot be deleted (when there is another P below)
            // Of course, we can backspace from the P below, but the formatting will change.
            e.preventDefault();
          }
        }
      } catch (e) {
        // Do Nothing
      }
    }
    if (e.keyCode === 8) {
      // delete on Mac
      let curr;
      try {
        if (window.getSelection) {
          curr = window.getSelection().getRangeAt(0).commonAncestorContainer;
        } else if (document.selection) {
          curr = document.selection.createRange();
        }
        if (curr.textContent === '') {
          let prev = curr.previousElementSibling;
          if (!prev) {
            e.preventDefault(); //Without this, empty P, H1, H2 (that doesn't have prev element) will be lost => can make empty column.
          }
        }
      } catch (e) {
        // Do Nothing
      }
    }
    if (e.which === 9 && !e.shiftKey) {
      // tab key pressed
      const activeCol = this.activeCol;
      if (activeCol) {
        if (activeCol.nextElementSibling && activeCol.nextElementSibling.hasAttribute('data-click')) {
          // Do Nothing
          const target = activeCol.nextElementSibling;
          if (target) target.click();
          // if(target.firstElementChild) target.firstElementChild.click();

          let selection = window.getSelection();
          let range = this.createRange(target, {
            count: 0
          });
          if (range) {
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }
          if (target.firstElementChild) {
            setTimeout(() => {
              target.firstElementChild.click();
            }, 200);
          }
          e.preventDefault();
        } else {
          if (activeCol.parentNode.nextElementSibling) {
            // Next row
            const row = activeCol.parentNode.nextElementSibling;
            if (row) {
              const firstCol = row.firstElementChild;
              if (firstCol) firstCol.click();
              // if(firstCol.firstElementChild) firstCol.firstElementChild.click();

              let selection = window.getSelection();
              let range = this.createRange(firstCol, {
                count: 0
              });
              if (range) {
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
              }
              if (firstCol.firstElementChild) {
                setTimeout(() => {
                  firstCol.firstElementChild.click();
                }, 200);
              }
              e.preventDefault();
            }
          }
        }
      }
    }
    if (e.which === 9 && e.shiftKey) {
      // tab + shift key pressed
      const activeCol = this.activeCol;
      if (activeCol) {
        if (activeCol.previousElementSibling && activeCol.previousElementSibling.hasAttribute('data-click')) {
          // Do Nothing
          const target = activeCol.previousElementSibling;
          if (target) target.click();
          if (target.firstElementChild) target.firstElementChild.click();
          let selection = window.getSelection();
          let range = this.createRange(target, {
            count: 0
          });
          if (range) {
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }
          if (target.firstElementChild) {
            setTimeout(() => {
              target.firstElementChild.click();
            }, 200);
          }
          e.preventDefault();
        } else {
          if (activeCol.parentNode.previousElementSibling) {
            // Prev row
            const divs = activeCol.parentNode.previousElementSibling.querySelectorAll('[data-click]');
            if (divs.length > 0) {
              const target = divs[divs.length - 1];
              if (target) target.click();
              if (target.firstElementChild) target.firstElementChild.click();
              let selection = window.getSelection();
              let range = this.createRange(target, {
                count: 0
              });
              if (range) {
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
              }
              if (target.firstElementChild) {
                setTimeout(() => {
                  target.firstElementChild.click();
                }, 200);
              }
              e.preventDefault();
            }
          }
        }
      }
    }

    // Formatting
    const markSpan = () => {
      let spans = col.querySelectorAll('span');
      Array.prototype.forEach.call(spans, span => {
        span.setAttribute('data-keep', '');
      });
    };
    const isCmd = e.ctrlKey || e.metaKey;
    if (isCmd && e.which === 66) {
      // CMD-B

      if (this.opts.useCssClasses) {
        this.uo.saveForUndo();
        this.dom.execCommandToggle('fontWeight', '', this.opts.cssClasses);
        this.opts.onChange();
        e.preventDefault();
        markSpan();
      }
    }
    if (isCmd && e.which === 73) {
      // CMD-I

      if (this.opts.useCssClasses) {
        this.uo.saveForUndo();
        this.dom.execCommandToggle('fontStyle', '', this.opts.cssClasses);
        this.opts.onChange();
        e.preventDefault();
        markSpan();
      }
    }
    if (isCmd && e.which === 85) {
      // CMD-U

      if (this.opts.useCssClasses) {
        this.uo.saveForUndo();
        this.dom.execCommandToggle('textUnderline', '', this.opts.cssClasses);
        this.opts.onChange();
        e.preventDefault();
        markSpan();
      }
    }
    if (isCmd && e.which === 83) {
      // CMD-S

      if (this.opts.useCssClasses) {
        this.uo.saveForUndo();
        this.dom.execCommandToggle('textLinethrough', '', this.opts.cssClasses);
        this.opts.onChange();
        e.preventDefault();
        markSpan();
      }
    }
    if (isCmd && e.which === 221) {
      this.uo.saveForUndo();

      // CMD-]
      e.preventDefault();
      document.execCommand('indent', false, null);
      this.opts.onChange();
      e.preventDefault();
      markSpan();
    }
    if (isCmd && e.which === 219) {
      this.uo.saveForUndo();

      // CMD-]
      e.preventDefault();
      document.execCommand('outdent', false, null);
      this.opts.onChange();
      e.preventDefault();
      markSpan();
    }
    if (isCmd && e.which === 75) {
      // CMD-K

      this.element.hyperlink.createLink();
      e.preventDefault();
    }
    if (isCmd && e.which === 80) {
      // CMD-P
      e.preventDefault();
      this.rte.insertImage();
    }
    if (this.cleanEditing) {
      this.colTool.columnTool.classList.remove('active');
      col.parentNode.querySelector('.is-row-tool').style.display = 'none';
      col.parentNode.querySelector('.is-col-tool').style.display = 'none';
    }
  }
  createRange(node, chars, range) {
    if (!range) {
      range = document.createRange();
      range.selectNode(node);
      range.setStart(node, 0);
    }
    if (chars.count === 0) {
      range.setEnd(node, chars.count);
    } else if (node && chars.count > 0) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length < chars.count) {
          chars.count -= node.textContent.length;
        } else {
          range.setEnd(node, chars.count);
          chars.count = 0;
        }
      } else {
        for (var lp = 0; lp < node.childNodes.length; lp++) {
          range = this.createRange(node.childNodes[lp], chars, range);
          if (chars.count === 0) {
            break;
          }
        }
      }
    }
    return range;
  }
  handleCellFocus(col) {
    const activeCol = this.activeCol;
    if (!activeCol) {
      if (col.firstElementChild) col.firstElementChild.click();else col.click();
    } else {
      if (col !== activeCol) {
        if (col.firstElementChild) col.firstElementChild.click();else col.click();
      }
    }
  }
  handleCellKeyup(col, e) {
    if (e.which === 46 || e.which === 8) {
      col.querySelectorAll('.is-social').forEach(elm => {
        elm.contentEditable = false; // Prevent div.is-social gets deleted while deleting its next element
      });
    }

    if (this.dom.textSelection()) {
      if (e.keyCode === '38') {
        // Up arrow
        this.util.saveSelection();
      } else if (e.keyCode === '40') {
        // Down arrow
        this.util.saveSelection();
      } else if (e.keyCode === '37') {
        // Left arrow
        this.util.saveSelection();
      } else if (e.keyCode === '39') {
        // Right arrow
        this.util.saveSelection();
      }
    }

    // See: handleCellKeydown
    // Cleanup unwanted span
    let spans = col.querySelectorAll('span');
    Array.prototype.forEach.call(spans, span => {
      let attr = span.hasAttribute('data-keep');
      if (!attr) {
        // Remove unwanted span
        span.outerHTML = span.innerHTML;
      }
    });

    // Cleanup all elements with unwanted style
    if (this.autoclean) {
      let elms = col.querySelectorAll('[style]');
      elms.forEach(elm => {
        let attr = elm.getAttribute('style');
        if (attr.includes('font-size')) {
          let attrkeep = elm.hasAttribute('data-keep-font-size');
          if (!attrkeep) {
            elm.style.fontSize = '';
          }
        }
        if (attr.includes('background-color')) {
          let attrkeep = elm.hasAttribute('data-keep-background-color');
          if (!attrkeep) {
            elm.style.backgroundColor = '';
          }
        }
        if (attr.includes('background')) {
          let attrkeep = elm.hasAttribute('data-keep-background');
          if (!attrkeep) {
            elm.style.background = '';
          }
        }
        if (attr.includes('line-height')) {
          let attrkeep = elm.hasAttribute('data-keep-line-height');
          if (!attrkeep) {
            elm.style.lineHeight = '';
          }
        }
      });
      col.querySelectorAll('[data-keep-font-size]').forEach(elm => elm.removeAttribute('data-keep-font-size'));
      col.querySelectorAll('[data-keep-background-color]').forEach(elm => elm.removeAttribute('data-keep-background-color'));
      col.querySelectorAll('[data-keep-background]').forEach(elm => elm.removeAttribute('data-keep-background'));
      col.querySelectorAll('[data-keep-line-height]').forEach(elm => elm.removeAttribute('data-keep-line-height'));
    }
    this.autoclean = false;
    var el;
    // var curr;
    try {
      if (this.win.getSelection) {
        // curr = window.getSelection().getRangeAt(0).commonAncestorContainer;
        el = this.win.getSelection().getRangeAt(0).commonAncestorContainer.parentNode;
      } else if (this.doc.selection) {
        // curr = this.doc.selection.createRange();
        el = this.doc.selection.createRange().parentElement();
      }
    } catch (e) {
      return;
    } //Use try to prevent lost selection after undo

    if (e.keyCode === 13 && !e.shiftKey) {
      //So that enter at the end of list returns <p>
      /*
      var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      var isOpera = window.opera;
      if(isChrome || isOpera) { 
          //Without this, pressing ENTER at the end of list will returns <p> on Chrome but then it become <div> (On Opera it returns <div>)
          //With this, we change it into <p>
          if(el.tagName.toLowerCase() === 'p' || el.tagName.toLowerCase() === 'div') {
              this.doc.execCommand('formatBlock', false, '<p>');
          }
      }*/
      if (el.tagName.toLowerCase() === 'p' || el.tagName.toLowerCase() === 'div') {
        this.doc.execCommand('formatBlock', false, '<p>');
      }

      /*
      if(isFirefox) {
          //On FF (when enter at the end of list) jQuery(curr).html() returns undefined
          if(curr) this.doc.execCommand('formatBlock', false, '<p>');
      }*/

      let elms = col.querySelectorAll('[data-keep]');
      Array.prototype.forEach.call(elms, elm => {
        elm.removeAttribute('data-keep');
      });
    }

    // LATER
    // jQuery('.cell-active').find('.elm-active').removeClass('elm-active');
    // jQuery("#divElementTool").css("display", "none"); //force hide ellement tool

    // Call onChange to indicate content change
    // this.opts.onChange();

    // console.log(this.oriLen,col.textContent.length);
    if (this.oriLen !== col.textContent.length) {
      // check if typing produce/reduce a character
      this.typing();
    }

    // Hide element highlight & tool during typing
    this.elmTool.hide();
  }
  typing() {
    // console.log('typing');
    if (this.timeoutId) clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.opts.onChange();
    }, 2000);
  }
  handleCellPaste(clipboardData, clipboardDataHtml) {
    if (localStorage.getItem('_pasteresult') !== null) {
      this.opts.paste = localStorage.getItem('_pasteresult');
    }
    this.uo.saveForUndo();
    const util = this.util;
    util.saveSelection(); //required. Without this, CTRL-A (select element) & CTRL-V won't replace the element, but will paste at the end of the element.

    // Create a temporary div to hold the pasted HTML
    let contentword = document.createElement('div');
    contentword.innerHTML = clipboardDataHtml;
    try {
      var sPastedText = '';

      //Check video embed
      var bPasteObject = false;
      var src = contentword.innerText;
      if (!this.opts.disableAutoEmbedVideo) {
        //var youRegex = /^http[s]?:\/\/(((www.youtube.com\/watch\?(feature=player_detailpage&)?)v=)|(youtu.be\/))([^#\&\?]*)/;
        var youRegex = /^http[s]?:\/\/(((www.youtube.com\/watch\?(feature=player_detailpage&)?)v=)|(youtu.be\/))([^#&?]*)/;
        var vimeoRegex = /^.*(vimeo\.com\/)((channels\/[A-z]+\/)|(groups\/[A-z]+\/videos\/)|(video\/))?([0-9]+)\/?/;
        var youRegexMatches = youRegex.exec(src);
        var vimeoRegexMatches = vimeoRegex.exec(src);
        if (youRegexMatches !== null || vimeoRegexMatches !== null) {
          if (youRegexMatches !== null && youRegexMatches.length >= 7) {
            var youMatch = youRegexMatches[6];
            src = 'https://www.youtube.com/embed/' + youMatch + '?rel=0';
          }
          if (vimeoRegexMatches !== null && vimeoRegexMatches.length >= 7) {
            var vimeoMatch = vimeoRegexMatches[6];
            src = 'https://player.vimeo.com/video/' + vimeoMatch;
          }
          sPastedText = '<div class="embed-responsive embed-responsive-16by9"><iframe tabindex="0" width="560" height="315" src="' + src + '" frameborder="0" allowfullscreen=""></iframe></div>';
          bPasteObject = true;
        }
      }
      if (!bPasteObject) {
        if (this.opts.paste === 'text') {
          /*
          let elms = contentword.querySelectorAll('p,h1,h2,h3,h4,h5,h6');
          Array.prototype.forEach.call(elms, (elm) => {
              elm.innerHTML = elm.innerHTML + ' '; //add space (&nbsp;)
          });
           // sPastedText = contentword.innerText;
          sPastedText = contentword.innerHTML;
          sPastedText = sPastedText.replace(/(<([^>]+)>)/ig,'<br>');
          sPastedText = sPastedText.replace(/(<br\s*\/?>){3,}/gi, '<br>');
          if(sPastedText.indexOf('<br>')===0) {
              sPastedText = sPastedText.substring(4);
          }
          if(sPastedText.substring(sPastedText.length-4)==='<br>'){
              sPastedText = sPastedText.substring(0, sPastedText.length-4);
          }
          sPastedText = sPastedText.trim();
          */

          sPastedText = clipboardData;
          // sPastedText = sPastedText.replace(/(?:\r\n|\r|\n)/g, '<br>');
        } else {
          sPastedText = contentword.innerHTML;
          if (this.opts.paste === 'html') {
            //with styles
            sPastedText = util.cleanHTML(sPastedText, false);
          } else {
            //html-without-styles (default)
            sPastedText = util.cleanHTML(sPastedText, true);
          }
          contentword.innerHTML = sPastedText;

          /*
          // remove attributes
          if(this.opts.paste === 'html'){//with styles
               let elms = contentword.querySelectorAll('*');
              Array.prototype.forEach.call(elms, (elm) => {
                  for(let n = 0;n<elm.attributes.length;n++) {
                      if(elm.attributes[n].name!=='style') elm.removeAttribute(elm.attributes[n].name);
                  }
              });
           } else { //html-without-styles (default)
              
              const removeAttributes = (element) => {
                  while (element.attributes.length > 0) {
                      element.removeAttribute(element.attributes[0].name);
                  }
              };
              let elms = contentword.querySelectorAll('*');
              Array.prototype.forEach.call(elms, (elm) => {
                  removeAttributes(elm);
              });
          }
          */

          /*
          Additional Cleanup:
              - Remove p inside li
              - Remove li with white-space: pre
          */
          let elms = contentword.querySelectorAll('li');
          Array.prototype.forEach.call(elms, elm => {
            elm.style.whiteSpace = '';
            const childNodes = elm.childNodes;
            let i = childNodes.length;
            while (i--) {
              if (childNodes[i].tagName === 'P') {
                childNodes[i].outerHTML = childNodes[i].innerHTML;
              }
            }
          });

          // NOTE: paste <h1><p> jadi nempel

          // // Source: https://gist.github.com/sbrin/6801034 
          // jQuery('p', $editor).each(function(){
          //     var str = jQuery(this).attr('style');
          //     var matches = /mso-list:\w+ \w+([0-9]+)/.exec(str);
          //     if (matches) {
          //         jQuery(this).data('_listLevel',  parseInt(matches[1], 10));
          //     }
          // });
          // var last_level=0;
          // var pnt = null;
          // jQuery('p', $editor).each(function(){
          //     var cur_level = jQuery(this).data('_listLevel');
          //     if(cur_level !== undefined){
          //         var txt = jQuery(this).text();
          //         var list_tag = '<ul></ul>';
          //         if (/^\s*\w+\./.test(txt)) {
          //             var matches = /([0-9])\./.exec(txt);
          //             if (matches) {
          //                 var start = parseInt(matches[1], 10);
          //                 list_tag = start>1 ? '<ol start="' + start + '"></ol>' : '<ol></ol>';
          //             }else{
          //                 list_tag = '<ol></ol>';
          //             }
          //         }

          //         if(cur_level>last_level){
          //             if(last_level===0){
          //                 jQuery(this).before(list_tag);
          //                 pnt = jQuery(this).prev();
          //             }else{
          //                 pnt = jQuery(list_tag).appendTo(pnt);
          //             }
          //         }
          //         if(cur_level<last_level){
          //             for(var i=0; i<last_level-cur_level; i++){
          //                 pnt = pnt.parent();
          //             }
          //         }
          //         jQuery('span:first', this).remove();
          //         pnt.append('<li>' + jQuery(this).html() + '</li>');
          //         jQuery(this).remove();
          //         last_level = cur_level;
          //     }else{
          //         last_level = 0;
          //     }
          // });
          // //jQuery('[style]', $editor).removeAttr('style'); //done (see cleanHTML)
          // jQuery('[align]', $editor).removeAttr('align');
          // //jQuery('span', $editor).replaceWith(function() {return jQuery(this).contents();}); //done (see cleanHTML)
          // jQuery('span:empty', $editor).remove();
          // //jQuery("[class^='Mso']", $editor).removeAttr('class'); //done (see cleanHTML)
          // jQuery('p:empty', $editor).remove();

          sPastedText = contentword.innerHTML;
        }
      }
      contentword = this.doc.querySelector('#idContentWord');
      if (contentword) contentword.parentNode.removeChild(contentword);
      util.restoreSelection();

      /*
      var oSel = this.win.getSelection();
      var range = oSel.getRangeAt(0);
      range.extractContents();
      range.collapse(true);
      var docFrag = range.createContextualFragment(sPastedText);
      var lastNode = docFrag.lastChild;
       range.insertNode(docFrag);
      */

      /*
      When selection is made by double clicking text (to select the entire block),
      the actual selection goes to the next block as well (default behavior, tested using a simple contentEditable div).
      To fix this, re-select the contents inside.
      */

      const blocks = this.dom.getSelectedBlocks();
      const selection = this.win.getSelection();

      /* 
      Check same selection for the block first (this is more accurate than the sameSelection checking below).
      In case of double click (to select the entire block), for example, on this element:
           <h2 class="font-light size-54"><span class="size-24">Heading</span> 2 here</h2>
       The sameSelection checking below is failed, since the container = this.getElm() will return not the entire h2, but only
           <span class="size-24">Heading</span>
       So, blocks checking below is made to fix it.
      */
      try {
        let blockSelection = false;
        if (selection.toString().trim() !== '') {
          if (blocks.length === 1) {
            if (blocks[0].innerText.trim() === selection.toString().trim()) {
              let range = document.createRange();
              range.selectNodeContents(blocks[0]);
              selection.removeAllRanges();
              selection.addRange(range);
              blockSelection = true;
            }
          }
          if (!blockSelection) {
            const container = this.dom.getElm();
            const sameSelection = container && container.innerText === selection.toString().trim();
            if (sameSelection || selection.toString().trim() === '') {
              let range = document.createRange();
              range.selectNodeContents(container);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        }
      } catch (e) {
        // Do Nothing
      }
      this.doc.execCommand('insertHTML', false, sPastedText);
      if (this.activeCol) {
        /*
        Additional Cleanup:
            - Remove empty elements (empty p, etc)
        */
        // this.activeCol.find('h1:empty,h2:empty,h3:empty,h4:empty,h5:empty,h6:empty,p:empty').remove();
        // this.activeCol.querySelectorAll('*:empty').forEach((x)=>{x.remove();}); // Makes <img> removed
        this.activeCol.querySelectorAll('h1:empty,h2:empty,h3:empty,h4:empty,h5:empty,h6:empty,p:empty').forEach(x => {
          x.remove();
        });

        /*
        Additional Cleanup:
            Fix HTML structure. The problem:
            <p class="elm-active">
                ...Sometimes h1, h2, p can be pasted here..
            </p>
        */
        let elmActive = this.activeCol.querySelector('p.elm-active,h1.elm-active,h2.elm-active,h3.elm-active,h4.elm-active,h5.elm-active,h6.elm-active');
        if (elmActive) {
          let elms = elmActive.querySelectorAll('p,h1,h2,h3,h4,h5,h6');
          if (elms.length > 0) {
            let elmClosestElement = elmActive.nextElementSibling;

            //Fix text that doesn't have paragraph
            let textNodes = Array.from(elmActive.childNodes).filter(node => node.nodeType === 3 && node.textContent.trim().length > 1);
            textNodes.forEach(node => {
              const span = document.createElement('p');
              node.after(span);
              span.appendChild(node);
            });
            if (elmActive.firstElementChild && elmActive.childNodes.length === 1) {
              if (elmActive.firstElementChild.tagName === 'SPAN') {
                // Paste HTML with styles 

                elmActive.outerHTML = elmActive.firstElementChild.innerHTML; //fix

                // Re-clean empty elements
                this.activeCol.querySelectorAll('*:empty').forEach(x => {
                  x.remove();
                });

                //place cursor
                if (elmClosestElement) this.dom.moveCursorToElement(elmClosestElement.previousElementSibling);else this.dom.moveCursorToElement(this.activeCol);
                let builderActive = this.doc.querySelector('.builder-active');
                if (builderActive) this.applyBehaviorOn(builderActive);

                //Trigger Change event
                this.opts.onChange();

                //Trigger Render event
                this.opts.onRender();
                return;
              }
            }

            // Paste HTML without styles 
            elmActive.outerHTML = elmActive.innerHTML; //fix

            // Re-clean empty elements
            // this.activeCol.querySelectorAll('*:empty').forEach((x)=>{x.remove();}); // Makes <img> removed
            this.activeCol.find('h1:empty,h2:empty,h3:empty,h4:empty,h5:empty,h6:empty,p:empty').remove();

            //place cursor
            if (elmClosestElement) this.dom.moveCursorToElement(elmClosestElement.previousElementSibling);else this.dom.moveCursorToElement(this.activeCol);
            let builderActive = this.doc.querySelector('.builder-active');
            if (builderActive) this.applyBehaviorOn(builderActive);

            //Trigger Change event
            this.opts.onChange();

            //Trigger Render event
            this.opts.onRender();
            return;
          }
        }
      }

      /*
      range.setStartAfter(lastNode);
      range.setEndAfter(lastNode);
      range.collapse(false);
      var comCon = range.commonAncestorContainer;
      if (comCon && comCon.parentNode) {
          try { comCon.parentNode.normalize(); } catch (e) {
              // Do Nothing
          }
      }
      oSel.removeAllRanges();
      oSel.addRange(range);
      */

      let builderActive = this.doc.querySelector('.builder-active');
      if (builderActive) this.applyBehaviorOn(builderActive);

      //Trigger Change event
      this.opts.onChange();

      //Trigger Render event
      this.opts.onRender();
    } catch (e) {

      // Do Nothing
    }
  }
  cellSelected() {
    const util = this.util;
    return util.cellSelected();
  }

  // https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
  loadScript(source, beforeEl, async = true, defer = true) {
    return new Promise((resolve, reject) => {
      let script = document.createElement('script');
      const prior = beforeEl || document.getElementsByTagName('script')[0];
      script.async = async;
      script.defer = defer;
      function onloadHander(_, isAbort) {
        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
          script.onload = null;
          script.onreadystatechange = null;
          script = undefined;
          if (isAbort) {
            reject();
          } else {
            resolve();
          }
        }
      }
      script.onload = onloadHander;
      script.onreadystatechange = onloadHander;
      script.src = source;
      prior.parentNode.insertBefore(script, prior);
    });
  }

  // If scriptPath is not set, this will be used.
  currentScriptPath() {
    let filename, location;
    var scriptElements = document.getElementsByTagName('script');
    for (var i = 0; i < scriptElements.length; i++) {
      var source = scriptElements[i].src;
      filename = 'contentbuilder.js';
      if (source.indexOf(filename) > -1) {
        location = source.substring(0, source.indexOf(filename));
      }
      filename = 'contentbuilder.min.js';
      if (source.indexOf(filename) > -1) {
        location = source.substring(0, source.indexOf(filename));
      }
    }
    return location;
    // var scripts = document.querySelectorAll('script[src]');
    // var currentScript = scripts[scripts.length - 1].src;
    // var currentScriptChunks = currentScript.split('/');
    // var currentScriptFile = currentScriptChunks[currentScriptChunks.length - 1];
    // return currentScript.replace(currentScriptFile, '');
  }

  sectionDropSetup() {
    if (this.blockContainer) {
      this.sortableOnCanvas = [];
      let wrapper;
      let boxes;
      if (this.page && this.page === '.is-wrapper') {
        wrapper = this.doc.querySelector(this.page);
        boxes = wrapper.querySelectorAll('.is-box.box-canvas');
      } else {
        boxes = this.doc.querySelectorAll(this.blockContainer);
      }
      boxes.forEach(box => {
        box.insertAdjacentHTML('afterbegin', `
                <div class="is-block block-dummy" style="top: 0%; left: 0%; width: 100%; height: 20%;background:#eee;opacity:0"></div>
                <div class="is-block block-dummy" style="top: 20%; left: 0%; width: 100%; height: 20%;background:#eee;opacity:0"></div>
                <div class="is-block block-dummy" style="top: 40%; left: 0%; width: 100%; height: 20%;background:#eee;opacity:0"></div>
                <div class="is-block block-dummy" style="top: 60%; left: 0%; width: 100%; height: 20%;background:#eee;opacity:0"></div>
                <div class="is-block block-dummy" style="top: 80%; left: 0%; width: 100%; height: 20%;background:#eee;opacity:0"></div>
                `);
        const obj = new Sortable(box, {
          scroll: true,
          group: 'shared',
          direction: 'horizontal',
          animation: 150,
          // sort: true, 
          onAdd: evt => {
            let itemEl = evt.item;
            if (itemEl.getAttribute('data-id')) {
              // If has data-id attribute, the dropped item is from snippet panel (snippetpanel.js)

              let snippetid = itemEl.getAttribute('data-id');
              let lastBlock;
              let elements = Array.from(box.querySelectorAll('.is-block')).filter(elm => !elm.parentNode.closest('.is-block')); // exclude child blocks
              if (elements.length > 0) {
                lastBlock = elements[elements.length - 1];
              }

              // snippetJSON is snippet's JSON (from assets/minimalist-blocks/content.js) that store all snippets' html
              const result = this.opts.snippetJSON.snippets.filter(item => {
                if (item.id + '' === snippetid) return item;else return false;
              });
              var html = result[0].html;
              var noedit = result[0].noedit;
              const occurrences = this.dom.countOccurrences(html, 'column');
              var bSnippet;
              if (html.indexOf('"row') === -1) {
                bSnippet = true; // Just snippet (without row/column grid)
              } else {
                bSnippet = false; // Snippet is wrapped in row/colum
              }

              if (this.opts.emailMode) bSnippet = false;

              // check if is block
              let isBlock = false;
              if (html.includes('"is-block')) {
                isBlock = true;
                bSnippet = false;
              }

              // Convert snippet into your defined 12 columns grid   
              var rowClass = this.opts.row; //row
              var colClass = this.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
              if (rowClass !== '' && colClass.length === 12) {
                // html = html.replace(new RegExp('row clearfix', 'g'), rowClass);
                html = html.replace(new RegExp('row clearfix', 'g'), 'row'); // backward
                html = html.replace(new RegExp('"row', 'g'), '"' + rowClass);
                html = html.replace(new RegExp('column full', 'g'), colClass[11]);
                html = html.replace(new RegExp('column half', 'g'), colClass[5]);
                html = html.replace(new RegExp('column third', 'g'), colClass[3]);
                html = html.replace(new RegExp('column fourth', 'g'), colClass[2]);
                html = html.replace(new RegExp('column fifth', 'g'), colClass[1]);
                html = html.replace(new RegExp('column sixth', 'g'), colClass[1]);
                html = html.replace(new RegExp('column two-third', 'g'), colClass[7]);
                html = html.replace(new RegExp('column two-fourth', 'g'), colClass[8]);
                html = html.replace(new RegExp('column two-fifth', 'g'), colClass[9]);
                html = html.replace(new RegExp('column two-sixth', 'g'), colClass[9]);
              }
              html = html.replace(/{id}/g, this.util.makeId());
              if (this.opts.onAdd) {
                html = this.opts.onAdd(html);
              }
              if (this.opts.snippetPathReplace.length > 0) {
                // try {
                if (this.opts.snippetPathReplace[0] !== '') {
                  var regex = new RegExp(this.opts.snippetPathReplace[0], 'g');
                  html = html.replace(regex, this.opts.snippetPathReplace[1]);
                  var string1 = this.opts.snippetPathReplace[0].replace(/\//g, '%2F');
                  var string2 = this.opts.snippetPathReplace[1].replace(/\//g, '%2F');
                  var regex2 = new RegExp(string1, 'g');
                  html = html.replace(regex2, string2);
                }
                // } catch (e) { 1; }
              }

              if (bSnippet) {
                // Just snippet (without row/column grid), ex. buttons, line, social, video, map.
                // Can be inserted after current row, column (cell), element, or last row.

                html = `<div class="${this.opts.row}"><div class="${this.opts.cols[this.opts.cols.length - 1]}"${noedit ? ' data-noedit' : ''}>${html}</div></div>`;

                // Clean snippet from sortable related code
                itemEl.removeAttribute('draggable');
                this.dom.removeClass(itemEl, 'snippet-item');
                let bw = '';
                if (this.page && this.page === '.is-wrapper') {
                  bw = '760px';
                } else {
                  if (occurrences === 2) {
                    bw = '760px';
                  } else if (occurrences >= 3) {
                    bw = '760px';
                  } else {
                    bw = '540px';
                  }
                }
                let containerClass = ''; // container's 'size-18 leading-14' is not for print
                if (this.isContentBox) containerClass = ' size-18 leading-14';
                const blockTemplate = `
                                <div class="is-block block-steady height-auto" data-new-dummy="1" style="top: 20%; left: 20%; width: ${bw};">
                                    <div class="is-container container-new${containerClass}">
                                    [%CONTENT%]
                                    </div>
                                </div>
                                `; // data-new-dummy will be used by onSort to apply top/left position (snippetpanel.js)
                itemEl.outerHTML = blockTemplate.replace('[%CONTENT%]', html);
              } else if (isBlock) {
                itemEl.outerHTML = html;
              } else {
                // Snippet is wrapped in row/colum (may contain custom code or has [data-html] attribute)
                // Can only be inserted after current row or last row (not on column or element).

                let snippet = this.dom.createElement('div');
                snippet.innerHTML = html;
                let blocks = snippet.querySelectorAll('[data-html]');
                Array.prototype.forEach.call(blocks, block => {
                  // Render custom code block
                  html = decodeURIComponent(block.getAttribute('data-html'));
                  html = html.replace(/{id}/g, this.util.makeId());
                  html = html.replace(/<script>/g, `${this.nonce ? `<script nonce="${this.nonce}">` : '<script>'}`);
                  for (var i = 1; i <= 20; i++) {
                    html = html.replace('[%HTML' + i + '%]', block.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-' + i))); //render editable area
                  }

                  block.innerHTML = html;
                });
                html = snippet.innerHTML;

                // Clean snippet from sortable related code
                itemEl.removeAttribute('draggable');
                this.dom.removeClass(itemEl, 'snippet-item');
                itemEl.innerHTML = '';

                // Use createContextualFragment() to make embedded script executable
                // https://ghinda.net/article/script-tags/
                var range = document.createRange();
                range.setStart(itemEl, 0);
                itemEl.appendChild(range.createContextualFragment(html));
                let bw = '';
                if (this.page && this.page === '.is-wrapper') {
                  bw = '760px';
                } else {
                  if (occurrences === 2) {
                    bw = '760px';
                  } else if (occurrences >= 3) {
                    bw = '760px';
                  } else {
                    bw = '540px';
                  }
                }
                let containerClass = ''; // container's 'size-18 leading-14' is not for print
                if (this.isContentBox) containerClass = ' size-18 leading-14';
                const blockTemplate = `
                                <div class="is-block block-steady height-auto" data-new-dummy="1" style="top: 20%; left: 20%; width: ${bw};">
                                    <div class="is-container container-new${containerClass}">
                                    [%CONTENT%]
                                    </div>
                                </div>
                                `;
                itemEl.outerHTML = blockTemplate.replace('[%CONTENT%]', itemEl.innerHTML);
              }
              this.activeCol = null;
              const builders = box.querySelectorAll('.is-container.container-new');
              builders.forEach(builder => {
                const block = builder.parentNode;
                if (lastBlock) {
                  lastBlock.insertAdjacentElement('afterend', block);
                } else {
                  const ovarlay = box.querySelector('.is-overlay');
                  if (ovarlay) ovarlay.insertAdjacentElement('afterend', block);else box.insertAdjacentElement('afterbegin', block);
                }

                // After snippet has been added, re-apply behavior on builder areas
                this.applyBehaviorOn(builder);
                builder.classList.remove('container-new');
              });
              if (this.opts.onBlockCanvasAdd) this.opts.onBlockCanvasAdd();
              this.opts.onChange();
              this.opts.onRender();
            }

            // destroy
            if (this.sortableOnCanvas) {
              this.sortableOnCanvas.forEach(obj => {
                if (obj) {
                  obj.destroy();
                }
              });
              let dummies = this.doc.querySelectorAll('.block-dummy');
              dummies.forEach(elm => elm.parentNode.removeChild(elm));
              this.sortableOnCanvas = [];
            }
            if (this.sortableOnPage) {
              this.sortableOnPage.destroy();
              this.sortableOnPage = null;
            }
          }
        });
        this.sortableOnCanvas.push(obj);
      });
    }
    if (this.page) {
      if (this.page !== '.is-wrapper') return; // only for ContentBox
      const wrapper = this.doc.querySelector(this.page);

      // to prevent flicker caused by snippet panel above wrapper
      if (!wrapper.querySelector('.is-section')) {
        wrapper.style.marginLeft = '300px';
      }
      this.sortableOnPage = new Sortable(wrapper, {
        scroll: true,
        group: 'shared',
        direction: 'vertical',
        animation: 150,
        sort: true,
        // draggable: '.dummy',
        // swapThreshold: 0.1,
        // invertSwap: true,
        onAdd: evt => {
          var itemEl = evt.item;
          if (itemEl.querySelector('.is-col-tool')) {
            let rowTool = itemEl.querySelector('.is-row-tool');
            let colTool = itemEl.querySelector('.is-col-tool');
            let rowAddTool = itemEl.querySelector('.is-rowadd-tool');
            itemEl.removeChild(rowTool);
            itemEl.removeChild(colTool);
            itemEl.removeChild(rowAddTool);
            let elms = itemEl.querySelectorAll('[data-click]');
            elms.forEach(elm => {
              elm.removeAttribute('data-click');
            });
            itemEl.removeAttribute('draggable');
            itemEl.classList.remove('row-active');
            itemEl.classList.remove('row-outline');
            elms = itemEl.querySelectorAll('.cell-active');
            elms.forEach(elm => {
              elm.classList.remove('cell-active');
            });
            elms = itemEl.querySelectorAll('*');
            elms.forEach(elm => {
              elm.style.cursor = '';
            });

            // itemEl.outerHTML = `
            // <div class="is-section is-box is-section-100 type-poppins">
            //     <div class="is-overlay"></div>
            //     <div class="is-boxes">
            //         <div class="is-box-centered">
            //             <div class="is-container is-content-900 v2 size-18 leading-14">
            //                 ${itemEl.outerHTML}
            //             </div>
            //         </div>
            //     </div>
            // </div>
            // `;
            itemEl.outerHTML = this.settings.sectionTemplate.replace('[%CONTENT%]', itemEl.outerHTML);
            this.activeCol = null;
            if (this.opts.onBlockSectionAdd) this.opts.onBlockSectionAdd();

            // //Trigger Change event
            // this.opts.onChange();

            // //Trigger Render event
            // this.opts.onRender();

            // destroy (new)
            if (this.sortableOnCanvas) {
              this.sortableOnCanvas.forEach(obj => {
                if (obj) {
                  obj.destroy();
                }
              });
              let dummies = this.doc.querySelectorAll('.block-dummy');
              dummies.forEach(elm => elm.parentNode.removeChild(elm));
              this.sortableOnCanvas = [];
            }
            if (this.sortableOnPage) {
              this.sortableOnPage.destroy();
              this.sortableOnPage = null;
            }
            return;
          }
          if (itemEl.getAttribute('data-id')) {
            // If has data-id attribute, the dropped item is from snippet panel (snippetpanel.js)

            let snippetid = itemEl.getAttribute('data-id');

            // snippetJSON is snippet's JSON (from assets/minimalist-blocks/content.js) that store all snippets' html
            const result = this.opts.snippetJSON.snippets.filter(item => {
              if (item.id + '' === snippetid) return item;else return false;
            });
            var html = result[0].html;
            var noedit = result[0].noedit;
            var bSnippet;
            if (html.indexOf('"row') === -1) {
              bSnippet = true; // Just snippet (without row/column grid)
            } else {
              bSnippet = false; // Snippet is wrapped in row/colum
            }

            if (this.opts.emailMode) bSnippet = false;

            // check if is block
            let isBlock = false;
            if (html.includes('"is-block')) {
              isBlock = true;
              bSnippet = false;
            }

            // Convert snippet into your defined 12 columns grid   
            var rowClass = this.opts.row; //row
            var colClass = this.opts.cols; //['col s1', 'col s2', 'col s3', 'col s4', 'col s5', 'col s6', 'col s7', 'col s8', 'col s9', 'col s10', 'col s11', 'col s12']
            if (rowClass !== '' && colClass.length === 12) {
              // html = html.replace(new RegExp('row clearfix', 'g'), rowClass);
              html = html.replace(new RegExp('row clearfix', 'g'), 'row'); // backward
              html = html.replace(new RegExp('"row', 'g'), '"' + rowClass);
              html = html.replace(new RegExp('column full', 'g'), colClass[11]);
              html = html.replace(new RegExp('column half', 'g'), colClass[5]);
              html = html.replace(new RegExp('column third', 'g'), colClass[3]);
              html = html.replace(new RegExp('column fourth', 'g'), colClass[2]);
              html = html.replace(new RegExp('column fifth', 'g'), colClass[1]);
              html = html.replace(new RegExp('column sixth', 'g'), colClass[1]);
              html = html.replace(new RegExp('column two-third', 'g'), colClass[7]);
              html = html.replace(new RegExp('column two-fourth', 'g'), colClass[8]);
              html = html.replace(new RegExp('column two-fifth', 'g'), colClass[9]);
              html = html.replace(new RegExp('column two-sixth', 'g'), colClass[9]);
            }
            html = html.replace(/{id}/g, this.util.makeId());
            if (this.opts.onAdd) {
              html = this.opts.onAdd(html);
            }
            if (this.opts.snippetPathReplace.length > 0) {
              // try {
              if (this.opts.snippetPathReplace[0] !== '') {
                var regex = new RegExp(this.opts.snippetPathReplace[0], 'g');
                html = html.replace(regex, this.opts.snippetPathReplace[1]);
                var string1 = this.opts.snippetPathReplace[0].replace(/\//g, '%2F');
                var string2 = this.opts.snippetPathReplace[1].replace(/\//g, '%2F');
                var regex2 = new RegExp(string1, 'g');
                html = html.replace(regex2, string2);
              }
              // } catch (e) { 1; }
            }

            if (bSnippet) {
              // Just snippet (without row/column grid), ex. buttons, line, social, video, map.
              // Can be inserted after current row, column (cell), element, or last row.

              html = `<div class="${this.opts.row}"><div class="${this.opts.cols[this.opts.cols.length - 1]}"${noedit ? ' data-noedit' : ''}>${html}</div></div>`;

              // Clean snippet from sortable related code
              itemEl.removeAttribute('draggable');
              this.dom.removeClass(itemEl, 'snippet-item');

              // itemEl.outerHTML = html;
              // itemEl.outerHTML = `
              // <div class="is-section is-box is-section-100 type-poppins">
              //     <div class="is-overlay"></div>
              //     <div class="is-boxes">
              //         <div class="is-box-centered">
              //             <div class="is-container is-content-900 v2 size-18 leading-14">${html}</div>
              //         </div>
              //     </div>
              // </div>
              // `;
              itemEl.outerHTML = this.settings.sectionTemplate.replace('[%CONTENT%]', html);
            } else if (isBlock) {
              let canvasTemplate = `
                            <div class="is-section is-box is-section-100 type-system-ui box-canvas autolayout last-box">
                                <div class="is-overlay"></div>
                                [%CONTENT%]
                            </div>
                            `;
              itemEl.outerHTML = canvasTemplate.replace('[%CONTENT%]', html);
            } else {
              // Snippet is wrapped in row/colum (may contain custom code or has [data-html] attribute)
              // Can only be inserted after current row or last row (not on column or element).

              let snippet = this.dom.createElement('div');
              snippet.innerHTML = html;
              let blocks = snippet.querySelectorAll('[data-html]');
              Array.prototype.forEach.call(blocks, block => {
                // Render custom code block
                html = decodeURIComponent(block.getAttribute('data-html'));
                html = html.replace(/{id}/g, this.util.makeId());
                html = html.replace(/<script>/g, `${this.nonce ? `<script nonce="${this.nonce}">` : '<script>'}`);
                for (var i = 1; i <= 20; i++) {
                  html = html.replace('[%HTML' + i + '%]', block.getAttribute('data-html-' + i) === undefined ? '' : decodeURIComponent(block.getAttribute('data-html-' + i))); //render editable area
                }

                block.innerHTML = html;
              });
              html = snippet.innerHTML;

              // Clean snippet from sortable related code
              itemEl.removeAttribute('draggable');
              this.dom.removeClass(itemEl, 'snippet-item');
              itemEl.innerHTML = '';

              // Use createContextualFragment() to make embedded script executable
              // https://ghinda.net/article/script-tags/
              var range = document.createRange();
              range.setStart(itemEl, 0);
              itemEl.appendChild(range.createContextualFragment(html));

              // itemEl.outerHTML = itemEl.innerHTML;

              // itemEl.outerHTML = `
              // <div class="is-section is-box is-section-100 type-poppins">
              //     <div class="is-overlay"></div>
              //     <div class="is-boxes">
              //         <div class="is-box-centered">
              //             <div class="is-container is-content-900 v2 size-18 leading-14">${itemEl.innerHTML}</div>
              //         </div>
              //     </div>
              // </div>
              // `;
              itemEl.outerHTML = this.settings.sectionTemplate.replace('[%CONTENT%]', itemEl.innerHTML);
            }
            // // After snippet has been added, re-apply behavior on builder areas
            // this.applyBehaviorOn(builder);

            this.activeCol = null;
            if (this.opts.onBlockSectionAdd) this.opts.onBlockSectionAdd();

            //Trigger Change event
            this.opts.onChange();

            //Trigger Render event
            this.opts.onRender();

            // // Hide element tool
            // this.elmTool.hide();
          }

          // this.sortableOnPage.option('draggable', '.dummy');

          // destroy
          if (this.sortableOnCanvas) {
            this.sortableOnCanvas.forEach(obj => {
              if (obj) {
                obj.destroy();
              }
            });
            let dummies = this.doc.querySelectorAll('.block-dummy');
            dummies.forEach(elm => elm.parentNode.removeChild(elm));
            this.sortableOnCanvas = [];
          }
          if (this.sortableOnPage) {
            this.sortableOnPage.destroy();
            this.sortableOnPage = null;
          }
        }
      });
    }
  }
  hideElementTools() {
    let elmTool = this.doc.querySelector('.is-element-tool');
    if (elmTool) elmTool.style.display = '';
    let videoTool = this.doc.querySelector('.is-video-tool');
    if (videoTool) videoTool.style.display = '';
    let audioTool = this.doc.querySelector('.is-audio-tool');
    if (audioTool) audioTool.style.display = '';
    let iframeTool = this.doc.querySelector('.is-iframe-tool');
    if (iframeTool) iframeTool.style.display = '';
    let moduleTool = this.doc.querySelector('.is-module-tool');
    if (moduleTool) moduleTool.style.display = '';
    let lockIndicator = this.doc.querySelector('.is-locked-indicator');
    if (lockIndicator) lockIndicator.style.display = '';
    let linkTool = this.doc.querySelector('#divLinkTool');
    if (linkTool) linkTool.style.display = '';
    let spacerTool = this.builderStuff.querySelector('.is-spacer-tool');
    if (spacerTool) spacerTool.style.display = '';
    this.element.image.hideImageTool();
    this.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
    this.doc.querySelectorAll('.elm-inspected').forEach(elm => elm.classList.remove('elm-inspected'));
    this.doc.querySelectorAll('.elm-active').forEach(elm => elm.classList.remove('elm-active'));
    this.activeImage = null;
    this.activeIcon = null;
    this.inspectedElement = null;
    this.activeElement = null;
  }
  hideTools() {
    // used by contentbuilder.js & grid.js

    // let elmTool = this.doc.querySelector('.is-element-tool');
    // if(elmTool) elmTool.style.display = '';

    let videoTool = this.doc.querySelector('.is-video-tool');
    if (videoTool) videoTool.style.display = '';
    let audioTool = this.doc.querySelector('.is-audio-tool');
    if (audioTool) audioTool.style.display = '';
    let iframeTool = this.doc.querySelector('.is-iframe-tool');
    if (iframeTool) iframeTool.style.display = '';
    let moduleTool = this.doc.querySelector('.is-module-tool');
    if (moduleTool) moduleTool.style.display = '';
    let lockIndicator = this.doc.querySelector('.is-locked-indicator');
    if (lockIndicator) lockIndicator.style.display = '';
    let linkTool = this.doc.querySelector('#divLinkTool');
    if (linkTool) linkTool.style.display = '';
    let spacerTool = this.builderStuff.querySelector('.is-spacer-tool');
    if (spacerTool) spacerTool.style.display = '';
    this.element.image.hideImageTool();

    // this.doc.querySelectorAll('.icon-active').forEach(elm => elm.classList.remove('icon-active'));
    // this.doc.querySelectorAll('.elm-inspected').forEach(elm => elm.classList.remove('elm-inspected'));
    // this.doc.querySelectorAll('.elm-active').forEach(elm => elm.classList.remove('elm-active'));
  }
}

export { ContentBuilder as default };
